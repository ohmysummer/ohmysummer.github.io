<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="ohmysummer">
    <meta name="description" content="ohmysummer&#39;s personal website">
    <meta name="keywords" content="Perl6,Rakudo">

    <base href="http://ohmysummer.github.io/">
    <title>
  第十四天 - 使用 Perl 6 设计(小)航天器 · 焉知非鱼
</title>

    <link rel="canonical" href="http://ohmysummer.github.io/post/2018-12-14-%E4%BD%BF%E7%94%A8perl6%E8%AE%BE%E8%AE%A1%E5%B0%8F%E8%88%AA%E5%A4%A9%E5%99%A8/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.cd087ace86754b082dec94545567f8361cba42e84f8e15edbc4a9f6e52bd1f6a.css" integrity="sha256-zQh6zoZ1Swgt7JRUVWf4Nhy6QuhPjhXtvEqfblK9H2o=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://ohmysummer.github.io/css/style.css">
    

    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://ohmysummer.github.io/">
      焉知非鱼
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/post">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/categories">归档</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/page/about/">关于</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/tags">标签</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>第十四天 - 使用 Perl 6 设计(小)航天器</h1>
    </header>

    

<h2 id="寻找共同点">寻找共同点</h2>

<p>大家好！</p>

<p>那些日子我花了一些时间在基础部件上工作，揭示了可能的惊喜，Perl 6 的 <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP（轻量级目录访问协议）</a>实现。</p>

<p>然而，现在谈论这个还为时尚早，所以我现在将有一些神秘的封面覆盖这个话题，因为我们有另一个 - 宇宙飞船！</p>

<p>航天器和LDAP之间的共同点是：LDAP规范使用一种称为符号的符号 <code>ASN.1</code>，它允许使用特定的文本语法定义抽象类型，并在 <code>ASN.1</code>编译器的帮助下，为特定的编程语言创建类型定义，以及什么是更多：此类型值的编码器和解码器，可以将您的值序列化为某些数据，例如，可以通过网络发送并在另一台计算机上很好地解析。</p>

<p>通过这种方式，您可以轻松地在应用程序中获得跨平台类型。编码器和解码器可以自动生成，不仅针对某些指定的编码格式，而且针对整个范围的二进制（例如 <code>BER</code>，<code>PER</code>和其他）和文本（例如<code>SOAP</code>）编码格式。</p>

<p>因此，为了完成工作，我必须至少实现 <code>ASN.1</code>Perl 6中的一些子集- 不是完整的规范，这很大，只关注LDAP规范中使用的功能。</p>

<p>“这听起来很有趣，但我们的宇宙飞船在哪里！？”，你可能会问。事实证明，这种 <code>Rocket</code> 类型是您在 <a href="http://asn1-playground.oss.com/">ASN.1 Playground</a> 网站上看到的第一件事，它让您可以免费访问 <code>ASN.1</code>编译器，它可以作为参考！</p>

<h2 id="asn-1-和限制"><code>ASN.1</code> 和限制</h2>

<p>这是花哨的代码：</p>

<pre><code>World-Schema DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
  Rocket ::= SEQUENCE
  {
     name      UTF8String (SIZE(1..16)),
     message   UTF8String DEFAULT &quot;Hello World&quot; ,
     fuel      ENUMERATED {solid, liquid, gas},
     speed     CHOICE
     {
        mph    INTEGER,
        kmph   INTEGER
     }  OPTIONAL,
     payload   SEQUENCE OF UTF8String
  }
END
</code></pre>

<p>让我们快速浏览一下这个定义：</p>

<ul>
<li><code>Rocket</code> 是一个 <code>SEQUENCE</code>  - 一组某类型的有序值，可以看作是异构列表/数组或类。<br /></li>
<li>场 <code>name</code> 和 <code>message</code> 有 <code>UTF8String</code> 型，这是肯定的，一种字符串表示的 <code>ASN.1</code>。字段name已应用长度限制，<code>(SIZE(1..16))</code> 和 <code>message</code> 具有指定的默认值 <code>DEFAULT &quot;Hello World&quot;</code>。</li>
<li>字段 <code>fuel</code>有 <code>ENUMERATED</code> 类型：它只是一个可供选择的标签枚举。<br /></li>
<li>字段 <code>speed</code> 是一个 <code>CHOICE</code>，它是一种特殊类型，它描述了一个字段，该值可以是指定类型之一。不同的是 <code>ENUMERATED</code>，价值不仅仅是标签。<code>OPTIONAL</code> 如你所知，关键字意味着如果不存在，该字段可能会被省略。</li>
<li>字段 <code>payload</code> 是一个 <code>SEQUENCE</code>，但指定了类型。这意味着我们可以根据需要在这里拥有尽可能多的 <code>UTF8String</code> 值。<br />
<br /></li>
</ul>

<p>这里我们将应用两个重要的限制：</p>

<ul>
<li>我们将使用 <code>Basic Encoding Rules（BER）</code> - 将 <code>ASN.1</code>类型编码指定为特定字节序列的规则。如上所述，有不同的格式，但我们将使用这一种。<br /></li>
</ul>

<p><code>Basic Encoding Rules</code> 标准是基于一个所谓的“TLV编码”的事情-的类型的值被编码为字节序列表示：“ Ť AG”，“ 大号 ength”和“ V传递类型的某些值的ALUE”。让我们更仔细地看一下&hellip;&hellip;以相反的顺序！</p>

<p>“值”是包含值的字节表示的部分。每种类型都有自己的编码模式（例如，<code>INTEGER</code> 编码方式不同 <code>UTF8String</code>）。</p>

<p>“长度”是表示“值”部分中的字节数的数字。这允许我们很好地处理增量解析（通常也是！）。它也可以具有“未知”值，这允许我们以未知的长度流式传输数据，但我们将把它放在一边。</p>

<p>“标签”简单地说是一个字节或一些字节，我们可以用它来确定我们手头有什么类型。其确切值由标记规则的数量（“标记模式”）确定，并且存在好的或更差的不同模式。</p>

<p>并且，如果您已经等待某些段落的第二个限制，那么它是：</p>

<p>我们将 <code>IMPLICIT</code> 在这里使用 BER 的类型标记模式。正如您所猜测的那样，<code>EXPLICIT</code> 标记模式也同时存在 <code>AUTOMATIC</code>（在上面的 Rocket 示例中使用）。</p>

<p>考虑到这一点，我们需要将 <code>ASN.1</code> 上面的类型更改为：</p>

<pre><code>World-Schema DEFINITIONS IMPLICIT TAGS ::=
BEGIN
  Rocket ::= SEQUENCE
  {
     name      UTF8String (SIZE(1..16)),
     message   UTF8String DEFAULT &quot;Hello World&quot; ,
     fuel      ENUMERATED {solid, liquid, gas},
     speed     CHOICE
     {
        mph   [0] INTEGER,
        kmph  [1] INTEGER
     }  OPTIONAL,
     payload   SEQUENCE OF UTF8String
  }
END
</code></pre>

<p>注意 <code>IMPLICIT TAGS</code> 用于代替字段中的 <code>AUTOMATIC TAGS</code> 和 <code>[$n]</code> 字符串 <code>speed</code>。</p>

<p>如果你看一下这个模式，事实证明，这是，其实，暧昧，因为 <code>mph</code> 和 <code>kmph</code> 都有 <code>INTEGER</code> 型。因此，如果我们 <code>INTEGER</code> 从字节流中读取了一个，它是 <code>mph</code> 值还是 <code>kmph</code> 值？如果我们谈论宇宙飞船，它会产生巨大的变化！</p>

<p>为了避免这种混淆，使用了特殊的标签，这里我们指定了我们想要的标签，因为与 <code>AUTOMATIC</code> 模式不同，<code>IMPLICIT</code> 它不适用于我们。</p>

<h2 id="逐步建设-问题答案">逐步建设。问题答案。</h2>

<p>那么，我们可以用 Perl 6 中的所有功能做什么呢？虽然编译器可能很有趣，但是可以通过可扩展的方式编译成 Perl 6，并且包含了奇特的功能？必须有一些更简单的东西。</p>

<p>比方说，我们有一个适用于航天器的脚本。当然，我们需要一个类型来表示一个，特别是一个类，让我们称之为 <code>Rocket</code>：</p>

<pre><code class="language-perl6">class  Rocket {}
</code></pre>

<p>当然，我们想知道一些有关它的数据：</p>

<pre><code class="language-perl6">class Rocket {
    has $.name;
    has $.message is default(&quot;Hello World&quot;);
    has $.fuel;
    has $.speed;
    has @.payload;
}
</code></pre>

<p>如果我们必须使我们的 <code>Rocket</code> 定义更明确，那么我们指定一些类型：</p>

<pre><code class="language-perl6">enum Fuel &lt;Solid Liquid Gas&gt;;

class Rocket {
    has Str $.name;
    has Str $.message is default(&quot;Hello World&quot;);
    has Fuel $.fuel;
    has $.speed;
    has Str @.payload;
}
</code></pre>

<p>现在它开始提醒我们一些事情&hellip;&hellip;</p>

<ul>
<li><code>Str</code> 类似 <code>UTF8String</code>，只是我们不能离开它这样，因为 <code>ASN.1</code>我们不仅有 <code>UTF8String</code>，而且 <code>BIT STRING</code>，<code>OCTET STRING</code> 和其他字符串类型。</li>
<li><code>Fuel</code> 枚举类似于 <code>ENUMERATED</code> 类型。<br /></li>
<li><code>@.payload</code> 中的 <code>@</code> 符号告诉我们，这将是一个序列，而且 <code>Str</code> 指定其元素的类型。<br /></li>
<li>但是虽然有一些类似的观点，但从我们 <code>ASN.1</code>的观点来看，我们没有足够的数据。让我们一步一步解决这些问题！<br /></li>
</ul>

<blockquote>
<p>我们怎么知道这完全Rocket是 <code>ASN.1</code>序列类型？</p>
</blockquote>

<p>通过应用角色：<code>class Rocket does ASNSequence</code>。</p>

<blockquote>
<p>我们怎么知道确切的字段顺序？</p>
</blockquote>

<p>通过实现此角色的存根方法：<code>method ASN-order { &lt;$!name $!message $!fuel $!speed @!payload&gt; }</code></p>

<blockquote>
<p>我们怎么知道这 <code>$.speed</code> 是可选的？</p>
</blockquote>

<p>我们只是应用它的特征！<a href="https://docs.perl6.org/language/traits">Traits</a> 允许我们在代码部分上执行自定义代码，特别是 <code>Attributes</code>。例如，虚构的API可以是这样的：<code>has $.speed is optional</code>。</p>

<blockquote>
<p>我们怎么知道 $.speed 是多少？</p>
</blockquote>

<p>由于 <code>CHOICE</code> 类型是“特殊的”，但仍然是一流的（例如，你可以使它递归），我们需要在这里发挥作用：<code>ASNChoice</code> 来救援。</p>

<blockquote>
<p>我们怎么知道 <code>ASN.1</code>我们的 Str 类型是什么类型的字符串？</p>
</blockquote>

<p>我们来写吧 <code>has Str $.name is UTF8String;</code>。</p>

<blockquote>
<p>我们如何指定字段的默认值？</p>
</blockquote>

<p>虽然 Perl 6 已经具有内置 <code>is default</code> 特性，但对我们来说不好的是我们无法“很好地”检测到它。因此，我们必须引入另一个自定义特征，以满足我们的目的并应用内置特征：<code>has Str $.message is default-value(&quot;Hello World&quot;);</code></p>

<p>让我们在一个包中回答所有这些问题：</p>

<pre><code class="language-perl6">role ASNSequence { #`[ Elves Special Magic Truly Happens Here ] }

role ASNChoice { #`[ And even here ]  }

class SpeedChoice does ASNChoice {
    method ASN-choice() {
        # Description of: names, tags, types specificed by this CHOICE
        { mph =&gt; (0 =&gt; Int), kmph =&gt; (1 =&gt; Int) }
    }
}

class Rocket does ASNSequence {
    has Str $.name is UTF8String;
    has Str $.message is default-value(&quot;Hello World&quot;) is UTF8String;
    has Fuel $.fuel;
    has SpeedChoice $.speed is optional;
    has Str @.payload is UTF8String;

    method ASN-order { &lt;$!name $!message $!fuel $!speed @!payload&gt; }
}
</code></pre>

<p>值可能类似于：</p>

<pre><code class="language-perl6">my $rocket = Rocket.new(
    name =&gt; 'Falcon',
    fuel =&gt; Solid,
    speed =&gt; SpeedChoice.new((mph =&gt; 18000)),
    payload =&gt; [ &quot;Car&quot;, &quot;GPS&quot; ]);
</code></pre>

<p>答案越多，问题就越多</p>

<p>对于这个微小的例子（另一方面，它已经 <code>ASN.1</code>展示了许多特性），实际上，我们需要在我们的应用程序中使用这个类的实例，并可能根据需要对其进行编码和解码。</p>

<p>那么精灵们对我们的数据秘密做了什么？让我们在下一篇文章中找到答案！</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>ohmysummer ❤ Perl 6</p>
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
