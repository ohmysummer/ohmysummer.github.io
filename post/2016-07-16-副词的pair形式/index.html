<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="ohmysummer">
    <meta name="description" content="ohmysummer&#39;s personal website">
    <meta name="keywords" content="Perl6,Rakudo">

    <base href="http://ohmysummer.github.io/">
    <title>
  副词的Pair形式 · 焉知非鱼
</title>

    <link rel="canonical" href="http://ohmysummer.github.io/post/2016-07-16-%E5%89%AF%E8%AF%8D%E7%9A%84pair%E5%BD%A2%E5%BC%8F/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.cd087ace86754b082dec94545567f8361cba42e84f8e15edbc4a9f6e52bd1f6a.css" integrity="sha256-zQh6zoZ1Swgt7JRUVWf4Nhy6QuhPjhXtvEqfblK9H2o=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://ohmysummer.github.io/css/style.css">
    

    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://ohmysummer.github.io/">
      焉知非鱼
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/post">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/categories">归档</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/page/about/">关于</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/tags">标签</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>副词的Pair形式</h1>
    </header>

    

<h2 id="副词的-pair-形式">副词的 Pair 形式</h2>

<p><a href="https://github.com/perl6/roast/blob/master/S02-literals/adverbs.t#L6-L69">S02-literals/adverbs.t lines 6–69</a></p>

<p>现在有一个普通的副词形式的 Pair 记号，也是人们所熟知的 &ldquo;colon pair&rdquo;（冒号对）形式。下面的表格展示了和胖箭头记号相一致的记号：</p>

<pre><code>Fat arrow           Adverbial pair  Paren form
=========           ==============  ==========
a =&gt; True           :a
a =&gt; False          :!a
a =&gt; 0              :a(0)
a =&gt; $x             :a($x)
a =&gt; 'foo'          :a&lt;foo&gt;         :a(&lt;foo&gt;)
a =&gt; &lt;foo bar&gt;      :a&lt;foo bar&gt;     :a(&lt;foo bar&gt;)
a =&gt; «$foo @bar»    :a«$foo @bar»   :a(«$foo @bar»)
a =&gt; {...}          :a{...}         :a({...})
a =&gt; [...]          :a[...]         :a([...])
a =&gt; $a             :$a
a =&gt; @a             :@a
a =&gt; %a             :%a
a =&gt; &amp;a             :&amp;a
a =&gt; %foo&lt;a&gt;        %foo&lt;a&gt;:p
</code></pre>

<p>胖箭头结构应只用于项(term)所在位置因为它被认为是一个独立的表达式，因为胖箭头自身被解析为一个普通的中缀操作符（即使自动引起它左侧的标识符时）。因为左侧是一个普通的表达式，胖箭头形式会使用任何值作为键来创建 Pair。另一方面，当用上面的形式来生成 Pair 对象时，副词形式被约束为使用标识符作为键。在键不是标识符的地方，你必须使用胖箭头形式来生成 Pair。</p>

<p>尽管有那个约束，但是冒号和括号之间有其它东西也是可能的；然而，所有可能的非标识符形式的副词形式的键都被保留用作特殊的语义形式。Perl 6 当前识别十进制数的键和空(null)键。在下面的表格中，第一列和第二列不是同一个东西：</p>

<pre><code>Simple pair         DIFFERS from    which means
===========         ============    ===========
2 =&gt; &lt;101010&gt;       :2&lt;101010&gt;      二进制字面值 0b101010
8 =&gt; &lt;123&gt;          :8&lt;123&gt;         八进制字面值 0o123
16 =&gt; &lt;deadbeef&gt;    :16&lt;deadbeef&gt;   十六进制字面值 0xdeadbeef
16 =&gt; $somevalue    :16($somevalue) 十六进制转换函数，把十六进制的字符串转换为数字
'' =&gt; $x            :($x)           签名字面值
'' =&gt; ($x,$y)       :($x,$y)        签名字面值
'' =&gt; &lt;x&gt;           :&lt;x&gt;            name extension
'' =&gt; «x»           :«x»            name extension
'' =&gt; [$x,$y]       :[$x,$y]        name extension
'' =&gt; { .say }      :{ .say }       adverbial block (not allowed on names)
</code></pre>

<p>所有的副词形式（包括普通的带有标识符键的副词）被认为是特殊的令牌(tokens)并且除了能在项的位置上被识别，也能在各种不同的位置上被识别。特别地，当把它用在中缀的位置上时，它们修改了之前的顶端的优先级比&rdquo;loose unary&rdquo;紧凑的操作符：</p>

<pre><code class="language-perl6">1 == 100 :fuzz(3)   # 调用: infix:&lt;==&gt;(1, 100, fuzz =&gt; 3)
</code></pre>

<p>在声明内部副词形式用于重命名参数声明：</p>

<pre><code class="language-perl6">sub foo ( :externalname($myname) ) { ... }
</code></pre>

<p>副词修改了各种引号形式的意义：</p>

<pre><code class="language-perl6">
q:x 'cat /etc/passwd'
</code></pre>

<p>当副词被追加到标识符（即，在后缀位置上）后面时，副词形式的语法用于生成那个标识符的唯一变体；该语法用于命名诸如 <code>infix:&lt;+&gt;</code> 这样的操作符和诸如 <code>statement_control:if</code> 这样的多重分发文法规则。当这样用时，副词被认为是名字的一部分，所以 <code>infix:&lt;+&gt;</code> 和 <code>infix:&lt;-&gt;</code> 是两个不同的操作符。同样地, <code>prefix:&lt;+&gt;</code> 不同于 <code>infix&lt;+&gt;</code>。（这种记法的好处有把不同的标识符分组到容易访问的集合中，例如，这就是 Perl 6 标准文法时如何知道当前中缀操作符集合的）。</p>

<p>只有能产生一列一个或更多值（偏好字符串）的标识符被允许作为名字扩展；特殊地，闭包不能作为值，所以 <code>:{...}</code> 形式的副词不能被允许作为名字扩展。特别地，这把方法名后面的 block 空了出来，所以它允许我们把 block 解析为方法的参数：</p>

<pre><code class="language-perl6">@stuff.sort:{ +$_ }
</code></pre>

<p>这些看起来它们使用的是 pairs，实际上它们等价于：</p>

<pre><code class="language-perl6">@stuff.sort: { +$_ }
</code></pre>

<p>所以这儿的冒号真得不是在引入 pairs，而是引入了该方法的参数列表。在其他任何位置，<code>:{...}</code> 会使用两种用法的一种，根据花括号定义的是闭包还是散列。如果被当做闭包， <code>:{...}</code> 会创建把空键(null)映射到闭包的 pair。如果被当做散列构造器，那么空键会被忽略，并且 <code>:{...}</code> 会创建一个以对象为键的散列而非像没有冒号的 <code>{...}</code>那样创建一个以字符串为键的散列。</p>

<p>胖箭头和副词对儿记法都能用于把具名参数作为项传递给函数或方法。在括号里面带有参数的调用后面，只有副词形式的语法能用于传递额外的参数。这通常用于传递额外的 block:</p>

<pre><code class="language-perl6">find($directory) :{ when not /^\./ }
</code></pre>

<p>这正好和前面的规则离经叛道，因为副词形式的 block 处于操作符的位置，所以它修改了 &ldquo;find operator&rdquo;。(括号不被认为是操作符)</p>

<p>注意（和往常一样）<code>{...}</code> 形式（要么基于操作符要么是特殊的）可以根据内容要么标示一个闭包，要么标示一个散列。它没有标示下标，因为 <code>:key{}</code> 实际上等价于 <code>key =&gt; {}</code>, 并且花括号一点儿也没有表现得像后缀一样。（然而，它所传递给的函数也能把那个值用于下标）</p>

<p>还要注意 <code>&lt;a b&gt;</code> 形式不是下标，因此并不等价于 <code>.{'a', 'b'}</code> 而是等价于 <code>('a', 'b')</code>。 裸的 <code>&lt;a&gt;</code> 转换为 <code>('a')</code> 而不是 <code>('a',)</code>。（然而，对于其它形式的括号，根据上下文，值可能也能用作下标）</p>

<p>两个更多地副词总是可以捆绑在一块儿。当在参数列表中用作具名参数时，你可能在参数之间放上逗号，因为它们对于函数来说就是普通的具名参数，并且胖箭头形式的参数效果相同。然而，当第一个 pair 出现在项(term)的位置上时，这个逗号才只允许出现。当期望一个中缀操作符时，那个副词总是被看做修改最近的之前的操作符，它没有被隐藏在圆括号中，并且如果你把多个这样的 pairs 作为一个字符串放在一块儿，那么你就不能在它们中间放上逗号，因为那会让之后的 pairs 看起来像项(terms)。（在操作符的位置上一点也不允许胖箭头形式）查看 S06 获取把副词用作具名参数的用法。</p>

<p>否定形式(:!a) 和符号形式(:$a, :@a, :%a) 绝对不会接收参数也不关心下一个字符是什么。它们被认为是完备的。这些形式需要一个标识符作为键。包含 twigil 的符号形式不会在键中包含那个 twigil。</p>

<p>对于接收一个非否定整数参数的标识符，它被允许缩写，例如，把 <code>:sweet(16)</code> 缩写为 <code>:16sweet</code>。（这个和 <code>:16&lt;deadbeef&gt;</code> 形式不一样，后者从来没有字母字符跟在数字后面。）只有字面的非负数字可以这样交换使用。请注意这个缩写允许：</p>

<pre><code class="language-perl6">s:2nd/foo/bar/  # or 3rd, 4th, 5th etc.
</code></pre>

<p>其它形式的副词（包括裸的 <code>:a</code> 形式）总是查找紧紧跟随的用括号括起的参数，并且把它吞噬掉。如果那没有达到预期，那么你必须在副词和开括号之间使用空白。在 Perl 6中单独的副词语法在各处都是相同的。基于参数是需要还是不需要，没有例外。（对于引号副词和 regex 副词有一个小例外，它们只接受圆括号作为它们的括号操作符，并且忽略其它括号，如果需要它们必须被放到括号里。查看上表中得&rdquo; Paren form&rdquo;）</p>

<p>除了上面要注意的之外，解析器常常会寻找括号。尽管没有标示一个真的下标，括号被类似地解析为后缀操作符。因为把括号后缀化可以和它们起初的使用 unspace 或点(或两者都) <code>:foo</code> 的区分开。</p>

<p>不管语法，用作具名参数的副词一般作为我们正谈论的函数的可选具名参数呈现 &ndash; 即使那个函数是操作符或宏。那个正被谈论的函数既不知道也不关心原语法是多么的怪异。</p>

<blockquote>
<p>翻译的真心大西瓜</p>
</blockquote>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>ohmysummer ❤ Perl 6</p>
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
