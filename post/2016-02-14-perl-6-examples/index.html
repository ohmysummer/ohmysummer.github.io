<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="ohmysummer">
    <meta name="description" content="ohmysummer&#39;s personal website">
    <meta name="keywords" content="Perl6,Rakudo">

    <base href="http://ohmysummer.github.io/">
    <title>
  Perl 6 Examples · 焉知非鱼
</title>

    <link rel="canonical" href="http://ohmysummer.github.io/post/2016-02-14-perl-6-examples/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.cd087ace86754b082dec94545567f8361cba42e84f8e15edbc4a9f6e52bd1f6a.css" integrity="sha256-zQh6zoZ1Swgt7JRUVWf4Nhy6QuhPjhXtvEqfblK9H2o=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://ohmysummer.github.io/css/style.css">
    

    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://ohmysummer.github.io/">
      焉知非鱼
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/post">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/categories">归档</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/page/about/">关于</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/tags">标签</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>Perl 6 Examples</h1>
    </header>

    

<h2 id="斐波拉契数列-fibonacci-sequence">斐波拉契数列（Fibonacci Sequence）</h2>

<hr />

<ul>
<li>analytic</li>
</ul>

<pre><code class="language-perl">use v6;

sub fibonacci (Int $n where 0..*  --&gt; Int) {
    constant phi = (1 + sqrt 5) / 2;

    return round( phi**($n+1) / sqrt 5);
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}

</code></pre>

<p>这种方法计算前1000个斐波拉契数大约为0.746s（2015.7.Rakudo, 以下都是）。</p>

<ul>
<li>迭代</li>
</ul>

<pre><code class="language-perl">use v6;

sub fibonacci (Int $n) {
    state @sequence = 1,1;

    while @sequence.elems &lt;= $n {
        @sequence.push( @sequence[*-2] + @sequence[*-1] );
    }

    return @sequence[$n];
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}
</code></pre>

<p>这种遍历法大概需要 1 秒多。</p>

<ul>
<li>递归</li>
</ul>

<pre><code class="language-perl">use v6;

sub fibonacci (Int $n where 0..*) {
    if $n == 0 | 1 {
        return 1;
    }
    else {
        return fibonacci($n-1) + fibonacci($n-2);
    }
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}
</code></pre>

<p>比较慢。第 20 个之后越来越慢。</p>

<ul>
<li>递归 - 超运算符</li>
</ul>

<pre><code class="language-perl">sub fibonacci (Int $n where 0..*) {
    if $n == 0 | 1 {
        return 1;
    }
    else {
        return [+] ($n-1, $n-2)».&amp;fibonacci;
    }
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}
</code></pre>

<p>和上面差不多。</p>

<ul>
<li>递归 - map</li>
</ul>

<pre><code class="language-perl">sub fibonacci (Int $n where 0..*) {
    if $n == 0 | 1 {
        return 1;
    }
    else {
        return [+] map &amp;fibonacci, ($n-1, $n-2);
    }
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}
</code></pre>

<p>同上。</p>

<ul>
<li>递归 - multi</li>
</ul>

<pre><code class="language-perl">use v6;

multi fibonacci (0)  { 1 }

multi fibonacci (1)  { 1 }

multi fibonacci (Int $n --&gt; Int) {
    return fibonacci($n-1) + fibonacci($n-2);
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}
</code></pre>

<p>比上一个稍快。</p>

<ul>
<li>递归 - multi_cached</li>
</ul>

<pre><code class="language-perl">multi fibonacci (0)  { 1 }

multi fibonacci (1)  { 1 }

my %cached;
multi fibonacci (Int $n --&gt; Int) {
    return %cached{$n} //= fibonacci($n-1) + fibonacci($n-2);
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}
</code></pre>

<p>0.849s 执行完毕。</p>

<ul>
<li>递归 - multi_cached_state</li>
</ul>

<pre><code class="language-perl">multi fibonacci (0)  { 1 }

multi fibonacci (1)  { 1 }

multi fibonacci (Int $n --&gt; Int) {
    state %cached;
    return %cached{$n} //= fibonacci($n-1) + fibonacci($n-2);
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}
</code></pre>

<p>0.885s</p>

<ul>
<li>递归 - multi_cached_trait</li>
</ul>

<pre><code class="language-perl">multi fibonacci (0)  { 1 }

multi fibonacci (1)  { 1 }

multi fibonacci (Int $n --&gt; Int) is cached {
    fibonacci($n-1) + fibonacci($n-2);
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}
</code></pre>

<p>目前报错。</p>

<ul>
<li>序列</li>
</ul>

<pre><code class="language-perl">use v6;

sub fibonacci (Int $n) {
    constant @sequence :=  1, 1, *+* ... *;

    return @sequence[$n];
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}
</code></pre>

<p>1.6s多。 其中 <code>:=</code> 是惰性赋值。按需求值。</p>

<ul>
<li>序列 - inline</li>
</ul>

<pre><code class="language-perl">sub fibonacci (Int $n) {
    (1, 1, *+* ... *)[$n];
}

for 0..1000 -&gt; $i {
    say $i.fmt('%3d'), ': ', fibonacci($i);
}
</code></pre>

<p>Finished in 133.808s.</p>

<h2 id="排序">排序</h2>

<hr />

<ul>
<li>bogosort</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

sub bogosort ( *@list ) {

    until [!after] @list {
        @list .= pick(*);
    }

    return @list;
}

#my @data = 6, 7, 2, 1, 8, 9, 2;
my @data =  &lt; p e r l s i x &gt;;

say 'input  = ' ~          @data;
say 'output = ' ~ bogosort @data;
</code></pre>

<p>输出：</p>

<pre><code>input  = p e r l s i x
output = e i l p r s x
[Finished in 1.326s]
</code></pre>

<ul>
<li>mergesort</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

sub merge (@a, @b) {
    gather while @a &amp;&amp; @b {
        if @a[0] before @b[0] { take @a.shift }
        else                  { take @b.shift }
    },
    @a,
    @b;
}

sub mergesort ( *@list ) {
    return @list if @list.elems &lt;= 1;

    my $middle = @list.elems div 2;
    my @left   = mergesort @list[ 0 ..^ $middle ];
    my @right  = mergesort @list[ $middle .. *  ];

    return merge(@left, @right);
}

# my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;
my @data = &lt; p e r l s i x &gt;;

say &quot;input  = {           @data  }&quot;;
say &quot;output = { mergesort(@data) }&quot;;
</code></pre>

<p>输出：</p>

<pre><code>input  = p e r l s i x
output = e i l p r s x
[Finished in 0.337s]
</code></pre>

<ul>
<li>mergesort_functional</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

multi merge ([], @ys) { @ys }

multi merge (@xs, []) { @xs }

multi merge ([$x, *@xs], [$y, *@ys]) {
    $x before $y ?? ($x, merge @xs, [$y, @ys])
                 !! ($y, merge [$x, @xs], @ys)
}


multi mergesort ( [] ) {  []  }

multi mergesort ([$x]) { [$x] }

multi mergesort (@xs)  {
    merge
        mergesort( @xs[0 ..^ @xs.elems div 2] ),
        mergesort( @xs[@xs.elems div 2 .. * ] )
}

 my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;
#my @data = &lt; p e r l s i x &gt;;

say &quot;input  = {           @data  }&quot;;
say &quot;output = { mergesort(@data) }&quot;;
</code></pre>

<p>输出：</p>

<pre><code>input  = 6 7 2 1 8 9 5 3 4
output = 1 2 3 4 5 6 7 8 9
[Finished in 0.373s]
</code></pre>

<ul>
<li>mergesort_functional_given</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

multi merge ([], @ys) { @ys }

multi merge (@xs, []) { @xs }

multi merge ([$x, *@xs], [$y, *@ys]) {
    $x before $y ?? ($x, merge @xs, [$y, @ys])
                 !! ($y, merge [$x, @xs], @ys)
}


multi mergesort ( [] ) {  []  }

multi mergesort ([$x]) { [$x] }

multi mergesort (@xs)  {
    given @xs.elems div 2 -&gt; $middle {
        merge
            mergesort( @xs[ 0 ..^ $middle ] ),
            mergesort( @xs[ $middle .. *  ] )
    }
}


 my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;
#my @data = &lt; p e r l s i x &gt;;

say &quot;input  = {           @data  }&quot;;
say &quot;output = { mergesort(@data) }&quot;;
</code></pre>

<p>输出：</p>

<pre><code>input  = 6 7 2 1 8 9 5 3 4
output = 1 2 3 4 5 6 7 8 9
[Finished in 0.375s]
</code></pre>

<ul>
<li>mergesort_functional_interleaved</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

multi merge ([], @ys) { @ys }

multi merge (@xs, []) { @xs }

multi merge ([$x, *@xs], [$y, *@ys]) {
    $x before $y ?? ($x, merge @xs, [$y, @ys])
                 !! ($y, merge [$x, @xs], @ys)
}


multi mergesort ( [] ) {  []  }

multi mergesort ([$x]) { [$x] }

multi mergesort (@xs)  {
    merge
        mergesort( @xs[0,2...*] ),
        mergesort( @xs[1,3...*] )
}

 my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;
#my @data = &lt; p e r l s i x &gt;;

say &quot;input  = {           @data  }&quot;;
say &quot;output = { mergesort(@data) }&quot;;
</code></pre>

<p>输出：</p>

<pre><code>input  = 6 7 2 1 8 9 5 3 4
output = 1 2 3 4 5 6 7 8 9
[Finished in 0.34s]
</code></pre>

<ul>
<li>quicksort</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

sub quicksort( *@list ) {
    return @list if @list.elems &lt; 2;

    my $pivot = @list.shift;
#     my $pivot = @list.=pick(*).shift;

    my (@before, @after);
    for @list -&gt; $elem {
        if $elem before $pivot { @before.push($elem); }
        else                   { @after.push($elem);  }
    }

    return quicksort(@before),
           $pivot,
           quicksort(@after);
}

#my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;
my @data = &lt; p e r l s i x &gt;;

say &quot;input  = {           @data  }&quot;;
say &quot;output = { quicksort(@data) }&quot;;
</code></pre>

<p>输出：</p>

<pre><code>input  = p e r l s i x
output = e i l p r s x
[Finished in 0.246s]
</code></pre>

<ul>
<li>quicksort_classify</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

multi quicksort(  []  ) {    };
multi quicksort(  Mu  ) {    };

multi quicksort( [$x] ) { $x };

multi quicksort( [$pivot, *@xs] ) {
    given @xs.classify:{ $^elem before $pivot ?? 'pre' !! 'post'} {
        quicksort( .&lt;pre&gt;  ),
        $pivot,
        quicksort( .&lt;post&gt; );
    }
}

#my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;
my @data = &lt; p e r l s i x &gt;;

say &quot;input  = {           @data  }&quot;;
say &quot;output = { quicksort(@data) }&quot;;
</code></pre>

<p>输出：</p>

<pre><code>input  = p e r l s i x
output =  e i  l p  r  s x
[Finished in 0.303s]
</code></pre>

<ul>
<li>quicksort_functional</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

multi quicksort(  []  ) {    };

multi quicksort( [$x] ) { $x };

multi quicksort( [$pivot, *@xs] ) {
    quicksort(@xs.grep: * before $pivot),
    $pivot,
    quicksort(@xs.grep: * !before $pivot);
}

#my @data = 6, 7, 2, 1, 8, 9, 5, 3, 4;
my @data = &lt; p e r l s i x &gt;;

say &quot;input  = {           @data  }&quot;;
say &quot;output = { quicksort(@data) }&quot;;
</code></pre>

<p>输出:</p>

<pre><code>input  = p e r l s i x
output =  e i l  p  r  s x
[Finished in 0.27s]
</code></pre>

<h2 id="pm-模块">pm 模块</h2>

<hr />

<p>首先把自定义的 Bank.pm 模块复制到 Perl 6 的 lib 目录下：</p>

<pre><code class="language-perl">cp Bank.pm /Users/chenyf/.rakudobrew/moar-nom/install/share/perl6/site/lib
</code></pre>

<p>Bank.pm</p>

<pre><code class="language-perl">#! /usr/bin/perl6
use v6;

class Ident {
    subset Pattern of Str where / \d**3 '-' \d**3 '-' \d**3 /;

    has Str $.name              = '????';
    has Str $.ID  where Pattern = '000-000-000';
}

role Taxable [:$THRESHOLD = 100_000] {
    constant GENERAL_TAX_RATE = 0.01;

    has %.tax_record;

    method tax_credits {...}

    method calculate_tax () {
        my $tax_payable = ($.balance min $THRESHOLD) * GENERAL_TAX_RATE
                          - $.tax_credits;

        %!tax_record{now} = $tax_payable;

        return $tax_payable;
    }
}

class Account
    does Taxable
{
    subset ID of Str where / &lt;alpha&gt;**4 &lt;digit&gt;**5 /;

    state ID $next_account_ID = 'AAAA00001';

    has Str     $.name        = die 'Must provide account name';
    has Numeric $.balance     = 0;
    has ID      $.ID          = $next_account_ID++;

    method deposit(Numeric $amount where *&gt;0) {
        $!balance += $amount;
    }

    method withdraw(Numeric $amount where *&gt;0) {
        fail &quot;Insufficient funds to withdraw $amount&quot;
            if $.balance &lt; $amount;
        $!balance -= $amount;
    }

    method description () {
        &quot;$.ID ($.name): balance=$.balance&quot;;
    }

    method tax_credits { 0 }
}

class Bank {
    has Ident   $!ident     handles&lt; name ID &gt;;
    has Account %!accounts;

    submethod BUILD (|args) {
        $!ident .= new(|args);
    }

    method add_account(Account $account) {
        %!accounts{$account.ID} = $account;
    }

    method close_account(Str $ID) {
        return %!accounts{$ID} :delete
            // fail &quot;No such account&quot;;
    }

    multi method get_account(Account::ID $ID) {
        return %!accounts{$ID} // fail &quot;No such account&quot;;
    }

    multi method get_account(Any $name) {
#        return %!accounts.values.grep({.name ~~ $name});
        self.for_each_account({.take if .name ~~ $name});
    }

    method for_each_account (&amp;action_on) {
        gather for %!accounts.values -&gt; $account is rw {
            action_on($account);
        }
    }

    method collect_taxes () {
        self.for_each_account: {
            my $tax = .calculate_tax();
            .withdraw($tax);
            take .ID =&gt; $tax;
        }
    }

    method report () {
        say &quot;[ {self.ID} [{self.name}] ]&quot;;         # Or: say &quot;[ $.ID [$.name] ]&quot;;
        self.for_each_account(*.description.say);
        say '';
    }
}


class Account::Corporate
    is Account
    does Taxable[THRESHOLD =&gt; 1_000_000]
{
    has Str $.company_ID;

    method tax_credits { 5_000 }

    method description () {
        callsame() ~ &quot;  [$.company_ID]&quot;;
    }
}
</code></pre>

<p>该模块的功能是计算银行存款汇率等。下面使用这个模块：</p>

<ul>
<li>demo</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

use Bank;

my Bank $bank .= new(:ID('123-456-789'));

$bank.add_account: Account.new(:name('Leslie Grace')                  );
$bank.add_account: Account.new(:name('Dana McKenna'), :balance(10_000));
$bank.add_account: Account.new(:name('AstroDynamic'), :balance(   2e7));
$bank.add_account: Account.new(:name('Jan van Quod'), :balance( 9_999));
$bank.add_account: Account.new(:name('OmniCorp LLC'), :balance(   1e6));
$bank.report;

$bank.get_account('AAAA00003').deposit(100);
$bank.get_account('Jan van Quod')».deposit(2);
$bank.get_account(/D.na/)».deposit(2);
#$bank.get_account(*)».deposit(99);
$bank.report;

given $bank.close_account('AAAA00005') {
    say &quot;Closed $^account.perl()\n&quot;;
    $bank.report;
}

$bank.close_account('ZZZZ99999');

$bank.get_account('AAAA00001').withdraw(1001);
$bank.report;
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=9999
AAAA00001 (Leslie Grace): balance=0
AAAA00005 (OmniCorp LLC): balance=1000000
AAAA00002 (Dana McKenna): balance=10000
AAAA00003 (AstroDynamic): balance=20000000

[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=10001
AAAA00001 (Leslie Grace): balance=0
AAAA00005 (OmniCorp LLC): balance=1000000
AAAA00002 (Dana McKenna): balance=10002
AAAA00003 (AstroDynamic): balance=20000102

Closed Account.new(name =&gt; &quot;OmniCorp LLC&quot;, balance =&gt; 1000000e0, ID =&gt; &quot;AAAA00005&quot;, tax_record =&gt; {}&lt;&gt;)

[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=10001
AAAA00001 (Leslie Grace): balance=0
AAAA00002 (Dana McKenna): balance=10002
AAAA00003 (AstroDynamic): balance=20000102

No such account
  in method close_account at /Users/chenyf/.rakudobrew/moar-nom/install/share/perl6/site/lib/Bank.pm:67
  in block &lt;unit&gt; at /Users/chenyf/Downloads/Perl6_Transparadigm_examples/04.bank_demo.pl:26

Actually thrown at:
  in block &lt;unit&gt; at /Users/chenyf/Downloads/Perl6_Transparadigm_examples/04.bank_demo.pl:26

[Finished in 0.768s]
</code></pre>

<ul>
<li>demo_inheritance</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

sub show ($text) {
    say '';
    say ('____/ ' ~ $text ~ ' \_________________________________________________').substr(0,50);
}

use Bank;

my Bank $bank .= new(:ID('123-456-789'), :name('Bank of Evil'));

$bank.add_account: Account.new(:name('Leslie Grace'), :balance( 1_000));
$bank.add_account: Account.new(:name('Dana McKenna'), :balance(10_000));
$bank.add_account: Account.new(:name('Jan van Quod'), :balance( 9_999));

$bank.add_account: Account::Corporate.new(:name('AstroDynamic'), :balance(2e7) :company_ID('ASDY'));
$bank.add_account: Account::Corporate.new(:name('OmniCorp LLC'), :balance(1e6) :company_ID('OMNI'));

show 'Status';
$bank.report;

show 'Taxes collected';
.say for $bank.collect_taxes();

show 'Status';
$bank.report;

$bank.collect_taxes();

show 'Tax records';
$bank.for_each_account({ say .name, ': ', .tax_record });

show 'Culling acounts';
given $bank {
    .for_each_account: {
        .close_account($^account.ID).say
            if $^account.balance &lt; 10_000;
    }
}

show 'Status';
$bank.report;
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">____/ Status \____________________________________
[ 123-456-789 [Bank of Evil] ]
AAAA00004 (AstroDynamic): balance=20000000  [ASDY]
AAAA00001 (Leslie Grace): balance=1000
AAAA00005 (OmniCorp LLC): balance=1000000  [OMNI]
AAAA00002 (Dana McKenna): balance=10000
AAAA00003 (Jan van Quod): balance=9999


____/ Taxes collected \___________________________
AAAA00004 =&gt; 5000
AAAA00001 =&gt; 10
AAAA00005 =&gt; 5000
AAAA00002 =&gt; 100
AAAA00003 =&gt; 99.99

____/ Status \____________________________________
[ 123-456-789 [Bank of Evil] ]
AAAA00004 (AstroDynamic): balance=19995000  [ASDY]
AAAA00001 (Leslie Grace): balance=990
AAAA00005 (OmniCorp LLC): balance=995000  [OMNI]
AAAA00002 (Dana McKenna): balance=9900
AAAA00003 (Jan van Quod): balance=9899.01

____/ Tax records \_______________________________
AstroDynamic: Instant:1440413601.447466 =&gt; 5000, Instant:1440413601.463112 =&gt; 5000
Leslie Grace: Instant:1440413601.450753 =&gt; 10, Instant:1440413601.465823 =&gt; 9.9
OmniCorp LLC: Instant:1440413601.452933 =&gt; 5000, Instant:1440413601.468346 =&gt; 4950
Dana McKenna: Instant:1440413601.454860 =&gt; 100, Instant:1440413601.470238 =&gt; 99
Jan van Quod: Instant:1440413601.457399 =&gt; 99.99, Instant:1440413601.471551 =&gt; 98.9901
____/ Culling acounts \___________________________
Account.new(name =&gt; &quot;Leslie Grace&quot;, balance =&gt; 980.1, ID =&gt; &quot;AAAA00001&quot;, tax_record =&gt; {&quot;Instant:1440413601.450753&quot; =&gt; 10.0, &quot;Instant:1440413601.465823&quot; =&gt; 9.9}&lt;&gt;)
Account.new(name =&gt; &quot;Dana McKenna&quot;, balance =&gt; 9801.0, ID =&gt; &quot;AAAA00002&quot;, tax_record =&gt; {&quot;Instant:1440413601.454860&quot; =&gt; 100.0, &quot;Instant:1440413601.470238&quot; =&gt; 99.0}&lt;&gt;)
Account.new(name =&gt; &quot;Jan van Quod&quot;, balance =&gt; 9800.0199, ID =&gt; &quot;AAAA00003&quot;, tax_record =&gt; {&quot;Instant:1440413601.457399&quot; =&gt; 99.99, &quot;Instant:1440413601.471551&quot; =&gt; 98.9901}&lt;&gt;)

____/ Status \____________________________________
[ 123-456-789 [Bank of Evil] ]
AAAA00004 (AstroDynamic): balance=19990000  [ASDY]
AAAA00005 (OmniCorp LLC): balance=990050  [OMNI]

[Finished in 0.817s]
</code></pre>

<ul>
<li>demo_unary_dot</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

use Bank;

my Bank $bank .= new(:ID('123-456-789'));

given $bank {
    .add_account: Account.new(:name('Leslie Grace'), :balance( 1_000));
    .add_account: Account.new(:name('Dana McKenna'), :balance(10_000));
    .add_account: Account.new(:name('AstroDynamic'), :balance(   2e7));
    .add_account: Account.new(:name('Jan van Quod'), :balance( 9_999));
    .add_account: Account.new(:name('OmniCorp LLC'), :balance(   1e6));
    .report;

    .get_account('AAAA00003').deposit(100);
    .report;

    say .close_account('AAAA00005');
    .report;

    .get_account('AAAA00001').withdraw(1001);
    .report;
}
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=9999
AAAA00001 (Leslie Grace): balance=1000
AAAA00005 (OmniCorp LLC): balance=1000000
AAAA00002 (Dana McKenna): balance=10000
AAAA00003 (AstroDynamic): balance=20000000

[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=9999
AAAA00001 (Leslie Grace): balance=1000
AAAA00005 (OmniCorp LLC): balance=1000000
AAAA00002 (Dana McKenna): balance=10000
AAAA00003 (AstroDynamic): balance=20000100

Account.new(name =&gt; &quot;OmniCorp LLC&quot;, balance =&gt; 1000000e0, ID =&gt; &quot;AAAA00005&quot;, tax_record =&gt; {}&lt;&gt;)
[ 123-456-789 [????] ]
AAAA00004 (Jan van Quod): balance=9999
AAAA00001 (Leslie Grace): balance=1000
AAAA00002 (Dana McKenna): balance=10000
AAAA00003 (AstroDynamic): balance=20000100

Insufficient funds to withdraw 1001
  in method withdraw at /Users/chenyf/.rakudobrew/moar-nom/install/share/perl6/site/lib/Bank.pm:43
  in block &lt;unit&gt; at /Users/chenyf/Downloads/Perl6_Transparadigm_examples/04.bank_demo_unary_dot.pl:22

Actually thrown at:
  in block &lt;unit&gt; at /Users/chenyf/Downloads/Perl6_Transparadigm_examples/04.bank_demo_unary_dot.pl:22

[Finished in 0.738s]
</code></pre>

<h2 id="lzw">LZW</h2>

<hr />

<p><a href="http://baike.baidu.com/view/401141.htm">LZW算法</a></p>

<ul>
<li>demo</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

sub compress(Str $uncompressed --&gt; List)  {
    # Build a look-up table of encoded representations
    # (each ASCII char represented by its equivalent codepoint)
    my %code_for = map { $^ASCII.chr =&gt; $^ASCII }, ^256;

    # Loop and collect each encoding...
    gather {
        # Track which characters we've seen but not yet encoded
        my $already_seen = &quot;&quot;;

        # Walk through each single character...
        for $uncompressed.comb -&gt; $next_char {
            # Now we've seen that next character as well
            my $now_seen = $already_seen ~ $next_char;

            # If new char sequence is known, keep looking
            if %code_for{$now_seen}:exists {
                $already_seen = $now_seen;
            }
            # Otherwise, we have an unknown sequence of chars
            else {
                # Emit encoding for what we've previously seen
                take %code_for{$already_seen};
                # Add encoding for new unknown sequence to table
                %code_for{$now_seen} = %code_for.elems;
                # Restart the current sequence from this char
                $already_seen = $next_char;
            }
        }
        # Emit the encoding for the final sequence (if any)
        take %code_for{$already_seen} if $already_seen ne &quot;&quot;;
    }
}

# Convert to codepoints...
my @codes = compress('To be or not to be. That be the question, matey!');
say @codes;
separator;

# Emit as characters...
say @codes&gt;&gt;.chr;
separator;

# Convert to a binary sequence...
my $bits_per_code = @codes.max.log(2).ceiling();
my $format = '%0' ~ $bits_per_code ~ 'b';
my $bits = @codes&gt;&gt;.fmt($format).join;
say $bits;
separator;

say $bits.comb(/.**1..7/).map({:2($^bitpattern).chr}).join;
separator;





sub separator { say '_' x 50 }
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">84 111 32 98 101 32 111 114 32 110 111 116 32 116 257 259 46 32 84 104 97 267 259 268 104 260 113 117 101 115 116 105 111 110 44 32 109 276 101 121 33
__________________________________________________
T o   b e   o r   n o t   t ā ă .   T h a ċ ă Č h Ą q u e s t i o n ,   m Ĕ e y !
__________________________________________________
001010100001101111000100000001100010001100101000100000001101111001110010000100000001101110001101111001110100000100000001110100100000001100000011000101110000100000001010100001101000001100001100001011100000011100001100001101000100000100001110001001110101001100101001110011001110100001101001001101111001101110000101100000100000001101101100010100001100101001111001000100001
__________________________________________________
x@1QoB\7NAt@0\
C aBp4 CDu'h4Ms8,l(2O
__________________________________________________
[Finished in 0.429s]
</code></pre>

<ul>
<li>LZW_functional</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

# To compress a string...
sub compress(Str $uncompressed) {
    # Encode the character list via a dictionary, from the start
    encode( $uncompressed.comb, code =&gt; hash(map {$^ASCII.chr =&gt; $^ASCII}, ^256), seen =&gt; &quot;&quot; )
}

# Encode an empty list where nothing already seen as nothing
multi encode([], :%code, :$seen where &quot;&quot;) {}

# Encode an empty list where something already seen by look-up
multi encode([], :%code, :$seen)          { %code{$seen} }

# Encode an list of one or more uncompressed characters...
multi encode([$next, *@uncompressed], :%code, :$seen)  {
    # If [already-seen plus next char] is a known sequence...
    %code{ $seen~$next }:exists
         # Then encode all of that together
        ?? encode(@uncompressed, :%code, seen =&gt; $seen~$next)

         # Else emit encoding for the already-seen sequence
        !! ( %code{$seen},
             # Plus the encoding for the rest of the string...
             encode( @uncompressed,
                     # Add encoding for new sequence to table
                     code =&gt; %( %code, $seen~$next =&gt; %code.elems ),
                     # Continue encoding from next character
                     seen =&gt; $next
             )
           )
}


# Convert to codepoints...
my @codes = compress('To be or not to be. That be the question, matey!');
say @codes;
separator;

# Emit as characters...
say @codes&gt;&gt;.chr;
separator;

# Convert to a binary sequence...
my $bits_per_code = @codes.max.log(2).ceiling();
my $format = '%0' ~ $bits_per_code ~ 'b';
my $bits = @codes&gt;&gt;.fmt($format).join;
say $bits;
separator;

say $bits.comb(/.**1..7/).map({:2($^bitpattern).chr}).join;
separator;





sub separator { say '_' x 50 }
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">84 111 32 98 101 32 111 114 32 110 111 116 32 116 257 259 46 32 84 104 97 267 259 268 104 260 113 117 101 115 116 105 111 110 44 32 109 276 101 121 33
__________________________________________________
T o   b e   o r   n o t   t ā ă .   T h a ċ ă Č h Ą q u e s t i o n ,   m Ĕ e y !
__________________________________________________
001010100001101111000100000001100010001100101000100000001101111001110010000100000001101110001101111001110100000100000001110100100000001100000011000101110000100000001010100001101000001100001100001011100000011100001100001101000100000100001110001001110101001100101001110011001110100001101001001101111001101110000101100000100000001101101100010100001100101001111001000100001
__________________________________________________
x@1QoB\7NAt@0\
C aBp4 CDu'h4Ms8,l(2O
__________________________________________________
[Finished in 0.658s]
</code></pre>

<ul>
<li>validation_concurrent</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

my @records = (
    { :Name&lt;Damian Conway&gt;, :Age(42), :ID('00012345')  },
    { :Name&lt;Leslie Duvall&gt;, :Age(29), :ID('668')       },
    { :Name&lt;Sam Georgious&gt;, :Age(-2), :ID('00000007')  },
);

sub normalize_data (Hash $record) {
    $record&lt;Name&gt;  .= subst(/&lt;lower&gt;/,{$&lt;lower&gt;.uc}, :g);
    $record&lt;Age&gt; max= 18;
    $record&lt;ID&gt;    .= fmt('%08d');
}

sub report ($outcome) {
    say &quot;\tInvalid record ($outcome)&quot;;
}


sub invalid_name ($rec) { &quot;Bad name: $rec&quot; if $rec&lt;Name&gt; !~~ /\S/;        }
sub invalid_age  ($rec) { &quot;Bad age:  $rec&quot; if $rec&lt;Age&gt;  &lt; 18;            }
sub invalid_ID   ($rec) { &quot;Bad ID:   $rec&quot; if $rec&lt;ID&gt;   !~~ /^\d ** 8$/; }


say 'Validating...';
my @invalidations = (
    @records».&amp;invalid_name,
    @records».&amp;invalid_age,
    @records».&amp;invalid_ID,
);

@invalidations».&amp;report;

say 'Normalizing...';
@records».&amp;normalize_data;

say 'Revalidating...';

@invalidations = (
    @records».&amp;invalid_name,
    @records».&amp;invalid_age,
    @records».&amp;invalid_ID,
);

@invalidations».&amp;report;
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">Validating...
postcircumfix:&lt;{ }&gt; not defined for type Str
  in sub invalid_name at -e:67
  in block &lt;unit&gt; at -e:73

Actually thrown at:
  in sub invalid_name at -e:67
  in block &lt;unit&gt; at -e:73

[Finished in 0.374s]
</code></pre>

<ul>
<li>validation_imperative</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

my @records = (
    { :Name&lt;Damian Conway&gt;, :Age(42), :ID('00012345')  },
    { :Name&lt;Leslie Duvall&gt;, :Age(29), :ID('668')       },
    { :Name&lt;Sam Georgious&gt;, :Age(-2), :ID('00000007')  },
);

sub normalize_data (Hash $record) {
    $record&lt;Name&gt;  .= subst(/&lt;lower&gt;/,{$&lt;lower&gt;.uc}, :g);
    $record&lt;Age&gt; max= 18;
    $record&lt;ID&gt;    .= fmt('%08d');
}

sub report ($outcome) {
    say &quot;\tInvalid record ($outcome)&quot;;
}


sub invalid_name ($rec) { &quot;Bad name: $rec&quot; if $rec&lt;Name&gt; !~~ /\S/;        }
sub invalid_age  ($rec) { &quot;Bad age:  $rec&quot; if $rec&lt;Age&gt;  &lt; 18;            }
sub invalid_ID   ($rec) { &quot;Bad ID:   $rec&quot; if $rec&lt;ID&gt;   !~~ /^\d ** 8$/; }


say 'Validating...';
my @invalidations = gather for @records -&gt; $record {
    take invalid_name($record);
    take invalid_age($record);
    take invalid_ID($record);
}

for @invalidations -&gt; $errmsg {
    report( $errmsg );
}

say 'Normalizing...';
for @records -&gt; $record {
    normalize_data($record);
}

say 'Revalidating...';

@invalidations = gather for @records -&gt; $record {
    take invalid_name($record);
    take invalid_age($record);
    take invalid_ID($record);
}

for @invalidations -&gt; $errmsg {
    report( $errmsg );
}
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">Validating...
    Invalid record (Bad ID:   Name  Leslie Duvall Age   29 ID   668)
    Invalid record (Bad age:  Name  Sam Georgious Age   -2 ID   00000007)
Normalizing...
Revalidating...
[Finished in 0.399s]
</code></pre>

<ul>
<li>validation_junctions</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

my @records = (
    { :Name&lt;Damian Conway&gt;, :Age(42), :ID('00012345')  },
    { :Name&lt;Leslie Duvall&gt;, :Age(29), :ID('668')       },
    { :Name&lt;Sam Georgious&gt;, :Age(-2), :ID('00000007')  },
);

sub normalize_data (Hash $record) {
    $record&lt;Name&gt;  .= subst(/&lt;lower&gt;/,{$&lt;lower&gt;.uc}, :g);
    $record&lt;Age&gt; max= 18;
    $record&lt;ID&gt;    .= fmt('%08d');
}

sub report ($outcome) {
    say &quot;\tInvalid record ($outcome)&quot;;
}


sub invalid_name ($rec) { &quot;Bad name: $rec&quot; if $rec&lt;Name&gt; !~~ /\S/;        }
sub invalid_age  ($rec) { &quot;Bad age:  $rec&quot; if $rec&lt;Age&gt;  &lt; 18;            }
sub invalid_ID   ($rec) { &quot;Bad ID:   $rec&quot; if $rec&lt;ID&gt;   !~~ /^\d ** 8$/; }

my $invalid_record = &amp;invalid_name | &amp;invalid_age | &amp;invalid_ID;

say 'Validating...';
report( $invalid_record(all @records) );

say 'Normalizing...';
normalize_data(all @records);

say 'Revalidating...';
report( $invalid_record(all @records) );
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">Validating...
    Invalid record (Bad ID:   Name  Leslie Duvall Age   29 ID   668)
    Invalid record (Bad age:  Name  Sam Georgious Age   -2 ID   00000007)
Normalizing...
Revalidating...
[Finished in 0.399s]
</code></pre>

<ul>
<li>prime_demo</li>
</ul>

<p>​</p>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

sub is_prime(Int $n) {
    return $n % all(2..$n.sqrt+1);
}


for 1..1001 -&gt; $n {
    say &quot;$n is prime&quot; if is_prime($n);
}
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">1 is prime
3 is prime
5 is prime
7 is prime
11 is prime
...
991 is prime
997 is prime
[Finished in 1.478s]
</code></pre>

<ul>
<li>统计</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

my @values = (1, 1, 3, 4, 4, 4, 4, 5, 5, 5, 7, 7, 12, 12, 1, 7, 7, 99);

say 'mean (a) = ', mean_a(@values);
say 'mean (g) = ', mean_g(@values);
say '    mode = ',   mode(@values);
say '  median = ', median(@values);

sub mean_a (*@list) {
    ([+] @list) / @list.elems;
}

sub mean_g (*@list) {
    ([*] @list) ** (1/@list.elems);
}

sub mode (*@list) {
    given @list.Bag {
        .pairs.grep({$^elem.value == .values.max})».key;
    }
}

sub median (*@list) {
    given @list.sort {
        .elems %% 2
            ?? mean_a( .[*/2-1, */2] )
            !!         .[*/2];
    }
}
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">mean (a) = 10.444444
mean (g) = 4.95872541158849
    mode = 7 4
  median = 5
[Finished in 0.319s]
</code></pre>

<ul>
<li>stats_hybird</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

my @values = (1, 1, 3, 4, 4, 4, 4, 5, 5, 5, 7, 7, 12, 12, 1, 7, 7, 99);

say 'mean (a) = ', mean_a(@values);
say 'mean (g) = ', mean_g(@values);
say '    mode = ',   mode(@values);
say '  median = ', median(@values);

sub mean_a (*@list) {
    my $sum = [+] @list;
    return $sum / @list.elems;
}

sub mean_g (*@list) {
    my $product = [*] @list;
    return $product ** (1/@list.elems)
}

sub mode (*@list) {
    my $frequencies = @list.Bag;
    my $list_elems  = $frequencies.pairs;
    my $max_freq    = $frequencies.values.max;
    my @max_vals    = $list_elems.grep({.value == $max_freq});

    return @max_vals».key;
}

sub median (*@list) {
    my @sorted = @list.sort;
    return @sorted.elems %% 2 ?? mean_a(@sorted.[*/2, */2-1])
                              !!        @sorted.[*/2]
}
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">mean (a) = 10.444444
mean (g) = 4.95872541158849
    mode = 7 4
  median = 5
[Finished in 0.319s]
</code></pre>

<ul>
<li>stats_imperative</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

my @values = (1, 1, 3, 4, 4, 4, 4, 5, 5, 5, 7, 7, 12, 12, 1, 7, 7, 99);

say 'mean (a) = ', mean_a(@values);
say 'mean (g) = ', mean_g(@values);
say '    mode = ',   mode(@values);
say '  median = ', median(@values);

sub mean_a (*@list) {
    my $sum;
    for @list -&gt; $elem {
        $sum += $elem;
    }
    return $sum / @list.elems;
}

sub mean_g (*@list) {
    my $product;
    for @list -&gt; $elem {
        $product *= $elem;
    }
    return $product ** (1/@list.elems);
}

sub mode (*@list) {
    my %counts;
    %counts{$_}++ for @list;
    my $max = %counts.values.max;
    return %counts.grep({ .value == $max })».key;
}

sub median (*@list) {
    @list.=sort();

    return @list.elems %% 2
            ?? mean_a( @list[*/2, */2-1] )
            !!         @list[*/2];
}
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">mean (a) = 10.444444
mean (g) = 4.95872541158849
    mode = 4 7
  median = 5
[Finished in 0.316s]
</code></pre>

<ul>
<li>stats_mode_func</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

my @values = (1, 1, 3, 4, 4, 4, 4, 5, 5, 5, 7, 7, 12, 12, 1, 7, 7, 99);

say 'mean (a) = ', mean_a(@values);
say 'mean (g) = ', mean_g(@values);
say '    mode = ',   mode(@values);
say '  median = ', median(@values);

sub mean_a (*@list) {
    sub sum { [+] @list }
    return sum() / @list.elems;
}

sub mean_g (*@list) {
    sub product { [*] @list }
    return product() ** (1/@list.elems)
}

sub mode (*@list) {
    sub frequencies { @list.Bag                             }
    sub list_elems  { frequencies.pairs                     }
    sub max_freq    { frequencies.values.max                }
    sub max_vals    { list_elems.grep: {.value == max_freq} }

    return max_vals».keys;
}

sub median (*@list) {
    sub sorted { @list.sort }
    return sorted.elems %% 2
                ?? mean_a(sorted.[*/2, */2-1])
                !!        sorted.[*/2]
}
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">mean (a) = 10.444444
mean (g) = 4.95872541158849
    mode = 7 4
  median = 5
[Finished in 0.357s]
</code></pre>

<ul>
<li>stats_OO</li>
</ul>

<pre><code class="language-perl">#! /usr/bin/env perl6
use v6;

class StatList is List {
    method mean_a () {
        sub sum { [+] self }
        return sum() / self.elems;
    }

    method mean_g () {
        sub product { [*] self }
        return product() ** (1/self.elems)
    }

    method median () {
        sub sorted { self.sort }
        return sorted.elems %% 2
                    ?? StatList.new(sorted.[*/2, */2-1]).mean_a()
                    !!              sorted.[*/2];
    }

    method mode () {
        sub frequencies { self.Bag                              }
        sub list_elems  { frequencies.pairs                     }
        sub max_freq    { frequencies.values.max                }
        sub max_vals    { list_elems.grep: {.value == max_freq} }

        return  max_vals».keys;
    }
}

my $list = StatList.new(1,3,5,8,8,11);

say $list.mean_a;
say $list.mean_g;
say $list.median;
say $list.mode;
</code></pre>

<p>输出：</p>

<pre><code class="language-perl">6
4.68393277169202
13
8
[Finished in 0.335s]
</code></pre>

<blockquote>
<p>以上所有文件都可以在<a href="http://www.bit.do/P6TP">这儿</a> 下载到 - a Perl 6 introductory tutorial by Damian Conway</p>
</blockquote>

<p>说明：以上脚本的结果都在 Atom 编辑器下运行得到，然而， 需要在终端中打开 Atom，并安装了 script 插件才行。快捷键 <code>command + i</code></p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>ohmysummer ❤ Perl 6</p>
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
