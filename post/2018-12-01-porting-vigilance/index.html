<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="ohmysummer">
    <meta name="description" content="ohmysummer&#39;s personal website">
    <meta name="keywords" content="Perl6,Rakudo">

    <base href="http://ohmysummer.github.io/">
    <title>
  第一天 - 移植 Vigilance, 将 Perl 6 与标准工具集成在一起 · 焉知非鱼
</title>

    <link rel="canonical" href="http://ohmysummer.github.io/post/2018-12-01-porting-vigilance/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.cd087ace86754b082dec94545567f8361cba42e84f8e15edbc4a9f6e52bd1f6a.css" integrity="sha256-zQh6zoZ1Swgt7JRUVWf4Nhy6QuhPjhXtvEqfblK9H2o=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://ohmysummer.github.io/css/style.css">
    

    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://ohmysummer.github.io/">
      焉知非鱼
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/post">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/categories">归档</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/page/about/">关于</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/tags">标签</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>第一天 - 移植 Vigilance, 将 Perl 6 与标准工具集成在一起</h1>
    </header>

    

<h1 id="移植-vigilance-将perl-6与标准工具集成在一起">移植 Vigilance，将Perl 6与标准工具集成在一起</h1>

<p>大家好，今天我们将采用基础设施脚本并将其从Perl 5移植到Perl 6.本文基于James Clark的一对帖子，你可以在这里找到：</p>

<ul>
<li><a href="http://blog.lazycat.com.au/2014/05/integrating-integrity-part-1.html">第1部分</a></li>
<li><a href="http://blog.lazycat.com.au/2014/05/integrating-integrity-part-2.html">第2部分</a></li>
</ul>

<p>此脚本用于创建和验证MD5总和。 这些是128位值，可用于验证数据完整性。 虽然MD5已经被证明在防范恶意行为者方面不安全，但它对于检测磁盘损坏仍然很有用。</p>

<p>Perl 6生态系统正在发展，其中包含多种工具，这些工具可以从Perl 5 CPAN移植，也可以替代。 我将介绍原始脚本和移植的几个方面，并说明我为什么要进行一些特定的更改。 希望这会鼓励你出去移植你自己的小脚本。</p>

<h2 id="shebang-和导入">Shebang 和导入</h2>

<p>Perl 5版本使用一些基础设施和一些实用程序来处理Unicode并使命令行输出更好：</p>

<pre><code class="language-perl">#!/usr/bin/perl -CSDA

use strict;
use warnings;
use utf8;
use Encode qw/encode_utf8 decode_utf8/;
use Getopt::Long;
use Digest::MD5;
use Term::ANSIColor;
use Term::ProgressBar;
use File::Find;
use File::Basename;
use Data::Dumper;
</code></pre>

<p>Perl 6默认启用了警告和限制，并且内置了Unicode支持，因此我们可以将其保留。 Data::Dumper也已经实现，它具有非常有用的IO功能。 将所有这些加在一起我们可以得到一个非常精益的标头：</p>

<pre><code class="language-perl6">#!/usr/bin/env perl6
use v6;

use Digest::MD5;
use Terminal::ANSIColor;
use Terminal::Spinners;
</code></pre>

<h2 id="命令行选项">命令行选项</h2>

<p>Perl 5有许多用于处理命令行参数的很棒的模块，在我们使用 Getopt::Long 的原始脚本中：</p>

<pre><code class="language-perl"># Define our command-line arguments.
my %opts = ( 'blocksize' =&gt; 16384 );
GetOptions(\%opts, &quot;verify=s&quot;, &quot;create=s&quot;, &quot;update=s&quot;, &quot;files&quot;, &quot;blocksize=s&quot;, &quot;help!&quot;);
</code></pre>

<p>在Perl 6中，我们可以直接在MAIN方法中定义命令行选项。 我们使用多个调度来根据传递的参数来控制脚本的执行：</p>

<pre><code class="language-perl6">multi MAIN (Str :$create, *@files where { so @files }) { ... }
multi MAIN (Str :$update, *@files) { ... }
multi MAIN (Str :$verify, *@files) { ... }
multi MAIN (*@files where { so @files }) { ... }
</code></pre>

<p>这也意味着我们不必定义帮助选项/sub，因为我们可以文档化我们的MAIN子例程，因此：</p>

<pre><code class="language-perl6">#| Verify the MD5 sums in a file that conforms to md5sum output:
#|   
multi MAIN (Str :$verify, *@files) { ... }
</code></pre>

<p>您可能已经注意到Perl 6版本没有定义blocksize选项，我将回过头来看看。</p>

<h2 id="io-读写文件">IO: 读写文件</h2>

<p>我们将校验和存储在一个文件中，其中每一行的格式都与GNU coreutils中的md5sum程序的输出相同：32个十六进制数字，两个空格和文件名。</p>

<p>一些基本的IO，我们使用正则表达式来解析每一行。 使用有意义的空格有助于保持每个正则表达式相当简洁：</p>

<pre><code class="language-perl6">sub load_md5sum_file
{
	my ($filename) = @_;
	my @plan;
	
	open(my $fh, '&lt;:utf8', $filename) or die &quot;Couldn't open '$filename' : $!\n&quot;;
	my $linenum = 0;
	while (my $line = &lt;$fh&gt;) {
		chomp $line;
		$linenum++;
		if ($line =~ /^(?\p{ASCII_Hex_Digit}{32})  (?.*)$/) {
			# Checksum and filename compatible with md5sum output.
			push @plan, create_plan_for_filename($+{filename}, $+{md5});
			
		} elsif ($line =~ /^(?\p{ASCII_Hex_Digit}{32})  (?.*)$/) {
			# Checksum and filename compatible with md5sum's manpage but not valid for the actual program.
			# We'll use it, but complain.
			print STDERR colored(&quot;Warning: &quot;, 'bold red'), colored(&quot;md5sum entry '&quot;, 'red'), $line, colored(&quot;' on line $linenum of file $filename is using only one space, not two - this doesn't match the output of the actual md5sum program!.&quot;, 'red'), &quot;\n&quot;;
			push @plan, create_plan_for_filename($+{filename}, $+{md5});
			
		} elsif ($line =~ /^\s*$/) {
			# Blank line, ignore.
			
		} else {
			# No idea. Best not to keep quiet, it could be a malformed checksum line and we don't want to just quietly skip the file if so.
			print STDERR colored(&quot;Warning: &quot;, 'bold red'), colored(&quot;Unrecognised md5sum entry '&quot;, 'red'), $line, colored(&quot;' on line $linenum of file $filename.&quot;, 'red'), &quot;\n&quot;;
			push @plan, { error =&gt; &quot;Unrecognised md5sum entry&quot; };
		}
	}
	close($fh) or die &quot;Couldn't close '$filename' : $!\n&quot;;
	
	return @plan;
}
</code></pre>

<p>Perl 6允许我们验证我们是否通过签名传递了实际存在的文件。 此外，我们用 grammar 替换正则表达式，如果需要，我们可以在脚本的不同位置使用该 grammar：</p>

<pre><code class="language-perl6">grammar MD5SUM {
	token TOP        { &lt;md5&gt; &lt;spacer&gt; &lt;filehandle&gt; }
	token md5        { &lt;xdigit&gt; ** 32 }
	token spacer     { \s+ }
	token filehandle { .* }
}

sub load-md5sum-file (Str $filehandle where { $filehandle.IO.f }) {
	my MD5Plan @plans;

	PARSE: for $filehandle.IO.lines(:close) -&gt; $line {
		next PARSE if !$line; # We don't get worked up over blank lines.

		my $match = MD5SUM.parse($line);

		if (!$match) {
			say $*ERR: colored(&quot;Couldn't parse $line&quot;, $ERROR_COLOUR);
			next PARSE;
		}

		if (!$match&lt;filehandle&gt;.IO.f) {
			say $*ERR: colored(&quot;{ $match&lt;filehandle&gt; } isn't an existing file.&quot;, $ERROR_COLOUR);
			next PARSE;
		}

		if ($match&lt;spacer&gt;.chars == 2) {
			@plans.push(MD5Plan.new($match&lt;filehandle&gt;.Str, $match&lt;md5&gt;.Str));
		}
		else {
			say $*ERR: colored(&quot;'$line' does not match the output of md5sum: wrong number of spaces.&quot;, $WARNING_COLOUR);
			@plans.push(MD5Plan.new($match&lt;filehandle&gt;.Str, $match&lt;md5&gt;.Str));
		}
	}

	 return @plans;
}
</code></pre>

<p>写出数据非常相似：</p>

<pre><code class="language-perl">sub save_md5sum_file
{
	my ($filename, @plan) = @_;
	
	my $fh;
	unless (open($fh, '&gt;:utf8', $filename)) {
		...
	}
	foreach my $plan_entry (@plan) {
		next unless $plan_entry-&gt;{correct_md5} &amp;&amp; $plan_entry-&gt;{filename};
		print $fh &quot;$plan_entry-&gt;{correct_md5}  $plan_entry-&gt;{filename}\n&quot;;
	}
	close($fh) or die &quot;Couldn't close '$filename' : $!\n&quot;;
}
</code></pre>

<p>值得注意的是，Perl 6默认以Unicode格式写入文件：</p>

<pre><code class="language-perl6">sub save-md5sum-file (Str $filehandle, @plans) {
	my $io = $filehandle.IO.open: :w;

	WRITE: for @plans -&gt; $plan {
		next WRITE unless $plan.computed-md5 &amp;&amp; $plan.filehandle;

		$io.say(&quot;{ $plan.computed-md5 }  { $plan.filehandle }&quot;);
	}

	$io.close;
}
</code></pre>

<h2 id="获得md5校验和">获得MD5校验和</h2>

<p>Perl 5版本的Digest::MD5使用了相当多的XS来提高性能。 XS中包含了以块的形式添加数据以进行整体解析的方法。 这允许我们使用ProgressBar向用户展示用户等待时的进度：</p>

<pre><code class="language-perl">sub run_md5_file
{
	my ($plan_entry, $progress_fn) = @_;
	
	# We use the OO interface to Digest::MD5 so we can feed it data a chunk at a time.
	my $md5 = Digest::MD5-&gt;new();
	my $current_bytes_read = 0;
	my $buffer;
	$plan_entry-&gt;{start_time} = time();
	$plan_entry-&gt;{elapsed_time} = 0;
	$plan_entry-&gt;{elapsed_bytes} = 0;
	
	# 3 argument form of open() allows us to specify 'raw' directly instead of using binmode and is a bit more modern.
	open(my $fh, '&lt;:raw', $plan_entry-&gt;{filename}) or die &quot;Couldn't open file $plan_entry-&gt;{filename}, $!\n&quot;;
	
	# Read the file in chunks and feed into md5.
	while ($current_bytes_read = read($fh, $buffer, $opts{blocksize})) {
		$md5-&gt;add($buffer);
		$plan_entry-&gt;{elapsed_bytes} += $current_bytes_read;
		$plan_entry-&gt;{elapsed_time} = time() - $plan_entry-&gt;{start_time};
		&amp;$progress_fn($plan_entry-&gt;{elapsed_bytes});
	}
	# The loop will exit as soon as read() returns 0 or undef. 0 is normal EOF, undef indicates an error.
	die &quot;Error while reading $plan_entry-&gt;{filename}, $!\n&quot; if ( ! defined $current_bytes_read);
	
	close($fh) or die &quot;Couldn't close file $plan_entry-&gt;{filename}, $!\n&quot;;
	
	# We made it out of the file alive. Store the md5 we computed. Note that this resets the Digest::MD5 object.
	$plan_entry-&gt;{computed_md5} = $md5-&gt;hexdigest();
}
</code></pre>

<p>Perl 6版本使用纯Perl并且缺少添加功能，因此我使用微调器而不是进度条。 我们还需要专门设置我们的编码，以避免在将二进制数据读取为Unicode时出现的错误：</p>

<pre><code class="language-perl6">sub calc-md5-sum (MD5Plan $plan) {
    my $md5 = Digest::MD5.new;

    print &quot;Calculating MD5 sum for { $plan.filehandle }       &quot;; # We need some space for the spinner to take up.
	                                                             # I like 'bounce', so I need 6 spaces for the spinner
	                                                             # + an extra one to separate it from the filehandle.

	my Buf $buffer = $plan.filehandle.IO.slurp(:close, :bin);

	my $decoded = $buffer.decode('iso-8859-1');

	my $spinner = Spinner.new(type =&gt; 'bounce');

	my $promise = Promise.start({
		$md5.md5_hex($decoded)
	});

	until $promise.status {
		$spinner.next;
	}

	say ''; # Add a new line after the spinner.

	$plan.computed-md5 = $promise.result;
}
</code></pre>

<h2 id="结束之前的思考">结束之前的思考</h2>

<p>我没有在我的系统上使用Perl 6版本因为Digest::MD5的低性能，在我的系统上我用md5sum调用替换它。 其他可能性是使用Inline::Perl5和Perl 5版本的Digest::MD5，或使用惊人的Perl 6原生调用接口来运行C实现。 我希望这篇文章能激发您将一些自己的Perl 5脚本移植到Perl 6，或者至少为您提供一些命令行交互的技巧。</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>ohmysummer ❤ Perl 6</p>
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
