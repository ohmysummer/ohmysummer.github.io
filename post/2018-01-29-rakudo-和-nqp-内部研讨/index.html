<!DOCTYPE html>
<html lang="zh" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Raku Rakudo 和 NQP 内部研讨(二) - Raku Programming</title>
  <meta name="description" content="title: Rakudo and NQP Internals subtitle: The guts tormented implementers made author: Jonathan Worthington">
  <meta name="author" content="焉知非鱼"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Raku Programming",
    
    "url": "https:\/\/ohmysummer.github.io\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/ohmysummer.github.io\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/ohmysummer.github.io\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/ohmysummer.github.io\/post\/2018-01-29-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8\/",
          "name": "Raku rakudo 和 n q p 内部研讨(二)"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "焉知非鱼"
  },
  "headline": "Raku Rakudo 和 NQP 内部研讨(二)",
  "description" : "title: Rakudo and NQP Internals subtitle: The guts tormented implementers made author: Jonathan Worthington",
  "inLanguage" : "zh",
  "wordCount":  4085 ,
  "datePublished" : "2018-01-29T23:01:01",
  "dateModified" : "2018-01-29T23:01:01",
  "image" : "https:\/\/ohmysummer.github.io\/img\/rakudo.png",
  "keywords" : [ "NQP, Rakudo" ],
  "mainEntityOfPage" : "https:\/\/ohmysummer.github.io\/post\/2018-01-29-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/ohmysummer.github.io\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/ohmysummer.github.io\/img\/rakudo.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Raku Rakudo 和 NQP 内部研讨(二)" />
<meta property="og:description" content="title: Rakudo and NQP Internals subtitle: The guts tormented implementers made author: Jonathan Worthington">
<meta property="og:image" content="https://ohmysummer.github.io/img/rakudo.png" />
<meta property="og:url" content="https://ohmysummer.github.io/post/2018-01-29-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Raku Programming" />

  <meta name="twitter:title" content="Raku Rakudo 和 NQP 内部研讨(二)" />
  <meta name="twitter:description" content="title: Rakudo and NQP Internals subtitle: The guts tormented implementers made author: Jonathan Worthington">
  <meta name="twitter:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:card" content="summary" />
  <link href='https://ohmysummer.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.63.2" />
  <link rel="alternate" href="https://ohmysummer.github.io/index.xml" type="application/rss+xml" title="Raku Programming"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://ohmysummer.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://ohmysummer.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'ohmycloudy', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://ohmysummer.github.io/">Raku Programming</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="博客" href="/">博客</a>
            </li>
          
        
          
            <li>
              <a title="归档" href="/categories">归档</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/page/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        

        

        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span class="hidden-sm hidden-md hidden-lg"></span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Raku Programming" href="https://ohmysummer.github.io/">
            <img class="avatar-img" src="https://ohmysummer.github.io/img/rakudo.png" alt="Raku Programming" />
          </a>
        </div>
      </div>
    

  </div>
</nav>



  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title"></h4>
        </div>
        <div class="modal-body">
          <gcse:search></gcse:search>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal"></button>
        </div>
      </div>
    </div>
  </div>


    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>Raku Rakudo 和 NQP 内部研讨(二)</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;20&nbsp;
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;4085&nbsp;
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;焉知非鱼
    
  
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <p>title: Rakudo and NQP Internals
subtitle: The guts tormented implementers made
author: Jonathan Worthington</p>
<h2 id="课程概览---第二天">课程概览 - 第二天</h2>
<p>欢迎回来. 今天我们会涉及到如下话题:</p>
<ul>
<li>6model</li>
<li>Bounded Serialization and Module Loading</li>
<li>The regex and grammar engine</li>
<li>The JVM backend</li>
<li>The MoarVM backend</li>
</ul>
<h1 id="6model">6model</h1>
<p><em>对象系统的组成成分</em></p>
<h2 id="什么是-6model">什么是 6model?</h2>
<p>6model 提供了一组<strong>用于构建类型和对象系统的原语</strong>.</p>
<p>Rakudo 的类, roles, 枚举和 subset 类型都由这些原语组装在一起. NQP 也是, 尽管 NQP 的对象系统更简单, 它仅仅提供了类和 roles.</p>
<p>这些原语已经在 Parrot 和 JVM 虚拟机上实现了. MoarVM 也提供了那些原语, 但是它走的更远, 它让 6model 成为 MoarVM 的对象系统.</p>
<p>那些原语可能比你想象的更加原始. 例如 6model <strong>没有内置继承或角色组合的概念</strong>. 这些东西在更高的层级中创建.</p>
<h2 id="object--行为--状态">Object = 行为 + 状态</h2>
<p>无论什么语言, 你发现对象总有:</p>
<ul>
<li>对象继承机制, 对象可以拥有 <strong>状态</strong></li>
<li>接收一个对象和名字, 使用名字定位一个<strong>行为</strong>(假设它存在), 并调用它.</li>
</ul>
<p>状态可以由类携带, 或自由存在。行为可能直接地附加在对象上，附加在每个类上，或者通过多种分派机制定位某个行为。</p>
<p>但总是会有<strong>状态</strong>和<strong>行为</strong>。</p>
<h2 id="类型">类型</h2>
<p>大多数语言也有一些<strong>类型</strong>的概念。通常，类型属于彼此之间的关系。例如，给出：</p>
<pre><code>class Event {
    has $.name;
    has $.start-date;
    has $.days;
}
class Hackathon is Event {
    has $.topic;
    has @.hackers;
}
</code></pre>
<p>我们可以说 <code>Hackathon</code> 是 <code>Event</code> 的子类型.</p>
<h2 id="package-种类">Package 种类</h2>
<p>我们不仅有不同的类型，我们有<strong>不同种类的类型</strong>。在 Raku 中，这些对应于不同的<strong>包和类型声明符</strong>。</p>
<pre><code>package     module      knowhow     class
grammar     role        enum        subset
</code></pre>
<p>它们具有相当不同的性质，并且行为方式相当不同。例如，针对 &ldquo;subset&rdquo; 类型的类型检查涉及调用它的 &ldquo;where&rdquo; 从句.</p>
<p>抛开差异，他们每个都会导致某种代表他们声明的类型的<strong>类型对象</strong>。</p>
<h2 id="元对象">元对象</h2>
<p>因此，如果 6model 本身不知道继承和角色组合这样的事情是什么，更不用说子集类型了，这些东西在哪里实现？</p>
<p>答案在于<strong>元对象</strong>。每个存在的对象都有一个与之关联的元对象，它描述了该对象是如何工作的。许多对象可能具有相同的元对象。例如，在 Raku 中，<strong>同一个类的所有对象将共享一个元对象</strong>。</p>
<p>要理解的是<strong>元对象只是一个对象</strong>。
有<em>什么</em>不可思议的。它只是碰巧拥有 <code>new_type</code>，<code>add_method</code>，<code>add_parent</code> 等名字的方法。因此，元对象<strong>不绑定到特定的目标虚拟机</strong>。</p>
<h2 id="representations">Representations</h2>
<p>元对象对对象的类型和语义感兴趣。但是，他们明确地不关心对象在内存中是如何布局的。</p>
<p>与对象有关的内存的分配，布局和访问由<strong>表示</strong>来控制。</p>
<p>表示不是对象。他们是<strong>低级的</strong>并且<strong>每个后端的实现方式也不同</strong>。但他们提供的API是相同的。</p>
<p>因此，除了具有元对象外，每个对象都有一个表示。虽然元对象可能存在于每种类型中，但表示的数量却少得多。</p>
<h2 id="stables-把元对象和表示组合在一起">STables 把元对象和表示组合在一起</h2>
<p>虽然对象拥有一个元对象和一个表示，但是在这之间实际上有一个间接层：<strong>STable</strong>。稍后我们会更仔细地看这些。</p>
<p><img src="eps/6model.eps" alt="50%"></p>
<h2 id="我们的第一个元对象">我们的第一个元对象</h2>
<p>这是我们的第一个对象系统。它支持具有方法的类型。类型将始终具有 <code>P6opaque</code> 表示。</p>
<pre><code>class SimpleHOW {
    has %!methods;
    
    method new_type() {
        nqp::newtype(self.new(), 'P6opaque')
    }
    
    method add_method($obj, $name, $code) {
        %!methods{$name} := $code;
    }
    
    method find_method($obj, $name) {
        %!methods{$name}
    }
}
</code></pre>
<h2 id="使用我们的元对象">使用我们的元对象</h2>
<p>首先，我们来创建一个新的类型，并添加单个方法。</p>
<pre><code>my $Greeter := SimpleHOW.new_type();
$Greeter.HOW.add_method($Greeter, 'greet',
    -&gt; $self, $name { say(&quot;Hello, $name&quot;) });
</code></pre>
<p>现在 <code>$Greeter</code> 变量包含新类型的类型对象。如果我们在它身上调用 <code>greet</code> 方法：</p>
<pre><code>$Greeter.greet('Katerina');
</code></pre>
<p>那么，我们的元对象的 <code>find_method</code> 方法将被调用, 使用 <code>greet</code> 参数，它返回的任何东西都会被调用，传递 <code>$Greeter</code> 和字符串 <code>Katerina</code> 作为参数。</p>
<h2 id="hows-that">HOW&rsquo;s that?</h2>
<p><code>HOW</code> 这个词通常用于元对象。按照惯例，关键字 <code>class</code> 的元对象将有一个像 <code>ClassHOW</code> 这样的名字。这不是严格遵循的，即使在 Rakudo 和 NQP 中。但是所有类型的元对象都以 <code>HOW</code> 结尾。</p>
<p>如果你拿一个对象并使用 <code>.HOW</code>，你就会得到元对象。我们可以按照我们的意愿去追逐这个链条。</p>
<pre><code>my $mo := $Greeter.HOW;
say($mo.HOW.name($mo));             # SimpleHOW
my $momo := $mo.HOW;
say($momo.HOW.name($momo));         # NQPClassHOW
my $momomo := $momo.HOW;
say($momomo.HOW.name($momomo));     # KnowHOW
</code></pre>
<h2 id="knowhow-the-root-of-it-all">KnowHOW, the root of it all</h2>
<p>如果你在任何对象上追逐足够多的 <code>HOW</code> 链，最终你会达到被称为 <code>KnowHOW</code> 的东西。 继续前进，你就开始兜圈子了; 链的末端是自我描述的。</p>
<p><code>KnowHOW</code> 是由 6model 提供的仅有的元对象。它支持:</p>
<ul>
<li>Having a name</li>
<li>Having attributes</li>
<li>Having methods</li>
<li>In a type check, it only type checks against itself</li>
</ul>
<p>就是这些而已。没有角色组合。没有继承。</p>
<h2 id="knowhow-声明符">knowhow 声明符</h2>
<p>Rakudo 和 NQP 都存在 <code>knowhow</code> 包声明符。 你没理由自己使用它。 但是，在 NQP 的 <code>src/how</code> 中，你会发现一堆使用它的元对象:</p>
<pre><code>NQPModuleHOW                An NQP module
NQPClassHOW                 An NQP class or grammar
NQPNativeHOW                An NQP native type (int/num/str)
NQPParametricRoleHOW        An NQP role declaration
NQPConcreteRoleHOW          An NQP role made concrete for a given class
NQPCurriedRoleHOW           An NQP role with some arguments pre-set
</code></pre>
<p>当然，在实现类的元对象可用之前，我们不能使用 <code>class</code>！ 因此，<code>knowhow</code> 就是我们所拥有的。</p>
<h2 id="giving-rubyish-classes">Giving Rubyish classes</h2>
<p>我们稍后会看一下 NQP 和 Rakudo 的元对象。 但首先，为了看到一些更易于管理的东西，让我们回到我们昨天工作的 Rubyish 编译器并添加非常基本的 OO 支持：</p>
<ul>
<li>声明一个类</li>
<li>添加方法</li>
<li>使用 <code>new</code> 语句创建类的实例</li>
<li>在类上调用方法</li>
</ul>
<p>我们暂时将继承和属性放在一边; 事实上，我们将使用 NQP 或 Raku 元对象来研究它们。</p>
<h2 id="解析类的定义">解析类的定义</h2>
<p>解析相对容易，但是我们设置了一些与方法相关的额外动态变量。 我们接下来会看到他们的用法。</p>
<pre><code>token statement:sym&lt;class&gt; {
    :my $*IN_CLASS := 1;
    :my @*METHODS;
    'class' \h+ &lt;classbody&gt;
}
rule classbody {
    :my $*CUR_BLOCK := QAST::Block.new(QAST::Stmts.new());
    &lt;ident&gt; \n
    &lt;statementlist&gt;
    'end'
}
</code></pre>
<h2 id="更新方法的-def">更新方法的 def</h2>
<p>方法声明就像函数一样。 在类的作用域内，应该将函数定义添加到周围的类中。 <code>def</code> 的 action 方法可以更新如下：</p>
<pre><code>method statement:sym&lt;def&gt;($/) {
    my $install := $&lt;defbody&gt;.ast;
    $*CUR_BLOCK[0].push(QAST::Op.new(
        :op('bind'),
        QAST::Var.new( :name($install.name), :scope('lexical'),
            :decl('var') ),
        $install
    ));
    if $*IN_CLASS {
        @*METHODS.push($install);
    }
    make QAST::Op.new( :op('null') );
}
</code></pre>
<p>即, 把 <code>QAST::Block</code> 推入到类的 <code>@*METHODS</code> 中。</p>
<h2 id="一个简单的元对象">一个简单的元对象</h2>
<p>我们之前写过的元对象就足够好了。 这是一些小调整。</p>
<pre><code>class RubyishClassHOW {
    has $!name;
    has %!methods;
    
    method new_type(:$name!) {
        nqp::newtype(self.new(:$name), 'HashAttrStore')
    }
    
    method add_method($obj, $name, $code) {
        %!methods{$name} := $code;
    }
    
    method find_method($obj, $name) {
        %!methods{$name}
    }
}
</code></pre>
<h2 id="构建元对象-1">构建元对象 (1)</h2>
<p>在 Rubyish 中, 我们会生成构建元对象的代码。首先, 让我们关注 <code>classbody</code>  action 方法。</p>
<pre><code>method classbody($/) {
    $*CUR_BLOCK.push($&lt;statementlist&gt;.ast);
    $*CUR_BLOCK.blocktype('immediate');
    make $*CUR_BLOCK;
}
</code></pre>
<p>注意 <code>blocktype</code> 是如何被设置为 <code>immediate</code> 的，因为我们希望类体中的代码作为程序主线的一部分运行。</p>
<h2 id="构建元对象-2">构建元对象 (2)</h2>
<p>我们损坏了名称，然后使用 <code>RubyishClassHOW</code> 创建一个新的类型对象来表示它。 请注意，<code>QAST:: WVal</code> 是一种引用对象的方法; 我们稍后会看到更多。</p>
<pre><code>method statement:sym&lt;class&gt;($/) {
    my $body_block  := $&lt;classbody&gt;.ast;
    my $class_stmts := QAST::Stmts.new( $body_block );
    my $ins_name    := '::' ~ $&lt;classbody&gt;&lt;ident&gt;;
    $class_stmts.push(QAST::Op.new(
        :op('bind'),
        QAST::Var.new( :name($ins_name), :scope('lexical'),
            :decl('var') ),
        QAST::Op.new(
            :op('callmethod'), :name('new_type'),
            QAST::WVal.new( :value(RubyishClassHOW) ),
            QAST::SVal.new( :value(~$&lt;classbody&gt;&lt;ident&gt;),
                :named('name') ) )
        ));

    # &lt;Method code comes here&gt;
    make $class_stmts;
}
</code></pre>
<h2 id="构建元对象-3">构建元对象 (3)</h2>
<p>我们还发出对 <code>add_method</code> 方法的调用来为类构建方法表。 回想一下，<code>QAST::BVal</code> 允许我们引用树中其他地方安装的 <code>QAST::Block</code>。</p>
<pre><code>my $class_var := QAST::Var.new( :name($ins_name), :scope('lexical') );
for @*METHODS {
    $class_stmts.push(QAST::Op.new(
        :op('callmethod'), :name('add_method'),
        QAST::Op.new( :op('how'), $class_var ),
        $class_var,
        QAST::SVal.new( :value($_.name) ),
        QAST::BVal.new( :value($_) )));
}
</code></pre>
<p>有了这个，我们就有了类和方法。</p>
<h2 id="new-关键字">new 关键字</h2>
<p>解析 <code>new</code> 并不令人惊讶（我们跳过构造函数参数）：</p>
<pre><code>token term:sym&lt;new&gt; {
    'new' \h+ :s &lt;ident&gt; '(' ')'
}
</code></pre>
<p>这些 action 会破坏类名以查找它，然后使用 <code>create</code> NQP op 来创建它的实例。</p>
<pre><code>method term:sym&lt;new&gt;($/) {
    make QAST::Op.new(
        :op('create'),
        QAST::Var.new( :name('::' ~ ~$&lt;ident&gt;), :scope('lexical') )
    );
}
</code></pre>
<h2 id="方法调用-1">方法调用 (1)</h2>
<p>最后但并非最不重要的是，我们需要解析方法调用。 这些可以作为一种后缀处理，具有非常严格的优先级。 首先，我们添加级别：</p>
<pre><code>Rubyish::Grammar.O(':prec&lt;y=&gt;, :assoc&lt;unary&gt;', '%methodop');
</code></pre>
<p>然后是解析，这与解析函数调用的方式并不太相似。</p>
<pre><code>token postfix:sym&lt;.&gt;  {
    '.' &lt;ident&gt; '(' :s &lt;EXPR&gt;* % [ ',' ] ')'
    &lt;O('%methodop')&gt;
}
</code></pre>
<h2 id="方法调用-2">方法调用 (2)</h2>
<p>方法调用的 action 相对简单。</p>
<pre><code>method postfix:sym&lt;.&gt;($/) {
    my $meth_call := QAST::Op.new( :op('callmethod'), :name(~$&lt;ident&gt;) );
    for $&lt;EXPR&gt; {
        $meth_call.push($_.ast);
    }
    make $meth_call;
}
</code></pre>
<p>发生“魔法”的关键点是 <code>EXPR</code> action 方法将取消后缀应用的术语，这意味着它成为第一个孩子（因而是调用者）。</p>
<h2 id="exercise-7">Exercise 7</h2>
<p>在本练习中，您将为 PHPish 添加对类和方法的基本支持。
这将涉及：</p>
<ul>
<li>使用方法为类编写基本元对象</li>
<li>检查它是否独立运行</li>
<li>为类，方法，新语句和方法调用添加解析</li>
<li>添加相关的 action 方法以使工作正常</li>
</ul>
<p>有关更多信息，请参阅练习册。</p>
<h2 id="stables">STables</h2>
<p>每个对象都有一个元对象和一个表示。 但是，它并没有直接指向他们。 相反，每个对象都指向一个 <strong>s-table</strong>，即共享表(<strong>shared table</strong>)的缩写。</p>
<p>STable <strong>表示一种类型</strong>，并且每个 <code>HOW</code>/<code>REPR</code> 组合都存在。 这是 MoarVM 的 <code>MVMSTable</code> 结构的简化版本:</p>
<pre><code>struct MVMSTable {
    MVMREPROps *REPR;   /* The representation operation table. */
    MVMObject  *HOW;    /* The meta-object. */
    MVMObject  *WHAT;   /* The type-object. */
    MVMObject  *WHO;    /* The underlying package stash. */
    /* More... */
};
</code></pre>
<h2 id="表示操作">表示操作</h2>
<p>表示操作分为:</p>
<ul>
<li><strong>常见的的东西</strong>：基于表示创建新类型，组成该类型（然后可以计算内存布局），分配，克隆，更改类型（用于 mixins），序列化和反序列化</li>
<li><strong>装箱</strong>：对于作为原生类型（int/str/num）的装箱类型，get/set 装箱值</li>
<li><strong>属性</strong>：对于可以存储对象属性的类型，get/bind 属性值以及计算访问提示</li>
<li><strong>Positional</strong>：用于提供类似数组存储的类型，通过索引获取和绑定，push/pop/shift/unshift, splice, 设置元素</li>
<li><strong>Associative</strong>：用于提供类似哈希存储的类型，按键获取和绑定，按键判断是否存在，按键删除</li>
</ul>
<p>表示可以选择它支持上面的哪些。</p>
<h2 id="常见表示">常见表示</h2>
<p>在使用 NQP 和 rakudo 时，您将遇到的最常见的表示形式是:</p>
<pre><code>P6opaque            Opaque attribute storage; default in Raku
P6int               A native integer; flattens into a P6opaque
P6num               A native float; flattens into a P6opaque
P6str               A native string reference; flattens into a P6opaque
P6bigint            Big integer; flattens into a P6opaque
VMArray             Automatically resizing array, type-parametric
VMHash              Hash table
Uninstantiable      Type object only; used for module, role, etc.
</code></pre>
<h2 id="类型设置">类型设置</h2>
<p><code>nqp::newtype</code> 操作是类型创建的核心。 例如，这是 <code>NQPModuleHOW</code> 中的 <code>new_type</code> 方法。 它创建一个新的元对象，基于它创建一个新类型和 <code>Uninstantiable</code> 表示，并给它一个空的哈希作为它的藏匿处:</p>
<pre><code>method new_type(:$name = '&lt;anon&gt;') {
    my $metaobj := self.new(:name($name));
    nqp::setwho(nqp::newtype($metaobj, 'Uninstantiable'), {});
}
</code></pre>
<p><code>nqp::newtype</code> 创建一个新的类型对象和 STable。 它将类型对象指向 STable，将 STable 的 <code>WHAT</code> 字段指向类型对象。 然后，它将 STable 的 <code>HOW</code> 字段设置为指定的元对象，并将 <code>REPROps</code> 设置为 <code>Uninstantiable</code> 的操作表。</p>
<h2 id="类型组合">类型组合</h2>
<p>各种表示需要类型来完成<strong>组合</strong>阶段。 对于其他东西，它是可选的。</p>
<p>表示组合通常发生在类组合时（通常在类声明的闭合 <code>}</code> 处完成）。 当元对象有机会配置底层表示时。</p>
<p>例如，必须为 <code>P6opaque</code> 配置应为其计算布局的属性。</p>
<pre><code># &lt;build attribute info array up into @repr_info&gt;
my %info := nqp::hash();
%info&lt;attribute&gt; := @repr_info;
nqp::composetype($obj, %info)
</code></pre>
<p><code>repr-compose-protocol.markdown</code> 详细记录了这个。</p>
<h2 id="方法缓存">方法缓存</h2>
<p>如果每个方法调用真的涉及调用 <code>find_method</code>，那么方法分派就太慢了。 因此，许多类型发布了<strong>方法缓存</strong> ，是一个将方法名映射到要调用的东西的哈希表。 这是通过反向遍历解析方法顺序来完成的（所以我们正确地覆盖）。</p>
<pre><code>method publish_method_cache($obj) {
    my %cache;
    my @mro_reversed := reverse(@!mro);
    for @mro_reversed {
        for $_.HOW.method_table($_) {
            %cache{nqp::iterkey_s($_)} := nqp::iterval($_);
        }
    }
    nqp::setmethcache($obj, %cache);
    nqp::setmethcacheauth($obj, 1);
}
</code></pre>
<p>方法缓存挂起了 <code>STable</code>。</p>
<h2 id="授权方法缓存">授权方法缓存</h2>
<p>我们可以选择方法缓存是否具有授权:</p>
<pre><code>nqp::setmethcacheauth($obj, 0);     # 非授权模式; 默认
nqp::setmethcacheauth($obj, 1);     # 授权模式
</code></pre>
<p>这实际上只是控制在方法缓存中找不到所谈论中的方法时会发生什么 。 在授权模式下，缓存被视为具有完整的方法集。 在非授权模式，如果在缓存中找不到该方法， 我们回退到调用 <code>find_method</code>。</p>
<p>在可能的情况下拥有授权方法缓存很好，因为它可以快速回应 <code>nqp::can(...)</code>。 但是，任何想要做回退处理的类型不能拥有授权模式。 Rakudo 按类型决定授权。</p>
<h2 id="类型检查">类型检查</h2>
<p>类型检查出现在 Raku 中的许多地方：</p>
<pre><code>if $obj ~~ SomeType { ... }         # 显式检查
my SomeType $obj = ...;             # 变量赋值
sub foo(SomeType $obj) { ... }      # 参数绑定
</code></pre>
<p>这些最终都归结为同样的操作， <code>nqp::istype</code>。 但是，<code>SomeType</code> 花样百出, 它可能是众多类型中的一种：</p>
<pre><code>class SomeType { }              # Class type
role SomeType { }               # Role type
subset SomeType where { ... }   # Subset type
</code></pre>
<h2 id="left-side-knows-检查">Left-side-knows 检查</h2>
<p>对于某些类型，被检查的对象有答案。 这是子类型关系的情况。</p>
<pre><code>Int ~~ Mu           # Int 知道它继承自 Mu
Block ~~ Callable   # Block 知道它能 Callable
</code></pre>
<p>这些情况由 <code>type_check</code> 方法处理。</p>
<pre><code>method type_check($obj, $checkee) {
    for self.mro($obj) {
        return 1 if $_ =:= $checkee;
        if nqp::can($_.HOW, 'role_typecheck_list') {
            for $_.HOW.role_typecheck_list($_) {
                return 1 if $_ =:= $checkee;
            }
        }
    }
    return 0;
}
</code></pre>
<h2 id="类型检查缓存">类型检查缓存</h2>
<p>再次，真正每个级别都迭代 MRO 和组合的角色会很慢。 因此，left-side-knows 检查通常由发布类型检查(type-check)缓存的元对象处理。</p>
<pre><code>method publish_type_cache($obj) {
    my @tc;
    for self.mro($obj) {
        @tc.push($_);
        if nqp::can($_.HOW, 'role_typecheck_list') {
            for $_.HOW.role_typecheck_list($_) {
                @tc.push($_);
            }
        }
    }
    nqp::settypecache($obj, @tc)
}
</code></pre>
<h2 id="right-side-knows-检查-1">Right-side-knows 检查 (1)</h2>
<p>还有其他种类的类型，它是我们的检查是否需要驱动检查的类型。 例如， 子集类型是这样的:</p>
<pre><code>subset Even of Int where * % 2 == 0;
</code></pre>
<p>我们需要调用与 <code>Even</code> 子集类型相关联的代码作为类型检查的一部分:</p>
<pre><code>say 11 ~~ Even    # False
say 42 ~~ Even    # True
</code></pre>
<h2 id="right-side-knows-检查-2">Right-side-knows 检查 (2)</h2>
<p>这些类型实现了 <code>accepts_type</code> 方法。 例如，这是 Raku 的 <code>SubsetHOW</code> 中的一个:</p>
<pre><code>method accepts_type($obj, $checkee) {
    nqp::istype($checkee, $!refinee) &amp;&amp;
        nqp::istrue($!refinement.ACCEPTS($checkee))
}
</code></pre>
<p>它还必须为此设置适当的类型检查模式以使其能工作:</p>
<pre><code>nqp::settypecheckmode($type, 2)
</code></pre>
<h2 id="boolification">Boolification</h2>
<p>事实证明，一个相对 hot-path 的操作是决定对象是否将在布尔上下文中计算为 true 或 false。 该 <code>nqp::istrue</code> 操作用于测试对象的真假。 还有一个 <code>nqp::isfalse</code> 操作。</p>
<p>对象如何通过 <code>nqp::setboolspec</code> 设置 boolifies, 它从下面的列表中获取一个标志和一个可选的代码对象。</p>
<pre><code>0   调用指定的代码对象，将对象传递给 test 
1   开箱为int; 非零为真 
2   开箱为浮点数; 非零为真 
3   开箱为字符串; 非空为真 
4   和上面一样，但 &quot;0&quot; 被认为是假 
5   如果是类型对象，则返回 false，否则返回 true 
6   开箱为或视为一个大整数; 非零为真 
7   对于迭代器对象; 如果有更多可用项，则为 true 
8   对于基于 VMArray/VMHash 的对象; 如果 elems 非零，则为 true
</code></pre>
<h2 id="调用">调用</h2>
<p>还有一个调用规范机制，它表示如果对象被调用（调用）会发生什么。</p>
<p>在 Rakudo 中，通常也在 NQP 中，我们有代码对象。 这些反过来持有 VM 级代码对象。 当我们调用代码对象时需要将调用转发到包含的代码对象。</p>
<p>以下是 NQP 设置的示例:</p>
<pre><code>my knowhow NQPRoutine {
    has $!do;
    ...
}
nqp::setinvokespec(NQPRoutine, NQPRoutine, '$!do', nqp::null);
</code></pre>
<p>在 Rakudo 中，请参阅 <code>Raku::Metamodel::InvocationProtocol</code>。</p>
<h2 id="nqp-的元对象">NQP 的元对象</h2>
<p>NQP 的元对象都是使用 <code>knowhow</code> 元对象实现的。 他们也不能假设存在 NQP 设置，意味着你会在那里找到一些奇怪的代码。</p>
<ul>
<li>NQP 迭代器类型为哈希启用 <code>.key</code> 和 <code>.value</code> 方法尚未设置，因此此代码使用 <code>nqp::iterkey_s</code> 和 <code>nqp::iterval</code>。</li>
<li>标量没有 <code>NQPMu</code> 默认值，所以空标量将为 <code>null</code>; 因此 <code>nqp::isnull</code> 会被经常使用。</li>
</ul>
<p>值得庆幸的是，您需要处理此代码的机会是非常低的。 它也比较紧凑; <code>NQPClassHOW</code>，最复杂的元对象，基本上只有大约 800 行直截了当的代码。</p>
<h2 id="rakudo-的元对象-概览">Rakudo 的元对象: 概览</h2>
<p>Rakudo 的故事大不相同。 Rakudo 的元对象是根据 NQP 的类和角色实现的。 这意味着继承和角色组合是可用的。</p>
<p>因此，由于 Raku 对象系统的丰富性, 虽然 <strong>Rakudo 的元对象必须处理很多</strong>,  但是它们被<strong>非常巧妙的分解了</strong> 。</p>
<p><strong>每个声明符都有一个元对象</strong> （所以 <code>class</code> 映射到 <code>ClassHOW</code>），以及角色的一些额外位（因其类型参数而实现起来相当复杂）。</p>
<p>但是，很多功能都会被<strong>分解到角色中</strong>, 它们在不同的元对象中被重用。</p>
<h2 id="例子-classhow">例子: ClassHOW</h2>
<p>以下是 <code>Raku::Metamodel::ClassHOW</code> 完成的角色：</p>
<pre><code>Naming                      Documenting
Versioning                  Stashing
AttributeContainer          MethodContainer
PrivateMethodContainer      MultiMethodContainer
RoleContainer               MultipleInheritance
DefaultParent               C3MRO
MROBasedMethodDispatch      MROBasedTypeChecking
Trusting                    BUILDPLAN
Mixins                      ArrayType
BoolificationProtocol       REPRComposeProtocol
InvocationProtocol
</code></pre>
<p>在这些名称中，您还将识别许多 Raku 功能，和我们在本节中介绍的 6model 概念中的一些。</p>
<h2 id="例子-enumhow">例子: EnumHOW</h2>
<p>如果我们看看 <code>Raku::Metamodel::EnumHOW</code>，我们会看到它重用了如下几个角色:</p>
<pre><code>Naming                      Stashing
AttributeContainer          MethodContainer
MultiMethodContainer        RoleContainer
MROBasedMethodDispatch      MROBasedTypeChecking
BUILDPLAN                   BoolificationProtocol
REPRComposeProtocol         InvocationProtocol
</code></pre>
<p>事实上，它只组合了一个额外的角色:</p>
<pre><code>BaseType
</code></pre>
<p>除了角色，<code>ClassHOW</code> 是 250 行代码, <code>EnumHOW</code> 是 150 行代码。 因此，大多数有趣的东西都存在于角色中。</p>
<h2 id="例子-naming">例子: Naming</h2>
<p>有些角色非常简单。 例如，所有的元对象组成 <code>Naming</code> 角色，它只提供两个方法和 <code>$!name</code> 属性:</p>
<pre><code>role Raku::Metamodel::Naming {
    has $!name;
    method set_name($obj, $name) {
        $!name := $name
    }
    method name($obj) {
        $!name
    }
}
</code></pre>
<p>代码最多的角色是 <code>C3MRO</code>，它计算 C3 方法解析顺序。 不过，它仍然只有 150 行代码。 要点：事情分为可管理的部分。</p>
<h2 id="例子-grammarhow">例子: GrammarHOW</h2>
<p>这是最简单的元对象：</p>
<pre><code>class Raku::Metamodel::GrammarHOW
    is Raku::Metamodel::ClassHOW
    does Raku::Metamodel::DefaultParent
{
}
</code></pre>
<p>从本质上讲，<code>grammar</code> 可以完成 <code>class</code> 所做的一切，但是组合 <code>DefaultParent</code> 角色，以便在 <code>BOOTSTRAP</code> 中使用不同的默认父级配置启用 grammar：</p>
<pre><code>Raku::Metamodel::ClassHOW.set_default_parent_type(Any);
Raku::Metamodel::GrammarHOW.set_default_parent_type(Grammar);
</code></pre>
<h2 id="容器处理">容器处理</h2>
<p>到目前为止，我们已经看到一种类型可以给出一个 boolification 规范和一个调用规范。 还有一个： <strong>容器规范</strong> 。 这在 Raku 中用于实现 <code>Scalar</code> 容器类型。</p>
<p>有几个操作与此有关:</p>
<pre><code>setcontspec         将类型配置为标量容器类型
iscont              检查对象是否是标量容器
decont              获取容器内的值
assign              将值赋值给容器
assignunchecked     赋值，假设不需要进行类型检查
</code></pre>
<p>例如，Rakudo 的 <code>BOOTSTRAP</code> 会:</p>
<pre><code>nqp::setcontspec(Scalar, 'rakudo_scalar', nqp::null());
</code></pre>
<h2 id="自动去容器化">自动去容器化</h2>
<p>有人可能想知道为什么 <code>nqp::decont</code> 不需要在 Raku 中无处不在。答案是一系列的 <code>nqp::ops</code> 将自动为您执行 <code>nqp::decont</code> 操作。</p>
<p>一个常见的例外是*<strong>属性访问没有去容器化</strong> 。 这意味着 <code>nqp::getattr</code> 和它的朋友们的第一个参数可能需要一个显式的 <code>nqp::decont</code>。</p>
<pre><code>nqp::getattr(nqp::decont(@list.Parcel), Parcel, '$!storage')
</code></pre>
<p>但是，因为 <code>self</code> 被定义为始终去容器化, 所以这通常不是问题。</p>
<h2 id="练习-8">练习 8</h2>
<p>随着时间的推移，将 PHPish 对象系统扩展为：</p>
<ul>
<li>方法缓存（如果它有用，您可能需要计时）</li>
<li>单继承类（需要更新你的方法缓存代码）</li>
<li>接口（这些将需要一个不同的元对象，而你将需要为此类添加一个 compose-time，以检查接口中的所有命名方法都提供好了）</li>
</ul>
<p>像往常一样，练习册有更多提示。</p>
<h1 id="有界序列化和模块加载">有界序列化和模块加载</h1>
<p><em>让我们拯救世界吧!</em></p>
<h2 id="一个问题">一个问题</h2>
<p>当我们在 Rubyish 中构建对象支持时，我们通过发射代码以在元对象上做调用。 这样做明显会有启动时间上的缺点。 然而，在 Raku 中，这种方法面临很多更严峻的挑战。</p>
<p>考虑以下例子:</p>
<pre><code>class ABoringExample {
    method yawn() { say &quot;This is at compile time!&quot;; }
}
BEGIN { ABoringExample.yawn }
</code></pre>
<p>我们编译时会运行 <code>BEGIN</code> 块。 因此，<code>ABoringExample</code> 的类型对象和元对象需要在我们运行 <code>BEGIN</code> 块时可用。</p>
<p>此外，这必须适用于用户定义的元对象。</p>
<h2 id="这个问题无处不在">这个问题无处不在</h2>
<p>子例程声明会生成一个 <code>Sub</code> 对象，它反过来指向一个 <code>Signature</code> 对象而该对象反过来有一个 <code>Parameter</code> 对象在里面。</p>
<p>所有这些都需要在编译时构建。 不仅仅是因为我们可以调用该 sub，但也因为 traits 可能需要混合到其中:</p>
<pre><code>role StoredProcWrapper { has $.sp_name }
multi trait_mod:&lt;is&gt;(Routine:D $r, :sp_wrapper($sp_name)!) {
    $r does StoredProcName($sp_name)
}
# ...
sub LoadStuffAsObjects($id) is sp_wrapper('LoadStuff') {
    call_sp($id).map({ Stuff.new(|%($_)) })
}
</code></pre>
<h2 id="编译时-vs-运行时">编译时 vs. 运行时</h2>
<p>一般来说，问题是我们需要能够在编译时建立起对象和元对象，然后在运行时指向它们。 而且，这是一个非常常见的情况，所以需要高效。</p>
<p>这本身并不会太糟糕。 但是，模块预编译使这一点变得更加棘手： <strong>在编译时创建的对象可能需要跨过一个进程边界</strong>，保存到磁盘，然后在未来某个点加载。</p>
<p>这是序列化上下文，有界序列化。那么 <code>World</code> 开始发挥作用。</p>
<h2 id="the-world">The World</h2>
<p>我们的小型 Rubyish 语言缺少的，但是 NQP 和 Rakudo 两者都有的一个概念是 <code>World</code> 类。 而 <code>Actions</code> 类专注于 QAST 树，因而是程序的运行时语义 ，<code>World</code> 专注于<strong>管理编译期间的声明和元对象</strong>。</p>
<p>world 每个编译单元总是具有唯一句柄。 这个可以基于原始源文本，例如在 Rakudo 中:</p>
<pre><code>my $file := nqp::getlexdyn('$?FILES');
my $source_id := nqp::sha1(
    nqp::defined(%*COMPILING&lt;%?OPTIONS&gt;&lt;outer_ctx&gt;)
        ?? self.target() ~ $sc_id++                 # REPL/eval case
        !! self.target());                          # Common case
my $*W := Raku::World.new(:handle($source_id), :description($file));
</code></pre>
<h2 id="序列化上下文">序列化上下文</h2>
<p>编译时/运行时对象交换的核心关键数据结构是<strong>序列化上下文</strong> 。 真的，一个序列化上下文只是三个数组，每个上下文一个数组, 用于：</p>
<ul>
<li><strong>对象</strong>： 任何 6model 对象都可以出现在此列表中，尽管只有把那些明智的序列化放在那里才有意义</li>
<li><strong>代码对象</strong>： VM 级代码对象, 此对象在序列化上下文可以指向（或间接地指向 ，由于闭包克隆）</li>
<li><strong>STables</strong>： 这个数组的存在是一个实现细节，其内容永远不会被特定于 VM 的代码的外部直接操纵 ，因此您可以忘记它</li>
</ul>
<p>每个编译单元有一个 <code>World</code>，反过来 <code>World</code> 拥有序列化上下文。 事实上，给 <code>World.new(...)</code> 的 <code>handle</code> 实际上用于 SC。</p>
<h2 id="将对象放在序列化上下文中">将对象放在序列化上下文中</h2>
<p><code>NQP::World</code> 和 <code>Raku::World</code> 都继承自 <code>HLL::World</code>。 它包含一个名为 <code>add_object</code> 的方法，它为当前编译单元添加了一个对象到序列化上下文中。 这里是它如何被用于 <code>NQP::World</code> 中的，例如：</p>
<pre><code>method pkg_create_mo($how, :$name, :$repr) {
    my %args;
    if nqp::defined($name) { %args&lt;name&gt; := $name; }
    if nqp::defined($repr) { %args&lt;repr&gt; := $repr; }
    my $type_obj := $how.new_type(|%args);
    self.add_object($type_obj);
    return $type_obj;
}
</code></pre>
<h2 id="引用序列化上下文中的对象">引用序列化上下文中的对象</h2>
<p>序列化上下文中的任何对象 - 目前正在编译中的或来自于另一个模块或设置 - 都可以使用 <code>QAST::WVal</code> 节点类型引用。</p>
<p>例如，这是 <code>Raku::World</code> 的实用方法:</p>
<pre><code>method add_constant_folded_result($r) {
    self.add_object($r);
    QAST::WVal.new( :value($r) )
}
</code></pre>
<p><code>QAST::WVal</code> 中的 <code>W</code> 意味着 &ldquo;World&rdquo;，这应该是一点点, 现在比我们以前遇到的更有意义。 <code>:-)</code></p>
<h2 id="序列化">序列化</h2>
<p>编译器工具链知道最终目标是要运行进程中的代码或生成字节码以写入磁盘。</p>
<p>在第一种情况下，这很容易：我们只是确保能从运行的代码中可以看到序列化上下文，并编译一个 <code>QAST::WVal</code> 来索引它。</p>
<p>第二种情况需要在序列化上下文中序列化所有的对象 ，然后反过来序列化它们指向的对象 ，根据需要遍历对象图。</p>
<p>它们被转储为二进制序列化格式，记录在 NQP 仓库中。</p>
<h2 id="whats-bounded-about-it">What&rsquo;s &ldquo;bounded&rdquo; about it</h2>
<p>考虑预编译以下模块:</p>
<pre><code>class Cache is Hash {
    has &amp;!computer;
    submethod BUILD(:&amp;!computer!) { }
    method at_key($key) is rw {
        callsame() //= &amp;!computer($key)
    }
}
</code></pre>
<p>这里, <code>Hash</code> 来自 Raku 的 <code>CORE.setting</code>。 显然，我们会在 <code>Cache</code> 元对象的 <code>@!parents</code> 中遇到这种类型 。 但是，我们不想重新序列化 <code>Hash</code> 类型！</p>
<p>当一个对象已经被另一个 SC 拥有时，我们只写一个对它的引用。 <strong>所有权是编译单元的序列化的边界</strong> 。</p>
<h2 id="反序列化和修正">反序列化和修正</h2>
<p>序列化的反面是反序列化。 这涉及到接收二进制 blob 表示对象和 STable 并从它那儿重新创建对象。</p>
<p>在这样做时，所有对其他序列化上下文的对象的引用必须被解析。 这意味着模块的依赖关系必须在它反序列化之前被加载。</p>
<p>出于这个原因，<code>HLL::World</code> 有一个 <code>add_load_dependency_task</code>， 用于添加代码（指定为 QAST）以在反序列化发生之前执行 。</p>
<p>还有一个 <code>add_fixup_task</code>，它开启代码的注册以在反序列化发生之后运行。</p>
<h2 id="另一个棘手的问题">另一个棘手的问题</h2>
<p>一个棘手的问题是如果你试图预编译一个包含以下内容的模块会发生什么:</p>
<pre><code># Ooh! Let's pretend we're Ruby!
augment class Int {
    method times(&amp;block) {
        for ^self { block($_) }
    }
}
</code></pre>
<p><code>Int</code> 元对象和 STable 在 <code>CORE.setting</code> 中序列化。 但是在这里，另一个模块正在修改元对象，而且 更新的方法缓存挂起了 <code>STable</code>，意味着它也发生了改变。</p>
<p>那么我们该怎么办？</p>
<h2 id="repossession">Repossession</h2>
<p>当一个对象属于序列化上下文的时候，我们就在编译时，它所属的序列化上下文不是我们当前正在编译过程中的那个。写障碍被触发。</p>
<p>这会将对象的所有权切换为我们正在编译的编译单元的序列化上下文。 它还记录了这种情况。</p>
<p>在序列化时，找到要更新的对象然后使用它的新版本来覆盖它。</p>
<h2 id="repossession-conflicts">Repossession conflicts</h2>
<p>这留下了另外一个问题：如果加载两个预编译的模块, 这个两个模块都想要扩充同一个类会发生什么？</p>
<p>曾经，&ldquo;latest won&rdquo;。 值得庆幸的是，今天这被检测为收回冲突，由此产生的异常表明加载了两个模块, 它们可能无法一起使用。</p>
<p>这应该是故事的结尾。 但事实并非如此。 事实证明，当 <code>Stash</code> 对象开始以有趣的方式发生冲突时， 当模块使用嵌套包时。 因此，现在有一个冲突解析机制，它查看有冲突的对象并尝试合并他们。 对于 <code>Stash</code> 来说，这很容易。</p>
<h2 id="sc-写障碍控制">SC 写障碍控制</h2>
<p>与序列化上下文相关的大多数 <code>nqp::ops</code> 很少看到，隐藏在 <code>HLL::World</code> 中。 然而，其中两个逃脱了进入常规代码中：</p>
<ul>
<li><strong><code>nqp::scwbdisable</code></strong> 禁用 repossession 检测写入屏障，意味着对自有对象所做的任何更改不会导致它被重新序列化。这通常是由想要保留缓存的元对象完成的。</li>
<li><strong><code>nqp::scwbenable</code></strong> 重新启用 repossession 检测。</li>
</ul>
<p>请注意，这不是二进制标志，而是一个计数器, 它由第一个 op 递增并由第二个递减。 只有当计数器为零时才会发生收回检测。</p>
<h2 id="意外收回">意外收回</h2>
<p>在 Rakudo 和 NQP 上工作时记住收回是很重要的，因为有时可能会让你始料不及。</p>
<p>例如，在 Rakudo 的 CORE.setting 中，你会找到一个 <code>BEGIN</code> 块 看起来像这样：</p>
<pre><code>BEGIN {
    my Mu $methodcall     := nqp::hash('prec', 'y=');
    ...
    trait_mod:&lt;is&gt;(&amp;postfix:&lt;i&gt;, :prec($methodcall));
    ...
}
</code></pre>
<p>如果这是在设置主线中完成的，则会导致对 <code>postfix:&lt;i&gt;</code> 的更改会在 CORE 设置中序列化，它可以通过任何编译单元触发设置加载来收回这个  。</p>
<h2 id="qastcompunit-revisited">QAST::CompUnit, revisited</h2>
<p>由 <code>World</code> 组装的各个片段都使用 <code>QAST::CompUnit</code> 传递到后端。</p>
<pre><code>my $compunit := QAST::CompUnit.new(
    :hll('raku'),
    :sc($*W.sc()),
    :code_ref_blocks($*W.code_ref_blocks()),
    :compilation_mode($*W.is_precompilation_mode()),
    :pre_deserialize($*W.load_dependency_tasks()),
    :post_deserialize($*W.fixup_tasks()),
    :repo_conflict_resolver(QAST::Op.new(
        :op('callmethod'), :name('resolve_repossession_conflicts'),
        QAST::Op.new(
            :op('getcurhllsym'),
            QAST::SVal.new( :value('ModuleLoader') )
        )
    )),
    ...);
</code></pre>
<h2 id="模块加载的工作原理-1">模块加载的工作原理 (1)</h2>
<p>在 Raku 代码中遇到 <code>use</code> 语句时：</p>
<pre><code>use Term::ANSIColor;
</code></pre>
<p>解析模块名，提取任何副词（例如 <code>:from</code>）然后将控制传递给 <code>Raku::World</code> 中的 <code>load_module</code> 方法:</p>
<pre><code>my $lnd    := $*W.dissect_longname($longname);
my $name   := $lnd.name;
my %cp     := $lnd.colonpairs_hash('use');
my $module := $*W.load_module($/, $name, %cp, $*GLOBALish);
</code></pre>
<h2 id="模块加载的工作原理-2">模块加载的工作原理 (2)</h2>
<p>此 <code>load_module</code> 方法首先代理给 <code>Raku::ModuleLoader</code> 以立即加载模块（必须的, 它可能会引入我们需要的类型或做其他更改以继续解析）。加载模块后，它还会注册一个加载依赖项任务以确保模块已加载, 如果我们在反序列化发生之前的预编译情况中。</p>
<pre><code>method load_module($/, $module_name, %opts, $cur_GLOBALish) {
    my $line   := HLL::Compiler.lineof($/.orig, $/.from, :cache(1));
    my $module := Raku::ModuleLoader.load_module($module_name, %opts,
        $cur_GLOBALish, :$line);
    
    if self.is_precompilation_mode() {
        self.add_load_dependency_task(:deserialize_past(...));
    }

    return $module;
}
</code></pre>
<h2 id="模块加载的工作原理-3">模块加载的工作原理 (3)</h2>
<p>在 <code>Raku::ModuleLoader</code> 中，完成了一些工作以找到模块在磁盘中国的位置 。如果它以预编译的形式存在，那么 <code>nqp::loadbytecode</code> op 用于加载它。否则，从磁盘中 slurp 源代码并编译。</p>
<p>加载预编译模块会自动触发它的反序列化。</p>
<p>在两个代码路径上执行的几个奇数行值得一些解释， 然而：</p>
<pre><code>my $*CTXSAVE := self;
my $*MAIN_CTX;
nqp::loadbytecode(%chosen&lt;load&gt;);
%modules_loaded{%chosen&lt;key&gt;} := $module_ctx := $*MAIN_CTX;
</code></pre>
<h2 id="模块加载的工作原理-4">模块加载的工作原理 (4)</h2>
<p>运行模块的主线时，其词法作用域是由某些相当于这样的代码捕获的：</p>
<pre><code>if $*CTXSAVE &amp;&amp; nqp::can($*CTXSAVE, 'ctxsave') {
    $*CTXSAVE.ctxsave();
}
</code></pre>
<p>ModuleLoader 有这样一个方法：</p>
<pre><code>method ctxsave() {
    $*MAIN_CTX := nqp::ctxcaller(nqp::ctx());
    $*CTXSAVE := 0;
}
</code></pre>
<p>这就是被加载的模块的 <code>UNIT</code>（外部词法作用域）是如何获得的。这反过来用于定位 <code>EXPORT</code>。</p>
<h2 id="模块加载的工作原理-5">模块加载的工作原理 (5)</h2>
<p>最后，<code>ModuleLoader</code> 触发全局合并。 这涉及到采用模块想要贡献到的 <code>GLOBAL</code> 和将它们合并到 <code>GLOBAL</code> 的当前视图中。</p>
<p>如果这听起来很奇怪，请注意 Raku 有单独的编译， 意味着所有模块都以一个完全干净和空的 <code>GLOBAL</code> 视图开始。这些视图在模块加载时得到了调和（和冲突发生了争执) 。</p>
<p>最后，返回 <code>UNIT</code> lexpad。</p>
<pre><code>my $UNIT := nqp::ctxlexpad($module_ctx);
if +@GLOBALish {
    unless nqp::isnull($UNIT&lt;GLOBALish&gt;) {
        merge_globals(@GLOBALish[0], $UNIT&lt;GLOBALish&gt;);
    }
}
return $UNIT;
</code></pre>
<h2 id="模块加载的工作原理-6">模块加载的工作原理 (6)</h2>
<p>到目前为止我们所看到的是 <code>need</code> 会做什么。然后使用 <code>use</code> 导入模块。这在模块加载器中还没有实现， 而是存在于 <code>Raku::World</code> 的 <code>import</code> 方法中。</p>
<p>它做了以下事情：</p>
<ul>
<li>找到需要导入的符号</li>
<li>如果有多个分派候选者导出并在目标作用域里也存在一些，则合并候选者列表</li>
<li>对于其他符号，将它们直接安装到目标作用域中， 抱怨是否有冲突</li>
<li>如果导入了任何运算符，请确保当前语言被扩充 ，以便能够解析它们</li>
</ul>
<h1 id="正则表达式和-grammar-引擎">正则表达式和 grammar 引擎</h1>
<p><em>内部如何解析 Raku</em></p>
<h2 id="涉及的部分">涉及的部分</h2>
<p>正则表达式和 grammar 处理涉及许多组件：</p>
<ul>
<li><strong>Raku 的正则表达式 grammar/action</strong>，从 <code>src/QRegex/P6Regex</code>，它解析 Raku 正则表达式语法并从中生成 QAST 树。这些不是由 NQP 和 Rakudo 直接使用的 ，而是子类化（例如， 嵌套代码块将在正确的 main 语言中解析 ）</li>
<li><strong><code>QAST::Regex</code></strong> QAST 节点，这表示我们可以编译的正则表达式构造的整个范围</li>
<li><strong><code>Cursor</code> 对象</strong>，在我们解析时保持状态</li>
<li><strong><code>Match</code> 对象</strong> ，表示解析的结果</li>
<li><strong>NFA 构造和求值</strong> ，用于最长 token 匹配</li>
</ul>
<h2 id="qastregex-节点">QAST::Regex 节点</h2>
<p>此节点涵盖所有正则表达式构造。它有一个 <strong><code>rxtype</code></strong> 属性用于指示要执行的正​​则表达式的类型。</p>
<p>它通常可以放置在 QAST 树中的任何位置, 尽管通常会在 <code>QAST::Block</code> 中找到自己。 而且，它期望声明词法 <code>$¢</code>。</p>
<p>除了少数例外，一旦到达 <code>QAST::Regex</code> 节点，QAST 编译器就会在它下面期望只找到其他 <code>QAST::Regex</code> 节点 。有一个显式的 <code>qastnode</code> rxtype 用于逃避到 QAST 的剩余部分。</p>
<p>我们现在将研究可用的 rxtypes</p>
<h2 id="literal">literal</h2>
<p><code>literal</code> rxtype 表示应该在正则表达式中匹配文字字符串 。要匹配的字符串作为子项传递给节点。</p>
<pre><code>QAST::Regex.new( :rxtype&lt;literal&gt;, 'meerkat' )
</code></pre>
<p>它有一个子类型 <code>ignorecase</code>，其匹配不区分大小写的字面值。</p>
<pre><code>QAST::Regex.new( :rxtype&lt;literal&gt;, :subtype&lt;ignorecase&gt;, 'meerkat' )
</code></pre>
<h2 id="concat">concat</h2>
<p><code>concat</code> 子类型用于匹配一个接一个的 <code>QAST::Regex</code> 节点序列。它希望这些节点成为它的子节点。</p>
<p>这将与上一张幻灯片相同，但会有点低效:</p>
<pre><code>QAST::Regex.new(
    :rxtype&lt;concat&gt;,
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'meer' ),
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'kat' )
)
</code></pre>
<h2 id="scan-和-pass">scan 和 pass</h2>
<p>正则表达式倾向于从 <code>scan</code> 节点开始并以 <code>pass</code> 节点结束。</p>
<ul>
<li><strong>scan</strong> 将生成代码以通过字符串，尝试匹配每个偏移处的模式，直到匹配成功或用完尝试的字符串为止 。这就是让 <code>'slaughter' ~~ /laughter/</code> 匹配的原理，尽管 <code>laughter</code> 不在字符串的开头。请注意如果匹配没有锚定它才会这样做 （如果被另一个规则调用则会被锚定） ）。</li>
<li><strong>pass</strong> 将在 <code>Cursor</code> 对象上生成一个对  <code>!cursor_pass</code>  的调用，表示正则表达式已匹配。 对于命名正则表达式，标记和规则，此节点也携带要调用的 action 方法的名称。</li>
</ul>
<h2 id="一个简单的例子">一个简单的例子</h2>
<p>如果我们给 NQP 以下正则表达式：</p>
<pre><code>/meerkat/
</code></pre>
<p>并使用 <code>--target=ast</code>，生成的 <code>QAST::Regex</code> 节点包含到目前为止我们所涉及的所有东西:</p>
<pre><code>- QAST::Regex(:rxtype(concat))
  - QAST::Regex(:rxtype(scan))
  - QAST::Regex(:rxtype(concat)) meerkat
    - QAST::Regex(:rxtype(literal)) meerkat
      - meerkat
  - QAST::Regex(:rxtype(pass))
</code></pre>
<h2 id="cclass">cclass</h2>
<p>用于各种常见的内置字符类， 通常通过反斜杠序列表达。例如，<code>\d</code> 和 <code>\W</code> 分别成为:</p>
<pre><code>QAST::Regex.new( :rxtype&lt;cclass&gt;, :name&lt;d&gt; )
QAST::Regex.new( :rxtype&lt;cclass&gt;, :name&lt;w&gt;, :negate(1) )
</code></pre>
<p><code>name</code> 的可用值如下：</p>
<pre><code>Code    含义 
.       任何字符 (真的, 任何)
d       任何数字字符（Unicode 识别） 
s       任何空白字符（Unicode 识别） 
w       任何单词字符或下划线（Unicode 识别） 
n       字面 \n, a \r\n 序列,或 Unicode LINE_SEPARATOR 
</code></pre>
<h2 id="enumcharlist">enumcharlist</h2>
<p>用于用户自定义字符类。要求当前字符类是子字符串中指定的任何一个。</p>
<p>例如，<code>\v</code>（匹配任何垂直空白字符） 编译成：</p>
<pre><code>QAST::Regex.new(
    :rxtype&lt;enumcharlist&gt;,
    &quot;\x[0a,0b,0c,0d,85,2028,2029]&quot;
)
</code></pre>
<h2 id="enumcharlist-和用户定义的字符类">enumcharlist 和用户定义的字符类</h2>
<p><code>enumcharlist</code> 节点也用于以下内容:</p>
<pre><code>/&lt;[A..Z]&gt;/
</code></pre>
<p>其中，如 <code>--target=ast</code> 显示，变为：</p>
<pre><code>- QAST::Regex(:rxtype(concat))
  - QAST::Regex(:rxtype(scan))
  - QAST::Regex(:rxtype(concat)) &lt;[A..Z]&gt;
    - QAST::Regex(:rxtype(enumcharlist)) [A..Z]
      - ABCDEFGHIJKLMNOPQRSTUVWXYZ
  - QAST::Regex(:rxtype(pass))
</code></pre>
<h2 id="anchor">anchor</h2>
<p>用于各种零宽断言。例如，<code>^</code>（字符串的开头）编译成：</p>
<pre><code>QAST::Regex.new( :rxtype&lt;anchor&gt;, :subtype&lt;bos&gt; )
</code></pre>
<p>可用的子类型是：</p>
<pre><code>bos     字符串的开头 (^)
eos     字符串的结尾 ($)
bol     行的开头 (^^)
eol     行的结尾 ($$)
lwb     左单词边界 (&lt;&lt;)
rwb     右单词边界 (&gt;&gt;)
fail    总是失败 
pass    总是通过
</code></pre>
<h2 id="quant">quant</h2>
<p>用于量词。<code>min</code> 和 <code>max</code> 属性用于指示子节点可以匹配的类型的数量。<code>max</code> 为 <code>-1</code> 意思是&quot;无限的&rdquo;。因此，正则表达式 <code>\d+</code> 编译成:</p>
<pre><code>QAST::Regex.new(
    :rxtype&lt;quant&gt;, :min(1), :max(-1),
    QAST::Regex.new( :rxtype&lt;concat&gt;, :name&lt;d&gt; )
)
</code></pre>
<p><code>backtrack</code> 属性也可以设置为以下之一:</p>
<pre><code>g       贪婪匹配 (\d+!, 默认)
f       非贪婪 (minimal) 匹配 (\d+?)
r       棘轮 (无回溯) 匹配 (\d+:)
</code></pre>
<h2 id="altseq">altseq</h2>
<p>尝试按顺序匹配其子项，直到找到匹配的子项。 这提供了 Raku 中的 <code>||</code> 语义，与 Perl 5 中的 <code>|</code> 语义相同。因此：</p>
<pre><code>the || them
</code></pre>
<p>编译成:</p>
<pre><code>QAST::Regex.new(
    :rxtype&lt;altseq&gt;,
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'the' ),
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'them' )
)
</code></pre>
<p>还有一个 <code>conjseq</code> 对应 Raku 的 <code>&amp;&amp;</code>。</p>
<h2 id="alt">alt</h2>
<p>支持 Raku 基于 LTM 的备选分支。正则表达式:</p>
<pre><code>the | them
</code></pre>
<p>编译成:</p>
<pre><code>QAST::Regex.new(
    :rxtype&lt;alt&gt;,
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'the' ),
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'them' )
)
</code></pre>
<p>如果可以的话，这将始终匹配 <code>them</code>，因为它先适用于具有最长声明前缀的分支。</p>
<h2 id="subrule-1">subrule (1)</h2>
<p>用于调用另一个规则，捕获是可选的。 例如:</p>
<pre><code>&lt;ident&gt;
</code></pre>
<p>会编译成:</p>
<pre><code>QAST::Regex.new(
    :rxtype&lt;subrule&gt;, :subtype&lt;capture&gt;, :name&lt;ident&gt;,
    QAST::Node.new( QAST::SVal.new( :value('ident') ) )
)
</code></pre>
<p><code>name</code> 属性是要捕获的名字，而 <code>QAST::SVal</code> 节点作为要调用的方法的名字。 额外的孩子节点可能会被提供给 <code>QAST::Node</code> 作为调用的参数。</p>
<h2 id="subrule-2">subrule (2)</h2>
<p>关于子规则还有一些值得注意的事情。首先，它不需要捕获。 例如：</p>
<pre><code>&lt;.ws&gt;
</code></pre>
<p>将编译成:</p>
<pre><code>QAST::Regex.new(
    :rxtype&lt;subrule&gt;, :subtype&lt;method&gt;,
    QAST::Node.new( QAST::SVal.new( :value('ws') ) )
)
</code></pre>
<h2 id="subrule-3">subrule (3)</h2>
<p><code>subrule</code> rxtype 也能够处理零宽断言。 例如：</p>
<pre><code>&lt;?alpha&gt;
</code></pre>
<p>将编译成:</p>
<pre><code>QAST::Regex.new(
    :rxtype&lt;subrule&gt;, :subtype&lt;zerowidth&gt;,
    QAST::Node.new( QAST::SVal.new( :value('alpha') ) )
)
</code></pre>
<h2 id="subrule-4">subrule (4)</h2>
<p>最后，还有两个适用于 <code>subrule</code> 的属性：</p>
<ul>
<li><strong>回溯</strong> 设置为 <code>r</code> 将阻止子规则调用回溯。这是在 <code>token</code> 和 <code>rule</code> 中设置的，并且避免了保持很多状态。</li>
<li>也可以在此节点上设置 <strong><code>negate</code></strong>。这可能与 <code>zerowidth</code> 子类型结合使用最有用, 因为 <code>&lt;!alpha&gt;</code> 就是那样编译的。</li>
</ul>
<p>最后但并非最不重要的是，<code>subrule</code> 也用于位置捕获。 而不是指定要调用的方法，捕获的内容被编译到嵌套的 <code>QAST::Block</code> 中并被调用。 这个是确保位置匹配获得自己的 <code>Match</code> 对象。</p>
<h2 id="subcapture">subcapture</h2>
<p>这用于实现不是子规则的命名捕获 。 即：</p>
<pre><code>$&lt;num&gt;=[\d+]
</code></pre>
<p>会编译成:</p>
<pre><code>QAST::Regex.new(
    :rx&lt;subcapture&gt;, :name&lt;num&gt;,
    QAST::Regex.new(
        :rxtype&lt;quant&gt;, :min(1), :max(-1),
        QAST::Regex.new(
            :rxtype&lt;cclass&gt;, :name&lt;d&gt;
        )
    )
)
</code></pre>
<h2 id="cursor">Cursor</h2>
<p><code>Cursor</code> 是一个<strong>保存匹配当前状态</strong>的对象。<code>Cursor</code> 是在进入 <code>token</code>/<code>rule</code>/<code>regex</code> 时创建的， 要么通过要么失败。从那时之后，<code>Cursor</code> 就是不可变了的。</p>
<p><code>Cursor</code> 内的状态包括：</p>
<ul>
<li>目标字符串</li>
<li>我们在当前规则中匹配的位置（-1 表示扫描）</li>
<li>匹配达到的当前位置</li>
<li>一堆回溯标记（稍后更多）</li>
<li>一堆捕获的游标（稍后更多）</li>
<li>可能是从 <code>Cursor</code> 生成的缓存 <code>Match</code> 对象</li>
<li>对于我们可能稍后回溯的传递的 <code>Cursor</code>， 要调用以重新启动匹配的代码对象</li>
</ul>
<h2 id="nqpcursorrole">NQPCursorRole</h2>
<p>NQP 和 Rakudo 都有自己的游标对象，分别叫做 <code>NQPCursor</code> 和 <code>Cursor</code>。但是，它们都组合了 <code>NQPCursorRole</code>，提供他们的大部分方法。</p>
<p>方法可分为以下几类：</p>
<ul>
<li>常见的内省方法： <code>orig</code>, <code>target</code>, <code>from</code> 和 <code>pos</code></li>
<li>内置规则：<code>before</code>, <code>after</code>, <code>ws</code>, <code>ww</code>, <code>wb</code>, <code>ident</code>, <code>alpha</code>,<code>alnum</code>, <code>upper</code>, <code>lower</code>, <code>digit</code>, <code>xdigit</code>, <code>space</code>, <code>blank</code>, <code>cntrl</code>, <code>punct</code></li>
<li>基础设施方法：所有的名称都以一个 <code>!</code> 开头, 主要由编译 <code>QAST::Regex</code> 节点生成的代码调用, 或作为实现内置规则的一部分。</li>
</ul>
<h2 id="it-starts-with-cursor_init">It starts with !cursor_init</h2>
<p>解析 grammar 或将字符串与正则表达式匹配 首先调用 <code>!cursor_init</code>，它创建一个 <code>Cursor</code> 并用目标字符串初始化它，设置选项（例如是否扫描）。</p>
<p>例如，以下是 <code>NQPCursor</code> 的 <code>parse</code> 方法的实现：</p>
<pre><code>method parse($target, :$rule = 'TOP', :$actions, *%options) {
    my $*ACTIONS := $actions;
    my $cur := self.'!cursor_init'($target, |%options);
    nqp::isinvokable($rule) ??
        $rule($cur).MATCH() !!
        nqp::findmethod($cur, $rule)($cur).MATCH()
}
</code></pre>
<h2 id="inside-a-rule-1">Inside a rule (1)</h2>
<p>进入 <code>token</code>, <code>rule</code> or <code>regex</code> 时发生的第一件事是创建一个新的 <code>Cursor</code> 来跟踪它的工作。这是通过调用 <code>!cursor_start_all</code> 方法来完成的，它返回一个状态数组，包括：</p>
<ul>
<li>新创建的 <code>Cursor</code></li>
<li>目标字符串</li>
<li>开始匹配的位置（-1 表示扫描）</li>
<li>当前的 <code>Cursor</code> 类型（泛型 <code>$?CLASS</code>）</li>
<li>回溯标记堆栈</li>
<li>重启标志：如果是重启则为 1，否则为 0</li>
</ul>
<p>除此之外：由于性能原因, 这个确切的因素将来可能会发生变化。</p>
<h2 id="inside-a-rule-2">Inside a rule (2)</h2>
<p>由 <code>!cursor_start_all</code> 返回的 <code>Cursor</code> 可能有各种各样的方法在匹配进行时调用它：</p>
<ul>
<li><strong><code>!cursor_start_subcapture</code></strong> 生成一个代表子捕获的 <code>Cursor</code></li>
<li><strong><code>!cursor_capture</code></strong> 将 <code>Cursor</code> 推到捕获堆栈 （通过调用子规则返回的一个或为一个创建的子规则返回的一个 subcapture）</li>
<li><strong><code>!cursor_pos</code></strong> 更新 <code>Cursor</code> 中的匹配位置（它仅在需要时同步） ！</li>
<li><strong><code>!cursor_pass</code></strong> 如果匹配成功; 到达的位置必须通过，如果它是一个命名的正则表达式，那么名称可以通过; 这也会触发对 action 方法的调用!</li>
<li><strong><code>!cursor_fail</code></strong> 如果匹配失败，则游标失败</li>
</ul>
<h2 id="inside-a-rule-3">Inside a rule (3)</h2>
<p>一旦 <code>token</code>, <code>rule</code> or <code>regex</code> 完成匹配，要么通过要么失败，它应该返回它工作的 <code>Cursor</code>。</p>
<p>事实上，这是协议：任何被称为 <code>subrule</code> 的东西应该将 <code>Cursor</code> 返回给它的调用者。不这样做会导致错误。</p>
<p>在 <code>Cursor</code> 失败的时候，任何回溯和捕获状态将被丢弃。如果它通过，但不能回溯到里面，然后回溯状态也可以被丢掉。</p>
<h2 id="cstack-和-capturing">cstack 和 capturing</h2>
<p><code>cstack</code>（ 要么 <strong>Capture stack</strong> 或 <strong>Cursor stack</strong>）就在哪里与捕获相对应的 <code>Cursor</code> 对象（位置或命名） 存储。它也可以用于存储我们可以回溯到的子规则的非捕获的 <code>Cursor</code> 。</p>
<p>在这样的东西里面:</p>
<pre><code>token xblock {
    &lt;EXPR&gt; &lt;.ws&gt; &lt;pblock&gt;
}
</code></pre>
<p><code>cstack</code> 最终会在它结束时有两个 <code>Cursor</code> 匹配：一个由 <code>EXPR</code> 调用返回，另一个由对<code>pblock</code> 的调用返回。</p>
<h2 id="bstack-和-backtracking">bstack 和 backtracking</h2>
<p><code>bstack</code> 是一堆整数。每个“标记”实际上都包含四个整数（所以只讨论4个项组才有意义，而不是个别整数）：</p>
<ul>
<li>正则表达式中的位置跳回（通常由跳转表解释）; 如果为0，那么回溯应该继续看下一项</li>
<li>要回到的字符串中的位置</li>
<li>可选地，重复计数（由量词使用）</li>
<li>标记点处的 <code>cstack</code> 高度。 这用于丢弃我们回溯的任何捕获。</li>
</ul>
<h2 id="match-object-production">Match object production</h2>
<p><code>Cursor</code> 或 <code>NQPCursor</code> 上的 <code>MATCH</code> 方法接收 <code>Cursor</code> 并创建一个 <code>Match</code> 或 <code>NQPMatch</code> 对象。我们的 action 方法将这些东西作为 <code>$/</code> 的参数传递。</p>
<p>它们是通过查看 <code>cstack</code> 产生，观察每个条目的名字，并建立一个位置捕获的数组和命名捕获的哈希。位置捕获正好有一个整数名称。</p>
<p>任何带有 <code>*</code>，<code>+</code> 或 <code>**</code> 的量词化捕获都会生成一个捕获结果的数组。</p>
<p>大部分工作都是由 <code>CAPHASH</code> 从 <code>NQPCursorRole</code> 中分解出来的。</p>
<h2 id="最长-token-匹配">最长 Token 匹配</h2>
<p>还剩一个重要的正则表达式相关主题：最长 token 匹配(Longest Token Matching, 或简称 LTM)。我们已经在 action 中见过它，但现在我们将花几分钟的时间思考它是如何工作的。</p>
<p>每个正则表达式或备选分支都有一个（可能是零长度） 声明性前缀。它涵盖了从正则表达式开始直到被认为是命令式构造（例如代码块， 正向向前查看，等等）的区域。</p>
<pre><code>token even { \d+ { +$/ % 2 == 0 } }
             DDD IIIIIIIIIIIIIIII
</code></pre>
<p>声明式前缀始终形成 <strong>regular language</strong>，并且作为结果可以转化为<strong>有限自动机</strong>。</p>
<h2 id="nfa-片段">NFA 片段</h2>
<p>一旦单个  <code>token</code>, <code>rule</code> 或 <code>regex</code>  被编译为 QAST，QAST 树被传递给 <strong><code>QRegex::NFA</code></strong>。</p>
<p>这将探讨 QAST，识别声明式前缀，以及从中构建 NFA（非确定性有限自动机）。</p>
<p>如果 QAST 树包含任何备选分支，那么这些分支中的每个分支也有 NFA 构建和存储。</p>
<p>此时，NFA 尚未准备好进行计算。每当有子规则调用，他们只是命名调用。从这个意义上讲，他们是关于整个 grammar 的泛型 ，可能需要多次具体化（由于 grammar 继承）。</p>
<h2 id="protoregex-和-alternation-nfas">Protoregex 和 alternation NFAs</h2>
<p><code>protoregex</code> 通过构建代表所有候选 NFA 的备选分支的 NFA 来决定调用哪个候选者 。</p>
<p>这个 <code>protoregex</code> NFA 总是特定于特定类型的 grammar。作为制作它的一部分，任何子规则调用都让它们的 NFA 替换该调用。</p>
<p>备选分支进行类似的过程，除了这次 NFA 是由分支的 NFA 构建的。</p>
<p>其中任何一个的结果都是可以针对目标字符串执行的 NFA。</p>
<h2 id="nfa-执行">NFA 执行</h2>
<p>有两个与执行 NFA 有关的 <code>nqp::ops</code>：</p>
<ul>
<li><strong><code>nfarunproto</code></strong> 根据目标字符串中给定的偏移量来计算 NFA 。它返回一个数组，指示候选者应该被尝试的顺序，不包括任何永远不可能的匹配。</li>
<li><strong><code>nfarunalt</code></strong> 根据目标字符串中给定的偏移量来计算 NFA 。然后它会推动所有分支的标记, 它可能会以相反的顺序匹配到 <code>bstack</code>，所以 最好的候选者在最顶端。那么正则表达式引擎只是立即“回溯”以开始尝试可能的候选者。</li>
</ul>
<p>这两个真的只是围绕同一底层 NFA 计算的薄薄的包装 。</p>
<h2 id="练习-9">练习 9</h2>
<p>在本练习中，您将探索一些正则表达式引擎实现。值得注意的是，你会遇到（如果允许时间）：</p>
<ul>
<li>Raku 正则表达式 grammar 和 action</li>
<li>如何在 NQP 和 Rakudo 中实现嵌入式代码块</li>
<li>NFA 存储的地方以及它们的外观</li>
</ul>
<p>请参阅练习页以获取指导。</p>
<h1 id="jvm-后端">JVM 后端</h1>
<p><em>将 Raku 带到 Java 的土地上</em></p>
<h2 id="the-jvm">The JVM</h2>
<p>虚拟机最初是为执行 Java 语言而构建的 现在拥有许多跨越多种语言的语言范式，静态，动态等。</p>
<p>指令集<strong>约200条指令</strong>，但VM 本身也提供了许多类库方法。</p>
<p>指令集和执行模型是<strong>基于堆栈的</strong>; 值是加载到要操作的堆栈上，作为方法参数传递等</p>
<p><strong>字节码</strong>存在于<strong>类文件</strong>中，它代表具有字段和方法的单个类。</p>
<h2 id="jvm-指令集-constants">JVM 指令集: constants</h2>
<p>将常量加载到堆栈的各种指令：</p>
<ul>
<li><strong><code>aconst_null</code></strong>  加载空引用</li>
<li><strong><code>iconst_m1</code>, <code>iconst_0</code>, <code>iconst_1</code>, &hellip; <code>iconst_5</code></strong> l 加载32位整数 -1,0,1,&hellip; 5 到堆栈上</li>
<li><strong><code>lconst_0</code>, <code>lconst_1</code></strong>  加载64位整数 0 和 1 到堆栈上</li>
<li><strong><code>fconst_0</code>, <code>fconst_1</code>, <code>fconst_2</code></strong>  加载 32 位浮点 0.0,1.0,2.0 到堆栈上</li>
<li><strong><code>dconst_0</code>, <code>dconst_1</code></strong>  加载 64 位浮点 0.0,1.0 到堆栈上</li>
<li><strong><code>bipush</code></strong>  接收 1 字节的参数并将其加载为 32位 整数</li>
<li><strong><code>sipush</code></strong> 接收 2 字节的参数并将其加载为 16 位整数</li>
<li><strong><code>ldc</code>, <code>ldc_w</code> and <code>ldc2_w</code></strong>  从常量池（int,float 或 String）中加载常量</li>
</ul>
<h2 id="jvm-指令集-locals">JVM 指令集: locals</h2>
<p>局部变量可以是整数（32位），长整数（64位），浮点数 （32位），双精度（64位）或对象引用。 有加载和存储它们的指令。</p>
<ul>
<li><strong><code>iload</code>, <code>lload</code>, <code>fload</code>, <code>dload</code> 和 <code>aload</code></strong>  接收一个索引并将该局部变量加载到堆栈上
<strong><code>istore</code>, <code>lstore</code>, <code>fstore</code>, <code>dstore</code> 和 <code>astore</code></strong>  接收一个索引并将当前堆栈顶部的内容存储到本地变量</li>
<li>前四个局部变量（索引 0 到 3）可以是使用 <strong><code>&lt;prefix&gt;[load|store]_[0..3]</code></strong> 形式的特殊指令，例如 <code>iload_0</code>, <code>lload_3</code>, <code>astore_2</code>, <code>dstore_0</code></li>
</ul>
<p>long 和 double 都计为两个插槽，因此两个相邻的 long 可能在索引 4 和 6; 试图在索引 5 访问某些东西会导致抱怨分割值！</p>
<h2 id="jvm-指令集-arrays">JVM 指令集: arrays</h2>
<p>可以使用 <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code> <code>byte</code>, <code>char</code>, <code>short</code> 或任何引用类型类型创建数组。它们不可调整大小。</p>
<ul>
<li><strong><code>newarray</code></strong>  创建一个包含任何原生类型的数组 其中一个字节表示类型并从栈顶分配长度</li>
<li><strong><code>anewarray</code></strong> 用于创建引用类型的数组; 类型被指定为常量池条目</li>
<li><strong><code>arraylength</code></strong>  获取数组的长度</li>
<li>从数组加载元素涉及把数组放置在堆栈上，索引在堆栈上，然后使用 <code>iaload</code>, <code>laload</code>, <code>faload</code>, <code>daload</code>, <code>aaload</code>, <code>baload</code>, <code>caload</code> 或 <code>saload</code> 其中的一个</li>
<li>将元素存储到数组涉及将数组放在堆栈上面 ，索引在堆栈上，值在堆栈上，然后使用 <code>iastore</code>, <code>lastore</code>, <code>fastore</code>, <code>dastore</code>, <code>aastore</code>, <code>bastore</code>, <code>castore</code>, 或 <code>sastore</code> 中的一个</li>
</ul>
<h2 id="jvm-指令集-arithmetic">JVM 指令集: arithmetic</h2>
<p>可以使用通常的算术和按位运算集：</p>
<ul>
<li><strong>加:</strong> <code>iadd</code>, <code>ladd</code>, <code>fadd</code>, <code>dadd</code></li>
<li><strong>减:</strong> <code>isub</code>, <code>lsub</code>, <code>fsub</code>, <code>dsub</code></li>
<li><strong>乘:</strong> <code>imul</code>, <code>lmul</code>, <code>fmul</code>, <code>dmul</code></li>
<li><strong>除:</strong> <code>idiv</code>, <code>ldiv</code>, <code>fdiv</code>, <code>ddiv</code></li>
<li><strong>取模:</strong> <code>irem</code>, <code>lrem</code>, <code>frem</code>, <code>drem</code></li>
<li><strong>取反:</strong> <code>ineg</code>, <code>lneg</code>, <code>fneg</code>, <code>dneg</code></li>
<li><strong>位移</strong>: <code>ishl</code>, <code>lshl</code>, <code>ishr</code>, <code>lshr</code>, <code>iushr</code>, <code>lushr</code></li>
<li><strong>按位:</strong> <code>iand</code>, <code>land</code>, <code>ior</code>, <code>lor</code>, <code>ixor</code>, <code>lxor</code></li>
</ul>
<h2 id="jvm-指令集-comparebranch">JVM 指令集: compare/branch</h2>
<p>血腥不规则！</p>
<p>对于 long，float 和 double，你使用 <code>lcmp</code>, <code>fcmpl</code>, <code>fcmpg</code>, <code>dcmpl</code>, 或 <code>dcmpg</code> 之一,它给出 -1, 0 或 1（就像各种 <code>cmp</code> 语言一样）。然后你用  <code>ifeq</code>, <code>ifne</code>, <code>iflt</code>, <code>ifge</code>, <code>ifgt</code>, 或 <code>ifle</code> 之一进行分支。</p>
<p>32 位整数比较非常特殊，有自己的指令集, 其比较和分支一体化: <code>if_icmpeq</code>, <code>if_icmpne</code>, <code>if_icmplt</code>, <code>if_icmpge</code>, <code>if_icmpgt</code> 和 <code>if_icmple</code>。</p>
<p>引用可以比较相等或不相等，并且根据 <code>if_acmpeq</code> 和 <code>if_acmpne</code> 进行分支。对于 nullness 空检查和分支，有 <code>ifnull</code> 和 <code>ifnonnull</code>。</p>
<p>最后，有一个无条件的 <code>goto</code> 和一个 <code>tableswitch</code> 用于编译成 switch 语句。</p>
<h2 id="jvm-指令集-对象和字段">JVM 指令集: 对象和字段</h2>
<p>使用 <code>new</code> 指令实例化对象。请注意字节码验证器将强制执行其构造函数 <code>invokespecial</code>（见下一张幻灯片）。</p>
<p>访问字段有四条指令（尽管我们没有经常这样做，对于 6model 对象，它被封装在表示的内部）：</p>
<ul>
<li><strong><code>getstatic</code></strong>  从常量池中获取字段引用, 将静态字段的值加载到堆栈上</li>
<li><strong><code>getfield</code></strong> 类似，但期望对象访问来自堆栈的实例字段</li>
<li><strong><code>putstatic</code></strong> 从常量池中获取字段引用, 将当前堆栈顶部值存储到静态字段</li>
<li><strong><code>putfield</code></strong> 是类似的，但期望对象存储实例字段到位于值下方的堆栈上</li>
</ul>
<h2 id="jvm-指令集-method-calls">JVM 指令集: method calls</h2>
<p>实例方法调用期望堆栈包含要调用的对象，然后是任何额外的参数。请注意这些对 Java 对象进行操作而不是对 6model 对象进行操作，所以我们不要把它们用于 Raku 的方法分派！</p>
<ul>
<li><strong><code>invokevirtual</code></strong> 执行正常的虚方法调用</li>
<li><strong><code>invokespecial</code></strong> 调用精确类中的方法（用于超级等）</li>
<li><strong><code>invokeinterface</code></strong> 通过接口调用方法</li>
</ul>
<p>还有 <strong><code>invokedynamic</code></strong>，只是期望参数在堆栈上。由于大多数 <code>nqp::ops</code> 是静态方法调用，我们用它很频繁 。</p>
<p>最后，还有 <strong><code>invokedynamic</code></strong>，这是实际的 Raku 级例程和方法调用被连接起来的方式。</p>
<h2 id="jvm-指令集-exceptions">JVM 指令集: exceptions</h2>
<p>只有一个与异常有关的指令， <strong><code>athrow</code></strong>。它抛出当前位于堆栈顶部的异常对象。</p>
<p>异常处理程序存储为表而不是字节码流。</p>
<h2 id="jvm-指令集-other-bits">JVM 指令集: other bits</h2>
<p>有各种强制指令可以在原始类型之间进行转换。它们的形式为 <code>&lt;from&gt;2&lt;to&gt;</code>，具有相同的用于数组的单字母代码。<code>i2l</code>, <code>i2f</code>, <code>i2d</code>, <code>l2i</code>, <code>l2f</code>, <code>l2d</code>, <code>f2i</code>, <code>f2l</code>, <code>f2d</code>, <code>d2i</code>, <code>d2l</code>, <code>d2f</code>, <code>i2b</code>, <code>i2c</code>, 和 <code>i2s</code>。</p>
<p>还有许多用于操作堆栈的指令：</p>
<ul>
<li><strong>Popping:</strong> <code>pop</code>, <code>pop2</code> (注意 long 或 double 计为 2 个插槽)</li>
<li><strong>Duplicating:</strong> <code>dup</code>, <code>dup2</code> (同一个规则)</li>
<li><strong>Swapping:</strong> <code>swap</code> (不, 对于 long/double 不存在)</li>
</ul>
<p>最后, 方法能使用  <code>ireturn</code>, <code>lreturn</code>, <code>freturn</code>, <code>dreturn</code>, <code>areturn</code>, 或 <code>return</code> (void) 方法返回(以当前的堆栈顶部为返回值)。</p>
<h2 id="jast-1">JAST (1)</h2>
<p>为了从 NQP 生成 JVM 字节码，我们构建了一堆 <strong>JAST</strong>  节点（JVM Abstract Syntax Tree 的缩写）。</p>
<p>有一些节点用于 push 常量：</p>
<pre><code>JAST::PushIVal.new( :value(42) )        # 64-bit integer constant
JAST::PushIndex.new( :value(69) )       # 32-bit integer constant
JAST::PushNVal.new( :value(1.5) )       # 64-bit double constant
JAST::PushSVal.new( :value('beer') )    # String constant
</code></pre>
<p>还有一个 <strong><code>JAST::PushCVal</code></strong>，用于 push 类字面值。</p>
<h2 id="jast-2">JAST (2)</h2>
<p>顶级结构由 <strong><code>JAST::Class</code></strong> 节点组成。它公开方法 <code>add_field</code>，它需要一个 <strong><code>JAST::Field</code></strong>，和 <code>add_method</code>，它需要一个 <strong><code>JAST::Method</code></strong>。</p>
<p><strong><code>JAST::Field</code></strong> 有方法(和具名构造器参数)来设置 <code>name</code>, <code>type</code> 还有它是否是 <code>static</code> 的。</p>
<p><strong><code>JAST::Method</code></strong> 更复杂。还有一个 <code>name</code> 和标志以表明它是否是 <code>static</code> 的, 它还有 <code>locals</code> 和 <code>arguments</code>，以及它返回的(<code>returns</code>)类型。附加字段捕获词法集，NQP 级异常处理程序等。</p>
<h2 id="jast-3">JAST (3)</h2>
<p>单个指令表示为 <strong><code>JAST::Instruction</code></strong> 节点。</p>
<pre><code>JAST::Instruction.new( :op('aconst_null') )
</code></pre>
<p>通常，这些被推到 <strong><code>JAST::InstructionList</code></strong> 中，虽然它们也可以被推到 <code>JAST::Method</code> 内部的指令列表中。</p>
<pre><code>my $il := JAST::InstructionList.new();
$il.append(JAST::PushIVal.new( :value($target) ));
$il.append(JAST::Instruction.new( :op('aload'), 'tc' ));
$il.append(JAST::Instruction.new( :op('invokestatic'), $TYPE_OPS,
    'lexotic_tc', $TYPE_SMO, 'Long', $TYPE_TC ));
# ...
</code></pre>
<h2 id="jast-4">JAST (4)</h2>
<p><strong><code>JAST::Label</code></strong> 节点代表一个标签。在给定的 <code>JAST::Method</code> 内部，标签需要是唯一的。</p>
<pre><code>my $if_id    := $qastcomp.unique($op_name);
my $else_lbl := JAST::Label.new(:name($if_id ~ '_else'));
</code></pre>
<p><code>JAST::Label</code> 可以用在分支中：</p>
<pre><code>$il.append(JAST::Instruction.new($else_lbl,
    :op($op_name eq 'if' ?? 'ifeq' !! 'ifne')));
</code></pre>
<p>并且它的位置就是被 push 的地方:</p>
<pre><code>$il.append($else_lbl);
</code></pre>
<h2 id="jast-5">JAST (5)</h2>
<p>最后，有 <strong><code>JAST::TryCatch</code></strong>，它代表一个（JVM 级别）异常处理程序。</p>
<p>它需要两个 <code>JAST::InstructionLists</code>，一个组成 <code>try</code>，另一个组成 <code>catch</code>。它还需要指定的异常类型 <code>type</code>。</p>
<pre><code>$il.append(JAST::TryCatch.new(
    :try($try_il),
    :catch($catch_il),
    :type($TYPE_EX_LEX)
));
</code></pre>
<h2 id="qast-到-jast-翻译器">QAST 到 JAST 翻译器</h2>
<p>JAST 提供了一种从 NQP 生成 JVM 字节码的方法。 然而，前端生成 QAST 树。他们之间是一个 QAST 到 JAST 的翻译器，它位于 NQP 的 <code>src/vm/jvm/QAST/</code> 目录。</p>
<p>总之，包括所有 QAST 节点（包括 regex）的翻译和 <code>nqp::ops</code>，它们大约为 5400 行。 这可能听起来很多，但它大约只有 Raku CORE.setting 的三分之一大小!</p>
<p>它的工作因以下几个因素而复杂化：</p>
<ul>
<li>它正在进行 Continuation Passing Style 转换， 因为它着手处理代码生成 - 虽然这是相对隔离的。</li>
<li>对于出现在 Raku 表达式（如 <code>try</code>）中间的东西,  JVM 拥有堆栈必须是空的约束。</li>
</ul>
<h2 id="类型和结果">类型和结果</h2>
<p>一切都围绕着四种原始类型，你会在编译器中看到到处都有原始类型:</p>
<pre><code>$RT_INT     a JVM long; 在 NQP 中映射到 `int`
$RT_NUM     a JVM double; 在 NQP 中映射到 `num`
$RT_STR     Java String 类; 在 NQP 中映射到 `str`
$RT_OBJ     6model 对象 (org.raku.nqp.sixmodel.SixModelObject)
</code></pre>
<p>编译 QAST 节点或 <code>nqp::op</code> 的代码总是返回一个 <code>Result</code>。此类型将 <code>JAST::InstructionList</code> 与上述类型之一组合在一起，表明它在堆栈上留下的内容 。</p>
<p><code>$RT_VOID</code> 表示没有结果。</p>
<h2 id="mapping-nqpops">Mapping nqp::ops</h2>
<p>为数不多的 <code>nqp::ops</code> 直接映射到 JVM ops:</p>
<pre><code>QAST::OperationsJAST.map_jvm_core_op('neg_i', 'lneg', [$RT_INT], $RT_INT);
</code></pre>
<p>其他一些映射到 Java 类库中的函数：</p>
<pre><code>QAST::OperationsJAST.map_classlib_core_op('abs_i', $TYPE_MATH, 'abs',
    [$RT_INT], $RT_INT);
</code></pre>
<p>但是，在 NQP 运行时, 大多数映射到对 <code>Ops</code> 类的调用 ，经常传递当前的 <code>ThreadContext</code> 对象:</p>
<pre><code>QAST::OperationsJAST.map_classlib_core_op('create', $TYPE_OPS, 'create',
    [$RT_OBJ], $RT_OBJ, :tc);
</code></pre>
<h2 id="运行时支持库">运行时支持库</h2>
<p>许多 <code>nqp::ops</code>，6model 的 JVM 实现，以及各种其他支持代码存在于 NQP 的 <code>src/vm/jvm/runtime/</code> 目录中。它内置于 <code>nqp-runtime.jar</code> 库中。</p>
<p>如果修改此代码，通常只需重新构建该 JAR 即可看到效果，而不是重建所有的 NQP。将其复制到它的安装位置，也可以为 Rakudo 更新。</p>
<p>Rakudo 还有一个（小得多）运行时支持库，它被构建到 <code>rakudo-runtime.jar</code> 中。</p>
<p><em>&lt;随着时间的推移探索&gt;</em></p>
<h2 id="总结-">总结 &hellip;</h2>
<p>JVM 支持包括将 QAST 树转换为 JVM 字节码，通过称为 JAST 的中间形式，和运行时支持库。</p>
<p>大多数工作都用于提供 JVM 所不原生提供的功能，例如 gather/take 所需的持续支持，6model，在堆栈展开之前, 在堆栈顶部运行的异常处理程序，等等。</p>
<p>从这里开始，需要进行优化，更好的代码生成， 和更好的 <code>invokedynamic</code> 使用。</p>
<h1 id="moarvm-后端">MoarVM 后端</h1>
<p><em>专为 NQP 和 Rakudo 构建的 VM</em></p>
<h2 id="moarvm-概览">MoarVM 概览</h2>
<p>使用 <strong>6model</strong> 作为其原生对象系统。</p>
<p>指令集与 <strong>nqp::ops</strong> 对齐。</p>
<p>提供两代 <strong>generational GC</strong>（由半空间复制处理）和 gen2（固定大小的池，除了大对象）</p>
<p>包括 <strong>Unicode database</strong> 支持，并致力于 <strong>NFG</strong> 字符串。</p>
<p>支持<strong>线程</strong>，可能的时候使用无锁数据结构。</p>
<h2 id="mast">MAST</h2>
<p>MoarVM 没有汇编语言或中间语言; 相反， MAST（MoarVM 汇编语法树）直接汇编为字节码。</p>
<p>MAST 低于 QAST，与 JAST 相当不同 （由于 VM 的设计相当不同以及 MoarVM 不是基于堆栈的这一事实）。但是，如果你熟悉的两者之一（或两者），你会很快对 MAST 感到宾至如归。毕竟，MAST 和 JAST 是同一个人设计的，并且上述的人也为 QAST 设计做出了贡献。<code>:-)</code></p>
<p>实际上，作为等效的 QAST 节点, 5 个 MAST 节点共享相同的名字和角色 。</p>
<h2 id="mast-nodes-literals">MAST nodes: literals</h2>
<p>文字整数，浮点数和字符串, 他们的表示并不令人惊讶:</p>
<pre><code>MAST::IVal.new( :value(42) )
MAST::NVal.new( :value(1.2) )
MAST::SVal.new( :value('cwrw') )
</code></pre>
<p>然而，虽然它们的 QAST 等价物基本上可以出现在任何地方，这些 MAST 节点只能用作期望文字的指令的参数 （例如，<code>const_i64</code>, <code>const_n64</code>, <code>const_s</code>, <code>argconst_[ins]</code>，命名参数中的参数名称绑定指令等）相反大多数指令期望一个本地参数。</p>
<h2 id="mast-帧">MAST: 帧</h2>
<p>MoarVM 中的词法作用域最小的可调用单元是帧。 这由 <code>MAST::Frame</code> 节点表示。</p>
<p>一个帧有：</p>
<ul>
<li>一个（高级别）名称和（低级别）一个编译单元唯一 ID</li>
<li>locals/寄存器列表（没有区别，术语可互换使用）。这些只有整数索引， 不是名字。</li>
<li>词法列表。这些都有名称和类型。</li>
<li>对其静态外部帧的引用（用于词法查找）</li>
<li>指令列表</li>
</ul>
<p>通常，<code>QAST::Block</code> 映射到 <code>MAST::Frame</code>。</p>
<h2 id="mast-nodes-locals">MAST nodes: locals</h2>
<p>有一个 <code>MAST::Local</code> 代表 locals（当帧执行时可用的存储空间）：</p>
<pre><code>MAST::Local.new( :index($!frame.add_local($type)) )
</code></pre>
<p>实际上，很难看到这是直接构建在 QAST 到 MAST 编译器。这一切都隐藏在一些帮助函数背后：</p>
<pre><code>fresh_o     Make a new object local
fresh_i     Make a new int64 local
fresh_n     Make a new num64 local
fresh_s     Make a new string local
</code></pre>
<p>使用后，通常会释放 local，以便可以在帧中的其他地方重复使用。</p>
<h2 id="mast-nodes-lexicals">MAST nodes: lexicals</h2>
<p>MoarVM 本身也支持词法变量，这（不同于 locals）从嵌套帧中可以看到。同样，这些节点很少直接在 QAST 编译器中生成，而是由解析词法（计算要看多少帧）的帮助程序生成。</p>
<pre><code>method resolve_lexical($name) {
    my $block := self;
    my $out   := 0;
    while $block {
        if ($block.lexicals()){$name} -&gt; $lex {
            return MAST::Lexical.new( :index($lex.index),
                                      :frames_out($out) );
        }
        $out++;
        $block := $block.outer;
    }
    nqp::die(&quot;Could not resolve lexical $name&quot;);
}
</code></pre>
<h2 id="mast-nodes-ops">MAST nodes: ops</h2>
<p><code>MAST::Op</code> 节点表示 MoarVM 的操作指令集。这些通常被  <code>push_op</code> 帮助程序创建并推到指令列表中:</p>
<pre><code>sub push_op(@dest, $op, *@args) {
    nqp::push(@dest, MAST::Op.new(
        :op($op),
        |@args
    ));
}
</code></pre>
<p>期望作为参数的节点类型随指令而变化。 例如， <code>push_o</code> 指令需要两个 <code>MAST::Local</code> 节点:</p>
<pre><code>push_op($arr.instructions, 'push_o', $arr_reg, $item_reg);
</code></pre>
<p>请注意，此级别没有强制/多态。 如果指令想要 local，那么你就不能使用文字了！</p>
<h2 id="mast-nodes-labels">MAST nodes: labels</h2>
<p>可以将 <code>MAST::Label</code> 放在指令列表中作为目标的一个分支，并用作某些分叉的 <code>MAST::Ops</code> 的参数。</p>
<p>标签在给定的 <code>MAST::Frame</code> 中必须是唯一的，这就是你经常会看到如下代码的原因：</p>
<pre><code>my $if_id    := $qastcomp.unique($op_name);
my $else_lbl := MAST::Label.new(:name($if_id ~ '_else'));
my $end_lbl  := MAST::Label.new(:name($if_id ~ '_end'));
</code></pre>
<p>以下是使用标签的一些示例:</p>
<pre><code>push_op(@ins, 'goto', $end_lbl);
nqp::push(@ins, $else_lbl);
</code></pre>
<h2 id="mast-nodes-calls">MAST nodes: calls</h2>
<p>调用归结为以下几个步骤：获取传入参数缓冲区的参数，设置调用点描述符，指示结果寄存器，并自己进行调用。</p>
<p>这是在 <code>MAST::Call</code> 节点后面抽象的：</p>
<pre><code>nqp::push(@ins, MAST::Call.new(
    :target($callee.result_reg),
    :flags(@arg_flags),
    |@arg_regs,
    :result($res_reg)
));
</code></pre>
<p>标志表示寄存器类型，以及命名和展平参数。</p>
<h2 id="mast-nodes-异常处理程序">MAST nodes: 异常处理程序</h2>
<p>异常处理程序用于控制流（例如循环中的 next/redo/last）或真正的异常（在 NQP/Raku 中由 <code>CATCH</code> 捕获）。这两个都设置为 <code>MAST::HandlerScope</code>，表示所涵盖的指令处理程序，它感兴趣的是什么样的异常以及如果处理程序被触发会做什么。</p>
<pre><code>MAST::HandlerScope.new(
    :instructions(@loop_il),
    :category_mask($HandlerCategory::redo),
    :action($HandlerAction::unwind_and_goto),
    :goto($redo_lbl)
)
</code></pre>
<p>在这里，action 是简单地展开调用堆栈并转到指定标签。相比之下， <code>CATCH</code> 块的 action 是在堆栈顶部运行一个处理程序块并随后展开。</p>
<h2 id="mast-nodes-编译单元">MAST nodes: 编译单元</h2>
<p>最后，MAST 汇编树的顶部始终是 <code>MAST::CompUnit</code>。这有一个帧列表（每一帧都使用 <code>add_frame</code> 方法添加）。</p>
<p>某些帧可以被称为特殊帧：</p>
<ul>
<li><strong><code>deserialize_frame</code></strong> 包含驱动反序列化的代码， 并且将始终在编译单元创建或加载时运行</li>
<li><strong><code>load_frame</code></strong> 当编译单元被加载为模块时, 保存应运行的代码</li>
<li><strong><code>main_frame</code></strong> 当编译单元是初始入口点时, 保存应运行的代码</li>
</ul>
<p>它还跟踪生成编译单元的 HLL 以及它依赖的序列化上下文集。</p>
<h2 id="qast-到-mast-的翻译器">QAST 到 MAST 的翻译器</h2>
<p>分布到三个文件中：</p>
<ul>
<li><strong><code>QASTOperationsMAST.nqp</code></strong> 处理 <code>nqp::op</code> 的编译</li>
<li><strong><code>QASTRegexCompilerMAST.nqp</code></strong> 处理 <code>QAST::Regex</code> 节点的编译</li>
<li><strong><code>QASTCompilerMAST.nqp</code></strong> 处理其余部分以及他们工作的各种寄存器</li>
</ul>
<p>这些参考：</p>
<ul>
<li>MAST 节点</li>
<li>关于所有可用 op 的元数据和各种操作</li>
</ul>
<h2 id="mastinstructionlist">MAST::InstructionList</h2>
<p>再次，有一个数据结构用于携带编译 QAST 节点的结果：<code>MAST::InstructionList</code>。它有三块儿信息：</p>
<ul>
<li>指令列表（<code>$il.instructions</code>）</li>
<li>保存结果（<code>$il.result_reg</code>)的寄存器（local）</li>
<li>结果寄存器类型（<code>$il.result_kind</code>）</li>
</ul>
<p>有四种主要类型的常量：</p>
<ul>
<li><code>$MVM_reg_obj</code>（6model 对象）</li>
<li><code>$MVM_reg_int64</code>（int）</li>
<li><code>$MVM_reg_num64</code>（num）</li>
<li><code>$MVM_reg_str</code>（str，虽然它实际上也是一个 6model 对象）</li>
</ul>
<h2 id="registerlocal-allocation">Register/local allocation</h2>
<p>每个块 <code>$*REGALLOC</code> 跟踪寄存器的使用情况。 尽管有这个名字，它不是以传统方式进行寄存器分配（如图着色）。相反，它保持跟踪可用的临时值，使它们可以重复使用。</p>
<p>获取要使用的新寄存器通常如下：</p>
<pre><code>my $callee_reg := $*REGALLOC.fresh_o(); # also _i, _n, _s
</code></pre>
<p>然后可以在不再需要时释放它:</p>
<pre><code>$*REGALLOC.release_register($callee_reg, $MVM_reg_obj);
</code></pre>
<h2 id="nqpop-mapping">nqp::op mapping</h2>
<p>许多 <code>nqp::ops</code> 在 MoarVM 指令集中具有相似或相同的名称。操作数类型数据也很容易获得，因此不需要在映射中指定:</p>
<pre><code>QAST::MASTOperations.add_core_moarop_mapping('atpos', 'atpos_o');
QAST::MASTOperations.add_core_moarop_mapping('atpos_i', 'atpos_i');
</code></pre>
<p>MoarVM 中的某些指令无效，但允许使用 r 值上下文作为 <code>nqp::ops</code>。因此，我们选择其中一个输入操作数作为结果，如果需要的话。</p>
<pre><code>QAST::MASTOperations.add_core_moarop_mapping('bindpos', 'bindpos_o', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindpos_i', 'bindpos_i', 2);
</code></pre>
<h2 id="在-moarvm-内部">在 MoarVM 内部</h2>
<p>顶级 <code>src</code> 目录不直接包含太多东西; 代码被归类到子目录里：</p>
<ul>
<li><strong><code>6model</code></strong> 包含 6model，REPR 的实现， 序列化&hellip;</li>
<li><strong><code>core</code></strong>  是 VM 的核心，包含解释器， 参数处理，字节码解码，线程处理， 调用，异常&hellip;</li>
<li><strong><code>gc</code></strong> 是内存分配和垃圾回收存在的地方</li>
<li><strong><code>io</code></strong> 包含与 IO 相关的功能，通常委托真正的工作到 <code>libuv</code></li>
<li><strong><code>mast</code></strong> 包含 MAST 到字节码编译器</li>
<li><strong><code>math</code></strong>  包含用于大整数支持的 libtommath 绑定</li>
<li><strong><code>platform</code></strong>  是平台特定的代码(因为不同的平台以不同的方式做事)</li>
<li><strong><code>strings</code></strong> 包含字符串操作，编码/解码 ASCII，UTF-8 等</li>
</ul>
<h2 id="总结--1">总结 &hellip;</h2>
<p>MoarVM <strong>使用 6model</strong> 作为其对象模型并具有与 <code>nqp::op</code> 集良好对齐的指令集。作为结果， 从 QAST 到它的映射相对简单。</p>
<p>它也将是我们支持 NFG 字符串的第一个地方 也应该得到良好的 Perl 5 互操作。</p>
<p>未来的发展将包括 6model 感知的 JIT 编译， 这应该会带来显着的性能提升。</p>
<h1 id="前方的路">前方的路</h1>
<p><em>这还不是结束??!!!</em></p>
<h2 id="这还不是全部">这还不是全部&hellip;</h2>
<p>这两天我们已经涵盖了很多方面。</p>
<p>当然，有些东西已被搁置。我们还没有查看每个文件的每一行代码！</p>
<p>而且，当然，我们没有涵盖尚未发明的东西，因为我们没有实现需要它们的 Raku规范。</p>
<p>但是， <strong>我们已经涵盖了所有组成 NQP 和 Rakudo 的关键部分</strong>。仔细阅读代码和一点点挖掘，应该有可能弄清楚 NQP 和 Rakudo 做的大部分东西，其中大多数东西已经被发现了。</p>
<h2 id="工具链将会发展">工具链将会发展</h2>
<p>NQP 工具链是为了响应理解 Raku 的需求而发展起来的。随着我们不断学习，这种知识将会处理成工具。</p>
<p>在过去，有一些相当戏剧性的改革。 这些很可能已经结束了，尽管肯定会有更多的教训转化成<strong>更好的抽象和 API</strong>。</p>
<p>例如，并发/并行工作目前正在进行中, 直接来自 Java 类库的类的术语。 但是，最后，关键的抽象可能会被捕获到 <code>nqp::</code> ops 中, 等等。</p>
<h2 id="记住-">记住 &hellip;</h2>
<p><strong>编译器并不神奇。他们只是软件</strong>。</p>
<p>Raku 是一种大型语言，实现它是非常重要的。 然而，NQP 和 Rakudo 已经通过将问题分解为解耦的碎片来管理复杂性做出了合理的尝试。</p>
<p>事实上，这是唯一可以让它易于管理的东西。 在你 hack 的时候记住这一点。 <strong>好的架构需要训练</strong>。 您想到的第一个解决方案很少是最好的解决方案。而你感觉不对的东西，通常是最后的解决方案。</p>
<p>请以优雅地解决实现问题而自豪，提问, 不要将代码视为神圣，并确保 <strong><code>--Ofun</code></strong>。</p>
<h2 id="谢谢你">谢谢你!</h2>
<p>感谢您参加课程！</p>
<p><em>还有问题吗?</em></p>
<p>顺便说一句，在 Edument AB，我们也建立并提供如下课程。。。</p>
<ul>
<li>Perl 5</li>
<li>Git</li>
<li>软件架构和领域驱动设计</li>
<li>JavaScript 和其它 Web 技术</li>
<li>C# 和 .Net</li>
<li>测试驱动开发</li>
</ul>
<p>有关更多信息，请参阅 <a href="http://edument.se/courses/">http://edument.se/courses/</a>。</p>


        
          <div class="blog-tags">
            
              <a href="https://ohmysummer.github.io//tags/nqp/">NQP</a>&nbsp;
            
              <a href="https://ohmysummer.github.io//tags/rakudo/">Rakudo</a>&nbsp;
            
          </div>
        

        

        
          
            
          

          
                  <h4 class="see-also"></h4>
                  <ul>
                
                
                    <li><a href="/post/2017-01-01-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/">Raku Rakudo 和 NQP 内部研讨(一)</a></li>
                
              </ul>

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://ohmysummer.github.io/post/2018-01-28-raku-core-hacking-qastalicious/" data-toggle="tooltip" data-placement="top" title="Raku Core Hacking: QASTalicious">&larr; </a>
            </li>
          
          
            <li class="next">
              <a href="https://ohmysummer.github.io/post/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/" data-toggle="tooltip" data-placement="top" title="Raku 中的数据类型 Bag"> &rarr;</a>
            </li>
          
        </ul>
      


      
        
          
          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ohmysummer" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
          
        
        
      

    </div>
  </div>
</div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            <a href="" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://ohmysummer.github.io/">焉知非鱼</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2020
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://ohmysummer.github.io/">Raku Programming</a>
            with <span style="color: red;">❤</span>
          
        </p>
        
        <p class="credits theme-by text-muted">
          
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://ohmysummer.github.io/js/main.js"></script>
<script src="https://ohmysummer.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://ohmysummer.github.io/js/load-photoswipe.js"></script>



<script>
  (function() {
    var cx = '009072066163920799339:qwme9vkotxk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>







    
  </body>
</html>

