<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Perl 6 Rakudo 和 NQP 内部研讨(二)</title>
  <meta property="og:title" content="Perl 6 Rakudo 和 NQP 内部研讨(二)" />
  <meta name="twitter:title" content="Perl 6 Rakudo 和 NQP 内部研讨(二)" />
  <meta name="description" content="title: Rakudo and NQP Internals subtitle: The guts tormented implementers made author: Jonathan Worthington
课程概览 - 第二天 欢迎回来. 今天我们会涉及到如下话题:
 6model Bounded Serialization and Module Loading The regex and grammar engine The JVM backend The MoarVM backend  6model 对象系统的组成成分
什么是 6model? 6model 提供了一组用于构建类型和对象系统的原语.
Rakudo 的类, roles, 枚举和 subset 类型都由这些原语组装在一起. NQP 也是, 尽管 NQP 的对象系统更简单, 它仅仅提供了类和 roles.
这些原语已经在 Parrot 和 JVM 虚拟机上实现了. MoarVM 也提供了那些原语, 但是它走的更远, 它让 6model 成为 MoarVM 的对象系统.">
  <meta property="og:description" content="title: Rakudo and NQP Internals subtitle: The guts tormented implementers made author: Jonathan Worthington
课程概览 - 第二天 欢迎回来. 今天我们会涉及到如下话题:
 6model Bounded Serialization and Module Loading The regex and grammar engine The JVM backend The MoarVM backend  6model 对象系统的组成成分
什么是 6model? 6model 提供了一组用于构建类型和对象系统的原语.
Rakudo 的类, roles, 枚举和 subset 类型都由这些原语组装在一起. NQP 也是, 尽管 NQP 的对象系统更简单, 它仅仅提供了类和 roles.
这些原语已经在 Parrot 和 JVM 虚拟机上实现了. MoarVM 也提供了那些原语, 但是它走的更远, 它让 6model 成为 MoarVM 的对象系统.">
  <meta name="twitter:description" content="title: Rakudo and NQP Internals subtitle: The guts tormented implementers made author: Jonathan Worthington
课程概览 - 第二天 欢迎回来. 今天我们会涉及到如下话题:
 6model Bounded Serialization and Module Loading The regex …">
  <meta name="author" content="焉知非鱼"/>
  <link href='https://ohmysummer.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://ohmysummer.github.io/post/2018-01-29-perl-6-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Rakudo Perl 6" />

  <meta name="generator" content="Hugo 0.53" />
  <link rel="canonical" href="https://ohmysummer.github.io/post/2018-01-29-perl-6-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/" />
  <link rel="alternate" href="https://ohmysummer.github.io/index.xml" type="application/rss+xml" title="Rakudo Perl 6">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://ohmysummer.github.io/css/codeblock.css" />



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'ohmycloudy', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://ohmysummer.github.io/">Rakudo Perl 6</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="博客" href="/">博客</a>
            </li>
          
        
          
            <li>
              <a title="归档" href="/categories">归档</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/page/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        

        

        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span class="hidden-sm hidden-md hidden-lg">Search</span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
          <a title="Rakudo Perl 6" href="https://ohmysummer.github.io/">
            <img class="avatar-img" src="https://ohmysummer.github.io/img/rakudo.png" alt="Rakudo Perl 6" />
          </a>
        
      </div>
    </div>

  </div>
</nav>



  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title">Search Rakudo Perl 6</h4>
        </div>
        <div class="modal-body">
          <gcse:search></gcse:search>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>


    
  
  
  




  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              <h1>Perl 6 Rakudo 和 NQP 内部研讨(二)</h1>
                
                
                  <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on January 29, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 52 minutes (10996 words)
  
  
</span>

                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        

<p>title: Rakudo and NQP Internals
subtitle: The guts tormented implementers made
author: Jonathan Worthington</p>

<h2 id="课程概览-第二天">课程概览 - 第二天</h2>

<p>欢迎回来. 今天我们会涉及到如下话题:</p>

<ul>
<li>6model</li>
<li>Bounded Serialization and Module Loading</li>
<li>The regex and grammar engine</li>
<li>The JVM backend</li>
<li>The MoarVM backend</li>
</ul>

<h1 id="6model">6model</h1>

<p><em>对象系统的组成成分</em></p>

<h2 id="什么是-6model">什么是 6model?</h2>

<p>6model 提供了一组<strong>用于构建类型和对象系统的原语</strong>.</p>

<p>Rakudo 的类, roles, 枚举和 subset 类型都由这些原语组装在一起. NQP 也是, 尽管 NQP 的对象系统更简单, 它仅仅提供了类和 roles.</p>

<p>这些原语已经在 Parrot 和 JVM 虚拟机上实现了. MoarVM 也提供了那些原语, 但是它走的更远, 它让 6model 成为 MoarVM 的对象系统.</p>

<p>那些原语可能比你想象的更加原始. 例如 6model <strong>没有内置继承或角色组合的概念</strong>. 这些东西在更高的层级中创建.</p>

<h2 id="object-行为-状态">Object = 行为 + 状态</h2>

<p>无论什么语言, 你发现对象总有:</p>

<ul>
<li>对象继承机制, 对象可以拥有 <strong>状态</strong></li>
<li>接收一个对象和名字, 使用名字定位一个<strong>行为</strong>(假设它存在), 并调用它.</li>
</ul>

<p>状态可以由类携带, 或自由存在。行为可能直接地附加在对象上，附加在每个类上，或者通过多种分派机制定位某个行为。</p>

<p>但总是会有<strong>状态</strong>和<strong>行为</strong>。</p>

<h2 id="类型">类型</h2>

<p>大多数语言也有一些<strong>类型</strong>的概念。通常，类型属于彼此之间的关系。例如，给出：</p>

<pre><code>class Event {
    has $.name;
    has $.start-date;
    has $.days;
}
class Hackathon is Event {
    has $.topic;
    has @.hackers;
}
</code></pre>

<p>我们可以说 <code>Hackathon</code> 是 <code>Event</code> 的子类型.</p>

<h2 id="package-种类">Package 种类</h2>

<p>我们不仅有不同的类型，我们有<strong>不同种类的类型</strong>。在 Perl 6 中，这些对应于不同的<strong>包和类型声明符</strong>。</p>

<pre><code>package     module      knowhow     class
grammar     role        enum        subset
</code></pre>

<p>它们具有相当不同的性质，并且行为方式相当不同。例如，针对 &ldquo;subset&rdquo; 类型的类型检查涉及调用它的 &ldquo;where&rdquo; 从句.</p>

<p>抛开差异，他们每个都会导致某种代表他们声明的类型的<strong>类型对象</strong>。</p>

<h2 id="元对象">元对象</h2>

<p>So if 6model doesn&rsquo;t natively know how things like inheritance and role composition work, let alone subset types, where are these things implemented?</p>

<p>所以，如果 6model 本身不知道继承和角色是如何组合起来工作的，更不用说子集类型，这些东西在哪里实现？</p>

<p>答案在于<strong>元对象</strong>。每个存在的对象都有一个与之关联的元对象，它描述了该对象是如何工作的。许多对象可能具有相同的元对象。例如，在 Perl 6 中，<strong>同一个类的所有对象将共享一个元对象</strong>。</p>

<p>要理解的是<strong>元对象只是一个对象</strong>。
有*什么*不可思议的。它只是碰巧拥有 <code>new_type</code>，<code>add_method</code>，<code>add_parent</code> 等名字的方法。因此，元对象<strong>不绑定到特定的目标虚拟机</strong>。</p>

<h2 id="representations">Representations</h2>

<p>元对象对对象的类型和语义感兴趣。但是，他们明确地不关心对象在内存中是如何布局的。</p>

<p>与对象有关的内存的分配，布局和访问由<strong>表示</strong>来控制。</p>

<p>表示不是对象。他们是<strong>低级的</strong>并且<strong>每个后端的实现方式也不同</strong>。但他们提供的API是相同的。</p>

<p>因此，除了具有元对象外，每个对象都有一个表示。虽然元对象可能存在于每种类型中，但表示的数量却少得多。</p>

<h2 id="stables-把元对象和表示组合在一起">STables 把元对象和表示组合在一起</h2>

<p>虽然对象拥有一个元对象和一个表示，但是在这之间实际上有一个间接层：<strong>STable</strong>。稍后我们会更仔细地看这些。</p>

<p><img src="eps/6model.eps" alt="50%" /></p>

<h2 id="我们的第一个元对象">我们的第一个元对象</h2>

<p>这是我们的第一个对象系统。它支持具有方法的类型。类型将始终具有 <code>P6opaque</code> 表示。</p>

<pre><code>class SimpleHOW {
    has %!methods;

    method new_type() {
        nqp::newtype(self.new(), 'P6opaque')
    }

    method add_method($obj, $name, $code) {
        %!methods{$name} := $code;
    }

    method find_method($obj, $name) {
        %!methods{$name}
    }
}
</code></pre>

<h2 id="使用我们的元对象">使用我们的元对象</h2>

<p>首先，我们来创建一个新的类型，并添加单个方法。</p>

<pre><code>my $Greeter := SimpleHOW.new_type();
$Greeter.HOW.add_method($Greeter, 'greet',
    -&gt; $self, $name { say(&quot;Hello, $name&quot;) });
</code></pre>

<p>现在 <code>$Greeter</code> 变量包含新类型的类型对象。如果我们在它身上调用 <code>greet</code> 方法：</p>

<pre><code>$Greeter.greet('Katerina');
</code></pre>

<p>Then our meta-object&rsquo;s <code>find_method</code> method will be called with the argument <code>greet</code>, and whatever it returns will be invoked, passing <code>$Greeter</code> and the string <code>Katerina</code> as arguments.
那么，我们的元对象的 <code>find_method</code> 方法将被调用 <code>greet</code> 参数，它返回的任何东西都会被调用，传递 <code>$Greeter</code> 和字符串 <code>Katerina</code> 作为参数。</p>

<h2 id="how-s-that">HOW&rsquo;s that?</h2>

<p>The word <code>HOW</code> is often used in connection with meta-objects. By convention,the meta-object for the keyword <code>class</code> will have a name like <code>ClassHOW</code>. It&rsquo;s not strictly followed, even in Rakudo and NQP. But all of the meta-objects for types do end in <code>HOW</code>.</p>

<p>If you take an object and use <code>.HOW</code> on it, you get the meta-object back. We can chase this up the chain as far as we wish.
&ldquo;HOW&rdquo; 这个词通常用于元对象。按照惯例，关键字 <code>class</code> 的元对象将有一个像 <code>ClassHOW</code> 这样的名字。这不是严格遵循，即使在 Rakudo 和 NQP 中。但是所有类型的元对象都以 &ldquo;HOW&rdquo; 结尾。</p>

<p>如果你拿一个对象并使用<code>.HOW</code>，你就会得到元对象。我们可以按照我们的意愿去追逐这个链条。</p>

<pre><code>my $mo := $Greeter.HOW;
say($mo.HOW.name($mo));             # SimpleHOW
my $momo := $mo.HOW;
say($momo.HOW.name($momo));         # NQPClassHOW
my $momomo := $momo.HOW;
say($momomo.HOW.name($momomo));     # KnowHOW
</code></pre>

<h2 id="knowhow-the-root-of-it-all">KnowHOW, the root of it all</h2>

<p>If you chase the <code>HOW</code>-chain far enough back on any object, eventually you&rsquo;ll
reach something that claims to be a <code>KnowHOW</code>. Keep going, and you just go in
circles; the end of the chain is self-describing.</p>

<p><code>KnowHOW</code> is the only meta-object provided by the 6model core. It supports:</p>

<ul>
<li>Having a name</li>
<li>Having attributes</li>
<li>Having methods</li>
<li>In a type check, it only type checks against itself</li>
</ul>

<p>That&rsquo;s it. No role composition. No inheritance.</p>

<h2 id="the-knowhow-declarator">The knowhow declarator</h2>

<p>The <code>knowhow</code> package declarator exists in both Rakudo and NQP. You&rsquo;ve very
little reason to use it yourself. However, inside of <code>src/how/</code> in NQP, you
will find a bunch of meta-objects using it:</p>

<pre><code>NQPModuleHOW                An NQP module
NQPClassHOW                 An NQP class or grammar
NQPNativeHOW                An NQP native type (int/num/str)
NQPParametricRoleHOW        An NQP role declaration
NQPConcreteRoleHOW          An NQP role made concrete for a given class
NQPCurriedRoleHOW           An NQP role with some arguments pre-set
</code></pre>

<p>Naturally, we can&rsquo;t use <code>class</code> until the meta-object that implements classes
is available! Thus, <code>knowhow</code> is all we have.</p>

<h2 id="giving-rubyish-classes">Giving Rubyish classes</h2>

<p>We&rsquo;ll take a look at the meta-objects for NQP and Rakudo in a little bit. But
first, to see something a little more manageable, let&rsquo;s return to the Rubyish
compiler we worked on yesterday and add very basic OO support:</p>

<ul>
<li>Declaring a class</li>
<li>Giving it methods</li>
<li>Creating a class instance with a <code>new</code> statement</li>
<li>Calling the methods on the class</li>
</ul>

<p>We&rsquo;ll put inheritance and attributes aside for now; in fact, we&rsquo;ll use the NQP
or Perl 6 meta-objects to study those.</p>

<h2 id="parsing-a-class-definition">Parsing a class definition</h2>

<p>The parsing is relatively easy, however we set up a couple of extra dynamic
variables related to methods. We&rsquo;ll see their usage next.</p>

<pre><code>token statement:sym&lt;class&gt; {
    :my $*IN_CLASS := 1;
    :my @*METHODS;
    'class' \h+ &lt;classbody&gt;
}
rule classbody {
    :my $*CUR_BLOCK := QAST::Block.new(QAST::Stmts.new());
    &lt;ident&gt; \n
    &lt;statementlist&gt;
    'end'
}
</code></pre>

<h2 id="updating-def-for-methods">Updating def for methods</h2>

<p>Methods are declared just like functions. Inside the scope of a class, a
function definition should be added to the surrounding class. The action
method for <code>def</code> can be updated as follows:</p>

<pre><code>method statement:sym&lt;def&gt;($/) {
    my $install := $&lt;defbody&gt;.ast;
    $*CUR_BLOCK[0].push(QAST::Op.new(
        :op('bind'),
        QAST::Var.new( :name($install.name), :scope('lexical'),
            :decl('var') ),
        $install
    ));
    if $*IN_CLASS {
        @*METHODS.push($install);
    }
    make QAST::Op.new( :op('null') );
}
</code></pre>

<p>That is, push the <code>QAST::Block</code> onto <code>@*METHODS</code> in a class.</p>

<h2 id="a-simple-meta-object">A simple meta-object</h2>

<p>The meta-object we wrote before is just about good enough. Here it is with a
couple of minor tweaks.</p>

<pre><code>class RubyishClassHOW {
    has $!name;
    has %!methods;

    method new_type(:$name!) {
        nqp::newtype(self.new(:$name), 'HashAttrStore')
    }

    method add_method($obj, $name, $code) {
        %!methods{$name} := $code;
    }

    method find_method($obj, $name) {
        %!methods{$name}
    }
}
</code></pre>

<h2 id="building-up-the-meta-object-1">Building up the meta-object (1)</h2>

<p>In Rubyish, we&rsquo;ll generate code that builds up the meta-object. First of all,
let&rsquo;s take care of the <code>classbody</code> action method.</p>

<pre><code>method classbody($/) {
    $*CUR_BLOCK.push($&lt;statementlist&gt;.ast);
    $*CUR_BLOCK.blocktype('immediate');
    make $*CUR_BLOCK;
}
</code></pre>

<p>Note how the <code>blocktype</code> is set to <code>immediate</code>, since we want code in the
class body to run as part of the program mainline.</p>

<h2 id="building-up-the-meta-object-2">Building up the meta-object (2)</h2>

<p>We mangle the name, then use <code>RubyishClassHOW</code> to create a new type object to
represent it. Note that <code>QAST::WVal</code> is a way to refer to an object; we&rsquo;ll see
much more on this later.</p>

<pre><code>method statement:sym&lt;class&gt;($/) {
    my $body_block  := $&lt;classbody&gt;.ast;
    my $class_stmts := QAST::Stmts.new( $body_block );
    my $ins_name    := '::' ~ $&lt;classbody&gt;&lt;ident&gt;;
    $class_stmts.push(QAST::Op.new(
        :op('bind'),
        QAST::Var.new( :name($ins_name), :scope('lexical'),
            :decl('var') ),
        QAST::Op.new(
            :op('callmethod'), :name('new_type'),
            QAST::WVal.new( :value(RubyishClassHOW) ),
            QAST::SVal.new( :value(~$&lt;classbody&gt;&lt;ident&gt;),
                :named('name') ) )
        ));

    # &lt;Method code comes here&gt;
    make $class_stmts;
}
</code></pre>

<h2 id="building-up-the-meta-object-3">Building up the meta-object (3)</h2>

<p>We also emit method calls to <code>add_method</code> to build up the method table for the
class. Recall that <code>QAST::BVal</code> lets us reference a <code>QAST::Block</code> that was
installed elsewhere in the tree.</p>

<pre><code>my $class_var := QAST::Var.new( :name($ins_name), :scope('lexical') );
for @*METHODS {
    $class_stmts.push(QAST::Op.new(
        :op('callmethod'), :name('add_method'),
        QAST::Op.new( :op('how'), $class_var ),
        $class_var,
        QAST::SVal.new( :value($_.name) ),
        QAST::BVal.new( :value($_) )));
}
</code></pre>

<p>And with that, we&rsquo;ve got classes and methods.</p>

<h2 id="the-new-keyword">The new keyword</h2>

<p>Parsing <code>new</code> is unsurprising (we skip constructor arguments):</p>

<pre><code>token term:sym&lt;new&gt; {
    'new' \h+ :s &lt;ident&gt; '(' ')'
}
</code></pre>

<p>The actions mangle the class name to look it up, and then use the <code>create</code> NQP
op to create an instance of it.</p>

<pre><code>method term:sym&lt;new&gt;($/) {
    make QAST::Op.new(
        :op('create'),
        QAST::Var.new( :name('::' ~ ~$&lt;ident&gt;), :scope('lexical') )
    );
}
</code></pre>

<h2 id="method-calls-1">Method calls (1)</h2>

<p>Last but not least, we need to parse method calls. These can be handled as a
kind of postfix, with a very tight precedence. First, we add the level:</p>

<pre><code>Rubyish::Grammar.O(':prec&lt;y=&gt;, :assoc&lt;unary&gt;', '%methodop');
</code></pre>

<p>And then the parsing, which is not too unlike how a function call was parsed.</p>

<pre><code>token postfix:sym&lt;.&gt;  {
    '.' &lt;ident&gt; '(' :s &lt;EXPR&gt;* % [ ',' ] ')'
    &lt;O('%methodop')&gt;
}
</code></pre>

<h2 id="method-calls-2">Method calls (2)</h2>

<p>The actions for a method call are relatively straightforward.</p>

<pre><code>method postfix:sym&lt;.&gt;($/) {
    my $meth_call := QAST::Op.new( :op('callmethod'), :name(~$&lt;ident&gt;) );
    for $&lt;EXPR&gt; {
        $meth_call.push($_.ast);
    }
    make $meth_call;
}
</code></pre>

<p>The key bit of &ldquo;magic&rdquo; that happens is that the <code>EXPR</code> action method will
unshift the term the postfix was applied to, meaning it becomes the first
child (and thus the invocant).</p>

<h2 id="exercise-7">Exercise 7</h2>

<p>In this exercise, you&rsquo;ll add basic support for classes and methods to PHPish.
This will involve:</p>

<ul>
<li>Writing a basic meta-object for a class with methods</li>
<li>Checking it works stand-alone</li>
<li>Adding parsing for classes, methods, new statements and method calls</li>
<li>Adding the relevant action methods to make things work</li>
</ul>

<p>See the exercise sheet for more information.</p>

<h2 id="stables">STables</h2>

<p>Each object has a meta-object and a representation. However, it does not point
directly to them. Instead, each object points to an <strong>s-table</strong>, short for
<strong>shared table</strong>.</p>

<p>STables <strong>represent a type</strong>, and exist per <code>HOW</code>/<code>REPR</code> combination. Here is
a cut-down version of the <code>MVMSTable</code> struct from MoarVM:</p>

<pre><code>struct MVMSTable {
    MVMREPROps *REPR;   /* The representation operation table. */
    MVMObject  *HOW;    /* The meta-object. */
    MVMObject  *WHAT;   /* The type-object. */
    MVMObject  *WHO;    /* The underlying package stash. */
    /* More... */
};
</code></pre>

<h2 id="representation-operations">Representation Operations</h2>

<p>The representation operations are broken down into:</p>

<ul>
<li><strong>Common things:</strong> creating a new type based on the representation, composing
that type (which may then compute a memory layout), allocation, cloning,
changing type (used for mixins), serialization and deserialization</li>
<li><strong>Boxing:</strong> for types that serve as boxes of native types (int/str/num),
get/set the boxed value</li>
<li><strong>Attributes:</strong> for types that can do storage of object attributes, get/bind
attribute values as well as compute access hints</li>
<li><strong>Positional:</strong> for types that provide array-like storage, get and bind by
index, push/pop/shift/unshift, splice, set elements</li>
<li><strong>Associative:</strong> for types that provide hash-like storage, get and bind by
key, exists by key, delete by key</li>
</ul>

<p>A representation can choose which of these it supports.</p>

<h2 id="common-representations">Common Representations</h2>

<p>The most common representations you&rsquo;ll encounter while working with NQP and
rakudo are:</p>

<pre><code>P6opaque            Opaque attribute storage; default in Perl 6
P6int               A native integer; flattens into a P6opaque
P6num               A native float; flattens into a P6opaque
P6str               A native string reference; flattens into a P6opaque
P6bigint            Big integer; flattens into a P6opaque
VMArray             Automatically resizing array, type-parametric
VMHash              Hash table
Uninstantiable      Type object only; used for module, role, etc.
</code></pre>

<h2 id="type-setup">Type setup</h2>

<p>The <code>nqp::newtype</code> operation is central to type creation. For example, here is
the <code>new_type</code> method from <code>NQPModuleHOW</code>. It creates a new meta-object, makes
a new type based upon it and the <code>Uninstantiable</code> representation, and gives it
an empty Hash as its stash.</p>

<pre><code>method new_type(:$name = '&lt;anon&gt;') {
    my $metaobj := self.new(:name($name));
    nqp::setwho(nqp::newtype($metaobj, 'Uninstantiable'), {});
}
</code></pre>

<p><code>nqp::newtype</code> creates a new type object and STable. It points the type object
at the STable, and the <code>WHAT</code> field of the STable back at the type object. It
then sets the <code>HOW</code> field of the STable to the specified meta-object, and the
<code>REPROps</code> to the operation table for <code>Uninstantiable</code>.</p>

<h2 id="type-composition">Type composition</h2>

<p>Various representations need types to go through a <strong>composition</strong> phase. For
others it is optional.</p>

<p>Representation composition typically happens at class composition time (which
is usually done at the point of the closing <code>}</code> of a class declaration). It is
when a meta-object has a chance to configure an underlying representation.</p>

<p>For example, <code>P6opaque</code> must be configured with the attributes that it should
compute a layout for.</p>

<pre><code># &lt;build attribute info array up into @repr_info&gt;
my %info := nqp::hash();
%info&lt;attribute&gt; := @repr_info;
nqp::composetype($obj, %info)
</code></pre>

<p><code>repr-compose-protocol.markdown</code> documents this in detail.</p>

<h2 id="method-caches">Method caches</h2>

<p>If every method call really involved a call to <code>find_method</code>, method dispatch
would be way too slow. Therefore, many types publish a <strong>method cache</strong>, which
is a hash table mapping a method name to the thing to call. Here it is done by
walking the method resolution order in reverse (so we get overrides correct).</p>

<pre><code>method publish_method_cache($obj) {
    my %cache;
    my @mro_reversed := reverse(@!mro);
    for @mro_reversed {
        for $_.HOW.method_table($_) {
            %cache{nqp::iterkey_s($_)} := nqp::iterval($_);
        }
    }
    nqp::setmethcache($obj, %cache);
    nqp::setmethcacheauth($obj, 1);
}
</code></pre>

<p>Method caches hang off an <code>STable</code>.</p>

<h2 id="authoritative-method-caches">Authoritative method caches</h2>

<p>We can choose if the method cache is authoritative or not:</p>

<pre><code>nqp::setmethcacheauth($obj, 0);     # Non-authoritative; default
nqp::setmethcacheauth($obj, 1);     # Authoritative
</code></pre>

<p>This really just controls what happens if the method in question is not found
in the method cache. In authoritative mode, the cache is taken as having the
complete set of methods. In non-authoritative mode, if the method is not found
in the cache, we fall back to calling <code>find_method</code>.</p>

<p>It&rsquo;s nice to have authoritative method caches when possible, since it can give
a fast answer to <code>nqp::can(...)</code>. However, any type that wants to do fallback
handling cannot have this. Rakudo decides on a type-by-type basis.</p>

<h2 id="type-checking">Type checking</h2>

<p>Type checks show up in many places in Perl 6:</p>

<pre><code>if $obj ~~ SomeType { ... }         # Explicit check
my SomeType $obj = ...;             # Variable assignment
sub foo(SomeType $obj) { ... }      # Parameter binding
</code></pre>

<p>These all eventually boil down to the same operation, <code>nqp::istype</code>. However,
there are many things that <code>SomeType</code> could be one of the many kinds of type:</p>

<pre><code>class SomeType { }              # Class type
role SomeType { }               # Role type
subset SomeType where { ... }   # Subset type
</code></pre>

<h2 id="left-side-knows-checks">Left-side-knows checks</h2>

<p>For some kinds of type, the object being checked has the answer. This is the
case with subtyping relationships.</p>

<pre><code>Int ~~ Mu           # Int knows it inherits from Mu
Block ~~ Callable   # Block knows it does Callable
</code></pre>

<p>These cases are handled by a <code>type_check</code> method.</p>

<pre><code>method type_check($obj, $checkee) {
    for self.mro($obj) {
        return 1 if $_ =:= $checkee;
        if nqp::can($_.HOW, 'role_typecheck_list') {
            for $_.HOW.role_typecheck_list($_) {
                return 1 if $_ =:= $checkee;
            }
        }
    }
    return 0;
}
</code></pre>

<h2 id="type-check-caches">Type check caches</h2>

<p>Once again, really iterating the MRO and the roles composed in at each level
would be really slow. Therefore, left-side-knows checks are typically handled
by the meta-object publishing a type-check cache.</p>

<pre><code>method publish_type_cache($obj) {
    my @tc;
    for self.mro($obj) {
        @tc.push($_);
        if nqp::can($_.HOW, 'role_typecheck_list') {
            for $_.HOW.role_typecheck_list($_) {
                @tc.push($_);
            }
        }
    }
    nqp::settypecache($obj, @tc)
}
</code></pre>

<h2 id="right-side-knows-checks-1">Right-side-knows checks (1)</h2>

<p>There are other kinds of type where it&rsquo;s the type that we&rsquo;re checking against
that needs to drive the checking. For example, subset types are this way:</p>

<pre><code>subset Even of Int where * % 2 == 0;
</code></pre>

<p>We need to invoke the code associated with the <code>Even</code> subset type as part of
the type check:</p>

<pre><code>say 11 ~~ Even    # False
say 42 ~~ Even    # True
</code></pre>

<h2 id="right-side-knows-checks-2">Right-side-knows checks (2)</h2>

<p>These kinds of type implement an <code>accepts_type</code> method. For example, here is
the one from Perl 6&rsquo;s <code>SubsetHOW</code>:</p>

<pre><code>method accepts_type($obj, $checkee) {
    nqp::istype($checkee, $!refinee) &amp;&amp;
        nqp::istrue($!refinement.ACCEPTS($checkee))
}
</code></pre>

<p>It must also set up the appropriate type check mode for this to work:</p>

<pre><code>nqp::settypecheckmode($type, 2)
</code></pre>

<h2 id="boolification">Boolification</h2>

<p>One relatively hot-path operation, it turns out, is deciding if an object will
evaluate to true or false in boolean context. The <code>nqp::istrue</code> operation is
used to test an object for truthiness. There&rsquo;s also an <code>nqp::isfalse</code>.</p>

<p>How an object boolifies is set through <code>nqp::setboolspec</code>, which takes a flag
from the list below and an optional code object.</p>

<pre><code>0   Call the specified code object, passing the object to test
1   Unbox as an int; non-zero is true
2   Unbox as a float; non-zero is true
3   Unbox as a string; non-empty is true
4   As above, but &quot;0&quot; is considered false
5   False if type object, true otherwise
6   Unbox or treat as a big integer; non-zero is true
7   For iterator objects; true if there are more items available
8   For VMArray/VMHash based objects; true if elems is non-zero
</code></pre>

<h2 id="invocation">Invocation</h2>

<p>There is also an invocation specification mechanism, which indicates what
happens if an object is invoked (called).</p>

<p>In Rakudo, and often in NQP too, we have code objects. These in turn hold a VM
level code object. When we invoke a code object, the invocation needs to be
forwarded to the contained code object.</p>

<p>Here&rsquo;s an example from NQP&rsquo;s setting:</p>

<pre><code>my knowhow NQPRoutine {
    has $!do;
    ...
}
nqp::setinvokespec(NQPRoutine, NQPRoutine, '$!do', nqp::null);
</code></pre>

<p>In Rakudo, see <code>Perl6::Metamodel::InvocationProtocol</code>.</p>

<h2 id="nqp-s-meta-objects">NQP&rsquo;s meta-objects</h2>

<p>NQP&rsquo;s meta-objects are all implemented using the <code>knowhow</code> meta-object. They
also cannot assume the presence of the NQP setting, meaning you&rsquo;ll find some
slightly odd code in there.</p>

<ul>
<li>The NQP iterator types for hashes that enable <code>.key</code> and <code>.value</code> methods
are not yet set up, so this code uses <code>nqp::iterkey_s</code> and <code>nqp::iterval</code>.</li>
<li>There is no <code>NQPMu</code> default for scalars to take yet, so an empty scalar will
be null; <code>nqp::isnull</code> is therefore used for often.</li>
</ul>

<p>Thankfully, your chances of needing to work on this code are fairly low. It&rsquo;s
also relatively compact; <code>NQPClassHOW</code>, the most complex meta-object, is only
around 800 lines of largely straightforward code.</p>

<h2 id="rakudo-s-meta-objects-overview">Rakudo&rsquo;s meta-objects: overview</h2>

<p>The story is much different in Rakudo. Rakudo&rsquo;s meta-objects are implemented
in terms of NQP&rsquo;s classes and roles. This means that inheritance and role
composition are available.</p>

<p>Therefore, while <strong>Rakudo&rsquo;s meta-objects must handle much more</strong> due to the
richness of the Perl 6 object system, they are <strong>very neatly factored</strong>.</p>

<p>There is <strong>a meta-object per declarator</strong> (so <code>class</code> maps to <code>ClassHOW</code>), and
a few extra bits for roles (which are rather complex to implement due to their
type parametricity).</p>

<p>However, much functionality is <strong>factored out into roles</strong>, which are re-used
amongst the different meta-objects.</p>

<h2 id="example-classhow">Example: ClassHOW</h2>

<p>Here are the roles that are done by <code>Perl6::Metamodel::ClassHOW</code>:</p>

<pre><code>Naming                      Documenting
Versioning                  Stashing
AttributeContainer          MethodContainer
PrivateMethodContainer      MultiMethodContainer
RoleContainer               MultipleInheritance
DefaultParent               C3MRO
MROBasedMethodDispatch      MROBasedTypeChecking
Trusting                    BUILDPLAN
Mixins                      ArrayType
BoolificationProtocol       REPRComposeProtocol
InvocationProtocol
</code></pre>

<p>Amongst the names, you&rsquo;ll recognize many Perl 6 features, as well as some of
the 6model concepts we&rsquo;ve covered in this section.</p>

<h2 id="example-enumhow">Example: EnumHOW</h2>

<p>If we look at <code>Perl6::Metamodel::EnumHOW</code>, we&rsquo;ll see that it re-uses a number
of these roles:</p>

<pre><code>Naming                      Stashing
AttributeContainer          MethodContainer
MultiMethodContainer        RoleContainer
MROBasedMethodDispatch      MROBasedTypeChecking
BUILDPLAN                   BoolificationProtocol
REPRComposeProtocol         InvocationProtocol
</code></pre>

<p>In fact, it has just one extra role that it composes:</p>

<pre><code>BaseType
</code></pre>

<p>The roles aside, <code>ClassHOW</code> is 250 lines of code, and <code>EnumHOW</code> about 150.
Thus, most interesting stuff lives in the roles.</p>

<h2 id="example-naming">Example: Naming</h2>

<p>Some of the roles are extremely simple. For example, all of the meta-objects
compose the <code>Naming</code> role, which simply provides two methods and a <code>$!name</code>
attribute:</p>

<pre><code>role Perl6::Metamodel::Naming {
    has $!name;
    method set_name($obj, $name) {
        $!name := $name
    }
    method name($obj) {
        $!name
    }
}
</code></pre>

<p>The role with most code is <code>C3MRO</code>, which computes the C3 method resolution
order. It&rsquo;s still only 150 lines of code, though. Takeaway: things are divided
into quite manageable pieces.</p>

<h2 id="example-grammarhow">Example: GrammarHOW</h2>

<p>This is the simplest meta-object:</p>

<pre><code>class Perl6::Metamodel::GrammarHOW
    is Perl6::Metamodel::ClassHOW
    does Perl6::Metamodel::DefaultParent
{
}
</code></pre>

<p>Essentially, a <code>grammar</code> does everything that a <code>class</code> does, but composes
the <code>DefaultParent</code> role so as to enable grammars to be configured with a
different default parent in <code>BOOTSTRAP</code>:</p>

<pre><code>Perl6::Metamodel::ClassHOW.set_default_parent_type(Any);
Perl6::Metamodel::GrammarHOW.set_default_parent_type(Grammar);
</code></pre>

<h2 id="container-handling">Container handling</h2>

<p>So far, we&rsquo;ve seen that a type can be given a boolification spec and an
invocation spec. There is one more of these: <strong>container spec</strong>. This is used
in implementing the <code>Scalar</code> container type in Perl 6.</p>

<p>Several operations relate to this:</p>

<pre><code>setcontspec         Configure a type as a scalar container type
iscont              Check if an object is a scalar container
decont              Get the value inside the container
assign              Assign a value into the container
assignunchecked     Assign, assuming no type-check needed
</code></pre>

<p>For example, Rakudo&rsquo;s <code>BOOTSTRAP</code> does:</p>

<pre><code>nqp::setcontspec(Scalar, 'rakudo_scalar', nqp::null());
</code></pre>

<h2 id="auto-decontainerization">Auto-decontainerization</h2>

<p>One may wonder why <code>nqp::decont</code> doesn&rsquo;t need to show up absolutely everywhere
in Perl 6. The answer is that a range of <code>nqp::op</code>s will automatically do a
<code>nqp::decont</code> operation for you.</p>

<p>One commonly encountered exception is that <strong>attribute access doesn&rsquo;t
decontainerize</strong>. This means <code>nqp::getattr</code> and friends may need an explicit
<code>nqp::decont</code> on their first argument.</p>

<pre><code>nqp::getattr(nqp::decont(@list.Parcel), Parcel, '$!storage')
</code></pre>

<p>However, since <code>self</code> is defined to always be decontainerized anyway, this
is not normally a problem.</p>

<h2 id="exercise-8">Exercise 8</h2>

<p>As time allows, extend the PHPish object system to have:</p>

<ul>
<li>A method cache (you may like to time if it makes a difference)</li>
<li>Single inheritance of classes (which will need updates to your method cache
code)</li>
<li>Interfaces (these will need a different meta-object, and you will need to
add a compose-time to the class, to check all named methods in the interface
are provided)</li>
</ul>

<p>As usual, the exercise sheet has more hints.</p>

<h1 id="bounded-serialization-and-module-loading">Bounded Serialization and Module Loading</h1>

<p><em>Let&rsquo;s save the World!</em></p>

<h2 id="a-problem">A problem</h2>

<p>When we built object support into Rubyish, we did so by emitting code to make
calls on the meta-objects. Doing this clearly has downsides for startup time.
In Perl 6, however, there are much more serious challenges to this approach.
Consider the following example:</p>

<pre><code>class ABoringExample {
    method yawn() { say &quot;This is at compile time!&quot;; }
}
BEGIN { ABoringExample.yawn }
</code></pre>

<p>A <code>BEGIN</code> block runs while we are compiling. Therefore, the type object and
meta-object for <code>ABoringExample</code> needs to be available at the point we run the
<code>BEGIN</code> block.</p>

<p>Also, this must work for user-defined meta-objects.</p>

<h2 id="this-problem-is-everywhere">This problem is everywhere</h2>

<p>A subroutine declaration produces a <code>Sub</code> object, which in turn refers to a
<code>Signature</code> object which in turn has <code>Parameter</code> objects inside of it.</p>

<p>All of these need constructing at compile time. Not only since we could call
the sub, but also because traits may need to mix into it:</p>

<pre><code>role StoredProcWrapper { has $.sp_name }
multi trait_mod:&lt;is&gt;(Routine:D $r, :sp_wrapper($sp_name)!) {
    $r does StoredProcName($sp_name)
}
# ...
sub LoadStuffAsObjects($id) is sp_wrapper('LoadStuff') {
    call_sp($id).map({ Stuff.new(|%($_)) })
}
</code></pre>

<h2 id="compile-time-vs-runtime">Compile-time vs. runtime</h2>

<p>The problem, in general, is that we need to be able to build up objects and
meta-objects at compile time, then refer to them at runtime. Moreover, this is
a very common case, so we need to do so efficiently.</p>

<p>That in itself wouldn&rsquo;t be too bad. However, module pre-compilation makes this
a good bit trickier: <strong>the objects created at compile time may need to cross a
process boundary</strong>, being saved to disk, then loaded at some future point.</p>

<p>This is where serialization contexts, bounded serialization and <code>World</code>s come
in to play.</p>

<h2 id="the-world">The World</h2>

<p>One concept our small <code>Rubyish</code> language lacked, but that both NQP and Rakudo
have, is a <code>World</code> class. While the <code>Actions</code> class is focused on QAST trees,
and thus the runtime semantics of a program, a <code>World</code> class is focused on
<strong>managing declarations and meta-objects</strong> during the compile.</p>

<p>A world always has a unique handle per compilation unit. This may be based on
the original source text, such as in Rakudo.</p>

<pre><code>my $file := nqp::getlexdyn('$?FILES');
my $source_id := nqp::sha1(
    nqp::defined(%*COMPILING&lt;%?OPTIONS&gt;&lt;outer_ctx&gt;)
        ?? self.target() ~ $sc_id++                 # REPL/eval case
        !! self.target());                          # Common case
my $*W := Perl6::World.new(:handle($source_id), :description($file));
</code></pre>

<h2 id="serialization-contexts">Serialization contexts</h2>

<p>The key data structure at the heart of compile-time/runtime object exchange is
a <strong>serialization context</strong>. Really, a serialization context is just three
arrays, one each for:</p>

<ul>
<li><strong>Objects:</strong> any 6model object can appear in this list, though it only makes
sense to put those that are sensible to serialize in there</li>
<li><strong>Code objects:</strong> VM-level code objects that objects in the serialization
context may refer to (or refer to through indirectly, due to a closure
cloning)</li>
<li><strong>STables:</strong> the existence of this array is an implementation detail, and
its contents are never directly manipulated outside of VM-specific code, so
you can forget about it</li>
</ul>

<p>There is one <code>World</code> per compilation unit, and a <code>World</code> in turn holds a
serialization context. In fact, the <code>handle</code> given to <code>World.new(...)</code> is
actually used for the SC.</p>

<h2 id="placing-objects-in-a-serialization-context">Placing objects in a serialization context</h2>

<p>Both <code>NQP::World</code> and <code>Perl6::World</code> inherit from <code>HLL::World</code>. It includes a
method named <code>add_object</code>, which adds an object into the serialization context
for the current compilation unit. Here is how it is used in <code>NQP::World</code>, for
example:</p>

<pre><code>method pkg_create_mo($how, :$name, :$repr) {
    my %args;
    if nqp::defined($name) { %args&lt;name&gt; := $name; }
    if nqp::defined($repr) { %args&lt;repr&gt; := $repr; }
    my $type_obj := $how.new_type(|%args);
    self.add_object($type_obj);
    return $type_obj;
}
</code></pre>

<h2 id="referencing-objects-in-a-serialization-context">Referencing objects in a serialization context</h2>

<p>Any object that is in a serialization context - either the one currently being
compiled or from one in another module or setting - can be referenced using
the <code>QAST::WVal</code> node type.</p>

<p>For example, here is a utility method from <code>Perl6::World</code>:</p>

<pre><code>method add_constant_folded_result($r) {
    self.add_object($r);
    QAST::WVal.new( :value($r) )
}
</code></pre>

<p>The <code>W</code> in <code>QAST::WVal</code> means &ldquo;World&rdquo;, which should make a little more sense
now than it did when we encountered it previously. <code>:-)</code></p>

<h2 id="serialization">Serialization</h2>

<p>The compiler toolchain knows if the eventual target is to run code in-process
or generate bytecode to write to disk.</p>

<p>In the first case, it&rsquo;s easy: we just make sure it is possible to see the
serialization context from the running code, and compile a <code>QAST::WVal</code> to
index into it.</p>

<p>The second case requires serializing all the objects in the serialization
context, and in turn serializing the objects that they point to, traversing
the object graph as needed.</p>

<p>They are dumped to a binary serialization format, documented in the NQP
repository.</p>

<h2 id="what-s-bounded-about-it">What&rsquo;s &ldquo;bounded&rdquo; about it</h2>

<p>Consider pre-compiling the following module:</p>

<pre><code>class Cache is Hash {
    has &amp;!computer;
    submethod BUILD(:&amp;!computer!) { }
    method at_key($key) is rw {
        callsame() //= &amp;!computer($key)
    }
}
</code></pre>

<p>Here, <code>Hash</code> comes from Perl 6&rsquo;s <code>CORE.setting</code>. Clearly, we will encounter
this type in the <code>@!parents</code> of the meta-object for <code>Cache</code>. However, we do
not want to re-serialize the <code>Hash</code> type!</p>

<p>When an object is already owned by another SC, we just write a reference to
it. <strong>Ownership is the boundary of a compilation unit&rsquo;s serialization.</strong></p>

<h2 id="deserialization-and-fixups">Deserialization and fixups</h2>

<p>The opposite of serialization is deserialization. This involves taking the
binary blob representing objects and STables and recreating the objects from
it.</p>

<p>In doing this, all references to objects from other serialization contexts must
be resolved. This means that they must have been loaded first. This implies
that a module&rsquo;s dependencies must be loaded before it can be deserialized.</p>

<p>For this reason, <code>HLL::World</code> has an <code>add_load_dependency_task</code>, for adding
code (specified as QAST) to execute before deserialization takes place.</p>

<p>There is also an <code>add_fixup_task</code>, which enables registration of code to run
after deserialization has taken place.</p>

<h2 id="another-tricky-problem">Another tricky problem</h2>

<p>One tricky issue is what happens if you try to pre-compile a module containing
the following:</p>

<pre><code># Ooh! Let's pretend we're Ruby!
augment class Int {
    method times(&amp;block) {
        for ^self { block($_) }
    }
}
</code></pre>

<p>The <code>Int</code> meta-object and STable are serialized in <code>CORE.setting</code>. But here,
another module is modifying the meta-object, and the updated method cache is
hung off the <code>STable</code>, meaning it too has changed.</p>

<p>So what do we do?</p>

<h2 id="repossession">Repossession</h2>

<p>When an object that belongs to a serialization context, we&rsquo;re at compile time,
and the serialization context it belongs to is not one we&rsquo;re currently in the
process of compiling, a write barrier is triggered.</p>

<p>This switches the ownership of the object to the serialization context of the
compilation unit we&rsquo;re currently compiling. It also records that this happened.</p>

<p>At serialization, the updated version of the object is serialized.</p>

<p>At deserialization, the object to update is located and then overwritten with
the new version of it.</p>

<h2 id="repossession-conflicts">Repossession conflicts</h2>

<p>This leaves just one more issue: what happens if you load two pre-compiled
modules that both want to augment the same class?</p>

<p>Once, &ldquo;latest won&rdquo;. Thankfully, today this is detected as a repossession
conflict, the resulting exception indicating two modules were loaded that may
not be used together.</p>

<p>This should have been the end of the story. But it&rsquo;s not. It turns out that
<code>Stash</code> objects started to conflict in interesting ways, when modules used
nested packages. Therefore, there is now a conflict resolution mechanism that
looks at the objects in conflict and tries to merge them. For <code>Stash</code>, that is
easy enough.</p>

<h2 id="sc-write-barrier-control">SC write barrier control</h2>

<p>Most of the <code>nqp::ops</code> related to serialization contexts are rarely seen,
hidden away in <code>HLL::World</code>. However, two of them escape into regular code:</p>

<ul>
<li><strong><code>nqp::scwbdisable</code></strong> disables the repossession detection write barrier,
meaning that any changes done to an owned object will not cause it to be
re-serialized. This is often done by meta-objects that want to keep caches.</li>
<li><strong><code>nqp::scwbenable</code></strong> re-enables repossession detection.</li>
</ul>

<p>Note that this isn&rsquo;t a binary flag, but rather a counter that is incremented
by the first op and decremented by the second. Repossession detection happens
only when the counter is at zero.</p>

<h2 id="accidental-repossession">Accidental Repossession</h2>

<p>It&rsquo;s important to keep repossession in mind when working on Rakudo and NQP, as
it can sometimes kick in when you might not have expected it.</p>

<p>For example, in Rakudo&rsquo;s CORE.setting, you&rsquo;ll find a <code>BEGIN</code> block that looks
like this:</p>

<pre><code>BEGIN {
    my Mu $methodcall     := nqp::hash('prec', 'y=');
    ...
    trait_mod:&lt;is&gt;(&amp;postfix:&lt;i&gt;, :prec($methodcall));
    ...
}
</code></pre>

<p>If this were done in the setting mainline, it would cause a change to the
<code>postfix:&lt;i&gt;</code> serialized in the CORE setting, which could as a result cause a
repossession of this by whatever compilation unit triggers setting loading.</p>

<h2 id="qast-compunit-revisited">QAST::CompUnit, revisited</h2>

<p>The various pieces assembled by the World are passed down to the backend using
<code>QAST::CompUnit</code>.</p>

<pre><code>my $compunit := QAST::CompUnit.new(
    :hll('perl6'),
    :sc($*W.sc()),
    :code_ref_blocks($*W.code_ref_blocks()),
    :compilation_mode($*W.is_precompilation_mode()),
    :pre_deserialize($*W.load_dependency_tasks()),
    :post_deserialize($*W.fixup_tasks()),
    :repo_conflict_resolver(QAST::Op.new(
        :op('callmethod'), :name('resolve_repossession_conflicts'),
        QAST::Op.new(
            :op('getcurhllsym'),
            QAST::SVal.new( :value('ModuleLoader') )
        )
    )),
    ...);
</code></pre>

<h2 id="how-module-loading-works-1">How module loading works (1)</h2>

<p>When a <code>use</code> statement is encountered in Perl 6 code:</p>

<pre><code>use Term::ANSIColor;
</code></pre>

<p>The module name is parsed, any adverbs extracted (such as <code>:from</code>) and then
control is passed on to the <code>load_module</code> method in <code>Perl6::World</code>:</p>

<pre><code>my $lnd    := $*W.dissect_longname($longname);
my $name   := $lnd.name;
my %cp     := $lnd.colonpairs_hash('use');
my $module := $*W.load_module($/, $name, %cp, $*GLOBALish);
</code></pre>

<h2 id="how-module-loading-works-2">How module loading works (2)</h2>

<p>This <code>load_module</code> method first delegates to <code>Perl6::ModuleLoader</code> to load the
module right away (required as it will probably introduce types or do other
changes that we need to continue parsing). Once the module is loaded, it also
registers a load dependency task to make sure the module is loaded if we are
in a pre-compiled situation before deserialization takes place.</p>

<pre><code>method load_module($/, $module_name, %opts, $cur_GLOBALish) {
    my $line   := HLL::Compiler.lineof($/.orig, $/.from, :cache(1));
    my $module := Perl6::ModuleLoader.load_module($module_name, %opts,
        $cur_GLOBALish, :$line);

    if self.is_precompilation_mode() {
        self.add_load_dependency_task(:deserialize_past(...));
    }

    return $module;
}
</code></pre>

<h2 id="how-module-loading-works-3">How module loading works (3)</h2>

<p>Inside <code>Perl6::ModuleLoader</code>, some work is done to locate where the module is
on disk. If it exists in a pre-compiled form, the <code>nqp::loadbytecode</code> op is
used to load it. Otherwise, the source is slurped from disk and compiled.</p>

<p>Loading a pre-compiled module automatically triggers its deserialization.</p>

<p>A couple of odd lines that are executed on both code paths deserve some
explanation, however:</p>

<pre><code>my $*CTXSAVE := self;
my $*MAIN_CTX;
nqp::loadbytecode(%chosen&lt;load&gt;);
%modules_loaded{%chosen&lt;key&gt;} := $module_ctx := $*MAIN_CTX;
</code></pre>

<h2 id="how-module-loading-works-4">How module loading works (4)</h2>

<p>When the mainline of the module is run, its lexical scope is captured by some
code equivalent to:</p>

<pre><code>if $*CTXSAVE &amp;&amp; nqp::can($*CTXSAVE, 'ctxsave') {
    $*CTXSAVE.ctxsave();
}
</code></pre>

<p>The ModuleLoader has such a method:</p>

<pre><code>method ctxsave() {
    $*MAIN_CTX := nqp::ctxcaller(nqp::ctx());
    $*CTXSAVE := 0;
}
</code></pre>

<p>This is how the <code>UNIT</code> (outer lexical scope) of a module being loaded is
obtained. This is in turn used to locate <code>EXPORT</code>.</p>

<h2 id="how-module-loading-works-5">How module loading works (5)</h2>

<p>Finally, <code>ModuleLoader</code> triggers global merging. This involves taking the
symbols the module wishes to contribute to <code>GLOBAL</code> and incorporating them
into the current view of <code>GLOBAL</code>.</p>

<p>If this sounds strange, note that Perl 6 has separate compilation, meaning all
modules start out with a completely clean and empty view of <code>GLOBAL</code>. These
views are reconciled (and conflicts whined about) as modules are loaded.</p>

<p>Finally, the <code>UNIT</code> lexpad is returned.</p>

<pre><code>my $UNIT := nqp::ctxlexpad($module_ctx);
if +@GLOBALish {
    unless nqp::isnull($UNIT&lt;GLOBALish&gt;) {
        merge_globals(@GLOBALish[0], $UNIT&lt;GLOBALish&gt;);
    }
}
return $UNIT;
</code></pre>

<h2 id="how-module-loading-works-6">How module loading works (6)</h2>

<p>What we have seen so far is what a <code>need</code> would do. A <code>use</code> then goes on to
import. This is not implemented in the module loader, but rather lives in the
<code>import</code> method in <code>Perl6::World</code>.</p>

<p>It does the following things:</p>

<ul>
<li>Locates the symbols that need to be imported</li>
<li>If there are multiple dispatch candidates exported and there also exist some
in the target scope, merges the candidate lists</li>
<li>For other symbols, installs them directly into the target scope, complaining
if there is a conflict</li>
<li>If any operators are imported, makes sure the current language is augmented
so as to be able to parse them</li>
</ul>

<h1 id="the-regex-and-grammar-engine">The regex and grammar engine</h1>

<p><em>Inside how Perl 6 is parsed</em></p>

<h2 id="the-pieces-involved">The pieces involved</h2>

<p>Regex and grammar handling involves a number of components:</p>

<ul>
<li>The <strong>Perl 6 Regex grammar/actions</strong>, from <code>src/QRegex/P6Regex</code>, which parse
the Perl 6 regex syntax and produce a QAST tree from it. These are not used
directly by NQP and Rakudo, but instead subclassed (so, for example, nested
code blocks will be parsed in the correct main language)</li>
<li>The <strong><code>QAST::Regex</code></strong> QAST node, which represents the whole range of regex
constructs we can compile</li>
<li><strong><code>Cursor</code> objects</strong>, which keep state as we parse</li>
<li><strong><code>Match</code> objects</strong>, which represent the result of a parse</li>
<li><strong>NFA construction and evaluation</strong>, used for Longest Token Matching</li>
</ul>

<h2 id="the-qast-regex-node">The QAST::Regex node</h2>

<p>This node covers all of the regex constructs. It has an <strong><code>rxtype</code></strong> property
that is used to indicate the kind of regex operation to perform.</p>

<p>It can be placed at any point in a QAST tree, though typically expects to find
itself inside of a <code>QAST::Block</code>. Furthermore, it expects the lexical <code>$¢</code> to
have been declared.</p>

<p>With a few exceptions, once you reach a <code>QAST::Regex</code> node, the QAST compiler
will expect to find only other <code>QAST::Regex</code> nodes beneath it. There is an
explicit <code>qastnode</code> rxtype for escaping back to the rest of QAST.</p>

<p>We&rsquo;ll now study the rxtypes available.</p>

<h2 id="literal">literal</h2>

<p>The <code>literal</code> rxtype indicates a literal string that should be matched in
a regex. The string to match is passed as a child to the node.</p>

<pre><code>QAST::Regex.new( :rxtype&lt;literal&gt;, 'meerkat' )
</code></pre>

<p>It has one subtype, <code>ignorecase</code>, which makes matching of the literal be case
insensitive.</p>

<pre><code>QAST::Regex.new( :rxtype&lt;literal&gt;, :subtype&lt;ignorecase&gt;, 'meerkat' )
</code></pre>

<h2 id="concat">concat</h2>

<p>The <code>concat</code> subtype is used to match a sequence of <code>QAST::Regex</code> nodes one
after the other. It expects these nodes as its children.</p>

<p>This will do the same as the previous slide, though will be a little less
efficient:</p>

<pre><code>QAST::Regex.new(
    :rxtype&lt;concat&gt;,
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'meer' ),
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'kat' )
)
</code></pre>

<h2 id="scan-and-pass">scan and pass</h2>

<p>Regexes tend to start with a <code>scan</code> node and end with a <code>pass</code> node.</p>

<ul>
<li><strong><code>scan</code></strong> will generate code to work through the string, trying to match
the pattern at each offset, until either a match is successful or it runs
out of string to try. This is what makes <code>'slaughter' ~~ /laughter/</code> match,
even though <code>laughter</code> is not at the start of the string. Note it will only
do this if the match is not anchored (which it will be if called by another
rule).</li>
<li><strong><code>pass</code></strong> will generate a call to <code>!cursor_pass</code> on the current <code>Cursor</code>
object, indicating that the regex has matched. For named regexes, tokens and
rules, this node conveys the name of the action method to invoke also.</li>
</ul>

<h2 id="a-simple-example">A simple example</h2>

<p>If we give NQP the following regex:</p>

<pre><code>/meerkat/
</code></pre>

<p>And use <code>--target=ast</code>, the resulting <code>QAST::Regex</code> nodes contain all of the
things we have covered so far:</p>

<pre><code>- QAST::Regex(:rxtype(concat))
  - QAST::Regex(:rxtype(scan))
  - QAST::Regex(:rxtype(concat)) meerkat
    - QAST::Regex(:rxtype(literal)) meerkat
      - meerkat
  - QAST::Regex(:rxtype(pass))
</code></pre>

<h2 id="cclass">cclass</h2>

<p>Used for the various common built-in character classes, typically expressed
through backslash sequences. For example, <code>\d</code> and <code>\W</code> respectively become:</p>

<pre><code>QAST::Regex.new( :rxtype&lt;cclass&gt;, :name&lt;d&gt; )
QAST::Regex.new( :rxtype&lt;cclass&gt;, :name&lt;w&gt;, :negate(1) )
</code></pre>

<p>The available values for <code>name</code> are as follows:</p>

<pre><code>Code    Meaning
.       Any character (really, any)
d       Any numeric character (Unicode aware)
s       Any whitespace character (Unicode aware)
w       Any word character or the underscore (Unicode aware)
n       A literal \n, a \r\n sequence, or a Unicode LINE_SEPARATOR
</code></pre>

<h2 id="enumcharlist">enumcharlist</h2>

<p>Used for user-defiend character classes. Requires that the current character
class be any of those specified in the child string.</p>

<p>For example, <code>\v</code> (which matches any vertical whitespace character) compiles
into:</p>

<pre><code>QAST::Regex.new(
    :rxtype&lt;enumcharlist&gt;,
    &quot;\x[0a,0b,0c,0d,85,2028,2029]&quot;
)
</code></pre>

<h2 id="enumcharlist-and-user-defined-character-classes">enumcharlist and user defined character classes</h2>

<p>The <code>enumcharlist</code> node is also used in things like:</p>

<pre><code>/&lt;[A..Z]&gt;/
</code></pre>

<p>Which, as <code>--target=ast</code> shows, becomes:</p>

<pre><code>- QAST::Regex(:rxtype(concat))
  - QAST::Regex(:rxtype(scan))
  - QAST::Regex(:rxtype(concat)) &lt;[A..Z]&gt;
    - QAST::Regex(:rxtype(enumcharlist)) [A..Z]
      - ABCDEFGHIJKLMNOPQRSTUVWXYZ
  - QAST::Regex(:rxtype(pass))
</code></pre>

<h2 id="anchor">anchor</h2>

<p>Used for various zero-width assertions. For example, <code>^</code> (start of string)
compiles into:</p>

<pre><code>QAST::Regex.new( :rxtype&lt;anchor&gt;, :subtype&lt;bos&gt; )
</code></pre>

<p>The available subtypes are:</p>

<pre><code>bos     Beginning of string (^)
eos     End of string ($)
bol     Beginning of line (^^)
eol     End of line ($$)
lwb     Left word boundary (&lt;&lt;)
rwb     Right word boundary (&gt;&gt;)
fail    Always fails
pass    Always passes
</code></pre>

<h2 id="quant">quant</h2>

<p>Used for quantifiers. The <code>min</code> and <code>max</code> properties are used to indicate how
many types the child node may match. A <code>max</code> of <code>-1</code> means &ldquo;unlimited&rdquo;. Thus,
the regex <code>\d+</code> compiles into:</p>

<pre><code>QAST::Regex.new(
    :rxtype&lt;quant&gt;, :min(1), :max(-1),
    QAST::Regex.new( :rxtype&lt;concat&gt;, :name&lt;d&gt; )
)
</code></pre>

<p>The <code>backtrack</code> property can also be set to one of:</p>

<pre><code>g       Greedy matching (\d+!, the default)
f       Frugal (minimal) matching (\d+?)
r       Ratchet (non-backtracking) matching (\d+:)
</code></pre>

<h2 id="altseq">altseq</h2>

<p>Tries to match its children in order, until it finds one that matches. This
provides <code>||</code> semantics in Perl 6, which are the same as <code>|</code> semantics in Perl
5. Thus:</p>

<pre><code>the || them
</code></pre>

<p>Compiles into:</p>

<pre><code>QAST::Regex.new(
    :rxtype&lt;altseq&gt;,
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'the' ),
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'them' )
)
</code></pre>

<p>There is also <code>conjseq</code> for Perl 6&rsquo;s <code>&amp;&amp;</code>.</p>

<h2 id="alt">alt</h2>

<p>Support Perl 6 LTM-based alternation. The regex:</p>

<pre><code>the | them
</code></pre>

<p>Compiles into:</p>

<pre><code>QAST::Regex.new(
    :rxtype&lt;alt&gt;,
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'the' ),
    QAST::Regex.new( :rxtype&lt;literal&gt;, 'them' )
)
</code></pre>

<p>This will always match <code>them</code> if it can, because it goes for the branch with
the longest declarative prefix first.</p>

<h2 id="subrule-1">subrule (1)</h2>

<p>Used to call another rule, optionally capturing. For example:</p>

<pre><code>&lt;ident&gt;
</code></pre>

<p>Will compile into:</p>

<pre><code>QAST::Regex.new(
    :rxtype&lt;subrule&gt;, :subtype&lt;capture&gt;, :name&lt;ident&gt;,
    QAST::Node.new( QAST::SVal.new( :value('ident') ) )
)
</code></pre>

<p>The <code>name</code> property is the name to capture as, while the <code>QAST::SVal</code> node is
taken as the name of the method to call. Extra children may be given to the
<code>QAST::Node</code>, which will be taken as arguments for the call.</p>

<h2 id="subrule-2">subrule (2)</h2>

<p>There are a few other things worth noting about subrule. First, it need not
capture. For example:</p>

<pre><code>&lt;.ws&gt;
</code></pre>

<p>Will compile into:</p>

<pre><code>QAST::Regex.new(
    :rxtype&lt;subrule&gt;, :subtype&lt;method&gt;,
    QAST::Node.new( QAST::SVal.new( :value('ws') ) )
)
</code></pre>

<h2 id="subrule-3">subrule (3)</h2>

<p>The <code>subrule</code> rxtype is also capable of handling zero-width assertions. For
example:</p>

<pre><code>&lt;?alpha&gt;
</code></pre>

<p>Will compile into:</p>

<pre><code>QAST::Regex.new(
    :rxtype&lt;subrule&gt;, :subtype&lt;zerowidth&gt;,
    QAST::Node.new( QAST::SVal.new( :value('alpha') ) )
)
</code></pre>

<h2 id="subrule-4">subrule (4)</h2>

<p>Finally, there are two other properties that apply to <code>subrule</code>:</p>

<ul>
<li><strong><code>backtrack</code></strong> being set to <code>r</code> will prevent the subrule call being
backtracked into. This is set in <code>token</code> and <code>rule</code>, and avoids keeping a
lot of state around.</li>
<li><strong><code>negate</code></strong> can also be set on this node. It is probably most useful in
combination with the <code>zerowidth</code> subtype, since that is how <code>&lt;!alpha&gt;</code> is
compiled.</li>
</ul>

<p>Last but not least, <code>subrule</code> is also used for positional captures. Instead of
specifying a method to call, the contents of the capture is compiled inside a
nested <code>QAST::Block</code> and that is called. This is to make sure positional
matches get their own <code>Match</code> object.</p>

<h2 id="subcapture">subcapture</h2>

<p>This is used for implementing named captures that are not subrules. That is:</p>

<pre><code>$&lt;num&gt;=[\d+]
</code></pre>

<p>Will compile into:</p>

<pre><code>QAST::Regex.new(
    :rx&lt;subcapture&gt;, :name&lt;num&gt;,
    QAST::Regex.new(
        :rxtype&lt;quant&gt;, :min(1), :max(-1),
        QAST::Regex.new(
            :rxtype&lt;cclass&gt;, :name&lt;d&gt;
        )
    )
)
</code></pre>

<h2 id="cursor">Cursor</h2>

<p>A <code>Cursor</code> is an object that <strong>holds the current state of a match</strong>. <code>Cursor</code>s
are created at the point of entry to a <code>token</code>/<code>rule</code>/<code>regex</code>, and either pass
or fail. From that point on, a <code>Cursor</code> is immutable.</p>

<p>The state inside a <code>Cursor</code> includes:</p>

<ul>
<li>The target string</li>
<li>The position we&rsquo;re matching from in the current rule (-1 indicates scan)</li>
<li>The current position reached by the match</li>
<li>A stack of backtrack marks (more later)</li>
<li>A stack of captured cursors (more later)</li>
<li>Potentially, a cached <code>Match</code> object produced from the <code>Cursor</code></li>
<li>For a passed <code>Cursor</code> that we may backtrack into later, the code object to
invoke to restart matching</li>
</ul>

<h2 id="nqpcursorrole">NQPCursorRole</h2>

<p>Both NQP and Rakudo have their own cursor objects, named <code>NQPCursor</code> and
<code>Cursor</code> respectively. However, they both compose <code>NQPCursorRole</code>, which
provides most of their methods.</p>

<p>The methods can be categorized as follows:</p>

<ul>
<li>Common introspection methods: <code>orig</code>, <code>target</code>, <code>from</code> and <code>pos</code></li>
<li>Built-in rules: <code>before</code>, <code>after</code>, <code>ws</code>, <code>ww</code>, <code>wb</code>, <code>ident</code>, <code>alpha</code>,
<code>alnum</code>, <code>upper</code>, <code>lower</code>, <code>digit</code>, <code>xdigit</code>, <code>space</code>, <code>blank</code>, <code>cntrl</code>,
<code>punct</code></li>
<li>Infrastructure methods: all have a name starting with a <code>!</code> and are called
mostly by code generated from compiling <code>QAST::Regex</code> nodes or as part of
implementing the built-in rules</li>
</ul>

<h2 id="it-starts-with-cursor-init">It starts with !cursor_init</h2>

<p>Parsing a grammar or matching a string against a regex always starts with a
call to <code>!cursor_init</code>, which creates a <code>Cursor</code> and initializes it with the
target string, setting up options (such as whether to scan or not).</p>

<p>For example, here is how <code>NQPCursor</code>&rsquo;s <code>parse</code> method is implemented:</p>

<pre><code>method parse($target, :$rule = 'TOP', :$actions, *%options) {
    my $*ACTIONS := $actions;
    my $cur := self.'!cursor_init'($target, |%options);
    nqp::isinvokable($rule) ??
        $rule($cur).MATCH() !!
        nqp::findmethod($cur, $rule)($cur).MATCH()
}
</code></pre>

<h2 id="inside-a-rule-1">Inside a rule (1)</h2>

<p>The first thing that happens on entry to a <code>token</code>, <code>rule</code> or <code>regex</code> is the
creation of a new <code>Cursor</code> to track its work. This is done by calling the
<code>!cursor_start_all</code> method, which returns an array of state, including:</p>

<ul>
<li>The newly created <code>Cursor</code></li>
<li>The target string</li>
<li>The position to start matching from (-1 indicates scan)</li>
<li>The current <code>Cursor</code> type (generic <code>$?CLASS</code>)</li>
<li>The backtracking mark stack</li>
<li>A restart flag: 1 if it is a restart, 0 otherwise</li>
</ul>

<p>Aside: this exact factoring will likely change in the future, for performance
reasons.</p>

<h2 id="inside-a-rule-2">Inside a rule (2)</h2>

<p>The <code>Cursor</code> returned by <code>!cursor_start_all</code> may have various methods call on
it as a match proceeds:</p>

<ul>
<li><strong><code>!cursor_start_subcapture</code></strong> to produce a <code>Cursor</code> that will represent a
sub-capture</li>
<li><strong><code>!cursor_capture</code></strong> pushes a <code>Cursor</code> onto the capture stack (either one
returned by calling a subrule or one created for a subcapture)</li>
<li><strong><code>!cursor_pos</code></strong> updates the match position in the <code>Cursor</code> (it&rsquo;s only
synchronized when needed)</li>
<li><strong><code>!cursor_pass</code></strong> if the match is successful; the position reached must be
passed, and if it is a named regex then the name can be passed; this also
triggers a call to an action method</li>
<li><strong><code>!cursor_fail</code></strong> if the match fails</li>
</ul>

<h2 id="inside-a-rule-3">Inside a rule (3)</h2>

<p>Once a <code>token</code>, <code>rule</code> or <code>regex</code> has finished matching, either passing or
failing, it should return the <code>Cursor</code> that it worked against.</p>

<p>In fact, this is the protocol: anything that is called as a <code>subrule</code> should
return a <code>Cursor</code> to its caller. Failing to do so will cause an error.</p>

<p>At the point a <code>Cursor</code> is failed, any backtracking and capture state will be
discarded. If it passes, but can not be backtracked in to, then backtracking
state can be thrown away too.</p>

<h2 id="the-cstack-and-capturing">The cstack and capturing</h2>

<p>The <code>cstack</code> (either <strong>Capture stack</strong> or <strong>Cursor stack</strong>) is where <code>Cursor</code>
objects that correspond to captures (positional or named) are stored. It may
also be used to store non-captured <code>Cursor</code>s for subrules we could backtrack
in to.</p>

<p>In something like:</p>

<pre><code>token xblock {
    &lt;EXPR&gt; &lt;.ws&gt; &lt;pblock&gt;
}
</code></pre>

<p>The <code>cstack</code> will end up with two <code>Cursor</code>s on it by the end of the match: one
returned by the call to <code>EXPR</code> and another returned by the call to <code>pblock</code>.</p>

<h2 id="the-bstack-and-backtracking">The bstack and backtracking</h2>

<p>The <code>bstack</code> is a stack of integers. Each &ldquo;mark&rdquo; actually consists of four
integers (so it only makes sense to talk about groups of 4 entries, not the
individual integers):</p>

<ul>
<li>The location in the regex to jump back to (typically interpreted by a jump
table); if 0, then the backtracker should just go on looking at the next
entry</li>
<li>The position in the string to go back to</li>
<li>Optionally, a repetition count (used by quantifiers)</li>
<li>The height of the <code>cstack</code> at the point the mark was made. This is used to
throw away any captures that we backtrack over.</li>
</ul>

<h2 id="match-object-production">Match object production</h2>

<p>The <code>MATCH</code> method on a <code>Cursor</code> or <code>NQPCursor</code> takes the <code>Cursor</code> and makes a
<code>Match</code> or <code>NQPMatch</code> object. These are the things our action methods were
passed as their <code>$/</code> argument.</p>

<p>They are produced by looking at the <code>cstack</code>, observing the names of each of
the entries, and building up an array of positional captures and a hash of
named captures. Positional captures just have an integer name.</p>

<p>Any capture qauntified with <code>*</code>, <code>+</code> or <code>**</code> will produce an array of captured
results.</p>

<p>Most of this work is factored out by <code>CAPHASH</code> from <code>NQPCursorRole</code>.</p>

<h2 id="longest-token-matching">Longest Token Matching</h2>

<p>All of this leaves one important regex related topic: Longest Token Matching.
We&rsquo;ve already seen it in action, but now we&rsquo;ll take a few moments to consider
how it works.</p>

<p>Every regex or branch alternation has a (possibly zero-length) declarative
prefix. It covers the region from the start of a regex up to a construct that
is deemed imperative (such as a code block, positive lookahead, etc.)</p>

<pre><code>token even { \d+ { +$/ % 2 == 0 } }
             DDD IIIIIIIIIIIIIIII
</code></pre>

<p>The declarative prefix always forms a <strong>regular language</strong>, and as a result
can be translated into a <strong>finite automata</strong>.</p>

<h2 id="nfa-fragments">NFA fragments</h2>

<p>Once an individual <code>token</code>, <code>rule</code> or <code>regex</code> has been compiled to QAST, the
QAST tree is passed to <strong><code>QRegex::NFA</code></strong>.</p>

<p>This explores the QAST, identifies the declarative prefix, and builds an
NFA (Non-deterministic Finite Automata) out of it.</p>

<p>If the QAST tree contains any alternations, then each branch of these also
has an NFA build and stored.</p>

<p>At this point, the NFAs are not ready to evaluate. Whenever there is a subrule
call, they simply name the call. In that sense, they are <strong>generic with regard
to the grammar as a whole</strong>, and may need to be made concrete many times (due
to grammar inheritance).</p>

<h2 id="protoregex-and-alternation-nfas">Protoregex and alternation NFAs</h2>

<p>A protoregex decides which candidate to call by building an NFA representing
the alternation of all the candidate NFAs.</p>

<p>This protoregex NFA is always specific to a particular type of grammar. As a
part of producing it, any subrule calls have their NFA substituted in for the
call.</p>

<p>Alternations go through a similar process, except this time the NFA is built
up out of the NFAs of the branches.</p>

<p>The result of either of these is an NFA that can be executed against a target
string.</p>

<h2 id="nfa-execution">NFA execution</h2>

<p>There are two <code>nqp::op</code>s that relate to executing NFAs:</p>

<ul>
<li><strong><code>nfarunproto</code></strong> evaluates the NFA from a given offset in the target string.
It returns an array indicating the order in which the candidates should be
tried, excluding any that could never possibly match.</li>
<li><strong><code>nfarunalt</code></strong> evaluates the NFA from a given offset in the target string.
It then pushes marks for all the branches that could possibly match onto the
<code>bstack</code> in reverse order, so the best possible candidate is at the top. The
regex engine then just immediately &ldquo;backtracks&rdquo; to start trying the possible
candidates.</li>
</ul>

<p>These two really are just thin wrappers around the same underlying NFA
evaluator.</p>

<h2 id="exercise-9">Exercise 9</h2>

<p>In this exercise, you&rsquo;ll explore some of the regex engine implementation. Of
note, you&rsquo;ll encounter (time-allowing):</p>

<ul>
<li>The Perl 6 regex grammar and actions</li>
<li>How embedded code blocks are implemented in NQP and Rakudo</li>
<li>Where NFAs are stored and how they look</li>
</ul>

<p>See the exercise sheet for guidance.</p>

<h1 id="the-jvm-backend">The JVM backend</h1>

<p><em>Bringing Perl 6 to the land of Java</em></p>

<h2 id="the-jvm">The JVM</h2>

<p>Virtual machine originally built to execute the Java language, and now host to
a large number of languages spanning many paradigms, static, dynamic, etc.</p>

<p>Instruction set of <strong>around 200 instructions</strong>, but many class library methods
are provided natively by the VM also</p>

<p>Instruction set and execution model are <strong>stack based</strong>; values are loaded on
to the stack to be operated on, passed as method arguments, etc.</p>

<p>The <strong>bytecode</strong> lives in a <strong>class file</strong>, which represents a single class
with fields and methods.</p>

<h2 id="jvm-instruction-set-constants">JVM instruction set: constants</h2>

<p>Various instructions load constants on to the stack:</p>

<ul>
<li><strong><code>aconst_null</code></strong> loads a null reference</li>
<li><strong><code>iconst_m1</code>, <code>iconst_0</code>, <code>iconst_1</code>, &hellip; <code>iconst_5</code></strong> load 32-bit integer
-1, 0, 1, &hellip; 5 onto the stack</li>
<li><strong><code>lconst_0</code>, <code>lconst_1</code></strong> load 64-bit integer 0 and 1 onto the stack</li>
<li><strong><code>fconst_0</code>, <code>fconst_1</code>, <code>fconst_2</code></strong> load 32-bit floating point 0.0, 1.0,
2.0 onto the stack</li>
<li><strong><code>dconst_0</code>, <code>dconst_1</code></strong> load 64-bit floating point 0.0, 1.0 onto the
stack</li>
<li><strong><code>bipush</code></strong> takes a 1-byte argument and loads it as a 32-bit integer</li>
<li><strong><code>sipush</code></strong> takes a 2-byte argument and loads it as a 16-bit integer</li>
<li><strong><code>ldc</code>, <code>ldc_w</code> and <code>ldc2_w</code></strong> load constants from the constant pool (int,
float or String)</li>
</ul>

<h2 id="jvm-instruction-set-locals">JVM instruction set: locals</h2>

<p>Local variables are either integers (32-bit), longs (64-bit), floats (32-bit),
doubles (64-bit) or object reference. There are instructions to load and store
them.</p>

<ul>
<li><strong><code>iload</code>, <code>lload</code>, <code>fload</code>, <code>dload</code> and <code>aload</code></strong> take an index and load
that local variable onto the stack</li>
<li><strong><code>istore</code>, <code>lstore</code>, <code>fstore</code>, <code>dstore</code> and <code>astore</code></strong> take an index and
store what is currently on the stack top to that local variable</li>
<li>The first four local variables (indexes 0 through 3) can be accessed using
special instructions of the form <strong><code>&lt;prefix&gt;[load|store]_[0..3]</code></strong>, for
example <code>iload_0</code>, <code>lload_3</code>, <code>astore_2</code>, <code>dstore_0</code></li>
</ul>

<p>Both longs and doubles count as two slots, so two adjacent longs might be in
index 4 and 6; trying to access something at 5 will complain about splitting
a value!</p>

<h2 id="jvm-instruction-set-arrays">JVM instruction set: arrays</h2>

<p>Arrays can be created with types <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code> <code>byte</code>,
<code>char</code>, <code>short</code> or any reference type. They are not resizable.</p>

<ul>
<li><strong><code>newarray</code></strong> creates an array of any of the native types, with a byte to
indicate type and taking the length to allocate from the stack top</li>
<li><strong><code>anewarray</code></strong> is for creating arrays of a reference type; the type is
specified as a constant pool entry</li>
<li><strong><code>arraylength</code></strong> gets the length of an array</li>
<li>Loading an element from an array involves putting the array on the stack,
the index on the stack, and then using one of <code>iaload</code>, <code>laload</code>, <code>faload</code>,
<code>daload</code>, <code>aaload</code>, <code>baload</code>, <code>caload</code> or <code>saload</code></li>
<li>Storing an element to an array involves putting the array on the stack,
the index on the stack, the value on the stack, and then using one of
<code>iastore</code>, <code>lastore</code>, <code>fastore</code>, <code>dastore</code>, <code>aastore</code>, <code>bastore</code>, <code>castore</code>,
or <code>sastore</code></li>
</ul>

<h2 id="jvm-instruction-set-arithmetic">JVM instruction set: arithmetic</h2>

<p>The usual set of arithmetic and bitwise operations are available</p>

<ul>
<li><strong>Addition:</strong> <code>iadd</code>, <code>ladd</code>, <code>fadd</code>, <code>dadd</code></li>
<li><strong>Subtraction:</strong> <code>isub</code>, <code>lsub</code>, <code>fsub</code>, <code>dsub</code></li>
<li><strong>Multiplication:</strong> <code>imul</code>, <code>lmul</code>, <code>fmul</code>, <code>dmul</code></li>
<li><strong>Division:</strong> <code>idiv</code>, <code>ldiv</code>, <code>fdiv</code>, <code>ddiv</code></li>
<li><strong>Modulo:</strong> <code>irem</code>, <code>lrem</code>, <code>frem</code>, <code>drem</code></li>
<li><strong>Negation:</strong> <code>ineg</code>, <code>lneg</code>, <code>fneg</code>, <code>dneg</code></li>
<li><strong>Bit shifts</strong>: <code>ishl</code>, <code>lshl</code>, <code>ishr</code>, <code>lshr</code>, <code>iushr</code>, <code>lushr</code></li>
<li><strong>Bitwise:</strong> <code>iand</code>, <code>land</code>, <code>ior</code>, <code>lor</code>, <code>ixor</code>, <code>lxor</code></li>
</ul>

<h2 id="jvm-instruction-set-compare-branch">JVM instruction set: compare/branch</h2>

<p>Bloody irregular!</p>

<p>For longs, floats and doubles, you use one of <code>lcmp</code>, <code>fcmpl</code>, <code>fcmpg</code>,
<code>dcmpl</code>, or <code>dcmpg</code>, which give -1, 0 or 1 (like a <code>cmp</code> in various
languages). You then branch with one of <code>ifeq</code>, <code>ifne</code>, <code>iflt</code>, <code>ifge</code>,
<code>ifgt</code>, or <code>ifle</code>.</p>

<p>32-bit integer comparisons are special enough to get their own instructions
that compare and branch all in one: <code>if_icmpeq</code>, <code>if_icmpne</code>, <code>if_icmplt</code>,
<code>if_icmpge</code>, <code>if_icmpgt</code> and <code>if_icmple</code>.</p>

<p>References can be compared for equality or inequality and branched on with
<code>if_acmpeq</code> and <code>if_acmpne</code>. For nullness check and branch, there are <code>ifnull</code>
and <code>ifnonnull</code>.</p>

<p>Finally, there&rsquo;s an unconditional <code>goto</code> and a <code>tableswitch</code> for compiling a
switch statement into.</p>

<h2 id="jvm-instruction-set-objects-and-fields">JVM instruction set: objects and fields</h2>

<p>An object is instantiated with the <code>new</code> instruction. Note that the bytecode
validator will enforce that its constructors are called with <code>invokespecial</code>
(see next slide).</p>

<p>There are four instructions for accessing fields (though we don&rsquo;t do this too
often, as for 6model objects it&rsquo;s encapsulated inside the representation):</p>

<ul>
<li><strong><code>getstatic</code></strong> takes a field reference from the constant pool and loads the
static field&rsquo;s value onto the stack</li>
<li><strong><code>getfield</code></strong> is similar, but expects the object to access an instance field
from to be on the stack</li>
<li><strong><code>putstatic</code></strong> takes a field reference from the constant pool and stores the
current stack top value to the static field</li>
<li><strong><code>putfield</code></strong> is similar, but expects the object to store the instance field
on to be on the stack beneath the value</li>
</ul>

<h2 id="jvm-instruction-set-method-calls">JVM instruction set: method calls</h2>

<p>Instance method calls expect the stack to contain the object to call a method
on, followed by any extra arguments. Note that these operate on <strong>Java
objects</strong> rather than 6model objects, so we don&rsquo;t use them for Perl 6&rsquo;s
method dispatch!</p>

<ul>
<li><strong><code>invokevirtual</code></strong> does a normal virtual method call</li>
<li><strong><code>invokespecial</code></strong> calls a method in an exact class (used for super, etc.)</li>
<li><strong><code>invokeinterface</code></strong> calls a method through an interface</li>
</ul>

<p>There is also <strong><code>invokestatic</code></strong> which just expects the arguments to be on the
stack. We use this very heavily, since most <code>nqp::</code> ops are static method calls.</p>

<p>Finally, there&rsquo;s <strong><code>invokedynamic</code></strong>, which is how actual Perl 6-level routine
and method calls are wired up.</p>

<h2 id="jvm-instruction-set-exceptions">JVM instruction set: exceptions</h2>

<p>There is only one instruction related to exceptions, <strong><code>athrow</code></strong>. It throws
the exception object that is currently on the stack top.</p>

<p>Exception handlers are stored as a table rather than in the bytecode stream.</p>

<h2 id="jvm-instruction-set-other-bits">JVM instruction set: other bits</h2>

<p>There are various coercion instructions that convert between the primitive
types. They are of the form <code>&lt;from&gt;2&lt;to&gt;</code>, with the same one-letter codes used
for arrays. The available ones are <code>i2l</code>, <code>i2f</code>, <code>i2d</code>, <code>l2i</code>, <code>l2f</code>, <code>l2d</code>,
<code>f2i</code>, <code>f2l</code>, <code>f2d</code>, <code>d2i</code>, <code>d2l</code>, <code>d2f</code>, <code>i2b</code>, <code>i2c</code>, and <code>i2s</code>.</p>

<p>There are also a number of instructions for manipulating the stack:</p>

<ul>
<li><strong>Popping:</strong> <code>pop</code>, <code>pop2</code> (note that a long or double counts as 2 slots)</li>
<li><strong>Duplicating:</strong> <code>dup</code>, <code>dup2</code> (same rules)</li>
<li><strong>Swapping:</strong> <code>swap</code> (nope, doesn&rsquo;t exist for long/double)</li>
</ul>

<p>Finally, a method can be returned from (taking the current stack top as the
return value) with <code>ireturn</code>, <code>lreturn</code>, <code>freturn</code>, <code>dreturn</code>, <code>areturn</code>, or
<code>return</code> (void).</p>

<h2 id="jast-1">JAST (1)</h2>

<p>To generate JVM bytecode from NQP, we build a bunch of <strong>JAST</strong> nodes (short
for JVM Abstract Syntax Tree).</p>

<p>There are some nodes for pushing constants:</p>

<pre><code>JAST::PushIVal.new( :value(42) )        # 64-bit integer constant
JAST::PushIndex.new( :value(69) )       # 32-bit integer constant
JAST::PushNVal.new( :value(1.5) )       # 64-bit double constant
JAST::PushSVal.new( :value('beer') )    # String constant
</code></pre>

<p>There is also a <strong><code>JAST::PushCVal</code></strong>, used for pushing class literals.</p>

<h2 id="jast-2">JAST (2)</h2>

<p>The top level structure is made up of a <strong><code>JAST::Class</code></strong> node. It exposes the
methods <code>add_field</code>, which expects a <strong><code>JAST::Field</code></strong>, and <code>add_method</code>, which
expects a <strong><code>JAST::Method</code></strong>.</p>

<p>A <strong><code>JAST::Field</code></strong> has methods (and named constructor parameters) to set a
<code>name</code>, <code>type</code> and if it&rsquo;s <code>static</code>.</p>

<p>A <strong><code>JAST::Method</code></strong> is rather more complex. Along with the <code>name</code> and a flag
to indicate if it&rsquo;s <code>static</code>, it also has lists of <code>locals</code> and <code>arguments</code>,
along with a type that it <code>returns</code>. Additional fields capture the set of
lexicals, NQP-level exception handlers, etc.</p>

<h2 id="jast-3">JAST (3)</h2>

<p>An individual instruction is expressed as a <strong><code>JAST::Instruction</code></strong> node.</p>

<pre><code>JAST::Instruction.new( :op('aconst_null') )
</code></pre>

<p>Typically, these are pushed onto a <strong><code>JAST::InstructionList</code></strong>, though they
can also be pushed onto the instruction list inside a <code>JAST::Method</code> too.</p>

<pre><code>my $il := JAST::InstructionList.new();
$il.append(JAST::PushIVal.new( :value($target) ));
$il.append(JAST::Instruction.new( :op('aload'), 'tc' ));
$il.append(JAST::Instruction.new( :op('invokestatic'), $TYPE_OPS,
    'lexotic_tc', $TYPE_SMO, 'Long', $TYPE_TC ));
# ...
</code></pre>

<h2 id="jast-4">JAST (4)</h2>

<p>The <strong><code>JAST::Label</code></strong> node represents a label. Within a given <code>JAST::Method</code>,
a label needs to be unique.</p>

<pre><code>my $if_id    := $qastcomp.unique($op_name);
my $else_lbl := JAST::Label.new(:name($if_id ~ '_else'));
</code></pre>

<p>A <code>JAST::Label</code> can be used in a branch:</p>

<pre><code>$il.append(JAST::Instruction.new($else_lbl,
    :op($op_name eq 'if' ?? 'ifeq' !! 'ifne')));
</code></pre>

<p>And its location is wherever it&rsquo;s pushed:</p>

<pre><code>$il.append($else_lbl);
</code></pre>

<h2 id="jast-5">JAST (5)</h2>

<p>Finally, there is <strong><code>JAST::TryCatch</code></strong>, which represents a (JVM-level)
exception handler.</p>

<p>It expects two <code>JAST::InstructionList</code>s, one that makes up the <code>try</code>, and
another that makes up the <code>catch</code>. It also needs to have an exception <code>type</code>
specified.</p>

<pre><code>$il.append(JAST::TryCatch.new(
    :try($try_il),
    :catch($catch_il),
    :type($TYPE_EX_LEX)
));
</code></pre>

<h2 id="the-qast-to-jast-translator">The QAST to JAST translator</h2>

<p>JAST provides a way to produce JVM bytecode from NQP. The frontend produces a
QAST tree, however. Between them is a QAST to JAST translator, which lives in
the <code>src/vm/jvm/QAST/</code> directory of NQP.</p>

<p>In all, including translation of all the QAST nodes (including regexes) and
<code>nqp::ops</code>, it weighs in at about 5,400 lines. That may sound like a lot, yet
it is only around a third of the size of the Perl 6 CORE.setting!</p>

<p>Its job is complicated by a couple of factors:</p>

<ul>
<li>It&rsquo;s doing a Continuation Passing Style transform on everything as it goes
about doing the code generation - though this is relatively well isolated</li>
<li>The JVM has stack-must-be-empty constraints on things that appear in the
middle of a Perl 6 expression (like <code>try</code>)</li>
</ul>

<h2 id="types-and-results">Types and results</h2>

<p>There are 4 primitive types that everything revolves around, which you will
see everywhere in the compiler:</p>

<pre><code>$RT_INT     a JVM long; maps to `int` in NQP
$RT_NUM     a JVM double; maps to `num` in NQP
$RT_STR     the Java String class; maps to `str` in NQP
$RT_OBJ     a 6model object (org.perl6.nqp.sixmodel.SixModelObject)
</code></pre>

<p>The code to compile a QAST node or an <code>nqp::op</code> always returns a <code>Result</code>.
This type pairs together a <code>JAST::InstructionList</code> with one of the above
types, indicating what it leaves behind on the stack.</p>

<p><code>$RT_VOID</code> indicates the absence of a result.</p>

<h2 id="mapping-nqp-ops">Mapping nqp::ops</h2>

<p>A handful of <code>nqp::ops</code> map directly to JVM ops:</p>

<pre><code>QAST::OperationsJAST.map_jvm_core_op('neg_i', 'lneg', [$RT_INT], $RT_INT);
</code></pre>

<p>Some others get mapped to functions in the Java class library:</p>

<pre><code>QAST::OperationsJAST.map_classlib_core_op('abs_i', $TYPE_MATH, 'abs',
    [$RT_INT], $RT_INT);
</code></pre>

<p>Most, however, are mapped to a a call on the <code>Ops</code> class in the NQP runtime,
often passing the current <code>ThreadContext</code> object:</p>

<pre><code>QAST::OperationsJAST.map_classlib_core_op('create', $TYPE_OPS, 'create',
    [$RT_OBJ], $RT_OBJ, :tc);
</code></pre>

<h2 id="the-runtime-support-library">The runtime support library</h2>

<p>Many of the <code>nqp::ops</code>, the JVM implementation of 6model, and various other
support code lives in the <code>src/vm/jvm/runtime/</code> directory in NQP. It is built
into the <code>nqp-runtime.jar</code> library.</p>

<p>If you modify this code, you typically need only re-build the JAR to see the
effects, rather than re-building all of NQP. Copy it to its install location,
and it can be updated for Rakudo too.</p>

<p>Rakudo also has a (much smaller) runtime support library, which is built to
<code>rakudo-runtime.jar</code>.</p>

<p><em><exploration as time allows></em></p>

<h2 id="in-summary">In summary&hellip;</h2>

<p>The JVM support consists of translating a QAST tree into JVM bytecode, through
an intermediate form known as JAST, and a runtime support library.</p>

<p>Most effort goes into providing things that the JVM does not provide natively,
such as the continuation support needed by gather/take, 6model, exception
handlers that run on the stack top before unwinding, and so forth.</p>

<p>From here, work is needed on optimization, better code generation, and better
use of <code>invokedynamic</code>.</p>

<h1 id="the-moarvm-backend">The MoarVM backend</h1>

<p><em>A VM built just for NQP and Rakudo</em></p>

<h2 id="moarvm-in-a-nutshell">MoarVM in a nutshell</h2>

<p>Uses <strong>6model</strong> as its native object system</p>

<p>Instruction set aligned with <strong>nqp::ops</strong></p>

<p>Provides <strong>generational GC</strong> with two generations: a nursery (handled by
semi-space copying) and gen2 (sized pools, except for large objects)</p>

<p>Includes <strong>Unicode database</strong> support, and working towards <strong>NFG</strong> strings</p>

<p>Support for <strong>threads</strong>, use of <strong>lock-free</strong> data structures where possible</p>

<h2 id="mast">MAST</h2>

<p>MoarVM doesn&rsquo;t have an assembly or intermediate language; instead, MAST (the
MoarVM Assembly Syntax Tree) is assembled directly into bytecode.</p>

<p>MAST is lower level than QAST, and rather different to JAST (due to the rather
different design of the VMs and the fact that MoarVM isn&rsquo;t stack based).
However, if you are familiar with either (or both) of these, you&rsquo;ll feel at
home quite quickly with MAST. After all, MAST and JAST were designed by the
same person, and said person also contributed to the QAST design. <code>:-)</code></p>

<p>In fact, 5 MAST nodes share exactly the same name and role as the equivalent
QAST nodes.</p>

<h2 id="mast-nodes-literals">MAST nodes: literals</h2>

<p>Literal integers, floating point numbers, and strings are unsurprising in
their representation.</p>

<pre><code>MAST::IVal.new( :value(42) )
MAST::NVal.new( :value(1.2) )
MAST::SVal.new( :value('cwrw') )
</code></pre>

<p>However, while their QAST equivalents can appear essentially anywhere, these
MAST nodes can only be used as arguments to instructions that expect literals
(for example, <code>const_i64</code>, <code>const_n64</code>, <code>const_s</code>, <code>argconst_[ins]</code>, parameter
names in the named parameter binding instructions, etc.) Most instructions
instead expect the argument to be in a local.</p>

<h2 id="mast-frames">MAST: frames</h2>

<p>A lexical scope, and the smallest invokable unit, in MoarVM is a frame. This
is represented by a <code>MAST::Frame</code> node.</p>

<p>A frame has:</p>

<ul>
<li>A (high level) name and a (low level) compilation unit unique ID</li>
<li>A list of locals/registers (there&rsquo;s no distinction, and the terms are used
interchangeably). These just have integer indexes, not names.</li>
<li>A list of lexicals. These have names and types.</li>
<li>A reference to its static outer frame (used in lexical lookup)</li>
<li>A list of instructions</li>
</ul>

<p>Typically, a <code>QAST::Block</code> maps to a <code>MAST::Frame</code>.</p>

<h2 id="mast-nodes-locals">MAST nodes: locals</h2>

<p>There is a <code>MAST::Local</code> to represent locals (storage slots available as the
frame executes):</p>

<pre><code>MAST::Local.new( :index($!frame.add_local($type)) )
</code></pre>

<p>In reality, it&rsquo;s very rare to see this being directly constructed in the QAST
to MAST compiler. It&rsquo;s all hidden behind some helpers:</p>

<pre><code>fresh_o     Make a new object local
fresh_i     Make a new int64 local
fresh_n     Make a new num64 local
fresh_s     Make a new string local
</code></pre>

<p>After use, a local is typically released so it can be re-used elsewhere in the
frame.</p>

<h2 id="mast-nodes-lexicals">MAST nodes: lexicals</h2>

<p>MoarVM also natively supports lexical variables, which (unlike locals) are
visible from nested frames. Again, these nodes are rarely generated directly
in the QAST compiler, but by a helper that resolves the lexical (calculating
how many frames out to look for it):</p>

<pre><code>method resolve_lexical($name) {
    my $block := self;
    my $out   := 0;
    while $block {
        if ($block.lexicals()){$name} -&gt; $lex {
            return MAST::Lexical.new( :index($lex.index),
                                      :frames_out($out) );
        }
        $out++;
        $block := $block.outer;
    }
    nqp::die(&quot;Could not resolve lexical $name&quot;);
}
</code></pre>

<h2 id="mast-nodes-ops">MAST nodes: ops</h2>

<p>A <code>MAST::Op</code> node represents an operation from the MoarVM instruction set.
These are often created and pushed onto an instruction list by the <code>push_op</code>
helper sub:</p>

<pre><code>sub push_op(@dest, $op, *@args) {
    nqp::push(@dest, MAST::Op.new(
        :op($op),
        |@args
    ));
}
</code></pre>

<p>The kinds of nodes expected as arguments varies with instruction. For example,
the <code>push_o</code> instruction expects two <code>MAST::Local</code> nodes:</p>

<pre><code>push_op($arr.instructions, 'push_o', $arr_reg, $item_reg);
</code></pre>

<p>Note that there is no coercion/polymorphism at this level. If the instruction
wants a local, you cannot use a literal at that point!</p>

<h2 id="mast-nodes-labels">MAST nodes: labels</h2>

<p>A <code>MAST::Label</code> can be placed in an instruction list as the target of a branch
and used as an argument to certain <code>MAST::Op</code>s that branch.</p>

<p>A label must be unique within a given <code>MAST::Frame</code>, which is why you&rsquo;ll often
see code like:</p>

<pre><code>my $if_id    := $qastcomp.unique($op_name);
my $else_lbl := MAST::Label.new(:name($if_id ~ '_else'));
my $end_lbl  := MAST::Label.new(:name($if_id ~ '_end'));
</code></pre>

<p>Here&rsquo;s some examples of using the labels:</p>

<pre><code>push_op(@ins, 'goto', $end_lbl);
nqp::push(@ins, $else_lbl);
</code></pre>

<h2 id="mast-nodes-calls">MAST nodes: calls</h2>

<p>Making a call boils down to a number of steps: getting the arguments to pass
into an arguments buffer, setting the callsite descriptor, indicating the
result register, and making the call itself.</p>

<p>This is abstracted behind the <code>MAST::Call</code> node:</p>

<pre><code>nqp::push(@ins, MAST::Call.new(
    :target($callee.result_reg),
    :flags(@arg_flags),
    |@arg_regs,
    :result($res_reg)
));
</code></pre>

<p>The flags indicate register type, as well as named and flattening arguments.</p>

<h2 id="mast-nodes-exception-handlers">MAST nodes: exception handlers</h2>

<p>Exception handlers are used both for control flow (such as next/redo/last in
loops) or true exceptions (caught by <code>CATCH</code> blocks in NQP/Perl 6). Both of
these are set up with a <code>MAST::HandlerScope</code>, which indicates the instructions
covered by the handler, what kind of exception it&rsquo;s interested in and what to
do if the handler is triggered.</p>

<pre><code>MAST::HandlerScope.new(
    :instructions(@loop_il),
    :category_mask($HandlerCategory::redo),
    :action($HandlerAction::unwind_and_goto),
    :goto($redo_lbl)
)
</code></pre>

<p>Here, the action is to simply unwind the call stack and go to the specified
label. By contrast, a <code>CATCH</code> block&rsquo;s action is to run a handler block on the
stack top and unwind afterwards.</p>

<h2 id="mast-nodes-compilation-units">MAST nodes: compilation units</h2>

<p>Finally, the top of a MAST assembly tree is always a <code>MAST::CompUnit</code>. This
has a list of frames (each one added with the <code>add_frame</code> method).</p>

<p>Certain frames can be called out as special:</p>

<ul>
<li><strong><code>deserialize_frame</code></strong> holds code that drives deserialization, and will
always be run when the compilation unit is created or loaded</li>
<li><strong><code>load_frame</code></strong> holds code that should run when the compilation unit is
loaded as a module</li>
<li><strong><code>main_frame</code></strong> holds code that should run when the compilation unit is
the initial entry point</li>
</ul>

<p>It also keeps track of the HLL that produced the compilation unit and the
set of serialization contexts that it depends on.</p>

<h2 id="the-qast-to-mast-translator">The QAST to MAST translator</h2>

<p>Spread over three files:</p>

<ul>
<li><strong><code>QASTOperationsMAST.nqp</code></strong> handles compilation of <code>nqp::op</code>s</li>
<li><strong><code>QASTRegexCompilerMAST.nqp</code></strong> handles compilation of <code>QAST::Regex</code> nodes</li>
<li><strong><code>QASTCompilerMAST.nqp</code></strong> handles the rest</li>
</ul>

<p>These reference:</p>

<ul>
<li>The MAST nodes</li>
<li>Meta-data about all of the ops available and the kinds of registers they
work on</li>
</ul>

<h2 id="mast-instructionlist">MAST::InstructionList</h2>

<p>Once again, there is a data structure used to convey the result of compiling a
QAST node: <code>MAST::InstructionList</code>. It holds three pieces of information:</p>

<ul>
<li>A list of instructions (<code>$il.instructions</code>)</li>
<li>The register (local) holding the result (<code>$il.result_reg</code>)</li>
<li>The kind of result register it is (<code>$il.result_kind</code>)</li>
</ul>

<p>There are constants for the four main kinds:</p>

<ul>
<li><code>$MVM_reg_obj</code> (6model object)</li>
<li><code>$MVM_reg_int64</code> (int)</li>
<li><code>$MVM_reg_num64</code> (num)</li>
<li><code>$MVM_reg_str</code> (str, though it&rsquo;s actually a 6model object too)</li>
</ul>

<h2 id="register-local-allocation">Register/local allocation</h2>

<p>There is a per-block <code>$*REGALLOC</code> that keeps track of register use. Despite
the name, it&rsquo;s not doing register allocation in the traditional sense (such as
by graph coloring). Rather, it keeps track of available temporaries, enabling
them to be re-used.</p>

<p>Obtaining a new register to work with is typically done as:</p>

<pre><code>my $callee_reg := $*REGALLOC.fresh_o(); # also _i, _n, _s
</code></pre>

<p>It can then be released when it&rsquo;s no longer needed:</p>

<pre><code>$*REGALLOC.release_register($callee_reg, $MVM_reg_obj);
</code></pre>

<h2 id="nqp-op-mapping">nqp::op mapping</h2>

<p>Many <code>nqp::ops</code> have similar or identical names in the MoarVM instruction set.
The operand type data is also readily available, so does not need to be
specified in the mappings:</p>

<pre><code>QAST::MASTOperations.add_core_moarop_mapping('atpos', 'atpos_o');
QAST::MASTOperations.add_core_moarop_mapping('atpos_i', 'atpos_i');
</code></pre>

<p>Some instructions in MoarVM are void, but are allowed in an r-value context as
<code>nqp::ops</code>. Therefore, we pick one of the input operands as the result, if one
is needed.</p>

<pre><code>QAST::MASTOperations.add_core_moarop_mapping('bindpos', 'bindpos_o', 2);
QAST::MASTOperations.add_core_moarop_mapping('bindpos_i', 'bindpos_i', 2);
</code></pre>

<h2 id="inside-moarvm">Inside MoarVM</h2>

<p>The top-level <code>src</code> directory doesn&rsquo;t contain much directly; the code is
categorized into sub-directories:</p>

<ul>
<li><strong><code>6model</code></strong> contains 6model, implementations of the REPRs, serialization&hellip;</li>
<li><strong><code>core</code></strong> is the heart of the VM, containing the interpreter, argument
handling, bytecode decoding, thread handling, invocation, exceptions&hellip;</li>
<li><strong><code>gc</code></strong> is where memory allocation and garbage collection lives</li>
<li><strong><code>io</code></strong> contains IO-related functionality, typically delegating the real
work to <code>libuv</code></li>
<li><strong><code>mast</code></strong> contains the MAST to bytecode compiler</li>
<li><strong><code>math</code></strong> contains the libtommath binding for big integer support</li>
<li><strong><code>platform</code></strong> is where platform-specific code goes (as different platforms
do things differently)</li>
<li><strong><code>strings</code></strong> contains string operations, encoding/decoding of ASCII, UTF-8,
etc.</li>
</ul>

<h2 id="in-summary-1">In summary&hellip;</h2>

<p>MoarVM <strong>uses 6model</strong> as its object model and has an instruction set that is
<strong>well aligned</strong> with the <code>nqp::op</code> set. As a result, the mapping from QAST
down to it is comparatively straightforward.</p>

<p>It will also be the first place that we support NFG strings, and should also
get good Perl 5 interop.</p>

<p>Future developments will include 6model-aware JIT compilation, which should
give a notable performance boost.</p>

<h1 id="the-road-ahead">The Road Ahead</h1>

<p><em>This isn&rsquo;t the end??!!!</em></p>

<h2 id="this-isn-t-all">This isn&rsquo;t all&hellip;</h2>

<p>We&rsquo;ve covered a lot of ground in these two days.</p>

<p>Naturally, there are things that have been put aside. We haven&rsquo;t looked at
every line of code of every file!</p>

<p>And, of course, we didn&rsquo;t cover the things not invented yet because we didn&rsquo;t
implement the bits of the Perl 6 spec that need them.</p>

<p>However, <strong>we have covered all of the key parts that make up NQP and Rakudo</strong>.
With careful reading of code and a little digging, it should be possible to
work out what most of NQP and Rakudo do, and where most things are found.</p>

<h2 id="the-toolchain-will-evolve">The toolchain will evolve</h2>

<p>The NQP toolchain has <strong>evolved in response to understanding Perl 6&rsquo;s needs</strong>.
As we continue to learn, this knowledge will be crunched into the tools.</p>

<p>In the past, there have been some fairly dramatic overhauls. These are very
likely over, though there are surely more lessons that can be turned into
<strong>better abstractions and APIs</strong>.</p>

<p>For example, the concurrency/parallelism work is currently done in terms of
classes from the Java Class Library directly. However, in time, the key
abstractions may well be captured into <code>nqp::</code> ops and so forth.</p>

<h2 id="remember">Remember&hellip;</h2>

<p><strong>Compilers aren&rsquo;t magical. They&rsquo;re just software.</strong></p>

<p>Perl 6 is a large language, and implementing it is non-trivial. However, NQP
and Rakudo have made a reasonable job of trying to <strong>manage the complexity</strong>
by breaking the problem into decoupled pieces.</p>

<p>In fact, that&rsquo;s the only thing that keeps it manageable at all. Keep this in
mind as you hack. <strong>Good architecture takes discipline.</strong> The first solution
you think of will rarely be the best one. Things that feel wrong, usually are.</p>

<p>Take pride in solving implementation problems elegantly, ask questions, treat
no code as sacred, and be sure to <strong><code>-Ofun</code></strong>.</p>

<h2 id="thank-you">Thank you!</h2>

<p>Thanks for atttending the course!</p>

<p><em>Any final questions?</em></p>

<p>By the way, at Edument AB we&rsquo;ve also built and deliver courses on&hellip;</p>

<ul>
<li>Perl 5</li>
<li>Git</li>
<li>Software architecture and Domain Driven Design</li>
<li>JavaScript and other web technologies</li>
<li>C# and .Net</li>
<li>Test Driven Development</li>
</ul>

<p>For more, see <a href="http://edument.se/courses/">http://edument.se/courses/</a>.</p>

<p>(FIXUP)</p>


        
          <div class="blog-tags">
            
              <a href="https://ohmysummer.github.io//tags/nqp/">NQP</a>&nbsp;
            
          </div>
        

        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://ohmysummer.github.io/post/2018-01-28-perl-6-core-hacking-qastalicious/" data-toggle="tooltip" data-placement="top" title="Perl 6 Core Hacking: QASTalicious">&larr; Previous Post</a>
            </li>
          
          
            <li class="next">
              <a href="https://ohmysummer.github.io/post/2018-02-07-perl-6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/" data-toggle="tooltip" data-placement="top" title="Perl 6 中的数据类型 Bag">Next Post &rarr;</a>
            </li>
          
        </ul>
      


      
        
          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ohmysummer" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
        
        
      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            
            <a href="https://ohmysummer.github.io/index.xml" title="RSS">
            
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://ohmysummer.github.io/">焉知非鱼</a>
            
          

          <span style="color: red;">❤</span>&nbsp;Perl 6
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.53</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://ohmysummer.github.io/js/main.js"></script>
<script src="https://ohmysummer.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script>
<script src="https://ohmysummer.github.io/js/load-photoswipe.js"></script>


<script>
  (function() {
    var cx = '009072066163920799339:qwme9vkotxk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>





  </body>
</html>

