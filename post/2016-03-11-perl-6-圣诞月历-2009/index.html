<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Perl 6 圣诞月历-(2009)</title>
  <meta property="og:title" content="Perl 6 圣诞月历-(2009)" />
  <meta name="twitter:title" content="Perl 6 圣诞月历-(2009)" />
  <meta name="description" content="2009 有用的和有意思的循环 让我们来看一个基本的例子.
for 1, 2, 3, 4 { .say }  这是一个最简单清晰的语法的例子.在这并没有使用括号来包起整个列表的语句,象这种写法可以贯穿整个 Perl 6. 通常比起 Perl 5 来你没有必要写那么多的括号了.
很象 Perl 5 , 这个循环中的值会默认存到 $_ .在这个方法调用的 say 其实就是 $_.say.注意在 Perl 6 中,你不能直接只打一个 say 而不加参数,它会默认使用 $_ 来传参.你需要使用 .say 。要么明确的指定是 $_.
下面这个语法块并不是一个普通的块.它能通过一个尖的指向,来告诉你的 循环变量传进去的参数的名字 .
for 1, 2, 3, 4 -&gt; $i { $i .say }  如果你调用的 return 内部有这个,将返回闭合的子函数. 这个尖尖也能取 多个 参数.象下面这样.
1 2 3
for 1, 2, 3, 4 -&gt; $i , $j { &quot;$i, $j&quot; .">
  <meta property="og:description" content="2009 有用的和有意思的循环 让我们来看一个基本的例子.
for 1, 2, 3, 4 { .say }  这是一个最简单清晰的语法的例子.在这并没有使用括号来包起整个列表的语句,象这种写法可以贯穿整个 Perl 6. 通常比起 Perl 5 来你没有必要写那么多的括号了.
很象 Perl 5 , 这个循环中的值会默认存到 $_ .在这个方法调用的 say 其实就是 $_.say.注意在 Perl 6 中,你不能直接只打一个 say 而不加参数,它会默认使用 $_ 来传参.你需要使用 .say 。要么明确的指定是 $_.
下面这个语法块并不是一个普通的块.它能通过一个尖的指向,来告诉你的 循环变量传进去的参数的名字 .
for 1, 2, 3, 4 -&gt; $i { $i .say }  如果你调用的 return 内部有这个,将返回闭合的子函数. 这个尖尖也能取 多个 参数.象下面这样.
1 2 3
for 1, 2, 3, 4 -&gt; $i , $j { &quot;$i, $j&quot; .">
  <meta name="twitter:description" content="2009 有用的和有意思的循环 让我们来看一个基本的例子.
for 1, 2, 3, 4 { .say }  这是一个最简单清晰的语法的例子.在这并没有使用括号来包起整个列表的语句,象这种写法可以贯穿整个 Perl 6. 通常比起 Perl 5 来你没有必要写那么多的括号了.
很象 Perl 5 , 这个循环中的值会默认存到 $_ .在这个方法调用的 say 其实就是 $_.say. …">
  <meta name="author" content="焉知非鱼"/>
  <link href='https://ohmysummer.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://ohmysummer.github.io/img/avatar-icon.jpg" />
  <meta name="twitter:image" content="https://ohmysummer.github.io/img/avatar-icon.jpg" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://ohmysummer.github.io/post/2016-03-11-perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2009/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Young For Perl 6" />

  <meta name="generator" content="Hugo 0.41" />
  <link rel="canonical" href="https://ohmysummer.github.io/post/2016-03-11-perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2009/" />
  <link rel="alternate" href="https://ohmysummer.github.io/index.xml" type="application/rss+xml" title="Young For Perl 6">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://ohmysummer.github.io/css/codeblock.css" />



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'ohmycloudy', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://ohmysummer.github.io/">Young For Perl 6</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="博客" href="/">博客</a>
            </li>
          
        
          
            <li>
              <a title="归档" href="/categories">归档</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/page/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        

        

        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span class="hidden-sm hidden-md hidden-lg">Search</span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
          <a title="Young For Perl 6" href="https://ohmysummer.github.io/">
            <img class="avatar-img" src="https://ohmysummer.github.io/img/avatar-icon.jpg" alt="Young For Perl 6" />
          </a>
        
      </div>
    </div>

  </div>
</nav>



  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title">Search Young For Perl 6</h4>
        </div>
        <div class="modal-body">
          <gcse:search></gcse:search>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>


    
  
  
  




  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              <h1>Perl 6 圣诞月历-(2009)</h1>
                
                
                  <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on March 11, 2016
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 26 minutes (5343 words)
  
  
</span>

                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        

<h1 id="2009">2009</h1>

<h2 id="有用的和有意思的循环">有用的和有意思的循环</h2>

<p>让我们来看一个基本的例子.</p>

<pre><code class="language-perl6">for 1, 2, 3, 4 { .say }
</code></pre>

<p>这是一个最简单清晰的语法的例子.在这并没有使用<code>括号</code>来包起整个列表的语句,象这种写法可以贯穿整个 Perl 6. 通常比起 Perl 5 来你没有必要写那么多的括号了.</p>

<p>很象 Perl 5 , 这个循环中的值会默认存到 <code>$_</code> .在这个方法调用的 say 其实就是 <code>$_.say</code>.注意在 Perl 6 中,你不能直接只打一个 say  而不加参数,它会默认使用 $_ 来传参.你需要使用 <code>.say</code> 。要么明确的指定是 <code>$_</code>.</p>

<p>下面这个语法块并不是一个普通的块.它能通过一个尖的指向,来告诉你的 循环变量传进去的参数的名字 .</p>

<pre><code class="language-perl6">for 1, 2, 3, 4 -&gt; $i { $i .say }
</code></pre>

<p>如果你调用的 return 内部有这个,将返回闭合的子函数.
这个尖尖也能取 多个 参数.象下面这样.</p>

<p>1
2
3</p>

<pre><code class="language-perl6">for 1, 2, 3, 4 -&gt; $i , $j { &quot;$i, $j&quot; .say }
# 1 2
# 3 4
</code></pre>

<p>实际做了些什么啦？就是你在列表进行迭代时一次取了<code>两个</code>元素 . 如果你不明确指明参数的话,就退化到 Perl 5 一样使用 <code>$_</code>.</p>

<p>我们可以意识到这个我们能做什么,比如迭代一个列表。当然,也可以是一个数组的值.</p>

<pre><code class="language-perl6">for @array { .say }
</code></pre>

<p>这是一个非常简单的例子,我们可能更加喜欢使用 <code>map:</code></p>

<pre><code class="language-perl6">@array.map : *.say;
</code></pre>

<p>如果对你来讲 顺序 和连续的并不重要,你可以使用 <code>hyperoperator（超运算符）</code>,上一个文章中也讲过这个,今天的主题也不详细讲这个了.</p>

<pre><code class="language-perl6"> @array».say;
</code></pre>

<p>我们也能使用 范围构造器中缀操作符 <code>..</code> 来生成一个数字的列表：</p>

<pre><code class="language-perl6">  for 1..4 { .say }
</code></pre>

<p>有一个最通用的功能,就是我们想些生成一个从 <code>0</code> 开始到 <code>$n</code> 的数字的列表,比如常用的数组下标.我们可以写成 <code>0 .. $n-1</code>或者另一个不同的范围构造器 <code>0..^$n</code>.但在 Perl 6 中提供了一个短的快捷的方法就是使用前缀的 <code>^</code>.</p>

<pre><code class="language-perl6">for ^4 { .say }
</code></pre>

<p>0
1
2
3</p>

<p>一个常用的理由是,人们在 Perl 5 中常常退回到 C 风格的循环的原因是必须知道 for 的成员数组中索引的位置,或者因为必须并行的迭代二个和更多的数组.Perl 6 提供了一个短的快捷方法,就是中缀的 Z 这个 zip 操作符.</p>

<pre><code class="language-perl6">for @array1 Z @array2 -&gt; $one , $two { ... }
</code></pre>

<p>假设二个数组是相同的长度<code>$one</code> 会是第一个 <code>@array1</code> 的成员元素,<code>$two</code> 会是相应的位置 <code>@array2</code> 的成员元素.如果是不同的长度的话.迭代会停止到短的那个数组结束的长度.
        我们可以很容易地在迭代数组包含进索引：</p>

<pre><code class="language-perl6">for ^Inf Z @array -&gt; $index , $item { ... }
</code></pre>

<p>如果一个无限长的列表,会让你害怕使用上面用法的话,可以象下面这样,使用前缀操作符 <code>^</code> 来取出数组元素的长度.</p>

<pre><code class="language-perl6">for ^@array.elems Z @array -&gt; $index , $item { ... }
</code></pre>

<p>上面这个可以得到相同的结果,但是更加优雅.因为中缀操作符 <code>Z</code> 操作时,第一个元素的长度决定了什么整个长度.</p>

<pre><code class="language-perl6">for @array.kv -&gt; $index , $item { ... }  
</code></pre>

<p><code>@array.kv</code> 会返回 <code>keys</code> 和 <code>values</code> 的交错,这个 <code>$key</code> 是数组元素的下标.所以同时迭代这二个可能是你比较想要的效果.
希望这篇文章让你了解 Perl 6 灵活的循环相关的一些概念,它们可以灵活的使用在各种常见任务上.在这之前,我要回答最后一个问题,我知道有人一直在想这个问题.怎么样一次性迭代四个数组.</p>

<pre><code class="language-perl6">for @one Z @two Z @three Z @four -&gt; $one , $two , $three , $four { ... }
</code></pre>

<p>这是一个关联列表中缀操作符,这样使用,是不是一种享受？</p>

<h2 id="超运算符">超运算符</h2>

<hr />

<p>pmichaud 在昨天介绍了 Perl 6 的 hyper 运算符,我这要进一步来探索 Perl6 中强大的元操作的特性.
首先,为简单起见,我将编写一个 lsay 的函数,可以轻松地得到好看的列表值的输出.这个 sub 是用我们用 Perl 来创建的</p>

<p>our sub lsay( @a ) { @a.perl.say }</p>

<p>接下来我们看 hyperoperator 的例子.在这个中,我们使用 <code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> 来替换 <code>»</code> 和 <code>«</code>, 主要因为这样更加容易看(我怕我会需要眼镜). <code>»</code>和<code>«</code> 是语言中真实的形式,但较长的 ASCII 字符版本也是可以正常工作的.</p>

<p>首先.来个基本的:
添加两个相同长度的列表</p>

<pre><code class="language-perl6">&gt; (1, 2, 3, 4) &lt;&lt;+&gt;&gt; (3, 1, 3, 1)
4, 3, 6, 5
&gt; (1, 2, 3, 4) &gt;&gt;+&lt;&lt; (3, 1, 3, 1)
4, 3, 6, 5
</code></pre>

<p>如果数组的长度是相同的,上面这两种形式之间没有区别.但是,如果长度是不同的：</p>

<pre><code class="language-perl6">&gt; (1, 2, 3, 4) &lt;&lt;+&gt;&gt; (3, 1)
4, 3, 6, 5
&gt; (1, 2, 3, 4) &gt;&gt;+&lt;&lt; (3, 1)
</code></pre>

<pre><code>Sorry, lists on both sides of non-dwimmy hyperop are not of same length : left: 4 elements, right: 2 elements
</code></pre>

<p>这规则是, 象诸如此类的尖尖是用来表明 hyperoperator 使用时,当一端比另一端短,可以延长短的那一端来进行扩展延伸.</p>

<p>象如果是尖尖指向内部,是指不能进行扩展延伸.当然,还可以有各种组合都是可以的.所以你也能指出只有<code>左边</code>能扩展延伸 (<code>&lt;&lt;+&lt;&lt;</code>),也可以只指出只有<code>右边</code>能(<code>&gt;&gt;+&gt;&gt;</code>).当然也能二边都是可以扩展延伸 (<code>&lt;&lt;+&gt;&gt;</code>),或者二边都不能扩展延伸 (<code>&gt;&gt;+&lt;&lt;</code>).  R 语言中也有向量的循环法则。
单标量扩展延伸如下：</p>

<pre><code class="language-perl6">&gt; (1, 2, 3, 4) &gt;&gt;+&gt;&gt; 2
3, 4, 5, 6
&gt; 3 &lt;&lt;+&lt;&lt; (1, 2, 3, 4)
4, 5, 6, 7
</code></pre>

<p>因此,这就是基本的使用中缀操作符 hyperoperator 的方法.您还可以使用前缀和后缀运算符：
单边运算时，元素要能漏到操作符的左边(  如<code>@a&gt;&gt;++</code>  )或右边（ 如 <code>~&lt;&lt;</code>  ）。想象一下漏斗，总是从大的口向小的口漏。
所以操作符前面或后面接什么样的超运算符要取决于操作数是在操作符的前面（用<code>&gt;&gt;</code>）或后面(用<code>&lt;&lt;</code>)</p>

<pre><code class="language-perl6">&gt; ~&lt;&lt;(1, 2, 3, 4)    # ~(1,2,3,4)
</code></pre>

<p>超运算符就是在普通运算符的后面，加强普通运算符的功能。如</p>

<pre><code class="language-perl6">&gt; ~&lt;&lt; &quot;1&quot; , &quot;2&quot; , &quot;3&quot; , &quot;4&quot;
&gt; -&lt;&lt;(1, 2, 3, 4)
-1 -2 -3 -4
&gt; my @a = (1, 2, 3, 4);
@a&gt;&gt;++;
@a ;    # 单边运算时，@a与&gt;&gt;之间不能有空格，如不能写成@a &gt;&gt;+
2, 3, 4, 5
</code></pre>

<p>你也能这样:</p>

<pre><code class="language-perl6">&gt; (0, pi/4, pi/2, pi, 2*pi)&gt;&gt;.sin  # R 中向量化的运算
0, 0.707106781186547, 1, 1.22464679914735e-16, -2.44929359829471e-16
&gt; (-1, 0, 3, 42)&gt;&gt;.Str
&quot;-1&quot; , &quot;0&quot; , &quot;3&quot; , &quot;42&quot;
</code></pre>

<p>这其实就是只是想说 <code>&gt;&gt;.</code> 是调用列表中的每一个成员的一种方法。点 (.)也是一个操作符</p>

<p>其他说明：hyperoperators 并不只是只能和内置操作符一起工作.他们也将能跟你定义以及任何新的运算符工作的很好（即大多数的的都能正常在现在的 Rakudo 上工作）.</p>

<p>只要给放在适当的地方.如<code>@a &gt;&gt;/=&gt;&gt;2</code> 整个数组成员都除以 2. 他们将来能和更多的结构一起工作,如多维列表,树与哈希;我们可 S03 Hyper operators .(据我所知,有些功能还尚未在 Rakudo 正常实现)</p>

<p>我并不知道是否有很多代码示例中广泛使用 hyperoperators. 但 LastOfTheCarelessMen’s Vector 是一个非常好的实现.它使用单循环直接的实现了一个 N 维向量类.</p>

<p><a href="https://github.com/LastOfTheCarelessMen/Vector/blob/master/lib/Vector.pm">N维向量</a></p>

<h2 id="reduce-和-hyper-元操作符">reduce 和 hyper 元操作符</h2>

<hr />

<p>Hyper  亢奋的；精力旺盛的 Hyper[ˈhaɪpə&reg;]</p>

<p>今天是第四天,在这个小盒子中,你会见到一些有意思的实现阶乘的函数</p>

<pre><code class="language-perl6">sub fac( Int $n ) {
        [*] 1.. $n
}
</code></pre>

<p>Okay, 它是怎么工作的？ 今天的 Advent 的盒子就是为了给你提供答案.
Perl 6 有一些不同的&rdquo;元操作符&rdquo;是用来修改现有的运算符完成更加强大的功能.
这个方括号中是一个有关“reduce metaoperator”的元操作符的例子,它是中缀运算符,会变成列表操作,操作是在后面各个元素的中间来, 例如,表达式</p>

<pre><code class="language-perl6"> [+] 1, $a , 5, $b
</code></pre>

<p>它相当于</p>

<pre><code class="language-perl6">   1 + $a + 5 + $b
</code></pre>

<p>这为我们提供了非常便利的机制“计算整个列表中的所有元素之和”：</p>

<pre><code class="language-perl6">$sum = [+] @a ; # @a 中所有元素之和
</code></pre>

<p>更多的中缀运算符(包含用户自己定义的),都能放到这个方括号来减少操作符;</p>

<pre><code class="language-perl6">$prod   = [*] @a ;         # 相乘 @a 中所有的元素
$mean   = ([+] @a ) / @a ; # 计算 @a 的平均值
$sorted = [&lt;=] @a ;        # 如果 @a 元素是数字排序就为 true
$min    = [min] @a , @b ;  # find the smallest element of @a and @b combined
</code></pre>

<p>在那个阶乘的子函数中,表达示 <code>[*] 1..$n</code> 返回全部 <code>1</code> 到 <code>$n</code> 之间所有乘数的乘积.</p>

<p>另一个非常有用的元操作符是 &ldquo;hyper&rdquo; 操作符,放置 <code>&gt;&gt;</code>（与<code>|</code>或）<code>&lt;&lt;</code> 在操作符的二边(一边),使得那个操作 &ldquo;hyper&rdquo;（更亢奋）.这个是用来操作列表中所有的成员,来进行这个包起来的运算符的操作.象下面的例子,我们来打算从 @a 和 @b 中成对的取出数据来进行运算后存入 @c.</p>

<pre><code class="language-perl6">@c = @a &gt;&gt;+&lt;&lt; @b ;
</code></pre>

<p>如果是在 Perl 5 中,我们需要写成象才面这样才能完成.</p>

<pre><code class="language-perl6">for ( $i = 0; $i &lt; @a ; $i ++) {
        $c [ $i ] = $a [ $i ] + $b [ $i ];
}
</code></pre>

<p>这只是有点长.</p>

<p>正如上面的方括号中,我们可以使用Hyper作用在各种运算符上,包括用户定义操作符：
  注：可以这样记忆 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符，它们就像是<code>漏斗</code>，<code>&lt;&lt;</code>  让元素从<code>右边</code>漏入，<code>&gt;&gt;</code> 让元素从<code>左边</code>漏入，然后进行运算。</p>

<pre><code class="language-perl6"># 对 @xyz 中所有的元素进行 ++ 的操作
@xyz &gt;&gt;++
</code></pre>

<pre><code class="language-perl6"># 从@a 和 @b 中找出最小的元素放到 @x 中
@x = @a   &gt;&gt;min&lt;&lt; @b ;
</code></pre>

<p>我们还可以<code>翻转&lt;&lt;的角度</code>,使标量的行为像一个<code>数组</code>：</p>

<pre><code class="language-perl6"># @a 中每个成员都乘 3.5  
my @a=2,4,6;
@b = @a   &gt;&gt;*&gt;&gt; 3.5;  
</code></pre>

<p>这其实相当于 <code>@b = @a   &gt;&gt;*&lt;&lt; (3.5,3.5,3.5）</code> 较短的向量会被自动循环使用！模仿 R 语言的短向量自动循环。
如果右边的向量没有左边的长，箭头就指向那个单个向量。</p>

<pre><code class="language-perl6"># @x 中每个成员都乘以 $m 然后在加 $b
@y = @x   &gt;&gt;*&gt;&gt; $m &gt;&gt;+&gt;&gt; $b ;
</code></pre>

<pre><code class="language-perl6"># 颠倒 @x 中所有的成员
@inv = 1  &lt;&lt;/&lt;&lt; @x ;
</code></pre>

<pre><code class="language-perl6"># concatenate @last, @first to produce @full
@full = ( @last   &gt;&gt;~&gt;&gt; ', ' )  &gt;&gt;~&lt;&lt; @first ;
</code></pre>

<pre><code class="language-perl6">&gt; my @string=&lt;I LOVE YOU&gt;
I LOVE YOU
&gt; @string &gt;&gt;~&gt;&gt;'-' &gt;&gt;~&gt;&gt; &quot;szx&quot;
I-szx LOVE-szx YOU-szx
</code></pre>

<p><code>&gt;&gt;~&lt;&lt;</code> 两侧的元素个数必须相同！
当然,reductions 和 hyper 操作符也能联合表达式</p>

<pre><code class="language-perl6">  # 计算 @x 的平方和
  $sumsq = [+] ( @x   &gt;&gt;**&gt;&gt; 2);
</code></pre>

<p>还有很多其他元操作符,包括X（cross交叉）,R（reverse反向）,S（顺序sequential）.事实上,这只是在恰当的位置放个运算符,如<code>+=,*=,?=</code>,只是元形式的后缀等号运算,它相当于：</p>

<pre><code class="language-perl6">$a += 5;     # same as $a = $a + 5;
$b = 7;      # same as $b = $b 7;
$c min= $d ; # same as $c = $c min $d;  
</code></pre>

<h2 id="static-types-和-multi-subs">static types 和 multi subs.</h2>

<hr />

<p>打开Advent 这第三个盒子,这次我们要读到什么啦？啊….真好.这次没想到有二个礼物.这个盒子中放着 <code>static types</code> 和 <code>multi subs</code>.
在 Perl 5 中,<code>$scalar</code> 的标量只能包含二种东西引用或值,这值可以是任何东西,能是整数,字符,数字,日期和你的名字.这通常是非常方便的,但并不明确.
在 Perl6 中给你机会修改标量的类型 .如果你这个值比较特别,你可以直接放个类型名在 <code>my</code> 和 <code>$variable</code> 的中间.象下面的例子,是在设置値一定要是一个 Int 型的数据,来节约 cpu 判断类型的时间,和让你更少的程序上出错.</p>

<pre><code class="language-perl6">my Int $days = 24;
</code></pre>

<p>其它的标量类型如下：</p>

<pre><code class="language-perl6">my Str $phrase   = &quot;Hello World&quot; ;
my Num $pi       = 3.141e0;
my Rat $other_pi = 22/7;
</code></pre>

<p>如果你还是想用老的设置值的方法,你可以不声明类型或使用 Any 的类型代替.</p>

<p>今天盒子中的第二个礼物 <code>multi subs</code> 也很容易,因为我们会手把手教你.到底什么是 <code>multi subs</code> ? 简单的来讲 <code>multi subs</code> 可以让我们 重载 <code>sub</code> 的名字 .当然 <code>Multi subs</code> 可以做更多其它的事情,所以下次其它作者的礼物中也会有这个,但现在我们会先介绍几个非常有用的一些 sub .</p>

<pre><code class="language-perl6">multi sub identify(Int $x) {
    return &quot;$x is an integer.&quot;;
}

multi sub identify(Str $x) {
    return qq&lt;&quot;$x&quot; is a string.&gt;;
}

multi sub identify(Int $x, Str $y) {
    return &quot;You have an integer $x, and a string \&quot;$y\&quot;.&quot;;
}

multi sub identify(Str $x, Int $y) {
    return &quot;You have a string \&quot;$x\&quot;, and an integer $y.&quot;;
}

multi sub identify(Int $x, Int $y) {
    return &quot;You have two integers $x and $y.&quot;;
}

multi sub identify(Str $x, Str $y) {
    return &quot;You have two strings \&quot;$x\&quot; and \&quot;$y\&quot;.&quot;;
}

say identify(42);
say identify(&quot;This rules!&quot;);
say identify(42, &quot;This rules!&quot;);
say identify(&quot;This rules!&quot;, 42);
say identify(&quot;This rules!&quot;, &quot;I agree!&quot;);
say identify(42, 24);
</code></pre>

<p>还有两个礼物很有优势吧.你可以尝试多使用他们,我们会不断的丰富这个 Advent 的树,并不断放更多的礼物,希望你能多来看看.</p>

<h2 id="comb-your-constraints">.comb your constraints</h2>

<hr />

<p>我们以前 advent 了解过的内容,对于今天所要介绍的礼物非常有用,今天要讲两个东西： comb 方法和 constraints 的概念。</p>

<p>constraints 和原来那章节中提到的<code>静态变量</code>定义的相同,constraints 可以让我们在写程序的时候就更方便的在子函数和方法上进行控制.</p>

<p>在很多其它的程序中,你可以通过参数调用子函数并可以在参数进入的时候就通过 <code>constraints</code> 来验证输入的内容.这样我们就能在程序声明的时候就验证输入的内容,不在需要等到程序运行的时候.</p>

<p>下面是一个基本的例子,如果是一个整数和偶数,在子函数中它会不能处理下去.在 Perl 5 中的实际基本就象下面这样子了：</p>

<pre><code class="language-perl6"> sub very_odd
 {
    my $odd = shift;
    unless ($odd % 2)
    {
        return undef;
    }
    # 在这接着处理奇数.
 }
</code></pre>

<p>在 Perl 6 中,我们可以只需要简单的：</p>

<pre><code class="language-perl6">  sub very_odd(Int $odd where {$odd % 2})
  {
        # 在这接着处理奇数.
  }
</code></pre>

<p>如果你试图来传入一个偶数来调用 very_odd.你会直接得到一个 error.不要担心：你可以使用 multi sub 的功能来给偶数一个机会:</p>

<pre><code class="language-perl6">  multi sub very_odd(Int $odd where {$odd % 2})
   {
       # Process the odd number here
  }
  multi sub very_odd(Int $odd) { return Bool::False; }
</code></pre>

<p>我们在使用成对的 <code>.comb</code> 方法时,这个 <code>constraints</code> 是非常有用.</p>

<p>为什么正好是 <code>.comb</code> ? 当我们早上梳整我们的头发时,我们先通常使用梳子来梳成你想要的样子(线条),然后在你的头上固定梳成的样子.前面讲的内容在这非常象.split.在这也一样,你<code>不是真想</code>要切开字符串,而是你想达到一个什么样目的.这一段简单的代码,来说明这两种目标：</p>

<pre><code class="language-perl6">  &gt;say &quot;Perl 6 Advent&quot;.comb(/&lt;alpha&gt;/).join('|');
  P|e|r|l|A|d|v|e|n|t
  &gt;say &quot;Perl 6 Advent&quot;.comb(/&lt;alpha&gt;+/).join('|');
  Perl|Advent
</code></pre>

<p>正则表达式有可能另一天会拿出来讲,但是我们先快速了解一下是没有坏处的.这个第一行,会输出 <code>P|e|r|l|A|d|v|e|n|t</code>. 它会取得每个字母然后放到一个暂时的数组中,然后使用 <code>join</code> 管道连接起来这是目的.第二行也有点象,但它捕获了更多的字母,会输出 <code>Perl|Advent</code> 这是第二个的目标单词.
这个 <code>.comb</code> 是非常非常强大,然而,你得到你梳出来的输出,你就能操作这个串了如果你有一个基本的ASCII十六进制字符的字符串,可以使用的 hyperoperators 超的操作符转变各自的块成为等效的 ASCII 字符！</p>

<pre><code class="language-perl6">say &quot;5065726C36&quot;.comb(/&lt;xdigit&gt;**2/)».fmt(&quot;0x%s&quot;)».chr
</code></pre>

<pre><code># Outputs &quot;Perl6&quot;
</code></pre>

<pre><code class="language-perl6">say &quot;5065726C36&quot;.comb(/&lt;xdigit&gt;**2/)
</code></pre>

<pre><code>50 65 72 6C 36
</code></pre>

<p><code>**</code>在正则里是量词，表示重复前面的十六进制数两次，合起来就是每两个字符分一下。</p>

<p>如果你提心这个,你可以使用 <code>.map</code> 的方法：</p>

<pre><code class="language-perl6">say &quot;5065726C36&quot;.comb(/&lt;xdigit&gt;**2/).map: { chr '0x' ~ $_ } ;
</code></pre>

<pre><code>#Outputs &quot;Perl6&quot;
</code></pre>

<p>记的,这是 Perl.做任何事情都不只一种方法.
今天给完了所有礼物,我现在向你挑战.有 KyleHasselbacher 的协助,我们能使用约束<code>.comb</code> 和 <code>.map</code> 做出一个像样的版本的古老的凯撒加密法.</p>

<pre><code class="language-perl6"> use v6;

 sub rotate_one( Str $c where { $c.chars == 1 }, Int $n ) {
    return $c if $c !~~ /&lt;alpha&gt;/;
    my $out = $c.ord + $n;
    $out -= 26 if $out &gt; ($c eq $c.uc ?? 'Z'.ord !! 'z'.ord);
    return $out.chr;
 }

 sub rotate(Str $s where {$s.chars}, Int $n = 3)
 {
    return ($s.comb.map: { rotate_one( $_, $n % 26 ) }).join( '' );
 }

 die &quot;Usage:\n$*PROGRAM_NAME string number_for_rotations&quot; unless @*ARGS == 2;

 my Str $mess   = @*ARGS[0];
 my Int $rotate = @*ARGS[1].Int;

 say qq|&quot;$mess&quot; rotated $rotate characters gives &quot;{rotate($mess,$rotate)}&quot;.|;
</code></pre>

<p>我希望你在休息的时候,可以使用目前为止在 Perl 6 中和今天的礼物中的学到的内容来编写编码算法.毕竟,编程语言本身只有更多的使用,才能让它变的更优秀.</p>

<h2 id="一个正则表达式的故事">一个正则表达式的故事</h2>

<hr />

<p>By perlpilot</p>

<p>在 advent 的第十天,我们有一个故事做为礼物……</p>

<p>曾几何时,在比你想象的更近的时候,一个叫 Tim 的学 Perl 6 程序的学生,工作中出现了一个简单的解析相关的问题.他的老板（我们叫他 C 先生）曾问过他,解析日志文件中包含着库存信息,确保在文件内是唯一有效的行.文件中每行内是这样的：
    <part number> <quantity> <color> <description></p>

<p>所以这个 Perl 6 的学生,他用熟悉正则表达式写了一个可爱的小正则表达式,可以用来找出有效的行.代码检查每行内容是这样写的：</p>

<pre><code class="language-perl6">next unless $line ~~ / ^^ \d+ \s+ \d+ \s+ \S+ \s+ \N* $$ /
</code></pre>

<p>使用 <code>~~</code> 操作符的原因是因为,右侧的正则表达式会匹配左侧标量.在正则内部,<code>^^</code> 是匹配行的开头,<code>\d+</code> 是用来匹配一个或者多个数字(由零件编号 part number 和数量 quantity 组成的),<code>\S+</code> 是用来匹配一个或者多个非空白字符,
 <code>\N*</code> 来匹配零个或者多个非换行符,<code>\s+</code> 匹配空白之间的这些东西和 <code>$$</code> 用来匹配行结束.
在 Perl 6 中,正则表达式的每个单独的部分可以使用空格来让它更具可读性,所以更加好,这个空格不会是正则的一部分只用来分隔.</p>

<p>但 C 先生决定最好信息的每个部分都可以从提取来验证. Tim 想了一下,“没问题,我只要使用括号来捕获”.下面就是全部需要做的：</p>

<pre><code class="language-perl6">next unless $line ~~ / ^^ (\d+) \s+ (\d+) \s+ (\S+) \s+ (\N*) $$ /
</code></pre>

<p>在成功的模式匹配以后,每个括号内都存着匹配到的对象本身(<code>$/</code>),可以通过 <code>$/[0]</code>,<code>$/[1]</code>,<code>$/[2]</code> 或 <code>$/[3]</code>.它可以通过特殊的变量 <code>$0</code>,<code>$1</code>,<code>$2</code>,<code>$3</code>访问.Tim 和他老板 C 先生都很高兴.</p>

<p>但随后发现了一些行中,没有从描述信息中给颜色信息分开,这些行其实也是有效的.在行中颜色信息和描述信息有个特殊的组合方式.他们总是象下面这样：</p>

<pre><code>&lt;part number&gt; &lt;quantity&gt; &lt;description&gt; (&lt;color&gt;)
</code></pre>

<p>在这像以前一样,可以加入包括任意数量的空格在字符中. Tim 认为,“现在这个本来简单的解析程序似乎突然更加复杂了”.幸运的是,Tim 可以找一个地方寻求帮助.他迅速登录到 <code>irc.freenode.org</code>,加入 <code>#perl6</code> 通道 并请求大家协助.有人建议他使用名字来命名他的正则表达式的各个部分,来使事情变得更容易.然后使用交替的方法来匹配这个正则表达式的最后一部分的多种可能.</p>

<p>首先,Tim 尝试给正则能捕获到的每个部分都加上一个名字,详细信息可以见 Perl 6 正则的纲要,下面是他所做的：</p>

<pre><code class="language-perl6">next unless $line ~~
    / ^^ $&lt;product&gt;=(\d+) \s+ $&lt;quantity&gt;=(\d+) \s+ $&lt;color&gt;=(\S+) \s+ $&lt;description&gt;=(\N*) $$ /
</code></pre>

<p>现在,成功的匹配后,每各部分都可以匹配到对象中不同的东西,通过特殊的变量 <code>$&lt;Product&gt;</code>,<code>$&lt;quantity&gt;</code>,<code>$&lt;color&gt;</code> 和 <code>$&lt;description&gt;</code>.
这比预期的更容易,让 Tim 感到非常有信心.接着,他需要补充：交替区分两种不同的有效行：</p>

<pre><code class="language-perl6">next unless $line ~~ / ^^
    $&lt;product&gt;=(\d+) \s+ $&lt;quantity&gt;=(\d+) \s+
    [
    | $&lt;description&gt;=(\N*) \s+ '(' $&lt;color&gt;=(\S+) ')'
    | $&lt;color&gt;=(\S+) \s+ $&lt;description&gt;=(\N*)
    ]
  $$
/
</code></pre>

<p>为了从正则表达式中的交替和其余部分隔离开,Tim 使用了分组括号（<code>[ and ]</code>）在要交替检查的部分.
这个分组是正则的一部分,其中像圆括号是唯一没有捕捉到 <code>$0</code> 的, 由于必须匹配到精确的圆括号, Tim 使用了另一个有用的 Perl6 正则表达式的优势：带引号的字符串字面匹配.因为分配给正则表达式的中 <code>$&lt;color&gt;</code> 和 <code>$&lt;description&gt;</code> 总是会在适当部分包含字符串.</p>

<p>Tim 非常的扬眉吐气！他展示了他的代码给 Mr.C,并表扬到 &ldquo;干得好 Tim！&rdquo;;</p>

<p>然而,经过成功过后,Tim 开始以更挑剔的眼光来看他的工作.对于一些行中描述之后颜色,它有可能是 <code>( color)</code> or <code>(color )</code> or<code>( color )</code>.他目前正则表达式是正常的,但如果描述中包括的颜色的部分象前面一样时,并不是所有匹配颜色的会设置 <code>$&lt;color&gt;</code>. Tim 初步修复,通过加入更多的 <code>\s*</code>：</p>

<pre><code class="language-perl6">next unless $line ~~ / ^^
    $&lt;product&gt;=(\d+) \s+ $&lt;quantity&gt;=(\d+) \s+
    [
    | $&lt;description&gt;=(\N*) \s+ '(' \s* $&lt;color&gt;=(\S+) \s* ')'
    | $&lt;color&gt;=(\S+) \s+ $&lt;description&gt;=(\N*)
    ]
  $$
/
</code></pre>

<p>这运行的非常良好,但正则表达式的开始显得有点凌乱.Tim 再次使用 #perl6 来让人帮助.</p>

<p>这时候有个名叫 PerlJam 告诉他,“你为什么不把你的正则表达式放到 <code>grammar</code> 中？这可以让你分配给每片到变量来匹配对象”“ Wha?? Tim 不知道 PerlJam 讲的是什么.通过简短的交流后,Tim 了解后,并知道在哪里查看必须的相关信息后.然后感谢 PerlJam,并在次回到了程序上.这一次的正则表达式几乎消失,因为它使用了 grammar.什么是 grammar ？,看下面匹配的代码：</p>

<pre><code class="language-perl6">grammar Inventory {
    regex product     { \d+ }
    regex quantity    { \d+ }
    regex color       { \S+ }
    regex description { \N* }
    regex TOP { ^^ &lt;product&gt; \s+ &lt;quantity&gt;  \s+
                [
                | &lt;description&gt; \s+ '(' \s* &lt;color&gt; \s*  ')'
                | &lt;color&gt; \s+ &lt;description&gt;
                ]
                $$
    }
}
# ...在来到代码开始的地方
next unless Inventory.parse($line);
</code></pre>

<p>以前的正则表达式中各自的变量变成了 grammar 中的命名正则表达式.在 Perl 6 的正则表达式中的命名正则是由括在尖括号内的名称来匹配（<code>&lt; and &gt;</code>）.当 <code>Grammar.parse</code> 调用来匹配一个标量时（会操作这特定的命名正则 <code>TOP</code>）行为是完全和以前一样,因为命名的正则表达相当于其它正则表达式的一部分,匹配的文本保存到匹配对象中,并引用该名称.</p>

<p>虽然仍然有改进的余地,Tim 和 Mr.C 对这个结果感到非常高兴.</p>

<p>完
注：默认情况下,允许启用空格注解； 所以,虽然在 Perl 5 中您可以用“hello there”本身来匹配“hello there”,但在 Perl 6 中,您必须将其改为 /hello <code>&lt;sp&gt;</code> there/.这样就可以在正则表达中将条件清晰地分离开来.</p>

<p>Perl 6 正则表达式可以被复用.在匹配单一的词时,复用正则表达式是很荒谬的；但在解析配置文件时,几乎必须要复用正则表达式（这取决于配置文法的复杂度、发生修改的频率等）.这样性能也会高很多.</p>

<p>在 Perl 5 中, Regexp::Common 模块,已经在尝试复用正则表达式,但是,因为 Perl 5 不允许复用正则表达式,所以不得不将它们封装在一个模块接口中. Perl 6 完全支持这种复用.
<a href="http://www.ibm.com/developerworks/cn/linux/l-cpregex.html">其它参数资料：</a></p>

<h2 id="类-属性-方法和其它">类, 属性, 方法和其它</h2>

<hr />

<p>By jnthnwrthngtn</p>

<p>我非常兴奋地撕下今天的礼物上闪亮的包装纸,里面是无可争议的 Perl 6 的对象模型,它内置了其类声明,角色组成,自豪的元模型(meta-model).除了有先进的功能外,让我们看看在 Perl 6 中是多么容易写一个类.</p>

<pre><code class="language-perl6">class Dog {
    has $.name;
    method bark($times) {
        say &quot;w00f! &quot; x $times;
    }
}
</code></pre>

<p>我们开始使用一个 class 的关键字.如果你有学过 Perl5 的话,你能想到的类有点像包(package)的变种,这个关键字为您提供一个优雅的语义.</p>

<p>接下来,我们使用 has 的关键字来声明属性访问器方法.这个&rdquo;.&ldquo;的东西名叫 twigil. Twigil 是用来告诉你指定变量的作用域.它是&rdquo;属性 + 存取方法&rdquo;的组合.它的选项是：</p>

<pre><code class="language-perl6">has $!name;       # 私有; 只能在内部可见
has $.name is rw; # Generates an l-value accessor
</code></pre>

<p>接下来是方法的使用,并介绍使用 method 的关键字.在对象中的方法象包中的子函数,不同之处在于方法是放在类的方法列表的条目中.
它还能自动取得调用者(invocant),所以你如果没有在参数列表中加入参数.它是会给自我传递过去.在 Perl 5 中需要我们显示的写 <code>$self = shift</code>.</p>

<p>所有的类都继承一个叫 new 的默认的构造器,会自动的映射命名参数到属性,所有传进的参数会存到属性中.我们可以调用 Dog 的构造器(这个 Dog 的类的对象,并取得一个新的实例).</p>

<pre><code class="language-perl6">my  $fido = Dog.new(name =&gt; 'Fido');
say $fido.name;  # Fido
$fido.bark(3);   # w00f! w00f! w00f!
</code></pre>

<p>请注意,Perl 6 中的方法调用操作符是&rdquo;.&ldquo;而不是 Perl 5 中使用的&rdquo;-&gt;&ldquo;.它缩短了 50％ 并更加合适从其他语言转过来的开发人员.</p>

<p>当然,很容易实现继承,下面我们建一个叫 puppy 子类 ,直接使用 is 加父类的名字就行了.</p>

<pre><code class="language-perl6">class Puppy is Dog {
    method bark($times) {
        say &quot;yap! &quot; x $times;
    }
}
</code></pre>

<p>这也支持委托,详细作用见下面的 FQA.</p>

<pre><code class="language-perl6">class DogWalker {
    has $.name;
    has Dog $.dog handles (dog_name =&gt; 'name');
}
my $bob = DogWalker.new(name =&gt; 'Bob', dog =&gt; $fido);
say $bob.name;      # Bob
say $bob.dog_name;  # Fido
</code></pre>

<p>在这里,我们声明指出我们想调用 DogWalker 类的名为 dog_name 的方法,并设置这个方法转到 Dog 类中包含名为 name 的方法.重命名只是其中的一个可选方式;委托常常有很多其它的实现方法.</p>

<p>内心深层之美比外在更加重要.所以,在整洁的语法之下是使用 meta-model(元模型)想法来实现对象.类,属性和方法都是 Perl 6 中最重要和 Meta-object 的.我们可以在运行时使用这些内省对象.</p>

<pre><code class="language-perl6">for Dog.^methods(:local) -&gt; $meth {
    say &quot;Dog has a method &quot; ~ $meth.name;
}
</code></pre>

<p>这个 <code>.^</code> 的操作是 <code>.</code> 操作的变种,用来替换元类(metaclass-描述类的这个对象)的调用.在这里,我们提供该类所定义的方法(Method)的列表,我们使用  <code>:local</code> 来排除那些从父类的继承. 这不只是给我们一个名字列表,而是方法对象的列表.其实我们直接使用这个对象来调用方法,但在这种情况下,我们只要它的名字就行.</p>

<p>让你了解 Meta-programming 并附送一个扩展 Perl6 的对象的功能：只要你知道声明一个方位,使用 method 的关键字让它在编译时在调用元类中的  add_method 来变成实际的方法.所以在 Perl 6 中,不仅为您提供了强大的对象模型,但也提供了机会,用来实现其它的特性,以满足未来我们还没有想到的需求.</p>

<p>这些都只是 Perl 6 的对象模型所提供的伟大的事情中的一些,也许我们会发现更多的东西在其他礼品中. :-)</p>

<p>注：
面向对象的概念</p>

<p>首先,我们定义几个预备性的术语.</p>

<pre><code class="language-perl6">构造器 (constructor):   创建一个对象的函数.
实例 (instance)：  一个对象的实例化实现.
标识 (identity)：  每个对象的实例都需要一个可以唯一标识这个实例的标记.
实例属性 (instance attribute)：  一个对象就是一组属性的集合.
实例方法 (instance method)：  所有存取或者更新对象某个实例一条或者多条属性的函数的集合.
类属性(class attribute)：  属于一个类中所有对象的属性,不会只在某个实例上发生变化.
类方法(class method)：  那些无须特定的对性实例就能够工作的从属于类的函数.
委托 (Delegation)： 　在对象需要执行某个工作时并不直接处理，而是要求另一个对外象代为处理(有时只处理部分工作),所以这时第二个对象代表第一个对象来执行该操作。
调用者(invocant):   对类来讲,调用者是包的名字,对实例方法来讲,调用者是指定对象的引用.换句话讲,调用者就是调用方法的那种东西,有的文章叫他为代理(agent)施动者(actor).
抽象类(abstract class):抽象类实现类的占位符，主要用来定义行为，而子类用来实现这个行为。
</code></pre>

<h2 id="arguments-and-parameters">arguments and parameters</h2>

<hr />

<p>By carl</p>

<p>在第９天的 advent 中…我打开了　…这是有关 parameters 和 arguments
你也许了解或者不了解 Perl5 的 是怎么处理函数参数的.先让你看看,它通常象下面的这个例子这样：</p>

<pre><code class="language-perl6">sub sum {
   [+] @_
}
say sum 100, 20, 3; # 123
</code></pre>

<p>这个 [+] 是在 Perl 6 中的,但我们也可以写成 Perl 5 风格的</p>

<pre><code class="language-perl6">my $i = 0;
$i _= $_ for @_;
$i;
</code></pre>

<p>我们要想到上面这些区别,这些在 Perl 6 中非常重要,也就是为什么我们讲 Perl 6 比 Perl 5 好.当你调用函数时.你可以从 @_ 找到你的参数.你然后取出它们来做一些操作.
这是非常灵活的.因为它不会对参数做任何默认的处理,程序会全部传给你来进行处理.当然这也同样是令人厌烦因为样样都要自己处理,但很方便我们来进行扩展进行参数的检查,看下面这个虚构的例子.</p>

<pre><code class="language-perl6">sub grade_essay {
  my ($essay, $grade) = @_;
  die 'The first argument must be of type Essay'
    unless $essay ~~ Essay;
  die 'The second argument must be an integer between 0 and 5'
    unless $grade ~~ Int &amp;&amp; $grade ~~ 0..5;

  %grades{$essay} = $grade;
}
</code></pre>

<p>(如果在 Perl 5 中,你需要使用 isa 来替换　~~　和使用 %grades 来替换成 $grades 才能正常工作.除了这些,都在 Perl6 中工作)</p>

<p>现在,这一刻,看看上面的内容,看到手册中的参数验证的实现,你是不是开始有点绝望吗？你感觉到了吧？好.
在 Perl 5 中的解决方法是使用优秀的 CPAN 模块,象 <code>Sub::Signatures</code> 和 <code>MooseX::Declare</code>,然后在你的程序中使用这些模块,并按照模块设置就行了.</p>

<p>在 Perl 6 的中的解决方法是,给你参数设置默认范围. 我在想看了下面这些时, “请确保键盘前的你不会流口水”.在 Perl 6 中,我会写这样来写子函数：</p>

<pre><code class="language-perl6">sub grade_essay(Essay $essay, Int $grade where 0..5) {
  %grades{$essay} = $grade;
}
</code></pre>

<p>现在我们见到,在这程序运行会对这个长版本的参数进行检查,没有必要在导入其它的 CPAN 的模块了.</p>

<p>有时,我们可以提供一些默认的值给参数：</p>

<pre><code class="language-perl6">sub entreat($message = 'Pretty please, with sugar on top!', $times = 1) {
    say $message for ^$times;
}
</code></pre>

<p>如果这些参数的默认的值是不固定的,可以使用老的方式来传参数.</p>

<pre><code class="language-perl6">sub xml_tag ($tag, $endtag = matching_tag($tag) ) {...}
</code></pre>

<p>如果您的参数是不确定的,对这种可选的参数可以加一个 ? 的标记.</p>

<pre><code class="language-perl6">sub deactivate(PowerPlant $plant, Str $comment?) {
  $plant.initiate_shutdown_sequence();
  say $comment if $comment;
}
</code></pre>

<p>有一个特性,我特别喜欢,我们可以在调用时通过参数名字来引用参数,这样你可以以喜欢的任何顺序传递命名参数.这样会永远记得在这个函数中参数本来的顺序：</p>

<pre><code class="language-perl6">sub draw_line($x1, $y1, $x2, $y2) { ... }

draw_line($x1, $y1, $x2, $y2); # phew. got it right this time.
draw_line($x1, $x2, $y1, $y2); # dang! :-/
</code></pre>

<p>这的方法是引用参数的名字,来使得这个问题被解决：</p>

<pre><code class="language-perl6">draw_line(:x1($x1), :y1($y1), :x2($x2), :y2($y2)); # works
draw_line(:x1($x1), :x2($x2), :y1($y1), :y2($y2)); # also works!
</code></pre>

<p>冒号的意思是 &ldquo;这来自命名参数&rdquo;, 整个结构读作:name_of_parameter($variable_passed_in).这可以使用的参数和变量具有相同的名称,但有一个简短形式：</p>

<pre><code class="language-perl6">draw_line(:$x1, :$y1, :$x2, :$y2); # works
draw_line(:$x1, :$x2, :$y1, :$y2); # also works!
</code></pre>

<p>我喜欢短形式.我觉得它使我的代码更具可读性.</p>

<p>如果作为 API 的作者,要强迫别人使用命名参数 – 例如还是在 draw_line 的情况下 – 你只需要提供在子程序参数前的冒号.</p>

<pre><code class="language-perl6">sub draw_line(:$x1, :$y1, :$x2, :$y2 ) { ... } # optional nameds
</code></pre>

<p>但要小心注意,命名参数默认是可选的.换句话说,上述内容相当于：</p>

<pre><code class="language-perl6">sub draw_line(:$x1?, :$y1?, :$x2?, :$y2?) { ... } # optional nameds
</code></pre>

<p>如果你想明确地指出必需的参数,可以追加！对下面的这些参数：</p>

<pre><code class="language-perl6">sub draw_line(:$x1!, :$y1!, :$x2!, :$y2!) { ... } # required nameds
</code></pre>

<p>现在调用这个,就像他们是普通的顺序位置参数传递进来.</p>

<p>关于可变参数呢？假如你想传递的参数是不确认多少个数量,比如参数是数组,可以在它前面带有“*”：</p>

<pre><code class="language-perl6">sub sum(*@terms) {
  [+] @terms
}
say sum 100, 20, 3;  # 123
</code></pre>

<p>我使用同样的例子来提出一个观点：当你不提供任何符号到您的子程序时,你最终是得到的符号其实是是 <code>*@_</code> .这是模拟 Perl 5 中的行为.</p>

<p>但数组前面的 * 号是仅用来捕获的位置参数(positional arguments).如果你想捕捉命名参数(named arguments),你要使用 “slurpy hash”：</p>

<pre><code class="language-perl6">sub detect_nonfoos(:$foo!, *%nonfoos) {
  say &quot;Besides 'foo', you passed in &quot;, %nonfoos.keys.fmt(&quot;'%s'&quot;, ', ');
}

detect_nonfoos(:foo(1), :bar(2), :baz(3));
# Besides 'foo', you passed in 'bar', 'baz'
</code></pre>

<p>哦,这可能是一个很好的通过以命名的参数传递哈希的方法,像这样：</p>

<pre><code class="language-perl6">detect_nonfoos(foo =&gt; 1, bar =&gt; 2, baz =&gt; 3);
# Besides 'foo', you passed in 'bar', 'baz'
</code></pre>

<p>这里的 Perl 5 中的一个重要区别：默认参数是只读的：</p>

<pre><code class="language-perl6">sub increase_by_one($n) {
  ++$n
}

my $value = 5;
increase_by_one($value); # boom
</code></pre>

<p>在这让参数只读,主要有两个原因,其一为了效率.当变量只读时可以使其最佳化,其二要鼓励程序员写程序时有个正确的习惯,只会有一点点不习惯.
所以这个功能不仅是为优化好,更是为了让你有个更好的灵魂.</p>

<p>下面是你需要做的工作：</p>

<pre><code class="language-perl6">sub increase_by_one($n is rw) {
   ++$n
}

my $value = 5;
say increase_by_one($value); # 6
</code></pre>

<p>有时可能你想让你的这个参数可以读写(RW),但是有时你可能更想修改传进来的参数复本.当你想使用这个 copy 时:</p>

<pre><code class="language-perl6">sub format_name($first, $middle is copy, $last) {
    $middle .= substr(0, 1);
    &quot;$first $middle. $last&quot;
}
</code></pre>

<p>原内容将保持不变.</p>

<p>在 Perl 6 中,当传递一个数组或哈希时,默认情况下它并不会给数组和哈希拉平成几个参数.相反,当你想让参数扁平化时可以使用&rdquo;|&ldquo;.</p>

<pre><code class="language-perl6">sub list_names($x, $y, $z) {
    &quot;$x, $y and $z&quot;
}

my @ducklings = &lt;huey dewey louie&gt;;
try {
    list_names(@ducklings);
}
say $!; # 'Not enough positional parameters passed;
# got 1 but expected 3'
say list_names(|@ducklings); # 'huey, dewey and louie'
</code></pre>

<p>同样,如果扁平化一个哈希,其参数内容将作为命名的参数(named arguments)发送到函数.</p>

<p>正如您传送数组和哈希一样,你也可以传送代码块：</p>

<pre><code class="language-perl6">sub traverse_inorder(TreeNode $n, &amp;action) {
    traverse_inorder($n.left, &amp;action) if $n.left;
    action($n);
    traverse_inorder($n.right, &amp;action) if $n.right;
}
</code></pre>

<p>下面前三个印记符号(@ % &amp; )其实是类型约束：</p>

<pre><code class="language-perl6">@ Array (actually, Positional)
% Hash (actually, Associative)
&amp; Code (actually, Callable)

$ 的印记是工作在不受约束的版本.
</code></pre>

<p>当心！常出的简单的小陷阱是人们常常落入指定类型约束两次,还都是同一个类型：</p>

<pre><code class="language-perl6">sub f(Array @a) { ... } # WRONG, unless you mean Array of Array
sub f( @a)      { ... } # probably what you meant
sub f(Int @a)   { ... } # Array of Int
</code></pre>

<p>你学到这,你应得的另一个 Perl6 单行…</p>

<pre><code class="language-perl6">$ perl6 -e '.fmt(&quot;%b&quot;).trans(&quot;01&quot; =&gt; &quot; #&quot;).say for &lt;734043054508967647390469416144647854399310&gt;.comb(/.**7/)'
</code></pre>

<h2 id="going-to-the-rats">Going to the Rats</h2>

<hr />

<p>As I hinted at back in the in the Day 1 post, Perl 6 has rational numbers. They are created in the most straightforward fashion, by dividing an integer with another integer. But it can be a bit hard to see that there is anything unusual about the result:</p>

<pre><code class="language-perl6">&gt; say (3/7).WHAT
Rat()
&gt; say 3/7
0.428571428571429
</code></pre>

<p>When you convert a Rat to a Str (for example, to “say” it), it converts to a decimal representation. This is based on the principle of least surprise: people generally expect <sup>1</sup>&frasl;<sub>4</sub> to equal 0.25. But the precision of the Rat is exact, rather than the approximation you’d get from a floating point number like a Num:</p>

<pre><code class="language-perl6">&gt; say (3/7).Num + (2/7).Num + (2/7).Num - 1;
-1.11022302462516e-16
&gt; say 3/7 + 2/7 + 2/7 - 1
0
</code></pre>

<p>The most straightforward way to see what is going on inside the Rat is to use the .perl method. .perl is a standard Perl 6 method which returns a human-readable string which, when eval’d, recreates the original object as closely as is possible:</p>

<pre><code class="language-perl6">&gt; say (3/7).perl
3/7
You can also pick at the components of the Rat:
&gt; say (3/7).numerator
3
&gt; say (3/7).denominator
7
&gt; say (3/7).nude.perl
[3, 7]
</code></pre>

<p>All the standard numeric operators and operations work on Rats. The basic arithmetic operators will generate a result which is also a Rat if that is possible; the rest will generate Nums:</p>

<pre><code class="language-perl6">&gt; my $a = 1/60000 + 1/60000; say $a.WHAT; say $a; say $a.perl
Rat()
3.33333333333333e-05
1/30000
&gt; my $a = 1/60000 + 1/60001; say $a.WHAT; say $a; say $a.perl
Num()
3.33330555601851e-05
3.33330555601851e-05
&gt; my $a = cos(1/60000); say $a.WHAT; say $a; say $a.perl
Num()
0.999999999861111
0.999999999861111
</code></pre>

<p>(Note that the <sup>1</sup>&frasl;<sub>60000</sub> + <sup>1</sup>&frasl;<sub>60000</sub> didn’t work in the last official release of Rakudo, but is fixed in the Rakudo github repository.)
There also is a nifty method on Num which creates a Rat within a given tolerance of the Num (default is 1e-6):</p>

<pre><code class="language-perl6">&gt; say 3.14.Rat.perl
157/50
&gt; say pi.Rat.perl
355/113
&gt; say pi.Rat(1e-10).perl
312689/99532
</code></pre>

<p>One interesting development which has not made it into the main Rakudo build yet is decimal numbers in the source are now spec’d to be Rats. Luckily this is implemented in the ng branch, so it is possible to demo how it will work once it is in mainstream Rakudo:</p>

<pre><code class="language-perl6">&gt; say 1.75.WHAT
Rat()
&gt; say 1.75.perl
7/4
&gt; say 1.752.perl
219/125
</code></pre>

<p>One last thing: in Rakudo, the Rat class is entirely implemented in Perl 6. The source code is thus a pretty good example of how to implement a numeric class in Perl 6.</p>

<h2 id="pick-your-game">.pick your game</h2>

<hr />

<p>December 15, 2009
又一个大学学期结束了，或者快要结束了，对于身在美国的大多数来说。这个礼物会有些乐趣，他可以 .pick 东西。
.pick 允许从一个列表中选择随机的元素，先来看看Perl5 的语法：</p>

<pre><code class="language-perl6">my @dice = (1, 2, 3, 4, 5, 6);
my $index = int (rand() * scalar @dice);
print $dice[$index] . &quot;\n&quot;;
</code></pre>

<blockquote>
<p>5</p>
</blockquote>

<p>Perl 6 可以简化这，同时能选择多个元素.</p>

<pre><code class="language-perl6">my @dice = 1..6;
say @dice.pick(2).join(&quot; &quot;);
</code></pre>

<pre><code>&gt; 3 4
</code></pre>

<p>仅仅使用一套骰子，你就可以和你的朋友们进行角色扮演的会话了。现在让我们看看使用 10 次6面的骰子会有多少攻击：</p>

<pre><code class="language-perl6">my @dice = 1..6;
say @dice.pick(10).join(&quot; &quot;);
</code></pre>

<pre><code>&gt; 5 3 1 4 2 6
</code></pre>

<p>对那些怀疑者，上面的结果并非拼写错误。 <code>.pick</code> 的行为实际上和它的名字是一致的。当你把某个东西选出来，你通常不会把它放回去了。如果你想把它们再放回去，允许同一个项目被再次选中，请在第二个参数中使用副词 :repalce。</p>

<pre><code class="language-perl6">my @dice = 1..6;
say @dice.pick(10, :replace).join(&quot; &quot;);
</code></pre>

<pre><code>&gt; 4 1 5 6 4 3 3 5 1 1
</code></pre>

<p>Note to game masters: don’t invite me to your D&amp;D games unless you need someone with terrible dice luck. ;)
There is no specific order the list items have to be in for .pick to work its magic. Take the values of monopoly money, for instance:</p>

<pre><code class="language-perl6">my @dice = &lt;1 5 10 20 50 100 500&gt;;
say @dice.pick(10, :replace).join(&quot; &quot;);
</code></pre>

<pre><code>&gt; 20 50 100 500 500 10 20 5 50 20
</code></pre>

<p>When dice aren’t available, a deck of cards is usually on hand. This version is very basic, but is meant to get ideas going.</p>

<pre><code class="language-perl6">use v6;
class Card
{
  has $.rank;
  has $.suit;

  multi method Str()
  {
    return $.rank ~ $.suit;
  }
}

my @deck;
for &lt;A 2 3 4 5 6 7 8 9 T J Q K&gt; -&gt; $rank
{
  for &lt;♥ ♣ ♦ ♠&gt; -&gt; $suit
  {
    @deck.push(Card.new(:$rank, :$suit));
  }
}
# Shuffle the cards.
@deck .= pick(*);
say @deck.Str;
</code></pre>

<pre><code>&gt; Not outputting the results here.
</code></pre>

<p>What does the pick(*) do? Call that a sneak peak for another gift. For now, see if you can improve on the card code and make a deck class.
With that, I hope I have proven that Perl 6 is fun. It certainly gets a high mark from me. ✓</p>

<h2 id="whatever">Whatever</h2>

<hr />

<p>by Moritz</p>

<p>Whatever 在 Perl 6 中是一种类型，在它出现的上下文中，Whatever 代表着它知道的任何东西。
例子：</p>

<pre><code class="language-perl6">1..*                 # infinite range
my @x = &lt;a b c d e&gt;;
say @x[*-2]          # indexing from the back of the array
                     # returns 'd'
say @x.map: * ~ 'A'; # concatenate A to whatever the
                     # thing is we pass to it
say @x.pick(*)       # randomly pick elements of @x
                     # until all are used up

say @array[*-5] 等价于：
say @array[-&gt; $x { $x-5 }]; # $x 是数组元素的个数

my $make-index = -&gt; $x { $x-5 };
say @array[$make-index];
</code></pre>

<p>所以这是怎么回事？
有些用法看起来很明显： <code>*</code> 在 <code>term</code> 位置上会产生一个 <code>Whatever</code> 对象， 并且有些内置函数(例如 List.pick) 知道怎么处理这个 <code>Whatever</code> 对象。
编辑器读取代码后， 知道怎么解析项和操作符：</p>

<pre><code class="language-perl6">say  2 + 4
|    | | |
|    | | + term (literal number)
|    | + operator (binary +)
|    +  term (literal number)
+ term (listop), which expects another term
</code></pre>

<p>所以，当你写下：
<code>* * 2</code>
编译器会把 第一个 <code>*</code> 解释为 <code>项</code>， 把第二个 <code>*</code> 解释为 <code>操作符</code>
上面那行代码生成了一个代码块： <code>* * 2</code> 等价于 <code>-&gt; $x { $x * 2 }</code>， 你可以想任何其它子例程或 <code>block</code> 一样调用它：</p>

<pre><code class="language-perl6">my $x = * * 2;
say $x(4);     # says 8
</code></pre>

<p>同样地：</p>

<pre><code class="language-perl6">say @x.map: * ~ 'A';
</code></pre>

<p>等价于</p>

<pre><code class="language-perl6">say @x.map: -&gt; $x { $x ~ 'A' };
</code></pre>

<p>而</p>

<pre><code class="language-perl6">say @x.map: *.succ;
</code></pre>

<p>等价于</p>

<pre><code class="language-perl6">say @x.map: -&gt; $x { $x.succ };
</code></pre>

<p>Whatever 在排序时很有用 — 例如， 根据数字大小排序( 前缀 &lsquo;+&rsquo; 意味着获取某个东西的数字值)：</p>

<pre><code class="language-perl6">@list.sort: +*
</code></pre>

<p>等价于：</p>

<pre><code class="language-perl6">my $desc = -&gt; $a, $b { $a &lt;=&gt; $b }
@list.sort: $desc
</code></pre>

<p>而把列表元素作为字符串排序  (前缀 &lsquo;~&rsquo; 意思是获取某个东西的字符串值)：</p>

<pre><code class="language-perl6">@list.sort: ~*
</code></pre>

<h2 id="junctions">Junctions</h2>

<hr />

<p>December 13, 2009
Among the many exciting things in Perl 6, junctions are one of my favourites. While I know I don’t really comprehend everything you can do with them, there are a few useful tricks which I think most people will appreciate, and it is those which I’m going to cover as today’s gift.
Junctions are values which have (potentially) more than one value at once. That sounds odd, so let’s get thinking about some code which uses them. First, let’s take an example. Suppose you want to check a variable for a match against a set of numbers:</p>

<pre><code class="language-perl6">if $var == 3 || $var == 5 || $var == 7 { ... }
</code></pre>

<p>I’ve never liked that kind of testing, seeing as how it requires much repetition. With an any junction we can rewrite this test:</p>

<pre><code class="language-perl6">if $var == any(3, 5, 7) { ... }
</code></pre>

<p>How does this work? Right near the core of Perl 6 is a concept called junctive autothreading. What this means is that, most of the time, you can pass a junction to anything expecting a single value. The code will run for each member of the junction, and the result will be all those results combined in the same kind of junction which was originally passed.
In the sample above, the infix:&lt;==&gt; operator is run for each element of the junction to compare them with $var. The results of each test are combined into a new any junction, which is then evaluated in Boolean context by the if statement. An any junction in Boolean context is true if any of its values are true, so if $var matches any value in the junction, the test will pass.
This can save a lot of duplicated code, and looks quite elegant. There’s another way to write it, as any junctions can also be constructed using the infix:&lt;|&gt; operator:</p>

<pre><code class="language-perl6">if $var == 3|5|7 { ... }
</code></pre>

<p>What if you want to invert this kind of test? There’s another kind of junction that’s very helpful, and it’s called none:</p>

<pre><code class="language-perl6">if $var == none(3, 5, 7) { ... }
</code></pre>

<p>As you may have guessed, a none junction in Boolean context is true only if none of its elements are true.
Junctive autothreading also applies in other circumstances, such as:</p>

<pre><code class="language-perl6">my $j = any(1, 2, 3);
my $k = $j + 2;
</code></pre>

<p>What will this do? By analogy to the first example, you can probably guess that $k will end up being any(3, 4, 5).
There is an important point to note in these examples. We’re talking about junctive autothreading, which should give you a hint. By the Perl 6 spec, the compiler is free to run these multiple operations on junctions in different threads so that they can execute in parallel. Much as with hyperoperators, you need to be aware that this could happen and avoid anything which would make a mess if run simultaneously.
The last thing I want to talk about is how junctions work with smartmatching. This is really just another instance of autothreading, but there are some other junction types which become particularly useful with smartmatching.
Say you have a text string, and you want to see if it matches all of a set of regexes:</p>

<pre><code class="language-perl6">$string ~~ /&lt;first&gt;/ &amp; /&lt;second&gt;/ &amp; /&lt;third&gt;/
</code></pre>

<p>Assuming, of course, you have defined regexes called first, secondand third. Rather like |, &amp; is an infix operator which creates junctions, this time all junctions which are only true if all their members are true.
The great thing about junctions is that they have this behaviour without the routine you’re passing them to having to know about it, so you can pass junctions to almost any library or core function and expect this kind of behaviour (it is possible for a routine to deliberately notice junctions and treat them how it prefers rather than using the normal autothreading mechanism). So if you have a routine which takes a value to smartmatch something against, you can pass it a junction and get that flexibility in the smartmatch for free. We use this in the Perl 6 test suite, with functions like Test::Util::is_run, which runs some code in another interpreter and smartmatches against its output.
To finish off, here are some other useful things you can do with junctions. First, checking if $value is present in @list:</p>

<pre><code class="language-perl6">any(@list) == $value
</code></pre>

<p>Junction constructors can work quite happily with the elements of arrays, so this opens up many possibilities. Others include:</p>

<pre><code class="language-perl6">all(@list) &gt; 0; # All members greater than zero?
all(@a) == any(@b); # All elements of @a present in @b?
</code></pre>

<p>Go experiment, and have fun!</p>

<h2 id="modules-and-exporting">Modules and Exporting</h2>

<hr />

<p>December 12, 2009
Today I’d like to talk about a fairly fundamental subject: libraries.
To write a library in Perl 6, we use the “module” keyword:</p>

<pre><code class="language-perl6">module Fancy::Utilities {
    sub lolgreet($who) {
        say &quot;O HAI &quot; ~ uc $who;
    }
}
</code></pre>

<p>Put that in Fancy/Utilities.pm somewhere in $PERL6LIB and we can use it like the following:</p>

<pre><code class="language-perl6">use Fancy::Utilities;
Fancy::Utilities::lolgreet('Tene');
</code></pre>

<p>That’s hardly ideal.  Just like in Perl 5, we can indicate that some symbols from the module should be made available in the lexical scope of the code loading the module.  We’ve got a rather different syntax for it, though:</p>

<pre><code class="language-perl6"># Utilities.pm
module Fancy::Utilities {
  sub lolgreet($who) is export {
    say &quot;O HAI &quot; ~ uc $who;
  }
}
</code></pre>

<pre><code class="language-perl6"># foo.pl
use Fancy::Utilities;
lolgreet('Jnthn');
If you don’t specify further, symbols marked “is export” are exported by default.  We can also choose to label symbols as being exported as part of a different named group:
module Fancy::Utilities {
sub lolgreet($who) is export(:lolcat, :greet) {
  say &quot;O HAI &quot; ~ uc $who;
}
sub nicegreet($who) is export(:greet, :DEFAULT) {
  say &quot;Good morning, $who!&quot;; # Always morning?
}
sub shortgreet is export(:greet) {
  say &quot;Hi!&quot;;
}
sub lolrequest($item) is export(:lolcat) {
  say &quot;I CAN HAZ A {uc $item}?&quot;;
}
}
</code></pre>

<p>Those tags can be referenced in the code loading this module to choose which symbols to import:</p>

<pre><code class="language-perl6">use Fancy::Utilities; # Just get the DEFAULTs
use Fancy::Utilities :greet, :lolcat;
use Fancy::Utilities :ALL; # Everything marked is export
Multi subs are export by default, so you only need to label them if you want to change that.
multi sub greet(Str $who) { say &quot;Good morning, $who!&quot; }
multi sub greet() { say &quot;Hi!&quot; }
multi sub greet(Lolcat $who) { say &quot;O HAI &quot; ~ $who.name }
Classes are just a specialization of modules, so you can export things from them as well.  In addition, you can export a method to make it available as a multi sub.  For example, the setting exports the “close” method from the IO class so you can call “close($fh);”
class IO {
    ...
    method close() is export {
        ...
    }
    ...
}
</code></pre>

<p>Perl 6 does support importing symbols by name from a library, but Rakudo does not yet implement it.</p>

<h2 id="roles">Roles</h2>

<hr />

<p>by jnthnwrthngtn
As the snow falls outside, we grab a glass of mulled wine – or maybe a cup of eggnog – to enjoy as we explore today’s exciting gift – roles!
Traditionally in object oriented programming, classes have taken on two tasks: instance management and re-use. Unfortunately, this can end up pulling classes in two directions: re-use wants them to be small and minimal, but if they’re representing a complex entity then they need to support all of the bits it needs. In Perl 6, classes retain the task of instance management. Re-use falls to roles.
So what does a role look like? Imagine that we are building up a bunch of classes that represent different types of product. Some of them will have various bits of data and functionality in common. For example, we may have a BatteryPower role.</p>

<pre><code class="language-perl6">role BatteryPower {
    has $.battery-type;
    has $.batteries-included;
    method find-power-accessories() {
        return ProductSearch::find($.battery-type);
    }
}
</code></pre>

<p>At first glance, this looks a lot like a class: it has attributes and methods. However, we can not use a role on its own. Instead, we must compose it into a class, using the does keyword.</p>

<pre><code class="language-perl6">class ElectricCar does BatteryPower {
    has $.manufacturer;
    has $.model;
}
</code></pre>

<p>Composition takes the attributes and methods – including generated accessors – from the role and copies them into the class. From that point on, it is as if the attributes and methods had been declared in the class itself. Unlike with inheritance, where the parents are looked at during method dispatch, with roles there is no runtime link beyond the class knowing to say “yes” if asked if it does a particular role.
Where things get really interesting is when we start to compose multiple roles into the class. Suppose that we have another role, SocketPower.</p>

<pre><code class="language-perl6">role SocketPower {
    has $.adapter-type;
    has $.min-voltage;
    has $.max-voltage;
    method find-power-accessories() {
        return ProductSearch::find($.adapter-type);
    }
}
</code></pre>

<p>Our laptop computer can be plugged in to the socket or battery powered, so we decide to compose in both roles.
class Laptop does BatteryPower does SocketPower {
}
We try to run this and…BOOM! Compile time fail! Unlike with inheritance and mix-ins, role composition puts all of the roles on a level playing field. If both provide a method of the same name – in this case, find-power-accessories – then the conflict will be detected as the class is being formed and you will be asked to resolve it. This can be done by supplying a method in our class that says what should be done.</p>

<pre><code class="language-perl6">class Laptop does BatteryPower does SocketPower {
    method find-power-accessories() {
        my $ss = $.adapter-type ~ ' OR ' ~ $.battery-type;
        return ProductSearch::find($ss);
    }
}
</code></pre>

<p>This is perhaps the most typical use of roles, but not the only one. Roles can also be taken and mixed in to an object (on a per-object basis, not a per-class basis) using the does and but operators, and if filled only with stub methods will act like interfaces in Java and C#. I won’t talk any more about those in this post, though: instead, I want to show you how roles are also Perl 6’s way of achieving generic programming, or parametric polymorphism.
Roles can also take parameters, which may be types or just values. For example, we may have a role that we apply to products that need to having a delivery cost calculated. However, we want to be able to provide alternative shipping calculation models, so we take a class that can handle the delivery calculation as a parameter to the role.</p>

<pre><code class="language-perl6">role DeliveryCalculation[::Calculator] {
    has $.mass;
    has $.dimensions;
    method calculate($destination) {
        my $calc = Calculator.new(
            :$!mass,
            :$!dimensions
        );
        return $calc.delivery-to($destination);
    }
}
</code></pre>

<p>Here, the ::Calculator in the square brackets after the role name indicates that we want to capture a type object and associate it with the name Calculator within the body of the role. We can then use that type object to call .new on it. Supposing we had written classes that did shipping calculations, such as ByDimension and ByMass, we could then write:</p>

<pre><code class="language-perl6">class Furniture does DeliveryCalculation[ByDimension] {
}
class HeavyWater does DeliveryCalculation[ByMass] {
}
</code></pre>

<p>In fact, when you declare a role with parameters, what goes in the square brackets is just a signature, and when you use a role what goes in the square brackets is just an argument list. Therefore you have the full power of Perl 6 signatures at your disposal. On top of that, roles are “multi” by default, so you can declare multiple roles with the same short name, but taking different types or numbers of parameters.
As well as being able to parametrize roles using the square bracket syntax, it is also possible to use the of keyword if each role takes just one parameter. Therefore, with these declarations:</p>

<pre><code class="language-perl6">role Cup[::Contents] { }
role Glass[::Contents] { }
class EggNog { }
class MulledWine { }
</code></pre>

<p>We may now write the following:</p>

<pre><code class="language-perl6">my Cup of EggNog $mug = get_eggnog();
my Glass of MulledWine $glass = get_wine();
</code></pre>

<p>You can even stack these up.</p>

<pre><code class="language-perl6">role Tray[::ItemType] { }
my Tray of Glass of MulledWine $valuable;
</code></pre>

<p>The last of these is just a more readable way of saying Tray[Glass[MulledWine]]. Cheers!
About these ads
Like this:</p>

<p>Like Loading&hellip;</p>


        
          <div class="blog-tags">
            
              <a href="https://ohmysummer.github.io//tags/%E5%9C%A3%E8%AF%9E/">圣诞</a>&nbsp;
            
          </div>
        

        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://ohmysummer.github.io/post/2016-03-11-token%E5%92%8Crule%E7%9A%84%E5%8C%BA%E5%88%AB/" data-toggle="tooltip" data-placement="top" title="token 和 rule 的区别">&larr; Previous Post</a>
            </li>
          
          
            <li class="next">
              <a href="https://ohmysummer.github.io/post/2016-03-12-%E5%8C%BF%E5%90%8D%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" data-toggle="tooltip" data-placement="top" title="匿名状态变量的工作原理">Next Post &rarr;</a>
            </li>
          
        </ul>
      


      
        
          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ohmysummer" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
        
        
      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            
            <a href="https://ohmysummer.github.io/index.xml" title="RSS">
            
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://ohmysummer.github.io/">焉知非鱼</a>
            
          

          <span style="color: red;">❤</span>&nbsp;Perl 6
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.41</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://ohmysummer.github.io/js/main.js"></script>
<script src="https://ohmysummer.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script>
<script src="https://ohmysummer.github.io/js/load-photoswipe.js"></script>


<script>
  (function() {
    var cx = '009072066163920799339:qwme9vkotxk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>





  </body>
</html>

