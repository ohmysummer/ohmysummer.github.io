<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>ç¬¬åäº”ç« . æ­£åˆ™è¡¨è¾¾å¼</title>
  <meta property="og:title" content="ç¬¬åäº”ç« . æ­£åˆ™è¡¨è¾¾å¼" />
  <meta name="twitter:title" content="ç¬¬åäº”ç« . æ­£åˆ™è¡¨è¾¾å¼" />
  <meta name="description" content="Regular Expressions">
  <meta property="og:description" content="Regular Expressions">
  <meta name="twitter:description" content="Regular Expressions">
  <meta name="author" content="ç„‰çŸ¥éé±¼"/>
  <link href='https://ohmysummer.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://ohmysummer.github.io/post/2018-09-15-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Rakudo Perl 6" />

  <meta name="generator" content="Hugo 0.49" />
  <link rel="canonical" href="https://ohmysummer.github.io/post/2018-09-15-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" />
  <link rel="alternate" href="https://ohmysummer.github.io/index.xml" type="application/rss+xml" title="Rakudo Perl 6">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://ohmysummer.github.io/css/codeblock.css" />



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'ohmycloudy', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://ohmysummer.github.io/">Rakudo Perl 6</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="åšå®¢" href="/">åšå®¢</a>
            </li>
          
        
          
            <li>
              <a title="å½’æ¡£" href="/categories">å½’æ¡£</a>
            </li>
          
        
          
            <li>
              <a title="å…³äº" href="/page/about/">å…³äº</a>
            </li>
          
        
          
            <li>
              <a title="æ ‡ç­¾" href="/tags">æ ‡ç­¾</a>
            </li>
          
        

        

        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span class="hidden-sm hidden-md hidden-lg">Search</span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
          <a title="Rakudo Perl 6" href="https://ohmysummer.github.io/">
            <img class="avatar-img" src="https://ohmysummer.github.io/img/rakudo.png" alt="Rakudo Perl 6" />
          </a>
        
      </div>
    </div>

  </div>
</nav>



  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title">Search Rakudo Perl 6</h4>
        </div>
        <div class="modal-body">
          <gcse:search></gcse:search>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>


    
  
  
  




  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              <h1>ç¬¬åäº”ç« . æ­£åˆ™è¡¨è¾¾å¼</h1>
                
                  
                    <h2 class="post-subheading">Regular Expressions</h2>
                  
                
                
                  <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on September 15, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 22 minutes (4680 words)
  
  
</span>

                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        

<h1 id="å£°æ˜">å£°æ˜</h1>

<p>æœ¬ç« ç¿»è¯‘ä»…ç”¨äº Perl 6 å­¦ä¹ å’Œç ”ç©¶, è¯·æ”¯æŒç”µå­ç‰ˆæˆ–<a href="https://www.amazon.co.uk/Learning-Perl-6-Brian-Foy/dp/149197768X/ref=sr_1_1?ie=UTF8&amp;qid=1536753267&amp;sr=8-1&amp;keywords=Learning+Perl+6">çº¸è´¨ç‰ˆ</a>ã€‚</p>

<h1 id="ç¬¬åäº”ç« -æ­£åˆ™è¡¨è¾¾å¼">ç¬¬åäº”ç« . æ­£åˆ™è¡¨è¾¾å¼</h1>

<p>Regular expressions (or <em>regexes</em>) are patterns that describe a possible set of matching texts. They are a little language of their own, and many characters have a special meaning inside patterns. They may look cryptic at first, but after you learn them you have quite a bit of power.</p>

<p>Forget what youâ€™ve seen about patterns in other languages. The Perl 6 pattern syntax started over. Itâ€™s less compact but also more powerful. In some cases it acts a bit differently.</p>

<p>This chapter shows simple patterns that match particular characters or sets of characters. Itâ€™s just the start. In <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2">Chapter 16</a> youâ€™ll see fancier patterns and the side effects of matching. In <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars">Chapter 17</a> youâ€™ll take it all to the next level.</p>

<p>æ­£åˆ™è¡¨è¾¾å¼ï¼ˆæˆ–æ­£åˆ™è¡¨è¾¾å¼ï¼‰æ˜¯æè¿°å¯èƒ½çš„åŒ¹é…æ–‡æœ¬é›†çš„æ¨¡å¼ã€‚å®ƒä»¬æ˜¯è‡ªå·±çš„ä¸€ç§è¯­è¨€ï¼Œè®¸å¤šå­—ç¬¦åœ¨æ¨¡å¼ä¸­å…·æœ‰ç‰¹æ®Šå«ä¹‰ã€‚å®ƒä»¬èµ·åˆå¯èƒ½çœ‹èµ·æ¥å¾ˆç¥ç§˜ï¼Œä½†æ˜¯åœ¨ä½ å­¦ä¹ å®ƒä»¬ä¹‹åä½ ä¼šæœ‰ç›¸å½“å¤§çš„åŠ›é‡ã€‚</p>

<p>å¿˜è®°ä½ åœ¨å…¶ä»–è¯­è¨€ä¸­çœ‹åˆ°çš„å…³äºæ¨¡å¼çš„å†…å®¹ã€‚ Perl 6æ¨¡å¼è¯­æ³•é‡æ–°å¼€å§‹ã€‚å®ƒä¸é‚£ä¹ˆç´§å‡‘ï¼Œä½†ä¹Ÿæ›´å¼ºå¤§ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒçš„ä½œç”¨æœ‰ç‚¹ä¸åŒã€‚</p>

<p>æœ¬ç« ä»‹ç»ä¸ç‰¹å®šå­—ç¬¦æˆ–å­—ç¬¦é›†åŒ¹é…çš„ç®€å•æ¨¡å¼ã€‚è¿™åªæ˜¯ä¸€ä¸ªå¼€å§‹ã€‚åœ¨ç¬¬16ç« ä¸­ï¼Œæ‚¨å°†çœ‹åˆ°æ›´æ¼‚äº®çš„æ¨¡å¼å’ŒåŒ¹é…çš„å‰¯ä½œç”¨ã€‚åœ¨ç¬¬17ç« ä¸­ï¼Œæ‚¨å°†æŠŠå®ƒå…¨éƒ¨æå‡åˆ°ä¸€ä¸ªæ–°çš„æ°´å¹³ã€‚</p>

<h1 id="the-match-operator">The Match Operator</h1>

<p>A pattern describes a set of text values. The simple pattern <code>abc</code> describes all the values that have an <code>a</code> next to a <code>b</code> next to a <code>c</code>. The trick then is to decide if a particular value is in the set of matching values. There are no half or partial matches; it matches or it doesnâ€™t.</p>

<p>A pattern inside <code>m/.../</code> immediately applies itself to the value in <code>$_</code>. If the pattern is in the <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> the match operator returns something that evaluates to <code>True</code> in a condition:</p>

<p>æ¨¡å¼æè¿°äº†ä¸€ç»„æ–‡æœ¬å€¼ã€‚ç®€å•æ¨¡å¼abcæè¿°äº†cæ—è¾¹çš„bæ—è¾¹çš„æ‰€æœ‰å€¼ã€‚ç„¶åï¼ŒæŠ€å·§æ˜¯ç¡®å®šç‰¹å®šå€¼æ˜¯å¦åœ¨åŒ¹é…å€¼é›†åˆä¸­ã€‚æ²¡æœ‰åŠåœºæ¯”èµ›æˆ–éƒ¨åˆ†æ¯”èµ›;å®ƒåŒ¹é…æˆ–ä¸åŒ¹é…ã€‚</p>

<p>m /&hellip;/ä¸­çš„æ¨¡å¼ç«‹å³å°†å…¶è‡ªèº«åº”ç”¨äº$ _ä¸­çš„å€¼ã€‚å¦‚æœæ¨¡å¼åœ¨Strä¸­ï¼Œåˆ™åŒ¹é…è¿ç®—ç¬¦è¿”å›åœ¨æ¡ä»¶ä¸­è¯„ä¼°ä¸ºTrueçš„å€¼ï¼š</p>

<pre><code>$_ = 'Hamadryas';
if m/Hama/ { put 'It matched!'; }
else       { put 'It missed!';  }
</code></pre>

<p>Thatâ€™s a bit verbose. The conditional operator takes care of that:</p>

<p>è¿™æœ‰ç‚¹å†—é•¿ã€‚æ¡ä»¶è¿ç®—ç¬¦è´Ÿè´£ï¼š</p>

<pre><code>put m/Hama/ ?? 'It matched!' !! 'It missed!';
</code></pre>

<p>You donâ€™t have to match against <code>$_</code>. You can use the smart match to apply it to a different value. Thatâ€™s the target:</p>

<p>ä½ ä¸å¿…åŒ¹é…$ _ã€‚æ‚¨å¯ä»¥ä½¿ç”¨æ™ºèƒ½åŒ¹é…å°†å…¶åº”ç”¨äºå…¶ä»–å€¼ã€‚è¿™æ˜¯ç›®æ ‡ï¼š</p>

<pre><code>my $genus = 'Hamadryas';
put $genus ~~ m/Hama/ ?? 'It matched!' !! 'It missed!';
</code></pre>

<p>That target could be anything, including an <a href="https://docs.perl6.org/type/Array.html"><code>Array</code></a> or <a href="https://docs.perl6.org/type/Hash.html"><code>Hash</code></a>. These match a single item:</p>

<p>è¯¥ç›®æ ‡å¯ä»¥æ˜¯ä»»ä½•ä¸œè¥¿ï¼ŒåŒ…æ‹¬æ•°ç»„æˆ–å“ˆå¸Œã€‚è¿™äº›åŒ¹é…å•ä¸ªé¡¹ç›®ï¼š</p>

<pre><code>$genus                ~~ m/Hama/;
@animals[0]           ~~ m/Hama/;
%butterfly&lt;Hamadryas&gt; ~~ m/perlicus/;
</code></pre>

<p>But you can also match against multiple items. The object on the left side of the smart match decides how the pattern applies to the object. This matches if any of the elements in <code>@animals</code> matches:</p>

<p>ä½†æ‚¨ä¹Ÿå¯ä»¥åŒ¹é…å¤šä¸ªé¡¹ç›®ã€‚æ™ºèƒ½åŒ¹é…å·¦ä¾§çš„å¯¹è±¡å†³å®šæ¨¡å¼å¦‚ä½•åº”ç”¨äºå¯¹è±¡ã€‚å¦‚æœ@animalsä¸­çš„ä»»ä½•å…ƒç´ åŒ¹é…ï¼Œåˆ™åŒ¹é…ï¼š</p>

<pre><code>if @animals ~~ m/Hama/ {
    put &quot;Matches at least one animal&quot;;
    }
</code></pre>

<p>This is the same as matching against a <a href="https://docs.perl6.org/type/Junction.html"><code>Junction</code></a>:</p>

<p>è¿™ä¸é’ˆå¯¹Junctionçš„åŒ¹é…ç›¸åŒï¼š</p>

<pre><code>if any(@animals) ~~ m/Hama/ {
    put &quot;Matches at least one animal&quot;;
    }
</code></pre>

<p>The match operator is commonly used in the condition inside a <code>.grep</code>:</p>

<p>åŒ¹é…è¿ç®—ç¬¦é€šå¸¸ç”¨äº.grepä¸­çš„æ¡ä»¶ï¼š</p>

<pre><code>my @hama-animals = @animals.grep: /Hama/;
</code></pre>

<h2 id="match-operator-syntax">Match Operator Syntax</h2>

<p>The match operator can use alternate delimiters, similar to the quoting mechanism:</p>

<p>åŒ¹é…è¿ç®—ç¬¦å¯ä»¥ä½¿ç”¨å¤‡ç”¨åˆ†éš”ç¬¦ï¼Œç±»ä¼¼äºå¼•ç”¨æœºåˆ¶ï¼š</p>

<pre><code>m{Hama}
m!Hama!
</code></pre>

<p>Whitespace inside the match operator doesnâ€™t matter. Itâ€™s not part of the pattern (until you say so, as youâ€™ll see later). All of these are the same, including the last example with vertical whitespace:</p>

<p>åŒ¹é…è¿ç®—ç¬¦å†…çš„ç©ºæ ¼å¹¶ä¸é‡è¦ã€‚å®ƒä¸æ˜¯æ¨¡å¼çš„ä¸€éƒ¨åˆ†ï¼ˆç›´åˆ°ä½ è¿™ä¹ˆè¯´ï¼Œä½ å°†åœ¨åé¢çœ‹åˆ°ï¼‰ã€‚æ‰€æœ‰è¿™äº›éƒ½æ˜¯ç›¸åŒçš„ï¼ŒåŒ…æ‹¬æœ€åä¸€ä¸ªå¸¦æœ‰å‚ç›´ç©ºæ ¼çš„ä¾‹å­ï¼š</p>

<pre><code>m/ Hama /
m{ Hama }
m! Hama !
m/
    Hama
/
</code></pre>

<p>You can put spaces between alphabetic characters, but youâ€™ll probably get a warning because Perl 6 wants you to put those together:</p>

<p>æ‚¨å¯ä»¥åœ¨å­—æ¯å­—ç¬¦ä¹‹é—´æ”¾ç½®ç©ºæ ¼ï¼Œä½†æ‚¨å¯èƒ½ä¼šæ”¶åˆ°è­¦å‘Šï¼Œå› ä¸ºPerl 6å¸Œæœ›æ‚¨å°†å®ƒä»¬æ”¾åœ¨ä¸€èµ·ï¼š</p>

<pre><code>m/ Ha ma /
</code></pre>

<p>If you want a literal space inside the match operator you can escape it (along with other things youâ€™ll see later):</p>

<p>å¦‚æœä½ æƒ³åœ¨åŒ¹é…è¿ç®—ç¬¦ä¸­ä½¿ç”¨æ–‡å­—ç©ºé—´ï¼Œä½ å¯ä»¥å°†å…¶è½¬ä¹‰ï¼ˆä»¥åŠç¨åä½ ä¼šçœ‹åˆ°çš„å…¶ä»–å†…å®¹ï¼‰ï¼š</p>

<pre><code>m/ Ha\ ma /
</code></pre>

<p>Quoting whitespace makes it literal too (the space around the quoted whitespace is still insignificant), or you can quote it all together:</p>

<p>å¼•ç”¨ç©ºæ ¼ä¹Ÿä½¿å®ƒæˆä¸ºå­—é¢å€¼ï¼ˆå¼•ç”¨çš„ç©ºæ ¼å‘¨å›´çš„ç©ºé—´ä»ç„¶æ— å…³ç´§è¦ï¼‰ï¼Œæˆ–è€…ä½ å¯ä»¥å°†å®ƒä»¬å…¨éƒ¨å¼•ç”¨ï¼š</p>

<pre><code>m/ Ha ' ' ma /
m/ 'Ha ma' /
</code></pre>

<p>You need to quote or escape any character thatâ€™s not alphabetic or a number, even if those characters arenâ€™t â€œspecial.â€ The other unquoted characters may be metacharacters that have special meaning in the pattern language.</p>

<p>æ‚¨éœ€è¦å¼•ç”¨æˆ–è½¬ä¹‰ä»»ä½•éå­—æ¯æˆ–æ•°å­—çš„å­—ç¬¦ï¼Œå³ä½¿è¿™äº›å­—ç¬¦ä¸æ˜¯â€œç‰¹æ®Šâ€ã€‚å…¶ä»–æœªåŠ å¼•å·çš„å­—ç¬¦å¯èƒ½æ˜¯åœ¨æ¨¡å¼è¯­è¨€ä¸­å…·æœ‰ç‰¹æ®Šå«ä¹‰çš„å…ƒå­—ç¬¦ã€‚</p>

<h2 id="successful-matches">Successful Matches</h2>

<p>If the match operator succeeds it returns a <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a> object, which is always a <code>True</code> value. If you <code>put</code> that object it shows you the part of the <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> that matched. The <code>say</code> calls <code>.gist</code> and the output is a bit different:</p>

<p>å¦‚æœåŒ¹é…è¿ç®—ç¬¦æˆåŠŸï¼Œåˆ™è¿”å›Matchå¯¹è±¡ï¼Œè¯¥å¯¹è±¡å§‹ç»ˆä¸ºTrueå€¼ã€‚å¦‚æœæ‚¨æ”¾ç½®è¯¥å¯¹è±¡ï¼Œå®ƒä¼šå‘æ‚¨æ˜¾ç¤ºåŒ¹é…çš„Stréƒ¨åˆ†ã€‚è¯´è°ƒç”¨.gistå’Œè¾“å‡ºæœ‰ç‚¹ä¸åŒï¼š</p>

<pre><code>$_ = 'Hamadryas';
my $match = m/Hama/;
put $match; # Hama
say $match; # ?Hama?
</code></pre>

<p>The output of <code>say</code> gets interesting as the patterns get more complicated. That makes it useful for the regex chapters, and youâ€™ll see more of that here compared to the rest of the book.</p>

<p>If the match does not succeed it returns <a href="https://docs.perl6.org/type/Nil.html"><code>Nil</code></a>, which is always <code>False</code>:</p>

<p>éšç€æ¨¡å¼å˜å¾—æ›´åŠ å¤æ‚ï¼Œsayçš„è¾“å‡ºå˜å¾—æœ‰è¶£ã€‚è¿™ä½¿å¾—å®ƒå¯¹æ­£åˆ™è¡¨è¾¾å¼ç« èŠ‚å¾ˆæœ‰ç”¨ï¼Œå¹¶ä¸”ä¸æœ¬ä¹¦çš„å…¶ä½™éƒ¨åˆ†ç›¸æ¯”ï¼Œæ‚¨å°†åœ¨è¿™é‡Œçœ‹åˆ°æ›´å¤šã€‚</p>

<p>å¦‚æœåŒ¹é…ä¸æˆåŠŸï¼Œåˆ™è¿”å›Nilï¼Œå®ƒå§‹ç»ˆä¸ºFalseï¼š</p>

<pre><code>$_ = 'Hamadryas';
my $match = m/Hama/;
put $match.^name;    # Nil
</code></pre>

<p>Itâ€™s usually a good idea to check the result before you do anything with it:</p>

<p>åœ¨å¯¹å®ƒåšä»»ä½•äº‹æƒ…ä¹‹å‰æ£€æŸ¥ç»“æœé€šå¸¸æ˜¯ä¸ªå¥½ä¸»æ„ï¼š</p>

<pre><code>if my $match = m/Hama/ { # matched
    say $match;
    }
</code></pre>

<p>You donâ€™t need the <code>$match</code> variable though. The result of the last match shows up in the special variable <code>$/</code>, which youâ€™ll see more of later:</p>

<p>æ‚¨ä¸éœ€è¦ <code>$match</code> å˜é‡ã€‚æœ€åä¸€ä¸ªåŒ¹é…çš„ç»“æœæ˜¾ç¤ºåœ¨ç‰¹æ®Šå˜é‡$ /ä¸­ï¼Œç¨åæ‚¨ä¼šçœ‹åˆ°æ›´å¤šï¼š</p>

<pre><code>if m/Hama/ { # matched
    say $/;
    }
</code></pre>

<h2 id="defining-a-pattern">Defining a Pattern</h2>

<p>Useful patterns can get quite long and unwieldy. Use <code>rx//</code> to define a pattern (a <a href="https://docs.perl6.org/type/Regex.html"><code>Regex</code></a>) for later use. This pattern is not immediately applied to any target. This allows you to define a pattern somewhere that doesnâ€™t distract from what you are doing:</p>

<p>æœ‰ç”¨çš„æ¨¡å¼å¯èƒ½ä¼šå˜å¾—éå¸¸å†—é•¿å’Œç¬¨æ‹™ã€‚ä½¿ç”¨rx //å®šä¹‰æ¨¡å¼ï¼ˆæ­£åˆ™è¡¨è¾¾å¼ï¼‰ä¾›ä»¥åä½¿ç”¨ã€‚æ­¤æ¨¡å¼ä¸ä¼šç«‹å³åº”ç”¨äºä»»ä½•ç›®æ ‡ã€‚è¿™å…è®¸æ‚¨åœ¨æŸä¸ªåœ°æ–¹å®šä¹‰ä¸€ä¸ªä¸ä¼šåˆ†æ•£æ‚¨æ­£åœ¨åšçš„äº‹æƒ…çš„æ¨¡å¼ï¼š</p>

<pre><code>my $genus = 'Hamadryas';
my $pattern = rx/ Hama /; # something much more complicated
$genus ~~ $pattern;
</code></pre>

<p>and reuse the pattern wherever you need it:</p>

<p>å¹¶åœ¨ä»»ä½•éœ€è¦çš„åœ°æ–¹é‡ç”¨æ¨¡å¼ï¼š</p>

<pre><code>for lines() -&gt; $line {
    put $line if $line ~~ $pattern;
    }
</code></pre>

<p>Itâ€™s possible to combine saved patterns into a larger one. This allows you to decompose complicated patterns into smaller, more tractable ones that you can reuse later (which youâ€™ll do extensively in <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars">Chapter 17</a>):</p>

<p>å¯ä»¥å°†ä¿å­˜çš„æ¨¡å¼ç»„åˆæˆæ›´å¤§çš„æ¨¡å¼ã€‚è¿™å…è®¸æ‚¨å°†å¤æ‚çš„æ¨¡å¼åˆ†è§£ä¸ºæ›´å°ï¼Œæ›´æ˜“å¤„ç†çš„æ¨¡å¼ï¼Œä»¥åå¯ä»¥é‡å¤ä½¿ç”¨ï¼ˆæ‚¨å°†åœ¨ç¬¬17ç« ä¸­è¿›è¡Œå¹¿æ³›çš„è®¨è®ºï¼‰ï¼š</p>

<pre><code>my $genus = 'Hamadryas';

my $hama  = rx/Hama/;
my $dryas = rx/dryas/;
my $match = $genus ~~ m/$hama$dryas/;

say $match;
</code></pre>

<p>Rather than storing a variable in an object, declare a lexical pattern with <code>regex</code>. This looks like a subroutine because it has a <a href="https://docs.perl6.org/type/Block.html"><code>Block</code></a> but itâ€™s not code inside; itâ€™s a pattern and uses that slang:</p>

<p>ä¸æ˜¯å°†å˜é‡å­˜å‚¨åœ¨å¯¹è±¡ä¸­ï¼Œè€Œæ˜¯ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å£°æ˜è¯æ³•æ¨¡å¼ã€‚è¿™çœ‹èµ·æ¥åƒä¸€ä¸ªå­ç¨‹åºï¼Œå› ä¸ºå®ƒæœ‰ä¸€ä¸ªBlockï¼Œä½†å®ƒä¸æ˜¯ä»£ç ;è¿™æ˜¯ä¸€ç§æ¨¡å¼å¹¶ä½¿ç”¨ä¿šè¯­ï¼š</p>

<pre><code>my regex hama { Hama }
</code></pre>

<p>Use this in a pattern by surrounding it with angle brackets:</p>

<p>é€šè¿‡ç”¨å°–æ‹¬å·åŒ…å›´å®ƒï¼Œåœ¨å›¾æ¡ˆä¸­ä½¿ç”¨å®ƒï¼š</p>

<pre><code>my $genus = 'Hamadryas';
put $genus ~~ m/&lt;hama&gt;/ ?? 'It matched!' !! 'It missed!';
</code></pre>

<p>You can define multiple named regexes and use them together:</p>

<p>æ‚¨å¯ä»¥å®šä¹‰å¤šä¸ªå·²å‘½åçš„æ­£åˆ™è¡¨è¾¾å¼å¹¶å°†å®ƒä»¬ä¸€èµ·ä½¿ç”¨ï¼š</p>

<pre><code>my regex hama  { Hama }
my regex dryas { dryas }

$_ = 'Hamadryas';
say m/&lt;hama&gt;&lt;dryas&gt;/;
</code></pre>

<p>Each named regex becomes a submatch. You can see the structure when you output it with <code>say</code>. It shows the overall result and the results of the subpatterns too:</p>

<p>æ¯ä¸ªå‘½åçš„æ­£åˆ™è¡¨è¾¾å¼éƒ½æˆä¸ºä¸€ä¸ªå­åŒ¹é…ã€‚ç”¨sayè¾“å‡ºå®ƒæ—¶å¯ä»¥çœ‹åˆ°ç»“æ„ã€‚å®ƒè¿˜æ˜¾ç¤ºäº†æ•´ä¸ªç»“æœå’Œå­æ¨¡å¼çš„ç»“æœï¼š</p>

<pre><code>?Hamadryas?
 hama =&gt; ?Hama?
 dryas =&gt; ?dryas?
</code></pre>

<p>Treat the <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a> object like a <a href="https://docs.perl6.org/type/Hash.html"><code>Hash</code></a> (although it isnâ€™t) to get the parts that matched the named regexes. The name of the regex is the â€œkeyâ€:</p>

<p>å°†Matchå¯¹è±¡è§†ä¸ºHashï¼ˆå°½ç®¡ä¸æ˜¯ï¼‰ï¼Œä»¥è·å¾—ä¸å‘½åæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…çš„éƒ¨åˆ†ã€‚æ­£åˆ™è¡¨è¾¾å¼çš„åç§°æ˜¯â€œå…³é”®â€ï¼š</p>

<pre><code>$_ = 'Hamadryas';
my $result =  m/&lt;hama&gt;&lt;dryas&gt;/;

if $result {
    put &quot;First: $result&lt;hama&gt;&quot;;
    put &quot;Second: $result&lt;dryas&gt;&quot;;
    }
</code></pre>

<h2 id="predefined-patterns">Predefined Patterns</h2>

<p><a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-predefined_patterns">Table 15-1</a> shows several of the predefined patterns that are ready for you to use. You can define your patterns in a library and export them just like you could with subroutines:</p>

<p><a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-predefined_patterns">è¡¨15-1</a>æ˜¾ç¤ºäº†å‡ ä¸ªå‡†å¤‡å¥½çš„é¢„å®šä¹‰æ¨¡å¼ä¾›ä½ ä½¿ç”¨ã€‚æ‚¨å¯ä»¥åœ¨åº“ä¸­å®šä¹‰æ¨¡å¼ï¼Œå¹¶åƒå­ç¨‹åºä¸€æ ·å¯¼å‡ºå®ƒä»¬ï¼š</p>

<pre><code># Patterns.pm6
my regex hama is export { Hama }
</code></pre>

<p>Load the module and those named regexes are available to your patterns:</p>

<p>åŠ è½½æ¨¡å—å’Œé‚£äº›åä¸ºæ­£åˆ™è¡¨è¾¾å¼çš„æ¨¡å¼å¯ç”¨ï¼š</p>

<pre><code>use lib &lt;.&gt;;
use Hama;

$_ = 'Hamadryas';
say m/ &lt;hama&gt; /;
</code></pre>

<table>
<thead>
<tr>
<th>Predefined pattern</th>
<th>What it matches</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>&lt;alnum&gt;</code></td>
<td>Alphabetic and digit characters</td>
</tr>

<tr>
<td><code>&lt;alpha&gt;</code></td>
<td>Alphabetic characters</td>
</tr>

<tr>
<td><code>&lt;ascii&gt;</code></td>
<td>Any ASCII character</td>
</tr>

<tr>
<td><code>&lt;blank&gt;</code></td>
<td>Horizontal whitespace</td>
</tr>

<tr>
<td><code>&lt;cntrl&gt;</code></td>
<td>Control characters</td>
</tr>

<tr>
<td><code>&lt;digit&gt;</code></td>
<td>Decimal digits</td>
</tr>

<tr>
<td><code>&lt;graph&gt;</code></td>
<td><code>&lt;alnum&gt;</code> + <code>&lt;punct&gt;</code></td>
</tr>

<tr>
<td><code>&lt;ident&gt;</code></td>
<td>A valid identifier character</td>
</tr>

<tr>
<td><code>&lt;lower&gt;</code></td>
<td>Lowercase characters</td>
</tr>

<tr>
<td><code>&lt;print&gt;</code></td>
<td><code>&lt;graph&gt;</code> + <code>&lt;space&gt;</code>, but without <code>&lt;cntrl&gt;</code></td>
</tr>

<tr>
<td><code>&lt;punct&gt;</code></td>
<td>Punctuation and symbols beyond ASCII</td>
</tr>

<tr>
<td><code>&lt;space&gt;</code></td>
<td>Whitespace</td>
</tr>

<tr>
<td><code>&lt;upper&gt;</code></td>
<td>Uppercase characters</td>
</tr>

<tr>
<td>`&lt;</td>
<td>wb&gt;`</td>
</tr>

<tr>
<td><code>&lt;word&gt;</code></td>
<td><code>&lt;alnum&gt;</code> + Unicode marks + connectors, like â€˜_â€™ (extra)</td>
</tr>

<tr>
<td><code>&lt;ws&gt;</code></td>
<td>Whitespace (required between word characters, optional otherwise)</td>
</tr>

<tr>
<td><code>&lt;ww&gt;</code></td>
<td>Within a word (an assertion rather than a character)</td>
</tr>

<tr>
<td><code>&lt;xdigit&gt;</code></td>
<td>Hexadecimal digits <code>[0-9A-Fa-f]</code></td>
</tr>
</tbody>
</table>

<p>EXERCISE 15.1Create a program that uses a regular expression to output all of the matching lines from the files you specify on the command line.</p>

<p>ç»ƒä¹ 15.1åˆ›å»ºä¸€ä¸ªç¨‹åºï¼Œè¯¥ç¨‹åºä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è¾“å‡ºæ‚¨åœ¨å‘½ä»¤è¡Œä¸­æŒ‡å®šçš„æ–‡ä»¶ä¸­çš„æ‰€æœ‰åŒ¹é…è¡Œã€‚</p>

<h1 id="matching-nonliteral-characters">Matching Nonliteral Characters</h1>

<p>You donâ€™t have to literally type a character to match it. You might have an easier time specifying its code point or name. You can use the same <code>\x[*CODEPOINT*]</code> or <code>\c[*NAME*]</code> that you saw in double-quoted <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>s in <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings">Chapter 4</a>.</p>

<p>If you specify a name it must be all uppercase.</p>

<p>You could match the initial capital <em>H</em> by name, even though you have to type a literal <code>H</code> in the name:</p>

<p>æ‚¨ä¸å¿…é€å­—è¾“å…¥åŒ¹é…å®ƒçš„å­—ç¬¦ã€‚æ‚¨å¯ä»¥æ›´è½»æ¾åœ°æŒ‡å®šå…¶ä»£ç ç‚¹æˆ–åç§°ã€‚æ‚¨å¯ä»¥ä½¿ç”¨åœ¨ç¬¬4ç« ä¸­åŒå¼•å·Strsä¸­çœ‹åˆ°çš„ç›¸åŒ\ x [* CODEPOINT <em>]æˆ–\ c [</em> NAME *]ã€‚</p>

<p>å¦‚æœæŒ‡å®šåç§°ï¼Œåˆ™å¿…é¡»å…¨éƒ¨ä¸ºå¤§å†™ã€‚</p>

<p>æ‚¨å¯ä»¥æŒ‰åç§°åŒ¹é…åˆå§‹å¤§å†™å­—æ¯Hï¼Œå³ä½¿æ‚¨å¿…é¡»åœ¨åç§°ä¸­é”®å…¥æ–‡å­—Hï¼š</p>

<pre><code>my $pattern = rx/
     \c[LATIN CAPITAL LETTER H] ama
    /;
$_ = &quot;Hamadryas&quot;;

put $pattern ?? 'Matched!' !! 'Missed!';
</code></pre>

<p>You can do the same thing with the code point. If you specify a code point use the hexadecimal number (with either case):</p>

<p>æ‚¨å¯ä»¥ä½¿ç”¨ä»£ç ç‚¹æ‰§è¡Œç›¸åŒçš„æ“ä½œã€‚å¦‚æœæŒ‡å®šä»£ç ç‚¹ï¼Œè¯·ä½¿ç”¨åå…­è¿›åˆ¶æ•°å­—ï¼ˆä¸¤ç§æƒ…å†µï¼‰ï¼š</p>

<pre><code>my $pattern = rx/
     \x[48] ama
    /;
$_ = &quot;Hamadryas&quot;;

put $pattern ?? 'Matched!' !! 'Missed!';
</code></pre>

<p>This makes more sense if you want to match a character thatâ€™s either hard to type or hard to read. If the <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> has the ğŸ± character (U+1F431 CAT FACE), you might not be able to distinguish that from ğŸ˜¸ (U+1F638 GRINNING CAT FACE WITH SMILING EYES) without looking very closely. Instead of letting another programmer mistake your intent, you can use the name to save some eyestrain:</p>

<pre><code>my $pattern = rx/
     \c[CAT FACE]  # or \x[1F431]
    /;
$_ = &quot;This is a catface: ğŸ±&quot;;
put $pattern ?? 'Matched!' !! 'Missed!';
</code></pre>

<h2 id="matching-any-character">Matching Any Character</h2>

<p>Patterns have <em>metacharacters</em> that match something other than their literal selves. Some of these are listed in <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-chars_to_escape">Table 15-2</a> (and most you wonâ€™t see in this chapter). The <code>.</code> matches any character (<em>including</em> a newline). This pattern matches any target that has at least one character:</p>

<p>æ¨¡å¼å…·æœ‰ä¸å…¶æ–‡å­—è‡ªæˆ‘åŒ¹é…çš„å…ƒå­—ç¬¦ã€‚å…¶ä¸­ä¸€äº›åˆ—åœ¨è¡¨15-2ä¸­ï¼ˆå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæ‚¨ä¸ä¼šåœ¨æœ¬ç« ä¸­çœ‹åˆ°ï¼‰ã€‚è¿™ä¸ªã€‚åŒ¹é…ä»»ä½•å­—ç¬¦ï¼ˆåŒ…æ‹¬æ¢è¡Œç¬¦ï¼‰ã€‚æ­¤æ¨¡å¼åŒ¹é…å…·æœ‰è‡³å°‘ä¸€ä¸ªå­—ç¬¦çš„ä»»ä½•ç›®æ ‡ï¼š</p>

<pre><code>m/ . /
</code></pre>

<p>To match a <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> with an <em>a</em> and a <em>c</em> separated by a character, put the dot between them in the pattern. This skips the lines that donâ€™t match that pattern:</p>

<p>è¦å°†Strä¸ç”±å­—ç¬¦åˆ†éš”çš„aå’ŒcåŒ¹é…ï¼Œè¯·åœ¨æ¨¡å¼ä¸­å°†å®ƒä»¬æ”¾åœ¨å®ƒä»¬ä¹‹é—´ã€‚è¿™ä¼šè·³è¿‡ä¸è¯¥æ¨¡å¼ä¸åŒ¹é…çš„è¡Œï¼š</p>

<pre><code>for lines() {
    next unless m/a.c/;
    .put
    }
</code></pre>

<h3 id="escaping-characters">ESCAPING CHARACTERS</h3>

<p>Some characters have special meaning in patterns. The colon introduces an adverb and the <code>#</code> starts a comment. To match those as literal characters you need to escape them. A backslash will do:</p>

<p>æœ‰äº›å­—ç¬¦åœ¨æ¨¡å¼ä¸­æœ‰ç‰¹æ®Šå«ä¹‰ã€‚å†’å·å¼•å…¥äº†ä¸€ä¸ªå‰¯è¯ï¼Œï¼ƒå¼€å§‹å‘è¡¨è¯„è®ºã€‚è¦å°†å®ƒä»¬ä½œä¸ºæ–‡å­—å­—ç¬¦è¿›è¡ŒåŒ¹é…ï¼Œæ‚¨éœ€è¦å°†å®ƒä»¬è½¬ä¹‰ã€‚åæ–œæ å¯ä»¥ï¼š</p>

<pre><code>my $pattern = rx/ \# \: Hama \. /
</code></pre>

<p>This means to match a literal backslash, you need to escape that too:</p>

<p>è¿™æ„å‘³ç€åŒ¹é…æ–‡å­—åæ–œæ ï¼Œä½ ä¹Ÿéœ€è¦é€ƒé¿å®ƒï¼š</p>

<pre><code>my $pattern = rx/ \# \: Hama \\ /
</code></pre>

<p>You can do the same thing with the other pattern metacharacters. To match a literal dot, escape it:</p>

<p>æ‚¨å¯ä»¥ä½¿ç”¨å…¶ä»–æ¨¡å¼å…ƒå­—ç¬¦æ‰§è¡Œç›¸åŒçš„æ“ä½œã€‚è¦åŒ¹é…æ–‡å­—ç‚¹ï¼Œè¯·å°†å…¶è½¬ä¹‰ï¼š</p>

<pre><code>my $pattern = rx/ \. /
</code></pre>

<p>The backslash only escapes the character that comes immediately after it. You canâ€™t escape a literal space character, and you canâ€™t escape a character that isnâ€™t special. <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-chars_to_escape">Table 15-2</a> shows what you need to escape, even though I havenâ€™t shown you most of those features yet.</p>

<p>åæ–œæ åªä¼šé€ƒé¿ç´§éšå…¶åçš„å­—ç¬¦ã€‚æ‚¨æ— æ³•è½¬ä¹‰æ–‡å­—ç©ºæ ¼å­—ç¬¦ï¼Œä¹Ÿæ— æ³•è½¬ä¹‰ä¸ç‰¹æ®Šçš„å­—ç¬¦ã€‚è¡¨15-2æ˜¾ç¤ºäº†æ‚¨éœ€è¦é€ƒè„±çš„å†…å®¹ï¼Œå³ä½¿æˆ‘è¿˜æ²¡æœ‰å‘æ‚¨å±•ç¤ºå¤§éƒ¨åˆ†åŠŸèƒ½ã€‚</p>

<table>
<thead>
<tr>
<th>Metacharacter</th>
<th>Why itâ€™s special</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>#</code></td>
<td>Starts a comment</td>
</tr>

<tr>
<td><code>\</code></td>
<td>Escapes the next character or a shortcut</td>
</tr>

<tr>
<td><code>.</code></td>
<td>Matches any character</td>
</tr>

<tr>
<td><code>:</code></td>
<td>Starts an adverb, or prevents backtracking</td>
</tr>

<tr>
<td><code>(</code> and <code>)</code></td>
<td>Starts a capture</td>
</tr>

<tr>
<td><code>&lt;</code> and <code>&gt;</code></td>
<td>Used to create higher-level thingys</td>
</tr>

<tr>
<td><code>[</code>, <code>]</code>, and <code>'</code></td>
<td>Used for grouping</td>
</tr>

<tr>
<td><code>+</code>, `</td>
<td><code>,</code>&amp;<code>,</code>-<code>, and</code>^`</td>
</tr>

<tr>
<td><code>?</code>, <code>*</code>, <code>+</code>, and <code>%</code></td>
<td>Quantifiers</td>
</tr>

<tr>
<td>`</td>
<td>`</td>
</tr>

<tr>
<td><code>^</code> and <code>$</code></td>
<td>Anchors</td>
</tr>

<tr>
<td><code>$</code></td>
<td>Starts a variable or named capture</td>
</tr>

<tr>
<td><code>=</code></td>
<td>Assigns to named captures</td>
</tr>
</tbody>
</table>

<p>Characters inside quotes are always their literal selves:</p>

<p>å¼•å·å†…çš„å­—ç¬¦æ€»æ˜¯å®ƒä»¬çš„æ–‡å­—è‡ªæˆ‘ï¼š</p>

<pre><code>my $pattern = rx/ '#:Hama' \\ /
</code></pre>

<p>You canâ€™t use the single quotes to escape the backslash since a single backslash will still try to escape the character that comes after it.</p>

<p>æ‚¨ä¸èƒ½ä½¿ç”¨å•å¼•å·æ¥è½¬ä¹‰åæ–œæ ï¼Œå› ä¸ºå•ä¸ªåæ–œæ ä»ä¼šå°è¯•è½¬ä¹‰åé¢çš„å­—ç¬¦ã€‚</p>

<h3 id="matching-literal-spaces">MATCHING LITERAL SPACES</h3>

<p>You have a tougher time if you want to match literal spaces. You canâ€™t escape a space with <code>\</code> because unspace isnâ€™t allowed in a pattern. Instead, put quotes around the literal space:</p>

<p>å¦‚æœä½ æƒ³åŒ¹é…æ–‡å­—ç©ºé—´ï¼Œä½ ä¼šæœ‰æ›´è‰°éš¾çš„æ—¶é—´ã€‚æ‚¨æ— æ³•ä½¿ç”¨\æ¥è½¬ä¹‰ç©ºæ ¼ï¼Œå› ä¸ºæ¨¡å¼ä¸­ä¸å…è®¸ä½¿ç”¨ç©ºæ ¼ã€‚ç›¸åï¼Œåœ¨æ–‡å­—ç©ºé—´å‘¨å›´åŠ ä¸Šå¼•å·ï¼š</p>

<pre><code>my $pattern = rx/ Hamadryas ' ' laodamia /;
</code></pre>

<p>Or put the entire sequence in quotes:</p>

<p>æˆ–è€…å°†æ•´ä¸ªåºåˆ—æ”¾åœ¨å¼•å·ä¸­ï¼š</p>

<pre><code>my $pattern = rx/ 'Hamadryas laodamia' /;
</code></pre>

<p>Those single quotes can quickly obscure what belongs where; it can be helpful to spread the pattern across lines and note what you are trying to do:</p>

<p>é‚£äº›å•å¼•å·å¾ˆå¿«å°±ä¼šæ¨¡ç³Šå±äºå“ªé‡Œ;å°†å›¾æ¡ˆåˆ†å¸ƒåœ¨çº¿æ¡ä¸Šå¹¶è®°ä¸‹æ‚¨è¦åšçš„äº‹æƒ…ä¼šå¾ˆæœ‰å¸®åŠ©ï¼š</p>

<pre><code>my $pattern = rx/
    Hamadryas    # genus
    ' '            # literal space
    laodamia     # species
    /;
</code></pre>

<p>You can make whitespace significant with the <code>:s</code> adverb:</p>

<p>ä½ å¯ä»¥ä½¿ç”¨ï¼šså‰¯è¯ä½¿ç©ºç™½æ˜¾ç€ï¼š</p>

<pre><code>my $pattern = rx:s/ Hamadryas laodamia /;

my $pattern = rx/ :s Hamadryas laodamia /;
</code></pre>

<p>The <code>:s</code> is the short form of <code>:sigspace</code>:</p>

<p>ï¼šsæ˜¯sigspaceçš„ç¼©å†™å½¢å¼ï¼šsigspaceï¼š</p>

<pre><code>my $pattern = rx:sigspace/ Hamadryas laodamia /;

my $pattern = rx/ :sigspace Hamadryas laodamia /;
</code></pre>

<p>Notice that this will match <code>Hamadryas laodamia</code>, even though the pattern has whitespace at the beginning and end. The <code>:s</code> turns the whitespace in the pattern into a subrule <code>&lt;.ws&gt;</code>:</p>

<p>è¯·æ³¨æ„ï¼Œè¿™å°†åŒ¹é…Hamadryas laodamiaï¼Œå³ä½¿è¯¥æ¨¡å¼åœ¨å¼€å¤´å’Œç»“å°¾éƒ½æœ‰ç©ºæ ¼ã€‚ ï¼šså°†æ¨¡å¼ä¸­çš„ç©ºæ ¼è½¬æ¢ä¸ºå­è§„åˆ™&lt;.ws&gt;ï¼š</p>

<pre><code>$_ = 'Hamadryas laodamia';
my $pattern = rx/ Hamadryas &lt;.ws&gt; laodamia /;
if m/$pattern/ {
    say $/;  # ?Hamadryas laodamia?
    }
</code></pre>

<p>You can combine adverbs, but they each get their own colon. Order does not matter. This pattern has significant whitespace and is case insensitive:</p>

<p>ä½ å¯ä»¥ç»“åˆå‰¯è¯ï¼Œä½†æ¯ä¸ªå‰¯è¯éƒ½æœ‰è‡ªå·±çš„å†’å·ã€‚è®¢å•æ— å…³ç´§è¦ã€‚æ­¤æ¨¡å¼å…·æœ‰é‡è¦çš„ç©ºç™½å¹¶ä¸”ä¸åŒºåˆ†å¤§å°å†™ï¼š</p>

<pre><code>my $pattern = rx:s:i/ Hamadryas Laodamia /;
</code></pre>

<h2 id="matching-types-of-characters">Matching Types of Characters</h2>

<p>So far, youâ€™ve matched literal characters. You typed out the characters you wanted, and escaped them in some cases. There are some sets of characters that are so common they get shortcuts. These start with a backslash followed by a letter that connotes the set of characters. <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch15.html#camelia-regex1-TABLE-character_class_shortcuts">Table 15-3</a> shows the list of shortcuts.</p>

<p>If you want to match any digit, you can use <code>\d</code>. This matches anything that is a digit, not just the Arabic digits:</p>

<p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ‚¨å·²ç»åŒ¹é…äº†å­—é¢å­—ç¬¦ã€‚æ‚¨é”®å…¥äº†æ‰€éœ€çš„å­—ç¬¦ï¼Œå¹¶åœ¨æŸäº›æƒ…å†µä¸‹å°†å…¶è½¬ä¹‰ã€‚æœ‰ä¸€äº›å­—ç¬¦ç»„å¾ˆå¸¸è§ï¼Œå®ƒä»¬å¯ä»¥è·å¾—å¿«æ·æ–¹å¼ã€‚å®ƒä»¬ä»¥åæ–œæ å¼€å¤´ï¼Œåè·Ÿä¸€ä¸ªè¡¨ç¤ºå­—ç¬¦é›†çš„å­—æ¯ã€‚è¡¨15-3æ˜¾ç¤ºäº†å¿«æ·æ–¹å¼åˆ—è¡¨ã€‚</p>

<p>å¦‚æœè¦åŒ¹é…ä»»ä½•æ•°å­—ï¼Œå¯ä»¥ä½¿ç”¨\ dã€‚è¿™åŒ¹é…ä»»ä½•æ•°å­—ï¼Œè€Œä¸ä»…ä»…æ˜¯é˜¿æ‹‰ä¼¯æ•°å­—ï¼š</p>

<pre><code>/ \d /
</code></pre>

<p>Each of these shortcuts comes with a complement. <code>\D</code> matches any nondigit.</p>

<p>è¿™äº›å¿«æ·æ–¹å¼ä¸­çš„æ¯ä¸€ä¸ªéƒ½æœ‰è¡¥å……ã€‚ \ DåŒ¹é…ä»»ä½•éæ•°å­—ã€‚</p>

<table>
<thead>
<tr>
<th>Shortcut</th>
<th>Characters that match</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>\d</code></td>
<td>Digits (Unicode property <code>N</code> )</td>
</tr>

<tr>
<td><code>\D</code></td>
<td>Anything that isnâ€™t a digit</td>
</tr>

<tr>
<td><code>\w</code></td>
<td>Word characters: letters, digits, or underscores</td>
</tr>

<tr>
<td><code>\W</code></td>
<td>Anything that isnâ€™t a word character</td>
</tr>

<tr>
<td><code>\s</code></td>
<td>Any kind of whitespace</td>
</tr>

<tr>
<td><code>\S</code></td>
<td>Anything that isnâ€™t whitespace</td>
</tr>

<tr>
<td><code>\h</code></td>
<td>Horizontal whitespace</td>
</tr>

<tr>
<td><code>\H</code></td>
<td>Anything that isnâ€™t horizontal whitespace</td>
</tr>

<tr>
<td><code>\v</code></td>
<td>Vertical whitespace</td>
</tr>

<tr>
<td><code>\V</code></td>
<td>Anything that isnâ€™t vertical whitespace</td>
</tr>

<tr>
<td><code>\t</code></td>
<td>A tab character (specifically, only U+0009)</td>
</tr>

<tr>
<td><code>\T</code></td>
<td>Anything that isnâ€™t a tab character</td>
</tr>

<tr>
<td><code>\n</code></td>
<td>A newline or carriage return/newline pair</td>
</tr>

<tr>
<td><code>\N</code></td>
<td>Anything that isnâ€™t a newline</td>
</tr>
</tbody>
</table>

<p>EXERCISE 15.2Write a program that outputs only those lines of input that contain three decimal digits in a row. You wrote most of this program in the previous exercise.</p>

<p>ç»ƒä¹ 15.2ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œåªè¾“å‡ºé‚£äº›åŒ…å«ä¸‰è¡Œåè¿›åˆ¶æ•°å­—çš„è¾“å…¥è¡Œã€‚ä½ åœ¨ä¸Šä¸€ä¸ªç»ƒä¹ ä¸­å†™äº†å¤§éƒ¨åˆ†è¿™ä¸ªç¨‹åºã€‚</p>

<h3 id="unicode-properties">UNICODE PROPERTIES</h3>

<p>The Unicode Character Database (UCD) defines the code points and their names and assigns them one or more properties. Each character knows many things about itself, and you can use some of that information to match them. Place the name of the Unicode property in <code>&lt;:...&gt;</code>. That colon must come right after the opening angle bracket. If you wanted to match something that is a letter, you could use the property <code>Letter</code>:</p>

<p>Unicodeå­—ç¬¦æ•°æ®åº“ï¼ˆUCDï¼‰å®šä¹‰ä»£ç ç‚¹åŠå…¶åç§°ï¼Œå¹¶ä¸ºå®ƒä»¬åˆ†é…ä¸€ä¸ªæˆ–å¤šä¸ªå±æ€§ã€‚æ¯ä¸ªè§’è‰²éƒ½çŸ¥é“å¾ˆå¤šå…³äºè‡ªèº«çš„äº‹æƒ…ï¼Œä½ å¯ä»¥ä½¿ç”¨å…¶ä¸­çš„ä¸€äº›ä¿¡æ¯æ¥åŒ¹é…å®ƒä»¬ã€‚å°†Unicodeå±æ€§çš„åç§°æ”¾åœ¨&lt;ï¼š&hellip;&gt;ä¸­ã€‚ç»“è‚ å¿…é¡»åœ¨å¼€è§’æ”¯æ¶åé¢ã€‚å¦‚æœä½ æƒ³åŒ¹é…ä¸€ä¸ªå­—æ¯çš„ä¸œè¥¿ï¼Œä½ å¯ä»¥ä½¿ç”¨å±æ€§å­—æ¯ï¼š</p>

<pre><code>/ &lt;:Letter&gt; /
</code></pre>

<p>Instead of matching a property, you can match characters that donâ€™t have that particular property. Put a <code>!</code> in front of the property name to negate it. This matches characters that arenâ€™t the title-case letters:</p>

<p>æ‚¨å¯ä»¥åŒ¹é…æ²¡æœ‰è¯¥ç‰¹å®šå±æ€§çš„å­—ç¬¦ï¼Œè€Œä¸æ˜¯åŒ¹é…å±æ€§ã€‚æ”¾ä¸€ä¸ªï¼åœ¨å±æ€§åç§°å‰é¢å¦å®šå®ƒã€‚è¿™åŒ¹é…ä¸æ˜¯æ ‡é¢˜å¤§å°å†™å­—æ¯çš„å­—ç¬¦ï¼š</p>

<pre><code>/ &lt;:!TitlecaseLetter&gt; /
</code></pre>

<p>Each property has a long form, like <code>Letter</code>, and a short form, in this case <code>L</code>. There are other properties, such as <code>Uppercase_Letter</code> and <code>Lu</code>, or <code>Number</code> and <code>N</code>:</p>

<p>æ¯ä¸ªå±æ€§éƒ½æœ‰ä¸€ä¸ªé•¿æ ¼å¼ï¼Œå¦‚Letterå’ŒçŸ­æ ¼å¼ï¼Œåœ¨æœ¬ä¾‹ä¸­ä¸ºL.è¿˜æœ‰å…¶ä»–å±æ€§ï¼Œå¦‚Uppercase_Letterå’ŒLuï¼Œæˆ–Numberå’ŒNï¼š</p>

<pre><code>/ &lt;:L&gt; /
/ &lt;:N&gt; /
</code></pre>

<p>You can match the characters that belong to certain Unicode blocks or scripts:</p>

<p>æ‚¨å¯ä»¥åŒ¹é…å±äºæŸäº›Unicodeå—æˆ–è„šæœ¬çš„å­—ç¬¦ï¼š</p>

<pre><code>&lt;:Block('Basic Latin')&gt;
&lt;:Script&lt;Latin&gt;&gt;
</code></pre>

<p>Even though you can abbreviate these property names Iâ€™ll use the longer names in this book. See the documentation for the other properties.</p>

<p>å³ä½¿æ‚¨å¯ä»¥ç¼©å†™è¿™äº›å±æ€§åç§°ï¼Œæˆ‘ä¹Ÿä¼šåœ¨æœ¬ä¹¦ä¸­ä½¿ç”¨è¾ƒé•¿çš„åç§°ã€‚è¯·å‚é˜…å…¶ä»–å±æ€§çš„æ–‡æ¡£ã€‚</p>

<h3 id="combining-properties">COMBINING PROPERTIES</h3>

<p>One property might not be enough to describe what you want to match. To build fancier ones, combine them with character class set operators. These arenâ€™t the same operators you saw in <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch14.html#camelia-junctions">Chapter 14</a>; theyâ€™re special to character classes.</p>

<p>The <code>+</code> creates the union of the two properties. Any character that has either property will match:</p>

<p>ä¸€ä¸ªå±æ€§å¯èƒ½ä¸è¶³ä»¥æè¿°æ‚¨æƒ³è¦åŒ¹é…çš„å†…å®¹ã€‚è¦æ„å»ºæ›´é«˜çº§çš„ï¼Œå°†å®ƒä»¬ä¸å­—ç¬¦ç±»é›†åˆè¿ç®—ç¬¦ç»„åˆã€‚è¿™äº›ä¸ç¬¬14ç« ä¸­çœ‹åˆ°çš„æ“ä½œç¬¦ä¸åŒ;ä»–ä»¬å¯¹è§’è‰²è¯¾å¾ˆç‰¹åˆ«ã€‚</p>

<p>+åˆ›å»ºä¸¤ä¸ªå±æ€§çš„å¹¶é›†ã€‚ä»»ä½•å…·æœ‰ä»»ä½•å±æ€§çš„å­—ç¬¦éƒ½å°†åŒ¹é…ï¼š</p>

<pre><code>/ &lt;:Letter + :Number&gt; /
/ &lt;:Open_Punctuation + :Close_Punctuation&gt; /
</code></pre>

<p>Subtract one property from another with <code>-</code>. Any character with the first property that doesnâ€™t have the second property will match this. The following example matches all the identifier characters (in the UCD sense, not the Perl 6 sense). There are the characters that can start an identifier and those that can be in the other positions:</p>

<p>ç”¨ - å‡å»å¦ä¸€ä¸ªå±æ€§ã€‚å…·æœ‰ç¬¬ä¸€ä¸ªå±æ€§ä½†æ²¡æœ‰ç¬¬äºŒä¸ªå±æ€§çš„ä»»ä½•å­—ç¬¦éƒ½å°†ä¸æ­¤åŒ¹é…ã€‚ä»¥ä¸‹ç¤ºä¾‹åŒ¹é…æ‰€æœ‰æ ‡è¯†ç¬¦å­—ç¬¦ï¼ˆåœ¨UCDæ„ä¹‰ä¸Šï¼Œè€Œä¸æ˜¯Perl 6æ„ä¹‰ä¸Šï¼‰ã€‚å¯ä»¥å¯åŠ¨æ ‡è¯†ç¬¦çš„å­—ç¬¦å’Œå¯ä»¥ä½äºå…¶ä»–ä½ç½®çš„å­—ç¬¦ï¼š</p>

<pre><code>/ &lt;:ID_Continue - :Number&gt; /
</code></pre>

<p>You can shorten this to not match a character without a particular property. It looks like you leave off the first part of the subtraction; the <code>-</code> comes right after the opening angle bracket. That implies youâ€™re subtracting from all characters. This matches all the characters that donâ€™t have the <code>Letter</code> property:</p>

<p>æ‚¨å¯ä»¥å°†æ­¤ç¼©çŸ­ä¸ºä¸æ²¡æœ‰ç‰¹å®šå±æ€§çš„è§’è‰²ä¸åŒ¹é…ã€‚çœ‹èµ·æ¥ä½ æ”¾å¼ƒäº†å‡æ³•çš„ç¬¬ä¸€éƒ¨åˆ†; - åœ¨æ‰“å¼€è§’åº¦æ”¯æ¶åé¢ã€‚è¿™æ„å‘³ç€ä½ è¦ä»æ‰€æœ‰è§’è‰²ä¸­å‡å»ã€‚è¿™åŒ¹é…æ‰€æœ‰æ²¡æœ‰Letterå±æ€§çš„å­—ç¬¦ï¼š</p>

<pre><code>/ &lt;-:Letter&gt; /
</code></pre>

<p>EXERCISE 15.3Write a program to count all of the characters that match either the <code>Letter</code> or <code>Number</code> properties. What percentage of the code points between 1 and 0xFFFD are either letters or numbers? The <code>.chr</code> method may be handy here.</p>

<p>ç»ƒä¹ 15.3ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥è®¡ç®—ä¸Letteræˆ–Numberå±æ€§åŒ¹é…çš„æ‰€æœ‰å­—ç¬¦ã€‚ 1å’Œ0xFFFDä¹‹é—´çš„ä»£ç ç‚¹ç™¾åˆ†æ¯”æ˜¯å­—æ¯è¿˜æ˜¯æ•°å­—ï¼Ÿ .chræ–¹æ³•åœ¨è¿™é‡Œå¯èƒ½å¾ˆæ–¹ä¾¿ã€‚</p>

<h2 id="user-defined-character-classes">User-Defined Character Classes</h2>

<p>You can define your own character classes. Put the characters that you want to match inside <code>&lt;[...]&gt;</code>. These arenâ€™t the same square brackets that you saw earlier for grouping; these are inside the angle brackets. This character class matches either <code>a</code>, <code>b</code>, or <code>3</code>:</p>

<p>æ‚¨å¯ä»¥å®šä¹‰è‡ªå·±çš„è§’è‰²ç±»ã€‚å°†è¦åŒ¹é…çš„å­—ç¬¦æ”¾åœ¨&lt;[&hellip;]&gt;ä¸­ã€‚è¿™äº›ä¸æ‚¨ä¹‹å‰çœ‹åˆ°çš„ç”¨äºåˆ†ç»„çš„æ–¹æ‹¬å·ä¸åŒ;è¿™äº›éƒ½åœ¨å°–æ‹¬å·å†…ã€‚æ­¤å­—ç¬¦ç±»åŒ¹é…aï¼Œbæˆ–3ï¼š</p>

<pre><code>/ &lt;[ab3]&gt; /
</code></pre>

<p>As with everything else so far, this matches one character and that one character can be any of the characters in the character class. This character class matches either case at a single position:</p>

<p>ä¸ç›®å‰ä¸ºæ­¢çš„æ‰€æœ‰å…¶ä»–å†…å®¹ä¸€æ ·ï¼Œå®ƒåŒ¹é…ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”ä¸€ä¸ªå­—ç¬¦å¯ä»¥æ˜¯å­—ç¬¦ç±»ä¸­çš„ä»»ä½•å­—ç¬¦ã€‚æ­¤å­—ç¬¦ç±»åŒ¹é…å•ä¸ªä½ç½®çš„ä»»ä¸€ä¸ªæ¡ˆä¾‹ï¼š</p>

<pre><code>/ &lt;[Hh]&gt; ama /    # also / [ :i h ] ama /
</code></pre>

<p>You could specify the hexadecimal value of the code point. The whitespace is insignificant:</p>

<p>æ‚¨å¯ä»¥æŒ‡å®šä»£ç ç‚¹çš„åå…­è¿›åˆ¶å€¼ã€‚ç©ºç™½æ˜¯å¾®ä¸è¶³é“çš„ï¼š</p>

<pre><code>/ &lt;[ \x[48] \x[68] ]&gt; ama /
</code></pre>

<p>The character name versions work too:</p>

<p>è§’è‰²åç§°ç‰ˆæœ¬ä¹Ÿé€‚ç”¨ï¼š</p>

<pre><code>/ &lt;[
    \c[LATIN CAPITAL LETTER H]
    \c[LATIN SMALL LETTER H]
    ]&gt;
/
</code></pre>

<p>You can make a long list of characters:</p>

<p>æ‚¨å¯ä»¥åˆ¶ä½œä¸€é•¿ä¸²å­—ç¬¦ï¼š</p>

<pre><code>/ &lt;[abcdefghijklmnopqrstuvwxyz]&gt; / # from a to z
</code></pre>

<p>Inside the character class the <code>#</code> is just a <code>#</code>. If you try to put a comment in there all of the characters in your message become part of the character class:</p>

<p>åœ¨è§’è‰²ç±»ä¸­ï¼Œï¼ƒåªæ˜¯ä¸€ä¸ªï¼ƒã€‚å¦‚æœæ‚¨å°è¯•åœ¨å…¶ä¸­æ”¾ç½®æ³¨é‡Šï¼Œåˆ™æ¶ˆæ¯ä¸­çš„æ‰€æœ‰å­—ç¬¦éƒ½å°†æˆä¸ºå­—ç¬¦ç±»çš„ä¸€éƒ¨åˆ†ï¼š</p>

<pre><code>/ &lt;[
    \x[48] # uppercase
    \x[68] # lowercase
  ]&gt;
/
</code></pre>

<p>Youâ€™ll probably get warnings about repeated characters if you try to do that.</p>

<p>å¦‚æœæ‚¨å°è¯•è¿™æ ·åšï¼Œæ‚¨å¯èƒ½ä¼šæ”¶åˆ°æœ‰å…³é‡å¤å­—ç¬¦çš„è­¦å‘Šã€‚</p>

<h3 id="character-class-ranges">CHARACTER CLASS RANGES</h3>

<p>But thatâ€™s too much work. You can use <code>..</code> to specify a range of characters. The literal characters work as well as the hexadecimal values and the names. Notice you donâ€™t quote the literal characters in these ranges:</p>

<p>ä½†é‚£å·¥ä½œå¤ªå¤šäº†ã€‚æ‚¨å¯ä»¥ä½¿ç”¨..æŒ‡å®šä¸€ç³»åˆ—å­—ç¬¦ã€‚æ–‡å­—å­—ç¬¦ä»¥åŠåå…­è¿›åˆ¶å€¼å’Œåç§°éƒ½èµ·ä½œç”¨ã€‚è¯·æ³¨æ„ï¼Œæ‚¨ä¸å¼•ç”¨è¿™äº›èŒƒå›´ä¸­çš„æ–‡å­—å­—ç¬¦ï¼š</p>

<pre><code>/ &lt;[a..z]&gt; /
/ &lt;[ \x[61] .. \x[7a] ]&gt; /
/ &lt;[ \c[LATIN SMALL LETTER A] .. \c[LATIN SMALL LETTER Z] ]&gt; /
</code></pre>

<p>The range doesnâ€™t have to be the only thing in the square brackets:</p>

<p>èŒƒå›´ä¸ä¸€å®šæ˜¯æ–¹æ‹¬å·ä¸­çš„å”¯ä¸€å†…å®¹ï¼š</p>

<pre><code>/ &lt;[a..z 123456789]&gt; /
</code></pre>

<p>You could have two ranges:</p>

<p>ä½ å¯ä»¥æœ‰ä¸¤ä¸ªèŒƒå›´ï¼š</p>

<pre><code>/ &lt;[a..z 1..9]&gt; /
</code></pre>

<h3 id="negated-character-classes">NEGATED CHARACTER CLASSES</h3>

<p>Sometimes itâ€™s easier to specify the characters that canâ€™t match. You can create a negated character class by adding a <code>-</code> between the opening angle bracket and the opening square bracket. This example matches any character that is <em>not</em> <code>a</code>, <code>b</code>, or <code>3</code>:</p>

<p>æœ‰æ—¶ï¼ŒæŒ‡å®šæ— æ³•åŒ¹é…çš„å­—ç¬¦ä¼šæ›´å®¹æ˜“ã€‚æ‚¨å¯ä»¥é€šè¿‡åœ¨å¼€è§’æ‹¬å·å’Œå¼€å§‹æ–¹æ‹¬å·ä¹‹é—´æ·»åŠ  - æ¥åˆ›å»ºå¦å®šå­—ç¬¦ç±»ã€‚æ­¤ç¤ºä¾‹åŒ¹é…ä»»ä½•ä¸æ˜¯aï¼Œbæˆ–3çš„å­—ç¬¦ï¼š</p>

<pre><code>/ &lt;-[ab3]&gt; /
</code></pre>

<p>Space inside a character class is also insignificant:</p>

<p>å­—ç¬¦ç±»ä¸­çš„ç©ºæ ¼ä¹Ÿæ˜¯å¾®ä¸è¶³é“çš„ï¼š</p>

<pre><code>/ &lt;-[ a b 3 ]&gt; /
</code></pre>

<p>You can use a negated character class of one character. Quotes inside the character class are literal characters because Perl 6 knows you arenâ€™t quoting:</p>

<p>æ‚¨å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå­—ç¬¦çš„å¦å®šå­—ç¬¦ç±»ã€‚å­—ç¬¦ç±»ä¸­çš„å¼•å·æ˜¯æ–‡å­—å­—ç¬¦ï¼Œå› ä¸ºPerl 6çŸ¥é“æ‚¨æ²¡æœ‰å¼•ç”¨ï¼š</p>

<pre><code>/ &lt;-[ ' ]&gt;  /   # not a quote character
</code></pre>

<p>This one matches any character that is not a newline:</p>

<p>è¿™ä¸ªåŒ¹é…ä»»ä½•ä¸æ˜¯æ¢è¡Œç¬¦çš„å­—ç¬¦ï¼š</p>

<pre><code>/ &lt;-[ \n ]&gt; /   # not a newline
</code></pre>

<p>The predefined character class shortcuts can be part of your character class:</p>

<p>é¢„å®šä¹‰çš„å­—ç¬¦ç±»å¿«æ·æ–¹å¼å¯ä»¥æ˜¯æ‚¨çš„è§’è‰²ç±»çš„ä¸€éƒ¨åˆ†ï¼š</p>

<pre><code>/ &lt;-[ \d \s ]&gt; /   # digits or whitespace
</code></pre>

<p>Like the Unicode properties, you can combine sets of characters:</p>

<p>ä¸Unicodeå±æ€§ä¸€æ ·ï¼Œæ‚¨å¯ä»¥ç»„åˆå­—ç¬¦é›†ï¼š</p>

<pre><code>/ &lt;[abc] + [xyz]&gt; /    # but, also &lt;[abcxyz]&gt;

/ &lt;[a..z] - [ijk]&gt; /   # easier than two ranges
</code></pre>

<p>EXERCISE 15.4Create a program to output all the input lines. Skip any line that contains a letter unless itâ€™s a vowel. Also skip any lines that are blank (that is, only have whitespace).</p>

<p>ç»ƒä¹ 15.4åˆ›å»ºä¸€ä¸ªç¨‹åºæ¥è¾“å‡ºæ‰€æœ‰è¾“å…¥è¡Œã€‚è·³è¿‡åŒ…å«å­—æ¯çš„ä»»ä½•è¡Œï¼Œé™¤éå®ƒæ˜¯å…ƒéŸ³ã€‚ä¹Ÿè·³è¿‡ä»»ä½•ç©ºç™½è¡Œï¼ˆå³åªæœ‰ç©ºæ ¼ï¼‰ã€‚</p>

<h1 id="matching-adverbs">Matching Adverbs</h1>

<p>You can change how the match operator works by applying adverbs, just like you changed how <code>Q</code> worked in <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch04.html#camelia-strings">Chapter 4</a>. There are several, but youâ€™ll only see the most commonly used here.</p>

<p>æ‚¨å¯ä»¥é€šè¿‡åº”ç”¨å‰¯è¯æ¥æ›´æ”¹åŒ¹é…è¿ç®—ç¬¦çš„å·¥ä½œæ–¹å¼ï¼Œå°±åƒæ‚¨åœ¨ç¬¬4ç« ä¸­æ›´æ”¹Qçš„å·¥ä½œæ–¹å¼ä¸€æ ·ã€‚æœ‰å‡ ä¸ªï¼Œä½†æ‚¨åªä¼šçœ‹åˆ°æ­¤å¤„æœ€å¸¸ç”¨çš„ã€‚</p>

<h2 id="matching-either-case">Matching Either Case</h2>

<p>So far a character in your pattern matches exactly the same character in the target. An <code>H</code> only matches an uppercase <em>H</em> and not any other sort of <em>H</em>:</p>

<p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ¨¡å¼ä¸­çš„å­—ç¬¦ä¸ç›®æ ‡ä¸­çš„å­—ç¬¦å®Œå…¨åŒ¹é…ã€‚ HåªåŒ¹é…å¤§å†™çš„Hè€Œä¸æ˜¯ä»»ä½•å…¶ä»–ç±»å‹çš„Hï¼š</p>

<pre><code>my $pattern = rx/ Hama /;
put 'Hamadryas' ~~ $pattern;  # Matches
</code></pre>

<p>Change your pattern by one character. Instead of an uppercase <code>H</code>, use a lowercase one:</p>

<p>å°†æ¨¡å¼æ›´æ”¹ä¸ºä¸€ä¸ªå­—ç¬¦ã€‚è€Œä¸æ˜¯å¤§å†™çš„Hï¼Œä½¿ç”¨å°å†™çš„ï¼š</p>

<pre><code>my $pattern = rx/ hama /;
put 'Hamadryas' ~~ $pattern;  # Misses because h is not H
</code></pre>

<p>The pattern is case sensitive, so this doesnâ€™t match. But you can make it case insensitive with an adverb. The <code>:i</code>adverb makes the literal alphabetic characters match either case. You can put the adverb right after the <code>rx</code> or the <code>m</code>:</p>

<p>è¯¥æ¨¡å¼åŒºåˆ†å¤§å°å†™ï¼Œå› æ­¤ä¸åŒ¹é…ã€‚ä½†æ˜¯ä½ å¯ä»¥ç”¨å‰¯è¯åŒºåˆ†å¤§å°å†™ã€‚ ï¼šiadverbä½¿æ–‡å­—å­—æ¯ç¬¦åˆä¸¤ç§æƒ…å†µã€‚ä½ å¯ä»¥æŠŠå‰¯è¯æ”¾åœ¨rxæˆ–mä¹‹åï¼š</p>

<pre><code>my $pattern = rx:i/ hama /;
put 'Hamadryas' ~~ $pattern;  # Matches, :i outside
</code></pre>

<p>This is the reason you canâ€™t use the colon as the delimiter!</p>

<p>When you use an adverb on the outside of the pattern, that adverb applies to the entire pattern. You can also put the adverb on the inside of the pattern:</p>

<p>è¿™å°±æ˜¯ä½ ä¸èƒ½ä½¿ç”¨å†’å·ä½œä¸ºåˆ†éš”ç¬¦çš„åŸå› ï¼</p>

<p>åœ¨æ¨¡å¼å¤–éƒ¨ä½¿ç”¨å‰¯è¯æ—¶ï¼Œè¯¥å‰¯è¯é€‚ç”¨äºæ•´ä¸ªæ¨¡å¼ã€‚ä½ ä¹Ÿå¯ä»¥æŠŠå‰¯è¯æ”¾åœ¨æ¨¡å¼çš„å†…éƒ¨ï¼š</p>

<pre><code>my $pattern = rx/ :i hama /;
put 'Hamadryas' ~~ $pattern;  # Matches, :i inside
</code></pre>

<p>Isnâ€™t that interesting? Now you start to see why whitespace isnâ€™t counted as part of the pattern. Thereâ€™s much more going on besides literal matching of characters.</p>

<p>The adverb applies from the point of its insertion to the end of the pattern. In this case it applies to the entire pattern because the <code>:i</code> is at the beginning. Put that adverb later in the pattern, and it applies from there to the rest of the pattern. Here the <code>ha</code> only match lowercase because the adverb shows up later. The rest of the pattern after the <code>:i</code> is case insensitive:</p>

<p>é‚£ä¸æ˜¯å¾ˆæœ‰è¶£å—ï¼Ÿç°åœ¨ä½ å¼€å§‹æ˜ç™½ä¸ºä»€ä¹ˆç©ºæ ¼ä¸ç®—ä½œæ¨¡å¼çš„ä¸€éƒ¨åˆ†ã€‚é™¤äº†å­—ç¬¦çš„å­—é¢åŒ¹é…ä¹‹å¤–è¿˜æœ‰æ›´å¤šçš„äº‹æƒ…è¦åšã€‚</p>

<p>å‰¯è¯ä»æ’å…¥ç‚¹åˆ°æ¨¡å¼ç»“å°¾ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒé€‚ç”¨äºæ•´ä¸ªæ¨¡å¼ï¼Œå› ä¸ºï¼šiåœ¨å¼€å¤´ã€‚å°†è¯¥å‰¯è¯æ”¾åœ¨æ¨¡å¼ä¸­ï¼Œç„¶åä»é‚£é‡Œåº”ç”¨åˆ°æ¨¡å¼çš„å…¶ä½™éƒ¨åˆ†ã€‚ haåªä¸å°å†™åŒ¹é…ï¼Œå› ä¸ºå‰¯è¯ä¼šåœ¨ç¨åå‡ºç°ã€‚åœ¨ä»¥ä¸‹æƒ…å†µä¹‹åçš„å…¶ä½™æ¨¡å¼ï¼šiä¸åŒºåˆ†å¤§å°å†™ï¼š</p>

<pre><code>my $pattern = rx/ ha :i ma /; # final ma case insensitive
</code></pre>

<p>You can group parts of patterns with square brackets. This example groups the <code>am</code> but doesnâ€™t do much else because thereâ€™s nothing else special going on:</p>

<p>æ‚¨å¯ä»¥ä½¿ç”¨æ–¹æ‹¬å·å¯¹éƒ¨åˆ†å›¾æ¡ˆè¿›è¡Œåˆ†ç»„ã€‚è¿™ä¸ªä¾‹å­å¯¹amè¿›è¡Œåˆ†ç»„ï¼Œä½†æ²¡æœ‰åšå¤ªå¤šå…¶ä»–äº‹æƒ…ï¼Œå› ä¸ºæ²¡æœ‰å…¶ä»–ç‰¹åˆ«çš„äº‹æƒ…ï¼š</p>

<pre><code>my $pattern = rx/ h [ am ] a /;
</code></pre>

<p>An adverb inside a group applies only to that group:</p>

<p>ç»„å†…çš„å‰¯è¯ä»…é€‚ç”¨äºè¯¥ç»„ï¼š</p>

<pre><code>my $pattern = rx/ h [ :i am ] a /;
</code></pre>

<p>The rules are the same: the adverb applies from the point of its insertion to the end of the group:</p>

<p>è§„åˆ™æ˜¯ç›¸åŒçš„ï¼šå‰¯è¯ä»æ’å…¥ç‚¹åˆ°ç»„å°¾ï¼š</p>

<pre><code>my $pattern = rx/ h [ a :i m ] a /; # matches haMa or hama
</code></pre>

<p>At this point, youâ€™re probably going to start mixing up whatâ€™s going on. Thereâ€™s another reason whitespace doesnâ€™t matterâ€”you can add comments to your pattern:</p>

<p>åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œä½ å¯èƒ½ä¼šå¼€å§‹æ··æ·†æ­£åœ¨å‘ç”Ÿçš„äº‹æƒ…ã€‚ç©ºç™½æ— å…³ç´§è¦çš„å¦ä¸€ä¸ªåŸå›  - æ‚¨å¯ä»¥ä¸ºæ‚¨çš„æ¨¡å¼æ·»åŠ æ³¨é‡Šï¼š</p>

<pre><code>my $pattern = rx/
    h
    [       # group this next part
        a
        :i   # case insensitive to end of group
        m
    ]       # end of group
    a
    /;
</code></pre>

<p>Everything from the <code>#</code> character to the end of the line is a comment. You can use embedded comments too:</p>

<p>ä»ï¼ƒå­—ç¬¦åˆ°è¡Œå°¾çš„æ‰€æœ‰å†…å®¹éƒ½æ˜¯æ³¨é‡Šã€‚æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨åµŒå…¥å¼æ³¨é‡Šï¼š</p>

<pre><code>my $pattern = rx/
    :i #`( case insensitive ) Hama
    /;
</code></pre>

<p>These arenâ€™t particularly good comments because youâ€™re annotating what the syntax already denotes. As a matter of good practice, you should comment what you are trying to match rather than what the syntax does. However, the world isnâ€™t going to end if you leave a reminder for yourself of what a new concept does.</p>

<p>EXERCISE 15.5Write a program that outputs only the lines of input that contain the text <code>ei</code>. Youâ€™ll probably want to save this program to build on in later exercises.</p>

<p>è¿™äº›å¹¶ä¸æ˜¯ç‰¹åˆ«å¥½çš„æ³¨é‡Šï¼Œå› ä¸ºæ‚¨æ­£åœ¨æ³¨é‡Šè¯­æ³•å·²ç»è¡¨ç¤ºçš„å†…å®¹ã€‚ä½œä¸ºä¸€ç§è‰¯å¥½å®è·µï¼Œæ‚¨åº”è¯¥è¯„è®ºæ‚¨è¦åŒ¹é…çš„å†…å®¹è€Œä¸æ˜¯è¯­æ³•çš„å†…å®¹ã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ ç»™è‡ªå·±ç•™ä¸‹ä¸€ä¸ªæ–°æ¦‚å¿µçš„æé†’ï¼Œä¸–ç•Œå°±ä¸ä¼šç»“æŸã€‚</p>

<p>ç»ƒä¹ 15.5ç¼–å†™ä¸€ä¸ªåªè¾“å‡ºåŒ…å«æ–‡æœ¬eiçš„è¾“å…¥è¡Œçš„ç¨‹åºã€‚ä½ å¯èƒ½æƒ³è¦ä¿å­˜è¿™ä¸ªç¨‹åºï¼Œä»¥ä¾¿åœ¨ä»¥åçš„ç»ƒä¹ ä¸­ç»§ç»­ä½¿ç”¨ã€‚</p>

<h2 id="ignoring-marks">Ignoring Marks</h2>

<p>The <code>:ignoremark</code> adverb changes the pattern so that accents and other marks donâ€™t matter. The marks can be there or not. It works if the marks are in the target or the pattern:</p>

<p>ï¼šignoremarkå‰¯è¯ä¼šæ›´æ”¹æ¨¡å¼ï¼Œä»¥ä¾¿é‡éŸ³å’Œå…¶ä»–æ ‡è®°æ— å…³ç´§è¦ã€‚æ ‡è®°å¯ä»¥å­˜åœ¨ä¸å¦ã€‚å¦‚æœæ ‡è®°åœ¨ç›®æ ‡æˆ–æ¨¡å¼ä¸­ï¼Œå®ƒå¯ä»¥å·¥ä½œï¼š</p>

<pre><code>$_ = 'hÃºdiÃ©';   # ??
put m/ hudie /            ?? 'Matched' !! 'Missed';  # Missed
put m:ignoremark/ hudie / ?? 'Matched' !! 'Missed';  # Matched

$_ = 'hudie';
put m:ignoremark/ hÃºdiÃ© / ?? 'Matched' !! 'Missed';  # Matched
</code></pre>

<p>It even works if both the target and the pattern have different marks in the same positions:</p>

<p>å¦‚æœç›®æ ‡å’Œæ¨¡å¼åœ¨ç›¸åŒä½ç½®å…·æœ‰ä¸åŒçš„æ ‡è®°ï¼Œå®ƒç”šè‡³å¯ä»¥å·¥ä½œï¼š</p>

<pre><code>$_ = 'hÃ¼diÃª';
put m:ignoremark/ hÃºdiÃ© / ?? 'Matched' !! 'Missed';  # Matched
</code></pre>

<p>Some adverbs can show up inside the pattern. They apply to the parts of the pattern that come after them:</p>

<p>ä¸€äº›å‰¯è¯å¯ä»¥å‡ºç°åœ¨æ¨¡å¼ä¸­ã€‚å®ƒä»¬é€‚ç”¨äºå®ƒä»¬ä¹‹åçš„æ¨¡å¼éƒ¨åˆ†ï¼š</p>

<pre><code>$_ = 'hÃ¼diÃª';
put m/ :ignoremark hudie / ?? 'Matched' !! 'Unmatched';  # Matched
</code></pre>

<h2 id="global-matches">Global Matches</h2>

<p>A pattern might be able to match several times in the same text. The <code>:global</code> adverb gets all of the nonoverlapping <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a>es. It returns a <a href="https://docs.perl6.org/type/List.html"><code>List</code></a>:</p>

<p>æ¨¡å¼å¯èƒ½èƒ½å¤Ÿåœ¨åŒä¸€æ–‡æœ¬ä¸­å¤šæ¬¡åŒ¹é…ã€‚ ï¼šå…¨å±€å‰¯è¯è·å–æ‰€æœ‰ä¸é‡å çš„åŒ¹é…ã€‚å®ƒè¿”å›ä¸€ä¸ªListï¼š</p>

<pre><code>$_ = 'Hamadryas perlicus';
my $matches = m:global/ . s /;
say $matches;   # (?as? ?us?)
</code></pre>

<p>No matches gets you an empty <a href="https://docs.perl6.org/type/List.html"><code>List</code></a>:</p>

<p>æ²¡æœ‰åŒ¹é…å¾—åˆ°ä¸€ä¸ªç©ºåˆ—è¡¨ï¼š</p>

<pre><code>$_ = 'Hamadryas perlicus';
my $matches = m:global/ six /;
say $matches;   # ()
</code></pre>

<p>The match operator can find overlapping matches too. Use <code>:overlap</code> to return a potentially longer list. The <code>?uta?</code> and <code>?ani?</code> here both match the same <em>a</em>:</p>

<p>åŒ¹é…è¿ç®—ç¬¦ä¹Ÿå¯ä»¥æ‰¾åˆ°é‡å åŒ¹é…ã€‚ä½¿ç”¨ï¼šé‡å ä»¥è¿”å›å¯èƒ½æ›´é•¿çš„åˆ—è¡¨ã€‚ ï¼Ÿï¼Ÿå’Œï¼Ÿaniï¼Ÿè¿™é‡Œä¸¤ä¸ªåŒ¹é…ç›¸åŒçš„aï¼š</p>

<pre><code>$_ = 'Bhutanitis thaidina';

my $global = m:global/ &lt;[aeiou]&gt; &lt;-[aeiou]&gt; &lt;[aeiou]&gt; /;
say $global;  # (?uta? ?iti? ?idi?)

my $overlap = m:overlap/ &lt;[aeiou]&gt; &lt;-[aeiou]&gt; &lt;[aeiou]&gt; /;
say $overlap; # (?uta? ?ani? ?iti? ?idi? ?ina?)
</code></pre>

<h1 id="things-that-use-patterns">Things That Use Patterns</h1>

<p>There are many features that you havenâ€™t been able to use so far because you hadnâ€™t seen regexes yet. Now youâ€™ve seen regexes, so you can see these things. There are a couple of <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> methods that work with a pattern to transform values. This section is a taste of the features youâ€™ll use most often.</p>

<p>The <code>.words</code> and <code>.comb</code> methods break up text. The <code>.split</code> method is the general case of that. It takes a pattern to decide how to break up the text. Whatever it matches are the parts that disappear. You could break up a line on tabs, for instance:</p>

<p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ‚¨è¿˜æ— æ³•ä½¿ç”¨è®¸å¤šåŠŸèƒ½ï¼Œå› ä¸ºæ‚¨å°šæœªçœ‹åˆ°æ­£åˆ™è¡¨è¾¾å¼ã€‚ç°åœ¨ä½ å·²ç»çœ‹è¿‡æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ‰€ä»¥ä½ å¯ä»¥çœ‹åˆ°è¿™äº›ä¸œè¥¿ã€‚æœ‰ä¸€äº›Stræ–¹æ³•å¯ä»¥ä½¿ç”¨æ¨¡å¼æ¥è½¬æ¢å€¼ã€‚æœ¬èŠ‚ä»‹ç»äº†æ‚¨æœ€å¸¸ä½¿ç”¨çš„åŠŸèƒ½ã€‚</p>

<p>.wordså’Œ.combæ–¹æ³•åˆ†è§£æ–‡æœ¬ã€‚ .splitæ–¹æ³•å°±æ˜¯è¿™ç§æƒ…å†µçš„ä¸€èˆ¬æƒ…å†µã€‚å®ƒéœ€è¦ä¸€ç§æ¨¡å¼æ¥å†³å®šå¦‚ä½•åˆ†è§£æ–‡æœ¬ã€‚æ— è®ºå®ƒåŒ¹é…ä»€ä¹ˆæ˜¯æ¶ˆå¤±çš„éƒ¨åˆ†ã€‚ä½ å¯ä»¥åœ¨æ ‡ç­¾ä¸Šåˆ’åˆ†ä¸€æ¡çº¿ï¼Œä¾‹å¦‚ï¼š</p>

<pre><code>my @words = $line.split: / \t /;
</code></pre>

<p><code>.grep</code> can use the match operator to select things. If the match operator succeeds it returns something thatâ€™s <code>True</code>, and that element is part of the result:</p>

<p><code>.grep</code>å¯ä»¥ä½¿ç”¨åŒ¹é…è¿ç®—ç¬¦æ¥é€‰æ‹©äº‹ç‰©ã€‚å¦‚æœåŒ¹é…è¿ç®—ç¬¦æˆåŠŸï¼Œåˆ™è¿”å›ä¸€äº›Trueï¼Œå¹¶ä¸”è¯¥å…ƒç´ æ˜¯ç»“æœçš„ä¸€éƒ¨åˆ†ï¼š</p>

<pre><code>my @words-with-e = @word.grep: /:i e/;
</code></pre>

<p>Or, to put it all together:</p>

<p>æˆ–è€…ï¼ŒæŠŠå®ƒä»¬æ”¾åœ¨ä¸€èµ·ï¼š</p>

<pre><code>my @words-with-e = $line.split( / \t / ).grep( /:i e/ );
</code></pre>

<p><code>.split</code> can specify multiple possible separators. Not all of them need be matches. This breaks up a line on a literal comma or whitespace:</p>

<p><code>.split</code>å¯ä»¥æŒ‡å®šå¤šä¸ªå¯èƒ½çš„åˆ†éš”ç¬¦ã€‚å¹¶éæ‰€æœ‰äººéƒ½éœ€è¦åŒ¹é…ã€‚è¿™ä¼šåœ¨æ–‡å­—é€—å·æˆ–ç©ºæ ¼ä¸Šåˆ’åˆ†ä¸€è¡Œï¼š</p>

<pre><code>my @words-with-e = $line
    .split( [ ',', / \s / ] )
    .grep( /:i e/ );
</code></pre>

<p><code>.comb</code> does a job similar to <code>.split</code>, but it breaks up the text by keeping the parts that matched. This keeps all the nonoverlapping groups of three digits and discards everything else:</p>

<p><code>.comb</code>çš„å·¥ä½œç±»ä¼¼äº.splitï¼Œä½†å®ƒé€šè¿‡ä¿ç•™åŒ¹é…çš„éƒ¨åˆ†æ¥åˆ†è§£æ–‡æœ¬ã€‚è¿™å°†ä¿ç•™æ‰€æœ‰ä¸‰ä¸ªæ•°å­—çš„éé‡å ç»„ï¼Œå¹¶ä¸¢å¼ƒå…¶ä»–æ‰€æœ‰å†…å®¹ï¼š</p>

<pre><code>my @digits = $line.comb: /\d\d\d/;
</code></pre>

<p>With no argument <code>.comb</code> uses the pattern of the single <code>.</code> to match any character. This breaks up a <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> into its characters without discarding anything:</p>

<p>æ²¡æœ‰å‚æ•°.combä½¿ç”¨å•ä¸€æ¨¡å¼ã€‚åŒ¹é…ä»»ä½•è§’è‰²ã€‚è¿™ä¼šå°†Stråˆ†è§£ä¸ºå…¶è§’è‰²è€Œä¸ä¸¢å¼ƒä»»ä½•å†…å®¹ï¼š</p>

<pre><code>my @characters = $line.comb: /./;
</code></pre>

<h2 id="substitutions">Substitutions</h2>

<p>The <code>.subst</code> method works with a pattern to substitute the matched text with other text:</p>

<p>.substæ–¹æ³•ä½¿ç”¨æ¨¡å¼å°†åŒ¹é…çš„æ–‡æœ¬æ›¿æ¢ä¸ºå…¶ä»–æ–‡æœ¬ï¼š</p>

<pre><code>my $line = &quot;This is PERL 6&quot;;
put $line.subst: /PERL/, 'Perl';  # This is Perl 6
</code></pre>

<p>This one makes the substitution for the first match:</p>

<p>è¿™ä¸ªæ›¿æ¢ç¬¬ä¸€åœºæ¯”èµ›ï¼š</p>

<pre><code>my $line = &quot;PERL PERL PERL&quot;;
put $line.subst: /PERL/, 'Perl';  # Perl PERL PERL
</code></pre>

<p>Use the <code>:g</code> adverb to make all possible substitutions:</p>

<p>ä½¿ç”¨ï¼šgå‰¯è¯è¿›è¡Œæ‰€æœ‰å¯èƒ½çš„æ›¿æ¢ï¼š</p>

<pre><code>my $line = &quot;PERL PERL PERL&quot;;
put $line.subst: /PERL/, 'Perl';  # Perl Perl Perl
</code></pre>

<p>Each of these returns the modified <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> and leaves the original alone. Use <code>.subst-mutate</code> to change the original value:</p>

<p>å…¶ä¸­æ¯ä¸ªéƒ½è¿”å›ä¿®æ”¹åçš„Strå¹¶å•ç‹¬ç•™ä¸‹åŸå§‹æ–‡ä»¶ã€‚ä½¿ç”¨.subst-mutateæ›´æ”¹åŸå§‹å€¼ï¼š</p>

<pre><code>my $line = &quot;PERL PERL PERL&quot;;
$line.subst-mutate: /PERL/, 'Perl', :g;
put $line;  # Perl Perl Perl
</code></pre>

<p>These will be much more useful with the regex features youâ€™ll see in the next chapter.</p>

<p>EXERCISE 15.6Using <code>.split</code>, output the third column of a tab-delimited file. The butterfly census file you made at the end of <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes">Chapter 9</a> would do nicely here.</p>

<p>å¯¹äºæ‚¨å°†åœ¨ä¸‹ä¸€ç« ä¸­çœ‹åˆ°çš„æ­£åˆ™è¡¨è¾¾å¼åŠŸèƒ½ï¼Œè¿™äº›åŠŸèƒ½å°†æ›´åŠ æœ‰ç”¨ã€‚</p>

<p>EXERCISE 15.6ä½¿ç”¨.splitï¼Œè¾“å‡ºåˆ¶è¡¨ç¬¦åˆ†éš”æ–‡ä»¶çš„ç¬¬ä¸‰åˆ—ã€‚ä½ åœ¨ç¬¬9ç« ç»“å°¾å¤„åˆ¶ä½œçš„è´è¶äººå£æ™®æŸ¥æ–‡ä»¶åœ¨è¿™é‡Œåšå¾—å¾ˆå¥½ã€‚</p>

<h1 id="summary">Summary</h1>

<p>You havenâ€™t seen the full power of regexes in this chapter since it was mostly about the mechanism of applying the patterns to text. Thatâ€™s not a big dealâ€”the patterns can be much more sophisticated, but the mechanisms are the same. In the next chapter youâ€™ll see most of the fancier features youâ€™ll regularly use.</p>

<p>åœ¨æœ¬ç« ä¸­ä½ æ²¡æœ‰çœ‹åˆ°æ­£åˆ™è¡¨è¾¾å¼çš„å…¨éƒ¨åŠŸèƒ½ï¼Œå› ä¸ºå®ƒä¸»è¦æ˜¯å…³äºå°†æ¨¡å¼åº”ç”¨äºæ–‡æœ¬çš„æœºåˆ¶ã€‚è¿™ä¸æ˜¯ä»€ä¹ˆå¤§é—®é¢˜ - æ¨¡å¼å¯ä»¥æ›´å¤æ‚ï¼Œä½†æœºåˆ¶æ˜¯ç›¸åŒçš„ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæ‚¨å°†çœ‹åˆ°æ‚¨ç»å¸¸ä½¿ç”¨çš„å¤§å¤šæ•°æ›´é«˜çº§çš„åŠŸèƒ½ã€‚</p>


        
          <div class="blog-tags">
            
              <a href="https://ohmysummer.github.io//tags/learningperl6/">LearningPerl6</a>&nbsp;
            
          </div>
        

        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://ohmysummer.github.io/post/2018-09-13-toptic-variable/" data-toggle="tooltip" data-placement="top" title="Toptic Variable">&larr; Previous Post</a>
            </li>
          
          
            <li class="next">
              <a href="https://ohmysummer.github.io/post/2018-09-16-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0.-%E6%9B%B4%E6%BC%82%E4%BA%AE%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-toggle="tooltip" data-placement="top" title="ç¬¬åå…­ç« . æ›´æ¼‚äº®çš„æ­£åˆ™è¡¨è¾¾å¼">Next Post &rarr;</a>
            </li>
          
        </ul>
      


      
        
          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ohmysummer" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
        
        
      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            
            <a href="https://ohmysummer.github.io/index.xml" title="RSS">
            
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://ohmysummer.github.io/">ç„‰çŸ¥éé±¼</a>
            
          

          <span style="color: red;">â¤</span>&nbsp;Perl 6
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.49</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://ohmysummer.github.io/js/main.js"></script>
<script src="https://ohmysummer.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script>
<script src="https://ohmysummer.github.io/js/load-photoswipe.js"></script>


<script>
  (function() {
    var cx = '009072066163920799339:qwme9vkotxk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>





  </body>
</html>

