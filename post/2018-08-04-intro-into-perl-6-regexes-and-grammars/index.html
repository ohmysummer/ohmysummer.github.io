<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="ohmysummer">
    <meta name="description" content="ohmysummer&#39;s personal website">
    <meta name="keywords" content="Perl6,Rakudo">

    <base href="http://ohmysummer.github.io/">
    <title>
  Intro Into Perl 6 Regexes and Grammars · 焉知非鱼
</title>

    <link rel="canonical" href="http://ohmysummer.github.io/post/2018-08-04-intro-into-perl-6-regexes-and-grammars/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.cd087ace86754b082dec94545567f8361cba42e84f8e15edbc4a9f6e52bd1f6a.css" integrity="sha256-zQh6zoZ1Swgt7JRUVWf4Nhy6QuhPjhXtvEqfblK9H2o=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://ohmysummer.github.io/css/style.css">
    

    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://ohmysummer.github.io/">
      焉知非鱼
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/post">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/categories">归档</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/page/about/">关于</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/tags">标签</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>Intro Into Perl 6 Regexes and Grammars</h1>
    </header>

    

<p><a href="tpm-regex.perl6.party">tpm-regex.perl6.party</a></p>

<h2 id="status-quo-pcre">STATUS QUO: PCRE</h2>

<p>“Perl 兼容的正则表达式”非常神秘，但许多语言只是盲目地遵循现状。</p>

<p><img src="https://tpm-regex.perl6.party/2018-pics/sheep1.jpg" alt="img" /></p>

<p>它们是 <code>&lt;?!</code>, <code>&lt;=?!</code>, or <code>&lt;!#?@$%^(</code> 吗？</p>

<pre><code class="language-perl">/(?&lt;!foo)bar(?=baz)/
</code></pre>

<p><img src="https://tpm-regex.perl6.party/2018-pics/sheep2.jpg" alt="img" /></p>

<h2 id="更好的正则表达式语法">更好的正则表达式语法</h2>

<p>Perl 6 并不害怕拒绝现状。</p>

<pre><code class="language-perl6">/&lt;!after foo&gt; bar &lt;before baz&gt;/
</code></pre>

<p><img src="https://tpm-regex.perl6.party/2018-pics/cat.jpg" alt="img" /></p>

<h2 id="空格可以自由使用">空格可以自由使用</h2>

<p>文字字符串：字母数字字符可以按原样使用。
其他的字符，只需使用引号或反斜杠：</p>

<pre><code class="language-perl6">say so &quot;I ♥ Perl 6&quot; ~~ /I \♥ Perl 6/;    # False
say so &quot;I ♥ Perl 6&quot; ~~ / 'I ♥ Perl 6' /; # True
say so &quot;I ♥ Perl 6&quot; ~~ /
    I #`(BTW, you can use inline,) &quot; ♥ &quot;
    &quot;Perl 6&quot; # as well as end-of-line comments
/; # True
</code></pre>

<h2 id="文本内容的变量">文本内容的变量</h2>

<p>默认设置是将内容与纯文本匹配。将变量放入尖括号中以将其解释为正则表达式。</p>

<pre><code class="language-perl6">my $stuff := 'the.+stuff';
say so &quot;the.+stuff&quot;      ~~ / $stuff /; # True
say so &quot;the other stuff&quot; ~~ / $stuff /; # False
say so &quot;the other stuff&quot; ~~ /&lt;$stuff&gt;/; # True
</code></pre>

<h2 id="方括号">方括号</h2>

<p>方括号用于非捕获分组：</p>

<pre><code class="language-perl6">say &quot;I really love Perl 6&quot; ~~ /
    I \s+ [really \s+]? 'love Perl 6'
/;  # OUTPUT: «｢I really love Perl 6｣␤»
</code></pre>

<h2 id="圆括号">圆括号</h2>

<p>圆括号仍用于捕获分组：</p>

<pre><code class="language-perl6">say &quot;I love Perl 6&quot; ~~ /
    I \s+ (\w+) ' Perl 6'
/;  # OUTPUT: «｢I love Perl 6｣
    #             0 =&gt; ｢love｣␤»
</code></pre>

<h2 id="与-pcre-相同">与 PCRE 相同&hellip;&hellip;</h2>

<p>有些东西保持不变：</p>

<pre><code class="language-perl6">say &quot;I love Perl 6&quot; ~~ /
    ^ . \s+ \S+ .? \w+ .*? \d+ $
/;  # OUTPUT: «｢I love Perl 6｣␤»
</code></pre>

<h2 id="除了">…除了</h2>

<p><code>^</code> 和 <code>$</code> 有更简单的含义：<strong>字符串</strong>的开始和结束 - 没有其他魔法。 <code>^^</code> 和 <code>$$</code> 用于<strong>行</strong>的开头和结尾（在 &ldquo;\n&rdquo; 之前，不包括在内）。</p>

<pre><code class="language-perl6">say so &quot;foo\n&quot; ~~ /^ foo $/;    # False
say so &quot;foo\n&quot; ~~ /^ foo \n $/; # True
say so &quot;foo\nbar&quot; ~~ /^ foo $$ \n ^^ bar $/; # True
</code></pre>

<h2 id="唔">唔&hellip;</h2>

<p>那么&hellip;&hellip; <code>\S+</code> 地狱？</p>

<pre><code class="language-perl6">/^ I \s+ truly \s+ madly \s+ deeply
    \s+ love  \s+ Perl  \s+ 6 \n  $/
</code></pre>

<p><img src="https://tpm-regex.perl6.party/2018-pics/cat-scared.jpg" alt="img" /></p>

<h2 id="sigspace">SIGSPACE</h2>

<p>不：使用 <strong><code>:sigspace</code></strong>（ <code>:s</code> 更短）
（在 grammars 中：声明 <strong><code>rule</code></strong> 而不是 <strong><code>token</code></strong>）</p>

<pre><code class="language-perl6">/^ :s I truly madly deeply love Perl 6 $/
</code></pre>

<p><img src="https://tpm-regex.perl6.party/2018-pics/cat-happy.jpg" alt="img" /></p>

<p><strong>SIGSPACE</strong> 在正则表达式中的 terms 之后自动放置 <strong><code>&lt;.ws&gt;</code></strong> token，<code>&lt;.ws&gt;</code> 默认情况下匹配零个或多个空白字符（只要不在单词内 (<strong><code>&lt;!ww&gt; \s*</code></strong>)）:</p>

<pre><code class="language-perl6">say so &quot;This is neat!&quot; ~~ /
  :s  This    is     neat \!
/; # True

say so &quot;This is neat!&quot; ~~ /
  :s  T h i s i s n e a t \!
/; # False
</code></pre>

<h2 id="字符类">字符类</h2>

<p>与之前相同，<strong><code>[...]</code></strong>，除了还添加尖括号（对特殊的东西使用尖括号是常见的模式）</p>

<pre><code class="language-perl6">say &quot;I love Perl 6&quot; ~~ /&lt;[a..zIP\d\s]&gt;+/
# OUTPUT: «｢I love Perl 6｣␤»
</code></pre>

<p>Ranges 使用 <strong><code>..</code></strong> 而不是 <strong><code>-</code></strong>。</p>

<p>要否定一个字符类，在方括号前放置一个减号：</p>

<pre><code class="language-perl6">say &quot;I love Perl 6&quot; ~~ /&lt;-[I]&gt; &lt;-[A..Z]&gt;+ \s+ \d+/
# OUTPUT: «｢Perl 6｣»
</code></pre>

<p>您可以通过添加/减去现有类来创建自定义类。使用加号而不是减号来添加内容：</p>

<pre><code class="language-perl6">say &quot;Awesome Perl 6&quot; ~~ /&lt;[\w]-[a..z]+[erl]&gt;**4/
# OUTPUT: «｢Perl｣»
</code></pre>

<p>匹配 Unicode 属性，在尖括号内使用冒号：</p>

<pre><code class="language-perl6">say &quot;Я люблю Perl 6&quot; ~~ /&lt;:Script('Latin')&gt;+/
# OUTPUT: «｢Perl｣»
</code></pre>

<p>可以否定 Unicode 属性或将它们与其他字符类混合和匹配：</p>

<pre><code class="language-perl6">say &quot;Я люблю Perl 6&quot; ~~ /&lt;-:Script('Latin')&gt;+/
# OUTPUT: «｢Я люблю ｣»

say &quot;Я люблю Perl 6&quot; ~~ /&lt;:Script('Latin')  +[\d\s]&gt;**4..*/
# OUTPUT: «｢ Perl 6｣»
</code></pre>

<h2 id="量化修改">量化修改</h2>

<p>匹配用分隔符分隔的东西：</p>

<pre><code class="language-perl6">say &quot;this,is,a,really,neat,feature&quot;
  ~~ /(\w+)**3 % ',' $/

# OUTPUT: «｢really,neat,feature｣
#             0 =&gt; ｢really｣
#             0 =&gt; ｢neat｣
#             0 =&gt; ｢feature｣»
</code></pre>

<p>捕获一个&rdquo;单词&rdquo; <strong><code>(\w+)</code></strong>，我们想要其中三个单词 <strong><code>**3</code></strong>，用逗号 <strong><code>% ','</code></strong> 分隔，锚定到字符串 <strong><code>$</code></strong> 的结尾。</p>

<h2 id="alternations">ALTERNATIONS</h2>

<p>最长 token 匹配（LTM）的选择 <code>|</code>，或首次列出的匹配 <code>||</code>：</p>

<pre><code class="language-perl6">say &quot;Perler&quot; ~~ / [Perl |  \w+] /;
# OUTPUT: «｢Perler｣» # this alternative is the longest

say &quot;Perler&quot; ~~ / [Perl || \w+] /;
# OUTPUT: «｢Perl｣»
# this alternative was the first listed in our regex
</code></pre>

<h2 id="变量的内容">变量的内容</h2>

<p>列表被解释为匹配的 alternatives 列表：</p>

<pre><code class="language-perl6">my @stuff := &lt;foo bar ber&gt;
say so &quot;thefoo&quot; ~~ /the @stuff/;      # True
say so &quot;thefoo&quot; ~~ /&lt; foo bar ber &gt;/; # True

# this is equivalent to the last regex above:
say so &quot;thefoo&quot; ~~ /[ foo | bar | ber ]/;
</code></pre>

<h2 id="conjugations">CONJUGATIONS</h2>

<p><strong><code>&amp;&amp;</code></strong> 测试两个正则表达式是否匹配字符串的相同部分：</p>

<pre><code class="language-perl6">say &quot;Perl ۶ or Perl 6&quot; ~~ / Perl \s+ \d /;
# OUTPUT: «｢Perl ۶｣␤»

say &quot;Perl ۶ or Perl 6&quot; ~~ /
    Perl \s+ [\d &amp;&amp; &lt;:Block('Basic Latin')&gt;]
/ # OUTPUT: «｢Perl 6｣␤»
</code></pre>

<h2 id="命名的-独立的正则表达式">命名的，独立的正则表达式</h2>

<p>在尖括号中使用其名称：</p>

<pre><code class="language-perl6">my regex quoted { \&quot; &lt;( &lt;-[&quot;]&gt;+ )&gt; \&quot; }

say 'I love &quot;Perl&quot; and &quot;Perl 6&quot;'
    ~~ /&lt;quoted&gt; &amp;&amp; .+ \d .+/;

# OUTPUT: «｢&quot;Perl 6&quot;｣
#            quoted =&gt; ｢Perl 6｣␤»
</code></pre>

<p><strong><code>&lt;(</code></strong> 是左匹配标记，<strong><code>)&gt;</code></strong> 是右匹配标记。控制在匹配中捕获的内容。（ <strong>&lt;(</strong> 在 Perl 5 中就像 <strong><code>\K</code></strong>）。</p>

<h2 id="命名捕获">命名捕获</h2>

<p>使用美元符号，后跟名称和等号。下一个 term 将被捕获（使用方括号将多个 term 分组以进行捕获）。</p>

<pre><code class="language-perl6">say '2018-07-26T19:00:00-04:00' ~~ /
    $&lt;year&gt;=\d**4 '-' $&lt;month&gt;=\d**2 '-' $&lt;day&gt;=[\d\d]
  T $&lt;time&gt;=[\d\d]**3 % ':'
/;

say &quot;TPM is at $&lt;time&gt; on $&lt;year month day&gt;.join('.')&quot;
# OUTPUT: «TPM is at 19:00:00 on 2018.07.26␤»
</code></pre>

<p>在正则表达式之外，<strong><code>$&lt;...&gt;</code></strong> 是 <strong><code>$/&lt;...&gt;</code></strong> 的快捷方式。 <strong><code>$/</code></strong> 是存储最后一个匹配项的默认变量，但您可以将匹配项赋值给任何变量：</p>

<pre><code class="language-perl6">my $m := 'I really love Perl 6' ~~ / :s
  (I|You) .+  $&lt;how&gt;=&lt; love like &gt;
  $&lt;what&gt;=.+
/;

say &quot;$0 $&lt;how&gt; $&lt;what&gt;&quot;;      # OUTPUT: «I love Perl 6␤»
say &quot;$/[0] $/&lt;how&gt; $/&lt;what&gt;&quot;; # OUTPUT: «I love Perl 6␤»
say &quot;$m[0] $m&lt;how&gt; $m&lt;what&gt;&quot;; # OUTPUT: «I love Perl 6␤»
</code></pre>

<p>几个用于命名捕获的修饰符：</p>

<pre><code class="language-perl6">&lt;foo&gt;       # match regex `foo` and capture under `foo`
&lt;.foo&gt;      # match, but don't capture
&lt;bar=.foo&gt;  # match, but name capture `bar` (in grammars)
&lt;bar=.&amp;foo&gt; # same as above, but used for standalone regexes
</code></pre>

<h2 id="重载">重载?</h2>

<p>你的大脑是否从所有新信息中融化了？</p>

<p><img src="https://tpm-regex.perl6.party/2018-pics/cat-exhausted.jpg" alt="img" /></p>

<h2 id="p5-模式">P5 模式</h2>

<p>在正则表达式上使用 <strong><code>:P5</code></strong> 副词启用 Perl 5（PCRE +）正则表达式模式：</p>

<pre><code class="language-perl6">say &quot;barbarbaz&quot; ~~ m:P5/(?&lt;!foo)bar(?=baz)/;
# OUTPUT: «｢bar｣␤»

say &quot;foo bar&quot; ~~ m:P5/foo ([a-r]+)/;
# OUTPUT: «｢foo bar｣
#            0 =&gt; ｢bar｣␤»
</code></pre>

<p>Perl 5.10 的大多数功能都可用。在学习 Perl 6 正则表达式时很好的训练轮，但很少被 Perl 6 用户使用。</p>

<h2 id="复杂的正则表达式">复杂的正则表达式</h2>

<p>让我们分解我们的 date-time 匹配正则表达式：</p>

<pre><code class="language-perl6">my regex date {
    $&lt;year&gt;=\d**4 '-' $&lt;month&gt;=\d**2 '-' $&lt;day&gt;=[\d\d]
}
my regex time { $&lt;clock&gt;=[\d\d]**3 % ':' $&lt;tz&gt;=.+ }
my regex date-time { &lt;date&gt; T &lt;time&gt; }
</code></pre>

<p>与它匹配会生成一个 <strong><code>Match</code></strong> 对象树，其中包含我们所有的命名捕获：</p>

<pre><code class="language-perl6">say '2018-07-26T19:00:00-04:00' ~~ &amp;date-time;

# OUTPUT: «｢2018-07-26T19:00:00-04:00｣
#             date =&gt; ｢2018-07-26｣
#                year =&gt; ｢2018｣
#                month =&gt; ｢07｣
#                day =&gt; ｢26｣
#             time =&gt; ｢19:00:00-04:00｣
#                clock =&gt; ｢19:00:00｣
#                tz =&gt; ｢-04:00｣␤»
</code></pre>

<p>我们可以访问单个内容，就像它是嵌套哈希一样：</p>

<pre><code class="language-perl6">'2018-07-26T19:00:00-04:00' ~~ &amp;date-time;
say &quot;In $&lt;date&gt;&lt;year&gt; TPM had a meeting at $&lt;time&gt;&lt;clock&gt;&quot;;

# OUTPUT: «In 2018 TPM had a meeting at 19:00:00␤»
</code></pre>

<h2 id="grammars-就像类一样">GRAMMARS 就像类一样</h2>

<p>单独的正则表达式就像单独的方法</p>

<pre><code class="language-perl6">my regex  re { ...               }
my method me { self.substr: 0, 3 }

say 'foobar' ~~ &amp;re; # OUTPUT: «｢foo｣␤»
say 'foobar' ~~ &amp;me; # OUTPUT: «foo␤»
</code></pre>

<p>独立的方法只是空想的 subs。第一个参数变成了调用者。</p>

<p>方法保存在 <strong>classes</strong> 中。正则表达式保留在 <strong>grammars</strong> 中。</p>

<pre><code class="language-perl6">grammar Re { regex  re { ...                 } }
class   Me { method me (\v) { v.substr: 0, 3 } }

say Re.subparse: 'foobar', :rule&lt;re&gt;; # OUTPUT: «｢foo｣␤»
say Me.me:       'foobar';            # OUTPUT: «foo␤»
</code></pre>

<p>grammars 开始解析的默认值是 <strong><code>TOP</code></strong>; 在这里，我们将其重写为 <strong><code>re</code></strong> regex。</p>

<p>你可以将 grammars 子类化并将角色混合到它们中&hellip;&hellip;</p>

<pre><code class="language-perl6">grammar GDate {
    regex TOP {
        $&lt;year&gt;=\d**4 '-' $&lt;month&gt;=\d**2 '-' $&lt;day&gt;=[\d\d]
    }
}
role GDateTime is GDate {
    regex time { $&lt;clock&gt;=[\d\d]**3 % ':' $&lt;tz&gt;=.+ }
    regex date-time { &lt;date=.GDate::TOP&gt; [T &lt;time&gt;]? }
}
</code></pre>

<p>&hellip;&hellip;甚至定义常规方法：</p>

<pre><code class="language-perl6">grammar TPM does GDateTime {
    regex TOP { &lt;date-time&gt; }
    method when (\date) {
        self.parse: date;
        say &quot;TPM had a meeting at &quot;
          ~ $&lt;date-time&gt;&lt;time&gt;&lt;clock&gt;
    }
}
TPM.when: '2018-07-26T19:00:00-04:00'
# OUTPUT: «TPM had a meeting at 19:00:00␤»
</code></pre>

<h2 id="其它正则表达式类型">其它正则表达式类型</h2>

<p>与 <strong><code>regex</code></strong> 一起，你还可以使用 <strong><code>rule</code></strong> 和 <strong><code>token</code></strong>：</p>

<pre><code class="language-perl6">grammar {
    regex TOP  { … }
    rule  date { … }
    token time { … }
}
</code></pre>

<ul>
<li><strong><code>token</code></strong> - 像 <strong><code>regex</code></strong>, 但是拥有 <strong><code>:ratchet</code></strong> (短形式：<strong><code>:r</code></strong>) 开启(不回溯)</li>
<li><strong><code>rule</code></strong> - 像 <strong><code>token</code></strong>, 但是拥有 <strong><code>sigspace</code></strong> (短形式：<strong><code>:s</code></strong>) 开启</li>
</ul>

<p>您可以在本地禁用这些副词：</p>

<pre><code class="language-perl6">rule date { # :ratchet and :sigspace here
    [ :!ratchet # no ratchet
        [
            :ratchet # ratchet again
        ]
        # no ratchet here
        [ :!sigspace
            # no ratchet and no sigspace here
        ]
    ]
}
</code></pre>

<h2 id="让我们解析一些东西">让我们解析一些东西</h2>

<p>构建 Grammar 来解析这些数据：</p>

<pre><code>[Grammars Talk]
    name: Zoffix
    lang: Perl 6
    topic: grammars and regexes
    length: 80
[Perf Talk]
    name: Zoffix
    lang: Perl 6
    topic: performance
    length: 30
</code></pre>

<pre><code class="language-perl6">grammar TPM {
    token key    { &lt;-[:\n]&gt;+         }
    token value  { &lt;-[\]\n]&gt;+        }
    rule row     { &lt;key&gt; ':' &lt;value&gt; }
    rule header  { '[' ~ ']' &lt;value&gt; }
    rule section { &lt;header&gt; &lt;row&gt;+   }
    rule TOP     { &lt;section&gt;+        }
}

TPM.parse: q:to/END/;
  [Grammars Talk]
      name: Zoffix
      lang: Perl 6
      topic: grammars and regexes
      length: 80
  [Perf Talk]
      name: Zoffix
      lang: Perl 6
      topic: performance
      length: 30
  END

my %result;
for $&lt;section&gt; {
    %result{.&lt;header&gt;&lt;value&gt;} = .&lt;row&gt;.map({
        ~.&lt;key&gt; =&gt; ~.&lt;value&gt;
    }).hash
}
say %result;

# OUTPUT:
# {
#   Grammars Talk =&gt; {
#     lang =&gt; Perl 6, length =&gt; 80, name =&gt; Zoffix,
#     topic =&gt; grammars and regexes
#   },
#   Perf Talk =&gt; {
#     lang =&gt; Perl 6, length =&gt; 30, name =&gt; Zoffix,
#     topic =&gt; performance
#   }
# }
</code></pre>

<h2 id="ewww">EWWW？</h2>

<p>如果我们对 token 进行更改，则可能很难在此处进行适当的更改。特别是对于大型 grammars。</p>

<pre><code class="language-perl6">my %result;
for $&lt;section&gt; {
    %result{.&lt;header&gt;&lt;value&gt;} = .&lt;row&gt;.map({
        ~.&lt;key&gt; =&gt; ~.&lt;value&gt;
    }).hash
}
say %result;
</code></pre>

<p>（Perl 6 核心 grammar 目前长 5,570 行）</p>

<h2 id="action-类">ACTION 类!</h2>

<p>一旦解析了 token（rule/regex），就会调用 Actions 类中具有相同名称的方法，并将该 token 的匹配对象作为参数</p>

<pre><code class="language-perl6">grammar Grammar {
    token TOP   { &lt;stuff&gt; }
    token stuff { …       }
}
class Actions {
    method TOP   ($match) { $match.make: $match.made }
    method stuff ($/)     { make 42 }
    # naming param `$/` lets us use some shortcuts
}
Grammar.parse('…', :actions(Actions)).made.say # 42
</code></pre>

<h2 id="make-made">MAKE/MADE</h2>

<p>这真的很简单：</p>

<pre><code class="language-perl6">class PretendMatch {
    has $!stuff;
    method make($stuff) {
        $!stuff = $stuff
    }
    method made { $!stuff }
}
</code></pre>

<p>只是一种附加并随后从 <strong><code>Match</code></strong> 对象中检索任意数据的方法。</p>

<p>方法为他们负责的 token 制作东西：</p>

<pre><code class="language-perl6">class TPMActions {
    method row     ($/) { make ~$&lt;key&gt; =&gt; ~$&lt;value&gt; }
    method header  ($/) { make ~$&lt;value&gt; }
    method section ($/) {
        make $&lt;header&gt;.made =&gt; $&lt;row&gt;».made.hash
    }
    method TOP ($/) { make $&lt;section&gt;».made.hash }
}
</code></pre>

<p>您不需要为每个 token 定义方法。</p>

<p>和以前一样，除了现在我们给我们的 Actions 类一个 <strong><code>:actions</code></strong> 命名参数：</p>

<pre><code class="language-perl6">my $match := TPM.parse: q:to/END/, :actions(TPMActions);
    [Grammars Talk]
        name: Zoffix

        […]
    END

dd $match.made
</code></pre>

<p>现在，我们可以自由地更改单个 token 和相应的 action 方法，而不会影响其他内容</p>

<pre><code class="language-perl6"># {
#     Grammars Talk =&gt; {
#         lang =&gt; Perl 6, length =&gt; 80, name =&gt; Zoffix,
#         topic =&gt; grammars and regexes
#     },
#     Perf Talk =&gt; {
#         lang =&gt; Perl 6, length =&gt; 30, name =&gt; Zoffix,
#         topic =&gt; performance
#     }
# }
</code></pre>

<h2 id="有用的模块">有用的模块</h2>

<p>安装 <strong><code>[ Grammar::Debugger](https://github.com/jnthn/grammar-debugger)</code></strong> (还包括 <strong><code>Grammar::Tracer</code></strong>)。</p>

<pre><code class="language-perl6">use Grammar::Tracer;
grammar {
    token TOP   { &lt;stuff&gt; }
    token stuff { &lt;some&gt; &lt;other&gt; }
    token some  { abc }
    token other { \d+ }
}.parse: 'abcdef';
</code></pre>

<p>只需 <strong><code>use</code></strong> 其中一个&hellip;&hellip;</p>

<p>&hellip;而漂亮的输出将显示你的 grammar 无法匹配的地方：</p>

<p><img src="https://tpm-regex.perl6.party/2018-pics/debugger.png" alt="img" /></p>

<h2 id="更多的-grammar-功能">更多的 GRAMMAR 功能</h2>

<p>&hellip;&hellip;我们今天不会谈论这个问题。</p>

<pre><code class="language-perl6"># Word boundaries
/ &lt;|w&gt; &lt;!|w&gt; &lt;ww&gt; &lt;!ww&gt;    /
/ «'Perl 6'»  &lt;&lt;'Perl 6'&gt;&gt; /

# Look arounds
/ &lt;!before …&gt; &lt;after …&gt; /
/ &lt;?[xyz]&gt; &lt;![xyz]&gt; /

# Executing arbitrary code and optionally using its value:
/   { ... }  /
/  &lt;{ ... }&gt; /
/ &lt;!{ ... }&gt; /
/ &lt;?{ ... }&gt; /

# The &quot;between&quot; operator and FAILGOAL method
grammar A {
    token TOP { '[' ~ ']' &lt;stuff-inside&gt;  };
    method FAILGOAL($goal) {
        die &quot;Cannot find $goal near position {self.pos}&quot;
    }
}

# Proto-regexes (sort of like multi-dispatch for regexes)
regex statement { &lt;term&gt; &lt;operator&gt; &lt;term&gt; }
regex operator:sym&lt;+&gt; { &lt;sym&gt; }
regex operator:sym&lt;-&gt; { &lt;sym&gt; }
...
method operator:sym&lt;-&gt; ($/) { say &quot;It's a minus op&quot; }
method operator:sym&lt;+&gt; ($/) { say &quot;It's a plus op&quot;  }
</code></pre>

<h2 id="grammer-book">GRAMMER BOOK</h2>

<p>由核心开发者 moritz++ 编写</p>

<p><img src="https://tpm-regex.perl6.party/2018-pics/grammar-book.png" alt="img" /></p>

<p><a href="https://www.amazon.com/Parsing-Perl-Regexes-Grammars-Recursive/dp/1484232275">亚马逊</a>和 <a href="https://www.apress.com/us/book/9781484232279">Apress</a> 上可买。</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>ohmysummer ❤ Perl 6</p>
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
