<!DOCTYPE html>
<html lang="zh" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Raku 中的特性(二) - Raku Programming</title>
  <meta name="description" content="Set  my $keywords = set &lt;if for unless while&gt;; # create a setsub has-keyword(*@words) {for @words -&gt; $word {return True if $word (elem) $keywords; # 依次检查数组中的元素是否属于集合 $keywords}False;}say has-keyword &#39;not&#39;, &#39;one&#39;, &#39;here&#39;; # Falsesay has-keyword &#39;but&#39;, &#39;here&#39;, &#39;for&#39;; # TrueSeries Operator  my @a=&lt;A G C T&gt;;my $x=@a;for 1 .">
  <meta name="author" content="焉知非鱼"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Raku Programming",
    
    "url": "https:\/\/ohmysummer.github.io\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/ohmysummer.github.io\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/ohmysummer.github.io\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/ohmysummer.github.io\/post\/2015-03-16-raku%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%BA%8C\/",
          "name": "Raku 中的特性(二)"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "焉知非鱼"
  },
  "headline": "Raku 中的特性(二)",
  "description" : "Set  my $keywords = set \u0026lt;if for unless while\u0026gt;; # create a set\rsub has-keyword(*@words) {\rfor @words -\u0026gt; $word {\rreturn True if $word (elem) $keywords; # 依次检查数组中的元素是否属于集合 $keywords\r}\rFalse;\r}\rsay has-keyword \u0027not\u0027, \u0027one\u0027, \u0027here\u0027; # False\rsay has-keyword \u0027but\u0027, \u0027here\u0027, \u0027for\u0027; # True\rSeries Operator  my @a=\u0026lt;A G C T\u0026gt;;\rmy $x=@a;\rfor 1 .",
  "inLanguage" : "zh",
  "wordCount":  9521 ,
  "datePublished" : "2015-03-16T00:00:00",
  "dateModified" : "2015-03-16T00:00:00",
  "image" : "https:\/\/ohmysummer.github.io\/img\/rakudo.png",
  "keywords" : [ "特性, Examples" ],
  "mainEntityOfPage" : "https:\/\/ohmysummer.github.io\/post\/2015-03-16-raku%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%BA%8C\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/ohmysummer.github.io\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/ohmysummer.github.io\/img\/rakudo.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Raku 中的特性(二)" />
<meta property="og:description" content="Set  my $keywords = set &lt;if for unless while&gt;; # create a setsub has-keyword(*@words) {for @words -&gt; $word {return True if $word (elem) $keywords; # 依次检查数组中的元素是否属于集合 $keywords}False;}say has-keyword &#39;not&#39;, &#39;one&#39;, &#39;here&#39;; # Falsesay has-keyword &#39;but&#39;, &#39;here&#39;, &#39;for&#39;; # TrueSeries Operator  my @a=&lt;A G C T&gt;;my $x=@a;for 1 .">
<meta property="og:image" content="https://ohmysummer.github.io/img/rakudo.png" />
<meta property="og:url" content="https://ohmysummer.github.io/post/2015-03-16-raku%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%BA%8C/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Raku Programming" />

  <meta name="twitter:title" content="Raku 中的特性(二)" />
  <meta name="twitter:description" content="Set  my $keywords = set &lt;if for unless while&gt;; # create a setsub has-keyword(*@words) {for @words -&gt; $word {return True if $word (elem) $keywords; # 依次检查数组中的元素是否属于集合 $keywords}False;} …">
  <meta name="twitter:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:card" content="summary" />
  <link href='https://ohmysummer.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.79.0" />
  <link rel="alternate" href="https://ohmysummer.github.io/index.xml" type="application/rss+xml" title="Raku Programming"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://ohmysummer.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://ohmysummer.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'ohmycloudy', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://ohmysummer.github.io/">Raku Programming</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="博客" href="/">博客</a>
            </li>
          
        
          
            <li>
              <a title="归档" href="/categories">归档</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/page/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        

        

        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span class="hidden-sm hidden-md hidden-lg"></span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Raku Programming" href="https://ohmysummer.github.io/">
            <img class="avatar-img" src="https://ohmysummer.github.io/img/rakudo.png" alt="Raku Programming" />
          </a>
        </div>
      </div>
    

  </div>
</nav>



  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title"></h4>
        </div>
        <div class="modal-body">
          <gcse:search></gcse:search>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal"></button>
        </div>
      </div>
    </div>
  </div>


    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>Raku 中的特性(二)</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;45&nbsp;
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;9521&nbsp;
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;焉知非鱼
    
  
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <h2 id="set">Set</h2>
<hr>
<pre><code class="language-raku" data-lang="raku">my $keywords = set &lt;if for unless while&gt;; # create a set

sub has-keyword(*@words) {
    for @words -&gt; $word {
        return True if $word (elem) $keywords; # 依次检查数组中的元素是否属于集合 $keywords
    }
    False;
}

say has-keyword 'not', 'one', 'here';       # False
say has-keyword 'but', 'here', 'for';       # True

</code></pre><h2 id="series-operator">Series Operator</h2>
<hr>
<pre><code class="language-raku" data-lang="raku">my @a=&lt;A G C T&gt;;
my $x=@a;
for 1 ... * -&gt; $a {  (( [X~] $x xx $a )).join(',').say;last if $a==4;   };
</code></pre><pre><code class="language-raku" data-lang="raku"># 倒序 range
for 10 ... 0 {
    .say;
}

</code></pre><p>flip/plop</p>
<pre><code class="language-raku" data-lang="raku">use v6;
my $file = open 'flip_flop.txt';
for $file.lines -&gt; $line {
    say $line if !($line ~~ m/^\;/ ff $line ~~ m/^\&quot;/);
}
</code></pre><p><code>$line ~~ m/^\;/ ff $line ~~ m/^\&quot;/</code> 过滤掉 <code>;</code> 和 <code>&quot;</code> 之间的内容, 再对它进行取反操作就是过滤后剩下的文本。</p>
<p>flip_flop.txt 内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">; next is some lines to skip,include this line
fuck fuck fuck
dam dam dam
mie mie mie
&#34; next is subject
There is more than one way to do it
                                -- Larry Wall

We hope Raku is wrote by the hole Socfilia
                                -- Larry Wall
; next is some lines to skip,include this line
fuck fuck fuck
dam dam dam
mie mie mie
&#34; next is subject
programming is hard,Let&#39;s go shopping
                               -- Larry Wall
Ruby is Another Raku
                               -- Larry Wall
</code></pre></div><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">There is more than one way to do it
                                -- Larry Wall
We hope Raku is wrote by the hole Socfilia
                                -- Larry Wall
programming is hard,Let&#39;s go shopping
                               -- Larry Wall
Ruby is Another Raku
                               -- Larry Wall
</code></pre></div><p>ff 操作符左右两侧的 <code>^</code> 表示排除:</p>
<pre><code class="language-raku" data-lang="raku">for 1..20 {.say if $_==9 ff $_==16}
say '-' x 10;
for 1..20 {.say if $_==9 ^ff $_==16}
say '-' x 10;
for 1..20 {.say if $_==9 ff^ $_==16}
say '-' x 10;
for 1..20 {.say if $_==9 ^ff^ $_==16}

输出：
9
10
11
12
13
14
15
16
----------
10
11
12
13
14
15
16
----------
9
10
11
12
13
14
15
----------
10
11
12
13
14
15
</code></pre><pre><code class="language-raku" data-lang="raku"># 无限循环
loop {
    say 'SPAM';
}

# In addition, there are various ways of writing lazy, infinite lists in Raku:
print &quot;SPAM\n&quot; xx *;      # repetition operator
print &quot;SPAM\n&quot;, ~* ... *; # sequence operator
map {say &quot;SPAM&quot;}, ^Inf;   # upto operator

</code></pre><h2 id="grammars">Grammars</h2>
<hr>
<pre><code class="language-raku" data-lang="raku">use v6;

BEGIN {
    @*INC.push('/Volumes/WORK/1-Books/3-Raku/examples/笔记/Grammars');
}
use Add1;

my @experssions = (
    &quot;2 + 3&quot;,
    &quot;2 + 4 &quot;,
    &quot;2 + 3 x&quot;,
    &quot;2 +&quot;,
    &quot;2 3&quot;,
    &quot;2 - 3&quot;,
);

for @experssions -&gt; $exp {
    print $exp, &quot; &quot;;
    my $result = Add1.parse($exp);
    say $result ?? 'OK' !! 'NOT OK';
    CATCH {
        say &quot;exception received: $!&quot;;
    }
}

</code></pre><pre><code class="language-raku" data-lang="raku">use v6;

BEGIN {
    @*INC.push('/Volumes/WORK/1-Books/3-Raku/examples/笔记/Grammars');
}
use Add2;

my @experssions = (
    &quot;2 + 3&quot;,
    &quot;2 + 4 &quot;,
    &quot;2 + 3 x&quot;,
    &quot;2 +&quot;,
    &quot;2 3&quot;,
    &quot;2 - 3&quot;,
);

for @experssions -&gt; $exp {
    print $exp, &quot; &quot;;
    my $result = Add2.parse($exp);
    say $result ?? 'OK' !! 'NOT OK';
    CATCH {
        say &quot;exception received: $!&quot;;
    }
}

</code></pre><pre><code class="language-raku" data-lang="raku">grammar CardGame {

    rule TOP { ^ &lt;deal&gt; $ }

    rule deal {
        &lt;hand&gt;+ % ';'
    }

    rule hand { [ &lt;card&gt; ]**5 }
    token card {&lt;face&gt;&lt;suit&gt;}

    proto token suit {*}
    token suit:sym&lt;♥&gt;  {&lt;sym&gt;}
    token suit:sym&lt;♦&gt;  {&lt;sym&gt;}
    token suit:sym&lt;♣&gt;  {&lt;sym&gt;}
    token suit:sym&lt;♠&gt;  {&lt;sym&gt;}

    token face {:i &lt;[2..9]&gt; | 10 | j | q | k | a }
}

say CardGame.parse(&quot;2♥ 5♥ 7♦ 8♣ 9♠&quot;);
say CardGame.parse(&quot;2♥ a♥ 7♦ 8♣ j♥&quot;);

</code></pre><pre><code class="language-raku" data-lang="raku">grammar CardGame {

    rule TOP { ^ &lt;deal&gt; $ }

    rule deal {
       :my %*PLAYED = ();
       &lt;hand&gt;+ % ';'
    }

    rule hand { [ &lt;card&gt; ]**5 }
    token card {&lt;face&gt;&lt;suit&gt;}

    proto token suit {*}
    token suit:sym&lt;♥&gt;  {&lt;sym&gt;}
    token suit:sym&lt;♦&gt;  {&lt;sym&gt;}
    token suit:sym&lt;♣&gt;  {&lt;sym&gt;}
    token suit:sym&lt;♠&gt;  {&lt;sym&gt;}

    token face {:i &lt;[2..9]&gt; | 10 | j | q | k | a }
}

class CardGame::Actions {
    method card($/) {
       my $card = $/.lc;
       say &quot;Hey, there's an extra $card&quot;
           if %*PLAYED{$card}++;
   }
}

my $a = CardGame::Actions.new;
say CardGame.parse(&quot;a♥ a♥ 7♦ 8♣ j♥&quot;, :actions($a));
# &quot;Hey there's an extra a♥&quot;
say CardGame.parse(&quot;a♥ 7♥ 7♦ 8♣ j♥; 10♥ j♥ q♥ k♥ a♦&quot;,
                   :actions($a));
# &quot;Hey there's an extra j♥&quot;


</code></pre><pre><code class="language-raku" data-lang="raku">﻿use v6;

my %dict;

grammar WordPairs {
    token TOP { &lt;word-pair&gt;* }
    token word-pair { (\S*) ' ' (\S*) &quot;\n&quot; }
}

class WordPairsActions {
    method word-pair($/) { %dict{$0}.push($1) }
}

my $match = WordPairs.parse(&quot;{@*ARGS[0]}&quot;.IO.slurp, :actions(WordPairsActions));
say ?$match;

say &quot;The pairs count of the key word \&quot;her\&quot; in wordpairs.txt is {%dict{&quot;her&quot;}.elems}&quot;;
</code></pre><pre><code class="language-raku" data-lang="raku">﻿use v6;

my $file=open &quot;test.txt&quot;, :r;

my %dict;
my $line;

repeat {
    $line=$file.get;
    my ($p1,$p2)=$line.split(' ');
    if ?%dict{$p1} {
        %dict{$p1} = &quot;{%dict{$p1}} {$p2}&quot;.words;
    } else {
        %dict{$p1} = $p2;
    }
} while !$file.eof;

## Test
say &quot;The pairs count of the key word \&quot;was\&quot; in wordpairs.txt is {%dict{&quot;was&quot;}.elems}&quot;;
</code></pre><pre><code class="language-raku" data-lang="raku">﻿grammar CSV {
    token TOP { [ &lt;line&gt; \n? ]+ }
    token line {
        ^^            # Beginning of a line
        &lt;value&gt;* % \, # Any number of &lt;value&gt;s with commas in `between` them
        $$            # End of a line
    }
    token value {
        [
        | &lt;-[&quot;,\n]&gt;     # Anything not a double quote, comma or newline
        | &lt;quoted-text&gt; # Or some quoted text
        ]*              # Any number of times
    }
    token quoted-text {
        \&quot;
        [
        | &lt;-[&quot;\\]&gt; # Anything not a &quot; or \
        | '\&quot;'     # Or \&quot;, an escaped quotation mark
        ]*         # Any number of times
        \&quot;
    }
}
# method parse($str, :$rule = 'TOP', :$actions) returns Match:D
say &quot;Valid CSV file!&quot; if CSV.parse( q:to/EOCSV/ );
    Year,Make,Model,Length
    1997,Ford,E350,2.34
    2000,Mercury,Cougar,2.38
    EOCSV

say CSV.parse( q:to/EOCSV/, 'line', :$actions );
    Year,Make,Model,Length
    1997,Ford,E350,2.34
    2000,Mercury,Cougar,2.38
    EOCSV
</code></pre><pre><code class="language-raku" data-lang="raku">﻿grammar MyGrammar {
    token chunk {
        { say &quot;chunk: called&quot; }
        ^^
        { say &quot;chunk: found start of line&quot; }
        (\S+)
        { say &quot;chunk: found first identifier: $0&quot; }
		#(\s*)
		#{say &quot;chunk: found space&quot;}
        \=
        { say &quot;chunk: found =&quot; }
		#(\s*)
		#{say &quot;chunk: found space&quot;}
        (\S+) $$
    }
}

say ?MyGrammar.parse(&quot;foo = bar&quot;, :rule&lt;chunk&gt;);

# output:
#
# chunk: called
# chunk: found start of line
# chunk: found fist identifer: foo
# False

#You can see that the rule matched the start of the line, and foo, but not the equals sign. What's between the two? A space. For which there is no rule to match it. Making chunk a rule instead of a token fixes this problem.
# 因为 (\S+)后面有一个空格, \= 后面也有个空格, rule 能识别空格

# E:\1-技术书籍\Raku\examples\Grammars&gt;raku -e &quot;'aabcd' ~~ /^ (.*){say $0.Str} b/&quot;
#aabcd
#aabc
#aab
#aa
</code></pre><pre><code class="language-raku" data-lang="raku">﻿grammar RakuVariableNames {

    token variable {
        &lt;sigil&gt; &lt;name&gt;
    }

    #token sigil {
    #    '$' | '@' | '&amp;' | '%' | '::'
    #}

    # 使用 proto
	proto token sigil {*}
    token sigil:sym&lt;$&gt;  { &lt;sym&gt; }
    token sigil:sym&lt;@&gt;  { &lt;sym&gt; }
    token sigil:sym&lt;%&gt;  { &lt;sym&gt; }
    token sigil:sym&lt;&amp;&gt;  { &lt;sym&gt; }
    token sigil:sym&lt;::&gt; { &lt;sym&gt; }

	# [ ... ] are non-capturing groups
	token name {
        &lt;identifier&gt;
        [ '::' &lt;identifier&gt; ] *
    }
	# 标识符以字母开头
    token identifier {
        &lt;alpha&gt; \w+
    }
}

my $match = RakuVariableNames.parse(&quot;@array&quot;,:rule('variable'));
say $match;

grammar SigilRichRaku is RakuVariableNames {
    token sigil:sym&lt;ħ&gt; { &lt;sym&gt; } # physicists will love you
}

my $rich = SigilRichRaku.parse(&quot;ħarray&quot;,:rule('variable'));
say $rich;

grammar LowBudgetRaku is RakuVariableNames {
    token sigil:sym&lt;$&gt; { '¢' }
}

my $money = LowBudgetRaku.parse('$array',:rule('variable'));
say $money;
</code></pre><pre><code class="language-raku" data-lang="raku">grammar StationDataParser {
    token TOP          { ^ &lt;keyval&gt;+ &lt;observations&gt; $             }
    token keyval       { $&lt;key&gt;=[&lt;-[=]&gt;+] '=' \h* $&lt;val&gt;=[\N+] \n }
    token observations { 'Obs:' \h* \n &lt;observation&gt;+             }
    token observation  { $&lt;year&gt;=[\d+] \h* &lt;temp&gt;+ %% [\h*] \n    }
    token temp         { '-'? \d+ \. \d+                          }
}

class StationData {
    has $.name;
    has $.country;
    has @.data;

    submethod BUILD(:%info (:Name($!name), :Country($!country), *%), :@!data) {
    }
}

class StationDataActions {
    method TOP($/) {
        make StationData.new(
            info =&gt; $&lt;keyval&gt;.map(*.ast).hash,
            data =&gt; $&lt;observations&gt;.ast
        );
    }

    method keyval($/) {
        make ~$&lt;key&gt; =&gt; ~$&lt;val&gt;;
    }
    method observations($/) {
        make $&lt;observation&gt;.map(*.ast).grep(*.value.none &lt;= -99);
    }
    method observation($/) {
        make +$&lt;year&gt; =&gt; $&lt;temp&gt;.map(*.Num);
    }
}

say StationDataParser.parse( q:to/EOCSV/, :actions(StationDataActions)).ast
Name= Jan Mayen
Country= NORWAY
Lat=   70.9
Long=    8.7
Height= 10
Start year= 1921
End year= 2009
Obs:
1921 -4.4 -7.1 -6.8 -4.3 -0.8  2.2  4.7  5.8  2.7 -2.0 -2.1 -4.0  
1922 -0.9 -1.7 -6.2 -3.7 -1.6  2.9  4.8  6.3  2.7 -0.2 -3.8 -2.6  
2008 -2.8 -2.7 -4.6 -1.8  1.1  3.3  6.1  6.9  5.8  1.2 -3.5 -0.8  
2009 -2.3 -5.3 -3.2 -1.6  2.0  2.9  6.7  7.2  3.8  0.6 -0.3 -1.3
EOCSV
</code></pre><pre><code class="language-raku" data-lang="raku"># file lib/JSON/Tiny/Grammar.pm

 grammar JSON::Tiny::Grammar {
     rule TOP      { ^[ &lt;object&gt; | &lt;array&gt; ]$ }
     rule object   { '{' ~ '}' &lt;pairlist&gt;     }
     rule pairlist { &lt;pair&gt;* % [ \, ]         }
     rule pair     { &lt;string&gt; ':' &lt;value&gt;     }
     rule array    { '[' ~ ']' [ &lt;value&gt;* % [ \, ] ] }

 proto token value { &lt;...&gt; };

 token value:sym&lt;number&gt; {
     '-'?
     [ 0 | &lt;[1..9]&gt; &lt;[0..9]&gt;* ]
     [ \. &lt;[0..9]&gt;+ ]?
     [ &lt;[eE]&gt; [\+|\-]? &lt;[0..9]&gt;+ ]?
 }

 token value:sym&lt;true&gt;   { &lt;sym&gt;    };
 token value:sym&lt;false&gt;  { &lt;sym&gt;    };
 token value:sym&lt;null&gt;   { &lt;sym&gt;    };
 token value:sym&lt;object&gt; { &lt;object&gt; };
 token value:sym&lt;array&gt;  { &lt;array&gt;  };
 token value:sym&lt;string&gt; { &lt;string&gt; }

 token string {
     \&quot; ~ \&quot; [ &lt;str&gt; | \\ &lt;str_escape&gt; ]*
 }

 token str {
     [
         &lt;!before \t&gt;
         &lt;!before \n&gt;
         &lt;!before \\&gt;
         &lt;!before \&quot;&gt;
         .
     ]+
     # &lt;-[&quot;\\\t\n]&gt;+
 }

 token str_escape {
     &lt;[&quot;\\/bfnrt]&gt; | u &lt;xdigit&gt;**4
 }

 }


 # test it:
 my $tester = '{
     &quot;country&quot;: &quot;Austria&quot;,
     &quot;cities&quot;: [ &quot;Wien&quot;, &quot;Salzburg&quot;, &quot;Innsbruck&quot; ],
     &quot;population&quot;: 8353243
 }';

 if JSON::Tiny::Grammar.parse($tester) {
     say &quot;It's valid JSON&quot;;
 } else {
     # TODO: error reporting
     say &quot;Not quite...&quot;;
 }
</code></pre><pre><code class="language-raku" data-lang="raku">grammar JSON::Tiny::Grammar {
     rule TOP      { ^[ &lt;object&gt; | &lt;array&gt; ]$ }
     rule object   { '{' ~ '}' &lt;pairlist&gt;     }
     rule pairlist { &lt;pair&gt;* % [ \, ]         }
     rule pair     { &lt;string&gt; ':' &lt;value&gt;     }
     rule array    { '[' ~ ']' [ &lt;value&gt;* % [ \, ] ] }

 proto token value { &lt;...&gt; };

 token value:sym&lt;number&gt; {
     '-'?
     [ 0 | &lt;[1..9]&gt; &lt;[0..9]&gt;* ]
     [ \. &lt;[0..9]&gt;+ ]?
     [ &lt;[eE]&gt; [\+|\-]? &lt;[0..9]&gt;+ ]?
 }

 token value:sym&lt;true&gt;   { &lt;sym&gt;    };
 token value:sym&lt;false&gt;  { &lt;sym&gt;    };
 token value:sym&lt;null&gt;   { &lt;sym&gt;    };
 token value:sym&lt;object&gt; { &lt;object&gt; };
 token value:sym&lt;array&gt;  { &lt;array&gt;  };
 token value:sym&lt;string&gt; { &lt;string&gt; }

 token string {
     \&quot; ~ \&quot; [ &lt;str&gt; | \\ &lt;str_escape&gt; ]*
 }

 token str {
     [
         &lt;!before \t&gt;
         &lt;!before \n&gt;
         &lt;!before \\&gt;
         &lt;!before \&quot;&gt;
         .
     ]+
     # &lt;-[&quot;\\\t\n]&gt;+
 }

 token str_escape {
     &lt;[&quot;\\/bfnrt]&gt; | u &lt;xdigit&gt;**4
 }

 }


 # test it:
 my $tester = '{
     &quot;country&quot;: &quot;Austria&quot;,
     &quot;cities&quot;: [ &quot;Wien&quot;, &quot;Salzburg&quot;, &quot;Innsbruck&quot; ],
     &quot;population&quot;: 8353243
 }';

 if JSON::Tiny::Grammar.parse($tester) {
     say &quot;It's valid JSON&quot;;
 } else {
     # TODO: error reporting
     say &quot;Not quite...&quot;;
 }




class JSON::Tiny::Actions {
    method TOP($/)      { make $/.values.[0].ast              }
    method object($/)   { make $&lt;pairlist&gt;.ast.hash           }
    method pairlist($/) { make $&lt;pair&gt;&gt;&gt;.ast                  }
    method pair($/)     { make $&lt;string&gt;.ast =&gt; $&lt;value&gt;.ast  }
    method array($/)    { make [$&lt;value&gt;&gt;&gt;.ast]               }
    method string($/)   { make join '', $/.caps&gt;&gt;.value&gt;&gt;.ast }

 # TODO: make that
 # make +$/
 # once prefix:&lt;+&gt; is sufficiently polymorphic
method value:sym&lt;number&gt;($/) { make try $/        }
method value:sym&lt;string&gt;($/) { make $&lt;string&gt;.ast }
method value:sym&lt;true&gt;  ($/) { make Bool::True    }
method value:sym&lt;false&gt; ($/) { make Bool::False   }
method value:sym&lt;null&gt;  ($/) { make Any           }
method value:sym&lt;object&gt;($/) { make $&lt;object&gt;.ast }
method value:sym&lt;array&gt; ($/) { make $&lt;array&gt;.ast  }
method str($/)               { make ~$/           }

method str_escape($/) {
    if $&lt;xdigit&gt; {
        make chr(:16($&lt;xdigit&gt;.join));
    } else {
        my %h = '\\' =&gt; &quot;\\&quot;,
        'n' =&gt; &quot;\n&quot;,
        't' =&gt; &quot;\t&quot;,
        'f' =&gt; &quot;\f&quot;,
        'r' =&gt; &quot;\r&quot;;
        make %h{$/};
    }
  }
}

my $actions = JSON::Tiny::Actions.new();
my $data_structure = JSON::Tiny::Grammar.parse($tester, 'TOP', :$actions);
say $data_structure;
</code></pre><pre><code class="language-raku" data-lang="raku">﻿use v6;

grammar KeyValuePairs {
    token TOP {
	    [ &lt;pair&gt; \n+ ]*
	}

	token ws { \h* }

	rule pair {
	    &lt;key=.identifier&gt; '=' &lt;value=.identifier&gt;
	}

	token identifier { \w+ }
}

class KeyValuePairsActions {
    method identifier($/)  { make ~$/                   }
	method pair      ($/)  { make ~$&lt;key&gt; =&gt; ~$&lt;value&gt;  }
	method TOP       ($/)  { make $&lt;pair&gt;&gt;&gt;.made        }
}

my $string = q:to/EOI/;
second=b
hits=42
perl=6
EOI

my $actions = KeyValuePairsActions.new;
my $match = KeyValuePairs.parse($string, :$actions).made;

for @$match -&gt; $p {
    say &quot;key: $p.key()\tValue: $p.value()&quot;;
}

</code></pre><pre><code class="language-raku" data-lang="raku">#use Module::Name::Actions;
grammar Legal-Module-Name {
  token TOP {

	# identifier followed by zero or more separator identifier pairs
    ^ &lt;identifier&gt; [&lt;separator&gt;&lt;identifier&gt;] ** 0..* $
  }

  token identifier  {
    # leading alpha or _ only
    &lt;[A..Za..z_]&gt;
    &lt;[A..Za..z0..9]&gt; ** 0..*
  }

  token separator  {
    '::' # colon pairs
  }
}

class Module::Name::Actions {
  method TOP($/)
  { make $/.values.ast ~ '-----';
    if $&lt;identifier&gt;.elems &gt; 5
    {
      warn 'Module name has a lot of identifiers, consider simplifying the name';
    }
  }
}

my $proposed_module_name = 'Superoooo::Newoooo::Moduleooooooooooo';

my $actions = Module::Name::Actions.new();
my $match_obj = Legal-Module-Name.parse($proposed_module_name, :actions($actions));

say $match_obj.Str;
</code></pre><p>我写的第一个 Grammar, 修改了很多次, 借助于 <code>Grammar::Debugger</code> 和 <code>Grammar::Tracer</code> 能方便地看出 Grammar 在哪里失败。<code>TOP</code> 里面添加了 <code>^</code> 和 <code>$</code> 限制时, 其后面的 token 和 rule 不能再添加 <code>^</code> 和 <code>$</code>, 否则匹配失败。</p>
<pre><code class="language-raku" data-lang="raku">use Grammar::Debugger;
use Grammar::Tracer;

use v6;
grammar Markdown::Toc {
    # token TOP   is breakpoint    {^ \s* &lt;section&gt;* $}
	token TOP    {^ \s* &lt;section&gt;* $}
	token section   {
	    &lt;sname&gt;  &lt;ws&gt; \n
	    &lt;lines&gt;*
	    &lt;subsection&gt;+
	}

    token subsection  {
    	&lt;subsname&gt; &lt;ws&gt; \n
        &lt;lines&gt;*
        &lt;s2section&gt; *
	}

    token s2section {
	    &lt;s2name&gt; &lt;ws&gt; \n
		&lt;lines&gt;*
    }

	token sname          { &lt;sigil2&gt;   &lt;ws&gt; &lt;snumber=.hnumber&gt;  &lt;ws&gt; &lt;shead=.hline&gt;     }
	token subsname       { &lt;sigil3&gt;   &lt;ws&gt; &lt;subnumber=.number&gt; &lt;ws&gt; &lt;shline=.hline&gt;    }
	token s2name         { &lt;sigil4&gt;   &lt;ws&gt; &lt;s2number=.number&gt;  &lt;ws&gt; &lt;s2hline=.hline&gt;   }
	token lines          {
	    [
		    &lt;!after '#' ** 2..* &gt;
            \N
        ]+
	    \n
	}
	token number {
	    \d+ % \.
	}

	token hline {
	    \N+
	}
	token hnumber { \w+      }
	token ws      { \h*      }
	token sigil2  { '#' ** 2 }
	token sigil3  { '#' ** 3 }
	token sigil4  { '#' ** 4 }
}

my $str = q:to/EOF/;
## 第四章 子例程和签名


一个子例程就是一段执行特殊任务的代码片段。它可以对提供的数据（`实参`）操作，并产生结果（返回值）。子例程的签名是它`所含的参数`和它产生的`返回值`的描述。从某一意义上来说，第三章描述的操作符也是Raku用特殊方式解释的子例程。

### 4.1.0 申明子例程

 一个子例程申明由几部分组成。首先， `sub `表明你在申明一个子例程，然后是可选的子例程的名称和`可选的签名`。子例程的主体是一个用花括号扩起来的代码块。
默认的，子例程是本地作用域的，就像任何使用 `my` 申明的变量一样。这意味着，一个子例程只能在它被申明的作用域内被调用。使用 `our` 来申明子例程可以使其在`当前包`中可见。
EOF

class Markdown::Toc::Actions {
	method s2section($/)        {
	    my $first = ~$&lt;s2name&gt;&lt;s2number&gt;;
	    my $second = ~$&lt;s2name&gt;&lt;s2hline&gt;;
		my $remove_dot = $first.subst(rx/\./,'',:g);
		my $remove_space = $second.subst(rx/\s+/,'-',:g);
		make '    - '~'['~$first~' '~$second~']' ~ '(#'~$remove_dot~$remove_space ~ ')' =&gt; $&lt;s2section&gt;&gt;&gt;.made;
	}

	method subsection($/) {
	    my $first = ~$&lt;subsname&gt;&lt;subnumber&gt;;
	    my $second = ~$&lt;subsname&gt;&lt;shline&gt;;
		my $remove_dot = $first.subst(rx/\./,'',:g);
		my $remove_space = $second.subst(rx/\s+/,'-',:g);
		make '  - '~'['~$first~' '~$second~']' ~ '(#'~$remove_dot~$remove_space ~ ')'	=&gt; $&lt;s2section&gt;&gt;&gt;.made;  
	}

    method section($/)    {
	    my $first = ~$&lt;sname&gt;&lt;snumber&gt;;
		my $second = ~$&lt;sname&gt;&lt;shead&gt;;
		#my $remove_dot = $first.subst(rx/\./,'',:g);
		my $remove_space = $second.subst(rx/\s+/,'',:g);
	    make '- '~'['~$first~' '~$second~']' ~ '(#'~$first~ '-'~$remove_space ~ ')'  =&gt; $&lt;subsection&gt;&gt;&gt;.made;
	}

    method TOP($/)    { make $&lt;section&gt;&gt;&gt;.made;                                                            }

}

my $actions = Markdown::Toc::Actions.new;
my $match  = Markdown::Toc.parse($str, :$actions).made;
#say $match.Str;

for @$match -&gt; $p {
    say $p.key();
    for $p.value() -&gt; $v {
        for $v -&gt; $n {
		   .say for $n.hash().keys();
		   for $n.hash().values() -&gt; $three {
		       .say for $three.hash().keys();
			}
		}

    }
}
</code></pre><pre><code class="language-raku" data-lang="raku">#use Grammar::Debugger;
#use Grammar::Tracer;

use v6;
grammar Markdown::Toc {
    # token TOP   is breakpoint    {^ \s* &lt;section&gt;* $}
	token TOP    {^ \s* &lt;section&gt;* $}
	token section   {
	    &lt;sname&gt; &lt;ws&gt;
		&lt;lines&gt;*
	    &lt;subsection&gt;+
	}

    token subsection  {
    	&lt;subsname&gt; &lt;ws&gt;
        &lt;lines&gt;*
        &lt;s2section&gt; *
	}

    token s2section {
	    &lt;s2name&gt; &lt;ws&gt;
		&lt;lines&gt;*
    }

	token sname          { &lt;sigil2&gt;   &lt;ws&gt; &lt;snumber=.hnumber&gt; &lt;ws&gt; &lt;shead=.hline&gt;  }
	token subsname       { &lt;sigil3&gt;   &lt;ws&gt; &lt;subnumber=.number&gt;    &lt;shline=.hline&gt;      }
	token s2name         { &lt;sigil4&gt;   &lt;ws&gt; &lt;s2number=.number&gt; &lt;s2hline=.hline&gt;   }
	token lines          {
	    [
		    &lt;!after '#' ** 2..* &gt;
            \N
        ]+
	    \n
	}

	token number {
	    \d+ % \.
	}

	token hline {
	    \N+
	}
	token hnumber { \w+}
	token ws     { \s*      }
	token sigil2 { '#' ** 2 }
	token sigil3 { '#' ** 3 }
	token sigil4 { '#' ** 4 }
}

my $str = q:to/EOF/;
## 第三章 操作符
blabla
#blabla
blabla
blabla
###  3.1 关于优先级的的一句话
blabla
###  3.2 比较和智能匹配
blabla
####   3.2.1 数字比较
blabla
####    3.2.2 字符串比较
blabla
####    3.2.3 智能匹配
blabla
### 3.3 测试
## 第四章 子例程和签名
blabla
###  4.1 申明子例程
blabla
###  4.2 添加签名
blabla
####   4.2.1 基础
blabla
####    4.2.2 传递数组、散列和代码
blabla
####    4.2.3 插值、数组和散列
blabla
EOF

class Markdown::Toc::Actions {
	method s2section($/)        {
	    my $first = ~$&lt;s2name&gt;&lt;s2number&gt;;
	    my $second = ~$&lt;s2name&gt;&lt;s2hline&gt;;
		my $remove_dot = $first.subst(rx/\./,'',:g);
		my $remove_space = $second.subst(rx/\s+/,'-',:g);
		make '    - '~'['~$first~' '~$second~']' ~ '(#'~$remove_dot~$remove_space ~ ')' =&gt; $&lt;s2section&gt;&gt;&gt;.made;
	}

	method subsection($/) {
	    my $first = ~$&lt;subsname&gt;&lt;subnumber&gt;;
	    my $second = ~$&lt;subsname&gt;&lt;shline&gt;;
		my $remove_dot = $first.subst(rx/\./,'',:g);
		my $remove_space = $second.subst(rx/\s+/,'-',:g);
		make '  - '~'['~$first~' '~$second~']' ~ '(#'~$remove_dot~$remove_space ~ ')'	=&gt; $&lt;s2section&gt;&gt;&gt;.made;  
	}

    method section($/)    {
	    my $first = ~$&lt;sname&gt;&lt;snumber&gt;;
		my $second = ~$&lt;sname&gt;&lt;shead&gt;;
		#my $remove_dot = $first.subst(rx/\./,'',:g);
		my $remove_space = $second.subst(rx/\s+/,'',:g);
	    make '- '~'['~$first~' '~$second~']' ~ '(#'~$first~ '-'~$remove_space ~ ')'  =&gt; $&lt;subsection&gt;&gt;&gt;.made;
	}

    method TOP($/)    { make $&lt;section&gt;&gt;&gt;.made;                                                            }

}

my $actions = Markdown::Toc::Actions.new;
my $match  = Markdown::Toc.parse($str, :$actions).made;
#say $match.Str;

for @$match -&gt; $p {
    say $p.key();
    for $p.value() -&gt; $v {
        for $v -&gt; $n {
		   .say for $n.hash().keys();
		   for $n.hash().values() -&gt; $three {
		       .say for $three.hash().keys();
			}
		}

    }
}
</code></pre><pre><code class="language-raku" data-lang="raku">use v6;

grammar KeyValuePairs {
    token TOP {
        [&lt;pair&gt; \n+]*
    }
    token ws { \h* }

    rule pair {
        &lt;key=.identifier&gt; '=' &lt;value=.identifier2&gt;
    }
    token identifier {
        \w+
    }
     token identifier2 {
        \w+
    }
}

class KeyValuePairsActions {
    method identifier($/) { $/.make: '[' ~$/ ~ ']'                }
    method identifier2($/) { $/.make: '{' ~$/ ~ '}'               }
    method pair      ($/) { $/.make: $&lt;key&gt;.made =&gt; $&lt;value&gt;.made }
    method TOP       ($/) { $/.make: $&lt;pair&gt;».made                }
}

my  $res = KeyValuePairs.parse(q:to/EOI/, :actions(KeyValuePairsActions)).made;
    second=b
    hits=42
    perl=6
    EOI
say $res;
for @$res -&gt; $p {
    say &quot;Key: $p.key()\tValue: $p.value()&quot;;
}

</code></pre><pre><code class="language-raku" data-lang="raku">﻿grammar VariableNames {

    token variable {
        &lt;sigil&gt; &lt;name&gt;
    }

    token sigil {
        '$' | '@' | '&amp;' | '%' | '::'
    }

	# [ ... ] are non-capturing groups
	token name {
        &lt;identifier&gt;
        [ '::' &lt;identifier&gt; ] *
    }
	# 标识符以字母开头
    token identifier {
        &lt;alpha&gt; \w+
    }
}

my $match = VariableNames.parse(&quot;@array&quot;,:rule('variable'));
say $match;

# we inherit from the original grammar...
grammar VARIABLENAMES is VariableNames {

    # ... and override that parsing rule that we want to change
    token identifier {
        # char classes are &lt;[ ... ]&gt; in Raku
        &lt;[A..Z]&gt; &lt;[A..Z0..9_]&gt;*
    }
}
my $test = VARIABLENAMES.parse(&quot;%A_HASH_TABLE&quot;,:rule('variable'));
say $test;

grammar LackMoney is VariableNames {
    token sigil {
        '¢' | '@' | '&amp;' | '%' | '::'
    }
}

# 继承以后, 带¢的变量能够解析, 带$的变量解析不了了
my $money = LackMoney.parse('$i_m_not_dollor',:rule('variable'));
say so $money; # false

</code></pre><pre><code class="language-raku" data-lang="raku">use v6;
grammar URL {
        token TOP {
            &lt;schema&gt; '://'
            [&lt;ip&gt; | &lt;hostname&gt; ]
            [ ':' &lt;port&gt;]?
            '/' &lt;path&gt;?
        }
        token byte {
            (\d**1..3) &lt;?{ $0 &lt; 256 }&gt;
        }
        token ip {
            &lt;byte&gt; [\. &lt;byte&gt; ] ** 3
        }
        token schema {
            \w+
        }
        token hostname {
            (\w+) ( \. \w+ )*
        }
        token port {
            \d+
        }
        token path {
            &lt;[ a..z A..Z 0..9 \-_.!~*'():@&amp;=+$,/ ]&gt;+
        }
    }

my  $match = URL.parse('http://raku.org/documentation/');
say $match.WHAT();
say $match&lt;path&gt;;       # raku.org
say &quot;hello &quot;;
</code></pre><pre><code class="language-raku" data-lang="raku">#use Grammar::Debugger;
#use Grammar::Tracer;

grammar SalesExport::Grammar {
    token TOP { ^ &lt;country&gt;+ $ }
    token country {
        &lt;cname=.name&gt; \n
        &lt;destination&gt;+
    }

    token destination {
        \s+ &lt;dname=.name&gt; \s+ ':' \s+
        &lt;lat=.num&gt; ',' &lt;long=.num&gt; \s+ ':' \s+
        &lt;sales=.integer&gt; \n
    }

    token name    { \w+          }
    token num     { \d+ [\.\d+]? }
    token integer { \d+          }
}

my $string = q:to/THE END/;
Norway
    Oslo : 59.914289,10.738739 : 2
    Bergen : 60.388533,5.331856 : 4
Ukraine
    Kiev : 50.456001,30.50384 : 3
Switzerland
    Wengen : 46.608265,7.922065 : 3
THE END

class SalesExport::Grammar::Actions {
	method destination($/) { make ~$&lt;dname&gt; =&gt; $&lt;sales&gt;          }
    method country($/)     { make ~$&lt;cname&gt; =&gt; $&lt;destination&gt;    }
    method TOP($/)         { make $&lt;country&gt;&gt;&gt;.made              }
}

my $actions = SalesExport::Grammar::Actions.new;
my $grammar_action = SalesExport::Grammar.parse($string, :actions($actions)).made;

# 获取所有国家的名字
for @$grammar_action -&gt; $p {
    say &quot;$p.key()&quot;;
}

say  &quot;-&quot; x 45;
for @$grammar_action -&gt; $p {
    for $p.value() -&gt; $d {
	   for @$d -&gt; $n {
	      say ~$n&lt;dname&gt;;
	   }
	  }
}

say  &quot;-&quot; x 45;

# 计算每个国家卖了多少票
for @$grammar_action -&gt; $c {
    for $c.value() -&gt; $d {
	   my $sales_count=0;
	   for @$d -&gt; $n {
	      $sales_count += ~$n&lt;sales&gt;;
	   }
	   say $sales_count;
	  }
}


 #`(
# say $string;
my $grammar_object = SalesExport::Grammar.parse($string);
if $grammar_object {
     say &quot;It's works&quot;;
 } else {
     # TODO: error reporting
     say &quot;Not quite works...&quot;;
 }


# say $grammar_object;
#  say $grammar_object&lt;country&gt;.Str;
say &quot;_&quot; x 45;
# say $grammar_object&lt;country&gt;[0];
# say $grammar_object&lt;country&gt;[1].Str;

 say &quot;_&quot; x 45;
# say $grammar_object&lt;country&gt;[].Str;
# say $grammar_object&lt;country&gt;.values;

# 获取国家的名字
say $grammar_object&lt;country&gt;[0]&lt;name&gt;.Str;
say $grammar_object&lt;country&gt;[1]&lt;name&gt;.Str;
say $grammar_object&lt;country&gt;[2]&lt;name&gt;.Str;

 say &quot;_&quot; x 45;
# 获取目的地
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;name&gt;.Str;
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;name&gt;.Str;

 say &quot;_&quot; x 45;
# 获取经度
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;lat&gt;.Str;
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;lat&gt;.Str;

 say &quot;_&quot; x 45;
# 获取纬度
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;long&gt;.Str;
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;long&gt;.Str;

 say &quot;_&quot; x 45;
# 获取sales
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[0]&lt;sales&gt;.Str;
say $grammar_object&lt;country&gt;[0]&lt;destination&gt;[1]&lt;sales&gt;.Str;

 say &quot;_&quot; x 45;
 # 获取所有国家
say $grammar_object&lt;country&gt;»&lt;name&gt;.Str;

 say &quot;_&quot; x 45;
 # 获取第一个国家的所有目的地
 say $grammar_object&lt;country&gt;[0]&lt;destination&gt;»&lt;name&gt;.Str;

 say &quot;_&quot; x 45;
 # 获取第一个国家的所有的 sales
 say $grammar_object&lt;country&gt;[0]&lt;destination&gt;»&lt;sales&gt;.Str;
)
</code></pre><p>只能在叶子节点上(最后一个正则名字的前面)使用超运算符 »
S/匹配对象中, 键就是正则的名字, 键值就是匹配到的部分内容.</p>
<pre><code class="language-raku" data-lang="raku">﻿#use Grammar::Debugger;
#use Grammar::Tracer;

grammar SalesExport::Grammar {
    token TOP { ^ &lt;country&gt;+ $ }
    token country {
        &lt;cname=.name&gt; \n
        &lt;destination&gt;+
    }

    token destination {
        \s+ &lt;dname=.name&gt; \s+ ':' \s+
        &lt;lat=.num&gt; ',' &lt;long=.num&gt; \s+ ':' \s+
        &lt;sales=.integer&gt; \n
    }

    token name    { \w+          }
    token num     { \d+ [\.\d+]? }
    token integer { \d+          }
}

my $string = q:to/THE END/;
Norway
    Oslo : 59.914289,10.738739 : 2
    Bergen : 60.388533,5.331856 : 4
Ukraine
    Kiev : 50.456001,30.50384 : 3
Switzerland
    Wengen : 46.608265,7.922065 : 3
THE END

class SalesExport::Grammar::Actions {
	method destination($/) { make ~$&lt;dname&gt; =&gt; [$&lt;sales&gt;.map(*.Num+10),$&lt;lat&gt;.map(*.Num+90) ]         }
    method country($/)     { make ~$&lt;cname&gt; =&gt; $&lt;destination&gt;&gt;&gt;.made            }
    method TOP($/)         { make $&lt;country&gt;&gt;&gt;.made                             }
}

my $actions = SalesExport::Grammar::Actions.new;
my $grammar_action = SalesExport::Grammar.parse($string, :actions($actions)).made;
#say $grammar_action.Str;
# 获取所有国家的名字
for @$grammar_action -&gt; $p {
    say &quot;$p.key()&quot;;
}
say '-' x 45;
# 获取所有目的地
for @$grammar_action -&gt; $p {
    for $p.value() -&gt; $d {
	    for @$d -&gt; $n{
		    say $n.key();
		}
	}
}
say '-' x 45;
# 获取出售的票数
for @$grammar_action -&gt; $p {
    print &quot;$p.key()\t&quot;;
    for $p.value() -&gt; $d {
	    my $count;
	    for @$d -&gt; $n{
		    $count += $n.value()[0];
		}
	say $count;
	}
}

say '-' x 45;
# 获取经度 lat
for @$grammar_action -&gt; $p {
    for $p.value() -&gt; $d {
	    for @$d -&gt; $n{
		    say $n.value()[1];
		}
	}
}
</code></pre><p>这将打印:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Norway
Ukraine
Switzerland
---------------------------------------------
Oslo
Bergen
Kiev
Wengen
---------------------------------------------
Norway  26
Ukraine 13
Switzerland     13
---------------------------------------------
149.914289
150.388533
140.456001
136.608265
</code></pre></div><pre><code class="language-raku" data-lang="raku">grammar TestGrammar {
    token TOP { ^ \d+ $ }
}

class TestActions {
    method TOP($/) {
        $/.make(2 + ~$/);
    }
}

my $actions = TestActions.new;
my $match = TestGrammar.parse('40', :$actions);
say $match;         # ｢40｣
say $match.made;    # 42

</code></pre><pre><code class="language-raku" data-lang="raku">﻿grammar MyGrammar {
    token TOP {
        ^ [ &lt;comment&gt; | &lt;chunk&gt; ]* $
    }

    token comment {
        '#' \N* \n
    }
    token chunk {
      ^^  (\S+) '=' (\S+) $$
    }
}

# 如何调试 Grammars
# try to parse the whole thing
say ?MyGrammar.parse(&quot;#a comment\nfoo = bar&quot;);            # False, 整体调试
# and now one by one
say so MyGrammar.parse(&quot;#a comment\n&quot;, :rule&lt;comment&gt;);   # True, 只单独调试 comment
say so MyGrammar.parse(&quot;foo = bar&quot;, :rule&lt;chunk&gt;);        # False, 只单独调试 chunk, 失败, 说明 chunk 不能匹配! 原因是空白符没有匹配
</code></pre><pre><code class="language-raku" data-lang="raku">﻿use v6;

grammar TestGrammar {
    token TOP   { ^ &lt;digit&gt; $ }
	token digit { \d+         }
}

class TestActions {
    method TOP($/) {
	   # $/.make( 2 + ~$/);
	   make +$&lt;digit&gt; + 2 ;
	}
}

my $actions = TestActions.new;
my $match   = TestGrammar.parse('40', :$actions);
say $match;
say $match.made;
</code></pre><pre><code class="language-raku" data-lang="raku">#use Grammar::Debugger;
#use Grammar::Tracer;

grammar SalesExport {
    token TOP { ^ &lt;country&gt;+ $ }
    token country {
        &lt;name&gt; \n
        &lt;destination&gt;+
    }
    token destination {
        \s+ &lt;name&gt; \s+ ':' \s+
        &lt;lat=.num&gt; ',' &lt;long=.num&gt; \s+ ':' \s+
        &lt;sales=.integer&gt; \n
    }
    token name    { \w+ [ \s \w+ ]*   }
    token num     { '-'? \d+ [\.\d+]? }
    token integer { '-'? \d+          }
}


# Now we can turn any file in this format into a data structure.
#  tripes.txt 最后一行要有一个空行
my $parsed = SalesExport.parsefile('tripes.txt');

if $parsed {
    my @countries = @($parsed&lt;country&gt;);
	#for @countries -&gt; $country { say ~$country&lt;name&gt;};
	for @countries { say [+] .&lt;destination&gt;»&lt;sales&gt;;}
}

if $parsed {
    my @countries = @($parsed&lt;country&gt;);
    my $top1 = @countries.max({
       [+] .&lt;destination&gt;»&lt;sales&gt;
       });
    say &quot;Most popular today: $top1&lt;name&gt; &quot;, [+] $top1&lt;destination&gt;&gt;&gt;&lt;sales&gt;;
}
else {
    die &quot;Parse error!&quot;;
}

</code></pre><p>tripes.txt</p>
<pre><code class="language-raku" data-lang="raku">Russia
    Vladivostok : 43.131621,131.923828 : 4
    Ulan Ude : 51.841624,107.608101 : 2
    Saint Petersburg : 59.939977,30.315785 : 10
Norway
    Oslo : 59.914289,10.738739 : 2
    Bergen : 60.388533,5.331856 : 4
Ukraine
    Kiev : 50.456001,30.50384 : 3
Switzerland
    Wengen : 46.608265,7.922065 : 3
    Bern : 46.949076,7.448151 : 1

</code></pre><pre><code class="language-raku" data-lang="raku">﻿use v6;

my $file=open &quot;wordpairs.txt&quot;, :r;

my %dict;
my $line;

repeat {
    $line=$file.get;
    my ($p1,$p2)=$line.split(' ');
    if ?%dict{$p1} {
        %dict{$p1} = &quot;{%dict{$p1}} {$p2}&quot;.words;
    } else {
        %dict{$p1} = $p2;
    }
} while !$file.eof;
</code></pre><p>wordpairs.txt</p>
<pre><code class="language-raku" data-lang="raku">it was
was the
the best
best of
of times
times it
it was
was the
the worst
worst of
of times
times it
it was
was the
the age
age of
of wisdom
wisdom it
</code></pre><h2 id="great-list-refactor">Great List Refactor</h2>
<hr>
<pre><code class="language-raku" data-lang="raku">﻿&gt; map {$^x + 2}, ( (1,2),3, (4,5))
3 4 5 6 7
&gt; map {$_ + 2}, ( (1,2),3, (4,5))
3 4 5 6 7
&gt; (10,(11,12,13),(14,15)).[2]
14 15
</code></pre><h2 id="raku-examples">Raku Examples</h2>
<hr>
<ul>
<li>1、生成8位随机密码</li>
</ul>
<pre><code class="language-raku" data-lang="raku">my  @char_set = (0..9, 'a'..'z', 'A'..'Z','~','!','@','#','$','%','^','&amp;','*');
say @char_set.pick(8).join(&quot;&quot;) # 不重复的8位密码

say @char_set.roll(8).join(&quot;&quot;)  # 可以重复
</code></pre><ul>
<li>2、打印前5个数字</li>
</ul>
<pre><code class="language-raku" data-lang="raku">.say for 1..10[^5]
.say for 1,2,3,4 ... [^10]  # 这个会无限循环
</code></pre><ul>
<li>
<p>3、排序</p>
</li>
<li>
<p>3.1 按数值排序</p>
</li>
</ul>
<pre><code class="language-raku" data-lang="raku">&gt; my %hash='Perl'=&gt;100,'Python'=&gt;100,'Go'=&gt;100,'CMD'=&gt;20,&quot;Php&quot;=&gt;80,&quot;Java&quot;=&gt;85;
&gt; %hash.values
100 100 100 20 80 85
&gt; %hash.values.sort
20 80 85 100 100 100
&gt; %hash.values.sort(-*)
100 100 100 85 80 20
</code></pre><ul>
<li>3.2 按分数排序散列：</li>
</ul>
<pre><code class="language-raku" data-lang="raku">use v6;
my %hash = 'Perl'=&gt;80,
         'Python'=&gt;100,
             'Go'=&gt;95,
            'CMD'=&gt;20,
            &quot;Php&quot;=&gt;80,
           &quot;Java&quot;=&gt;85;

for %hash.sort({-.value}).hash.keys -&gt; $key {
    say $key, &quot;\t&quot;, %hash{&quot;$key&quot;}
}

# Python	100
# Go	95
# Java	85
# Perl	80
# Php	80
# CMD	20
</code></pre><pre><code class="language-raku" data-lang="raku">&gt; ('xx'..'zz').classify(*.substr(1))&lt;z&gt;
xz yz zz

加密：
sub rot13 { $^s.trans('a..z' =&gt; 'n..za..m', 'A..Z' =&gt; 'N..ZA..M') }

# 执行外部命令
shell( &quot;ssh www.myopps.com uptime&quot; )
shell( &quot;ls&quot; )
shell( &quot;ls -a&quot; )
# shell 将命令的执行结果直接发送到屏幕

my $list = QX(&quot;ls&quot;)
# 可以将命令的结果保存到变量中。

#  批量创建文件夹
for 'A'.. 'Z' -&gt; $i { shell(&quot;mkdir $i&quot;) }
</code></pre><ul>
<li>4、求 1! + 2! + 3! + 4! +5! + 6! +7! +8! +9! +10!</li>
</ul>
<pre><code class="language-raku" data-lang="raku">     &gt; multi sub postfix:&lt;!&gt;(Int $x){ [*] 1..$x }
     &gt; say [+] 1!,2!,3!,4!,5!,6!,7!,8!,9!,10! # 4037913

</code></pre><ul>
<li>5、列出对象所有可用的方法
使用元对象协议， 即<code>对象名.^methods</code></li>
</ul>
<pre><code class="language-raku" data-lang="raku">&gt; &quot;SB&quot;.^methods
</code></pre><blockquote>
<p>BUILD Int Num chomp chop substr pred succ match ords lines samecase samespace tr
im-leading trim-trailing trim words encode wordcase trans indent codes path WHIC
H Bool Str Stringy DUMP ACCEPTS Numeric gist perl comb subst split</p>
</blockquote>
<ul>
<li>6、 匿名子例程</li>
</ul>
<pre><code class="language-raku" data-lang="raku">my $x = sub($a){ $a+2 };say $x($_) for 1..4
my $x = -&gt; $a { $a+2 };say $x($_) for 1..4
my $x = * + 2;say $x($_) for 1..4
</code></pre><p>以后是不是不会写这种 <code>=*+2</code> 的都不好意思说自己会写Raku</p>
<ul>
<li>7、字符串翻转与分割</li>
</ul>
<pre><code class="language-raku" data-lang="raku">&gt; 1223.flip
3221
&gt; 'abcd'.flip
dcba
&gt; 1234.comb
1 2 3 4
&gt; 1234.comb(/./)
1 2 3 4
&gt; 'abcd'.comb
a b c d
</code></pre><ul>
<li>8、有这么一个四位数A，其个位数相加得到B，将B 乘以 B的反转数后得到 A，请求出这个&gt;数字。</li>
</ul>
<p>举例， 1458 就符合这个条件，1+4+5+8 ＝ 18， 18 ＊ 81 ＝1458</p>
<p>请找出另一个符合上面条件的四位数。</p>
<pre><code class="language-raku" data-lang="raku">&gt; (^37).map: { my $r = $_ * .flip; 1000 &lt; $r and $_ == [+] $r.comb and say $r }
</code></pre><p>解释下：
(^37) 产生一个范围  0 .. ^37 , 就是 0到36之前的数，在表达式中代表 B</p>
<p>来个正常思维的：</p>
<pre><code class="language-raku" data-lang="raku">&gt; my $b;
&gt; for 1000..^10000 -&gt; $i {$b=[+] $i.comb;say $i if $b*$b.flip == $i;}
</code></pre><p>1458
1729</p>
<ul>
<li>9、 大小写转换</li>
</ul>
<pre><code class="language-raku" data-lang="raku">&gt; my $word= &quot;I Love Raku&quot;
I Love Raku
&gt; $word.wordcase()
I Love Raku
&gt; my $lowercase = &quot;i love perl 6&quot;
i love perl 6
&gt; $lowercase.wordcase()
I Love Raku
&gt; $word.samecase('A')
I LOVE PERL 6
&gt; $word.samecase('a')
i love perl 6
&gt; $word.samecase('a').wordcase()
I Love Raku
</code></pre><ul>
<li>10、 多行文本</li>
</ul>
<pre><code class="language-raku" data-lang="raku">my $string = q:to/THE END/;
Norway
    Oslo : 59.914289,10.738739 : 2
    Bergen : 60.388533,5.331856 : 4
Ukraine
    Kiev : 50.456001,30.50384 : 3
Switzerland
    Wengen : 46.608265,7.922065 : 3
THE END

say $string;
</code></pre><ul>
<li>11、 超运算符与子例程</li>
</ul>
<pre><code class="language-raku" data-lang="raku">use v6;

my @a = &lt;1 2 3 4&gt;;
sub by2($n){
    return 2*$n;
}

sub power2($n) {
    return $n ** 2;
}
my @b = @a&gt;&gt;.&amp;by2&gt;&gt;.&amp;power2;
say @b; # 4 16 36 64
</code></pre><p>为什么是 &amp;function 呢：
the name of the by2 function is &amp;by2, just as the name of the foo scalar is $foo and the name of the foo array is @foo</p>
<ul>
<li>12、 如何在Raku 中执行外部命令并捕获输出</li>
</ul>
<pre><code class="language-raku" data-lang="raku">&gt; my $res = qqx{mkdir 123456}

# 或使用 qx{ }
&gt; my $res = qx{mkdir 112233}
</code></pre><ul>
<li>13、   Does Raku support something equivalent to Perl5&rsquo;s <strong>DATA</strong> and <strong>END</strong> sections?</li>
</ul>
<pre><code class="language-raku" data-lang="raku">use v6;
=foo This is a Pod block. A single line one. This Pod block's name is 'foo'.

=begin qux
This is another syntax for defining a Pod block.
It allows for multi line content.
This block's name is 'qux'.
=end qux

=data A data block -- a Pod block with the name 'data'.

# Data blocks are P6's version of P5's __DATA__.
# But you can have multiple data blocks:

=begin data
Another data block.
This time a multi line one.
=end data

$=pod.grep(*.name eq 'data').map(*.contents[0].contents.say);

say '-' x 45;
for @$=pod {
  if .name eq 'data' {
    say .contents[0].contents
  }
};
</code></pre><ul>
<li>14、生成含有26个英文字母和下划线的 junction</li>
</ul>
<pre><code class="language-raku" data-lang="raku">&gt; any('A'..'Z','a'..'z','_');
any(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, _)
</code></pre><ul>
<li>15、判断一个字符是否在某个集合中</li>
</ul>
<pre><code class="language-raku" data-lang="raku">&gt;  so any('A'..'Z','a'..'z') ∈ set(&quot;12a34&quot;.comb)
</code></pre><p>&ldquo;12a34&rdquo;.comb 会把字符串分割为单个字符，返回一个字符数组</p>
<ul>
<li>16、生成 IP 地址范围</li>
</ul>
<pre><code class="language-raku" data-lang="raku">.say for &quot;192.168.10.&quot; &lt;&lt;~&gt;&gt; (0..255).list
</code></pre><ul>
<li>17、 生成 OC 中的测试数组</li>
</ul>
<pre><code class="language-raku" data-lang="raku"> .say for &quot;@&quot; &lt;&lt;~&gt;&gt; '&quot;Perl' &lt;&lt;~&gt;&gt;  (1..30).list &lt;&lt;~&gt;&gt; '&quot;,'
</code></pre><pre><code>@&quot;Perl&quot;1&quot;,
@&quot;Perl&quot;2&quot;,
@&quot;Perl&quot;3&quot;,
@&quot;Perl&quot;4&quot;,
@&quot;Perl&quot;5&quot;,
…
</code></pre>
<ul>
<li>18、我想以AGCT4种字母为基础生成字符串。</li>
</ul>
<p>比如希望长度为1，输出A,G,C,T。
如果长度为2，输出AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT。这样的结果。</p>
<p>@a X~ &quot;&quot;   # 长度为1
(@a X~ @a) # 长度为2
(@a X~ @a) X~ @a     # 长度为3
@a X~ @a X~ @a X~ @a # 长度为4</p>
<pre><code class="language-raku" data-lang="raku">&gt; my @a=&lt;A G C T&gt;
A G C T
&gt; my $x=@a
A G C T
&gt; $x xx 2
A G C T A G C T
&gt; $x xx 3
A G C T A G C T A G C T
&gt; ($x xx 3).WHAT
(List)
&gt; $x.WHAT
(Array)

&gt; ([X~] $x xx 2).join(',')
AA,AG,AC,AT,GA,GG,GC,GT,CA,CG,CC,CT,TA,TG,TC,TT
</code></pre><p>惰性操作符：</p>
<pre><code class="language-raku" data-lang="raku">my @a=&lt;A G C T&gt;;
my $x=@a;  # 或者使用 $x =@('A','G','C','T')
for 1 ...^ * -&gt; $a {(([X~] $x xx $a)).join(',').say;last if $a==4;};
</code></pre><h2 id="best-of-raku">Best Of Raku</h2>
<hr>
<ul>
<li>Command Line 命令行</li>
</ul>
<pre><code class="language-raku" data-lang="raku">
               Perl 5                                     Raku
 print &quot;bananas are good\n&quot;;                     say &quot;bananas are good&quot;;
 print &quot;and I said: $quotes{\&quot;me\&quot;}\n&quot;;          say &quot;and I said: %quotes{&quot;me&quot;}.&quot;;
 print &quot;and I said: $quotes{\&quot;me\&quot;}\n&quot;;          say &quot;and I said: %quotes&lt;me&gt;.&quot;;
 print &quot;What is ... &quot;;                           $result = prompt &quot;What is ... &quot;;
 chomp($result = &lt;&gt;);
</code></pre><ul>
<li>File IO</li>
</ul>
<pre><code class="language-raku" data-lang="raku">
               Perl 5                                     Raku
 $content = do { local $/;                       $content = slurp &quot;poetry.txt&quot;;
    open my $FH, &quot;poetry.txt&quot;; &lt;$FH&gt;
 };

chomp(@content = do {                            @content = lines &quot;poetry.txt&quot;;
    open my $FH, &quot;poetry.txt&quot;; &lt;$FH&gt;
});
</code></pre><ul>
<li>Automatic multithreading</li>
</ul>
<p>Applying operations to junctions and arrays is now syntactically compact and readable. Raku will create threads where appropriate to use multiple processors, cores or hyperthreading for high level language SIMD concurrent processing.</p>
<pre><code class="language-raku" data-lang="raku">               Perl 5                                     Raku
 my $sum;                                        my $sum = [+] @numbers;
 $sum += $_ for @numbers;
 for (0 .. $#factor1) {                          @product = @factor1 &gt;&gt;*&lt;&lt; @factor2;
   $product[$] = $factor1[$] * $factor2[$_];
 }
</code></pre><p>The Perl 5 code is a simplification, of course Raku &ldquo;does the right thing&rdquo; when the arrays have different lengths.</p>
<ul>
<li>Comparison 比较</li>
</ul>
<p>Here are junctions, then chained comparison operators.</p>
<pre><code class="language-raku" data-lang="raku">               Perl 5                                     Raku
 if ($a == 3 or $a == 4 or $a == 7) {...}        if $a = 3 | 4 | 7 {...}
 if (4 &lt; $a and $a &lt; 12) {...}                   if 4 &lt; $a &lt; 12    {...}
 if (4 &lt; $a and $a &lt;= 12) {...}                  if $a ~~ 4^..12   {...}
 $a = defined $b ? $b : $c;                      $a = $b // $c;
</code></pre><p>The defined-OR operator eases lot of cases where Perl 5 newbies could fall into traps.</p>
<ul>
<li>Case 结构</li>
</ul>
<pre><code class="language-raku" data-lang="raku">               Perl 5                                      Raku
                                                     given $a {
 if ($a == 2 or $a == 5) {...} }}                      when 2 | 5  {...}
 elsif ($a == 6 or $a == 7 or $a == 8 or $a == 9) {}   when 6 .. 9 {...}
 elsif ($a =~ /g/) {...}                               when 'g'    {...}
 else {...}                                            default     {...}
                                                     }
</code></pre><p>That new construct (backported to 5.10) is clear to read, very versatile and when used in combination with junctions, becomes even clearer.</p>
<ul>
<li>强大的循环</li>
</ul>
<p>List iteration via for is now much more versatile.</p>
<pre><code class="language-raku" data-lang="raku">               Perl 5                                     Raku
 for my $i (0..15) {...}                         for ^16 -&gt; $i        {...}
 for (my $i=15; $i&gt;1; $i-2) {...}                for 15,*-2...1 -&gt; $i {...}   # 15 13 11 9 7 5 3 1
 for my $key (keys %hash) {                      for %hash.kv -&gt; $key, $value {
   print &quot;$key =&gt; $hash{$key}\n&quot;; ...              say &quot;$key =&gt; $value&quot;; ...
 for my $i (0..$#a) {                            for zip(@a; @b; @c) -&gt; $a, $b, $c {...}
   my $a = @a[$i];
   my $b = @b[$i];
   my $c = @c[$i]; ...
</code></pre><ul>
<li>子例程中的具名参数</li>
</ul>
<pre><code class="language-raku" data-lang="raku">               Perl 5                                     Raku
 sub routine {                                   sub routine ($a, $b, *@rest) {...}
   my $a = shift;
   my $b = shift;
   my @rest = @_;
 }
</code></pre><ul>
<li>Objects with auto generated new and getters and setters</li>
</ul>
<p>Simple Object creation is now as easy as it gets.</p>
<pre><code class="language-raku" data-lang="raku">               Perl 5                                     Raku
 package Heart::Gold;                            class Heart::Gold {
                                                   has $.speed;
 sub new {                                         method stop { $.speed = 0 }
   bless {speed =&gt; 0 }, shift;                   }  
 }
                                                 my Heart::Gold $hg1 .= new;
 sub speed {                                     $hg1.speed = 100;
   my $self = shift;                             my $hg2 = $hg1.clone;
   my $speed = shift;
   if (defined $speed) { $self-&gt;{speed} = $speed }
   else { $self-&gt;{speed} }
 }

 sub stop {
   my $self = shift;
   $self-&gt;{speed} = 0;
 }
</code></pre><h2 id="raku-variable">Raku Variable</h2>
<hr>
<ul>
<li>Variable Types</li>
</ul>
<p>Raku (as Perl 5) knows 3 basic types of variables: Scalars (single values), Arrays (ordered and indexed lists of several values) and Hashes (2 column table, with ID and associated value pairs). They can be easily distinguished, because in front of their name is a special character called sigil (latin for sign). It&rsquo;s the $ (similar to S) for Scalars, @ (like an a) for Arrays and a % (kv pair icon) for a Hash. They are now invariant (not changing), which means for instance, an array vaiable starts always with an @, even if you just want a slice of the content.</p>
<pre><code class="language-raku" data-lang="raku">$scalar
@array
@array[1]              # $array[1]   in Perl 5
@array[1,2]            # @array[1,2] in Perl 5
%hash
%hash{'ba'}            # $hash{'ba'} in Perl 5
%hash{'ba','da','bim'} # @hash{'ba','da','bim'} in Perl 5
</code></pre><p>The sigils also mark distinct namespaces, meaning: in one lexical scope you can have 3 different variables named $stuff, @stuff and %stuff. These sigils can also be used as an operator to enforce a context in which the following data will be seen.</p>
<p>The fourth namespace is for subroutines and similar, even if you don&rsquo;t usually think of them as variables. It&rsquo;s sigil &amp; is used to refer to subroutines without calling them.</p>
<p>All special namespaces from Perl 5 (often marked with special syntax), like tokens (<strong>PACKAGE</strong>), formats, file or dir handles, or builtins are now regular variables or routines.</p>
<p>Because all variables contain objects, they have methods. In fact, all operators, including square or curly bracket subscripts, are just methods of an object with a fancy name.</p>
<p>The primary sigil can be followed by a secondary sigil, called a twigil, which indicates a special scope for that variable.</p>
<p>Scalar</p>
<p>This type stores one value, usually a reference to something: a value of a data type, a code object, an object or a compound of values like a pair, junction, array, hash or capture. The scalar context is now called item context, hence the scalar instruction from Perl 5 was renamed to item.</p>
<pre><code class="language-raku" data-lang="raku">$CHAPTER = 3;              # first comment!
$bin = 0b11;               # same value in binary format
$pi = 3.14159_26535_89793; # the underscores just ease reading
$float = 6.02e-23;         # floating number in scientific notation
$text = 'Welcome all!';    # single quoted string

# double quoted string, does eval $pi to it's content
$text = &quot; What is $pi?&quot;;
$text = q:to'EOT';         # heredoc string

    handy for multiline text
    like HTML templates or email

EOT
$handle = open $file_name; # file handle
# an object from a class with a nested namespace
$object = Class::Name.new();
$condition = 3|5|7;                # a junction, a logical conjunction of values
$arrayref = [0,1,1,2,3,5,8,13,21]; # an array stored as a single item

# a hash stored as a single item
$hashref = {'audreyt' =&gt; 'pugs',
            'pm'      =&gt; 'pct',
            'damian'  =&gt; 'larrys evil henchman'};
# pointing to a callable
$coderef = sub { do_something_completely_diffenent(@_) };
</code></pre><p>(For info on some of those terms: comment, binary format, the underscores ease reading, scientific notation, single-quoted string, double-quoted string, heredoc string, file handle, class, junction, list of values, hash, callable.)</p>
<p>Unlike Perl 5, references are automatically dereferenced to a fitting context. So you could use these $arrayrefs and $hashrefs similarly to an array or hash, making $ the universal variable prefix, pretty much like in PHP. The primary difference is that $ prefixed lists are not flattened in lists.</p>
<pre><code class="language-raku" data-lang="raku">my $a = (1, 2, 3);
my @a = 1, 2, 3;
for $a { }          # just one iteration
for @a { }          # three iterations
</code></pre><p>Scalar Methods</p>
<pre><code class="language-raku" data-lang="raku">my $chapter = 3;
undefine $chapter;
defined $a; # false, returns 0
</code></pre><ul>
<li>Array</li>
</ul>
<p>An array is an ordered and indexed list of scalars. If not specified otherwise, they can be changed, expanded and shortened anytime and used as a list, stack, queue and much more. As in Haskell, lists are processed lazily, which means: the compiler looks only at the part it currently needs. This way Raku can handle infinite lists or do computation on lists that have not been computed yet. The lazy command enforces this and the eager command forces all values to be computed.</p>
<p>The list context is forced with a @() operator or list() command. That&rsquo;s not autoflattening like in Perl 5 (automatically convert a List of Lists into one List). If you still want that, say flat(). Or say lol() to explicitly prevent autoflattening.</p>
<pre><code class="language-raku" data-lang="raku">@primes = (2,3,5,7,11,13,17,19,23); # an array gets filled like in Perl 5
@primes =  2,3,5,7,11,13,17,19,23 ; # same thing, since unlike P5 round braces just do group
@primes = &lt;2 3 5 7 11 13 17 19 23&gt;; # ditto, &lt;&gt; is the new qw()
$primes = (2,3,5,7,11,13,17,19,23); # same array object just sits in $primes, $primes[0] is 2
$primes = item @primes;             # same thing, more explicit
$primes = 2,;                       # just 2, first element of the Parcel
@primes = 2;                        # array with one element
@primes = [2,3,5,7,11,13,17,19,23]; # array with one element (List of Lists - LoL)
@dev    = {'dan' =&gt; 'parrot'};      # array with one element (a Hash)
@data   = [1..5],[6..10],[11..15];  # Array of Arrays (LoL)
@list   = lol @data;                # no change
@list   = flat @data;               # returns 1..15
</code></pre><ul>
<li>Array Slices</li>
</ul>
<pre><code class="language-raku" data-lang="raku">@primes                       # all values as list
@primes.values                # same thing
@primes.keys                  # list of all indices
&quot;@primes[]&quot;                   # insert all values in a string, uses [] to distinguish from mail adresses
$prime = @primes[0];          # get the first prime
$prime = @primes[*-1];        # get the last one
@some = @primes[2..5];        # get several
$cell = @data[1][2];          # get 8, third value of second value (list)
$cell = @data[1;2];           # same thing, shorten syntax
@numbers = @data[1];          # get a copy of the second subarray (6..10)
@copy = @data;                # shallow copy of the array
</code></pre><ul>
<li>Array Methods</li>
</ul>
<p>Some of the more important things you can do with lists. All the methods can also used like ops in &ldquo;elems @array;&rdquo;</p>
<pre><code class="language-raku" data-lang="raku">? @array;              # boolean context, Bool::True if array has any value in it, even if it's a 0
+ @array;              # numeric context, number of elements (like in Perl 5 scalar @a)
~ @array;              # string context, you get content of all cells, stringified and joined, same as &quot;@primes[]&quot;

@array.elems;          # same as + @array
@array.end;            # number of the last element, equal to @array.elems-1
@array.cat;            # same ~ @array
@array.join('');       # also same result, you can put another string as parameter that gets between all values
@array.unshift;        # prepend one value to the array
@array.shift;          # remove the first value and return it
@array.push;           # add one value on the end
@array.pop;            # remove one value from the end and return it
@array.splice($pos,$n);# starting at $pos remove $n values and replace them with values that follow those two
</code></pre><ul>
<li>parameters</li>
</ul>
<pre><code class="language-raku" data-lang="raku">@array.delete(@ind);   # delete all cells with indices in @ind
@array.exists(@ind);   # Bool::True if all indices of @ind have a value (can be 0 or '')
@array.pick([$n]);     # return $n (default is 1) randomly selected values, without duplication
@array.roll([$n]);     # return $n (default is 1) randomly selected values, duplication possible (like roll dice)
@array.reverse;        # all elements in reversed order
# returns a list where $n times first item is taken to last
# position if $n is positive, if negative the other way around
@array.rotate($n);

@array.sort($coderef); # returns a list sorted by a user-defined criteria, default is alphanumerical sorting
@array.min;            # numerical smallest value of that array
@array.max;            # numerical largest value of that array
$a,$b= @array.minmax;  # both at once, like in .sort,  .min, or .max, a sorting algorithm can be provided

@array.map($coderef);  # high oder map function, runs $coderef with every value as $_ and returns the list or results
@array.classify($cr);  # kind of map, but creates a hash, where keys are the results of $cr and values are from @array
@array.categorize($cr);# kind of classify, but closure can have no (Nil) or several results, so a key can have a list of values
@array.grep({$_&gt;1});   # high order grep, returns only these elements that pass a condition ($cr returns something positive)
@array.first($coder);  # kind of grep, return just the first matching value
@array.zip;            # join arrays by picking first element left successively from here and then there
There is even a whole class of metaoperators that work upon lists.
</code></pre><ul>
<li>Hash</li>
</ul>
<p>In Raku a Hash is an unordered list of Pairs. A Pair is a single key =&gt; value association and appears in many places of the language syntax. A hash allows lookup of values by key using {} or &lt;&gt; syntax.</p>
<pre><code class="language-raku" data-lang="raku">%dev =  'pugs'=&gt;'audreyt', 'pct'=&gt;'pm', &quot;STD&quot;=&gt;'larry';
%dev = :rakudo('jnthn'), :testsuite('moritz');            # adverb (pair) syntax works as well
%dev = ('audreyt', 'pugs', 'pm', 'pct', 'larry', &quot;STD&quot;);  # lists get autoconverted in hash context
%compiler = Parrot =&gt; {Rakudo =&gt; 'jnthn'}, SMOP =&gt; {Mildew =&gt; 'ruoso'};       # hash of hashes (HoH)
</code></pre><ul>
<li>Hash Slices</li>
</ul>
<pre><code class="language-raku" data-lang="raku">$value = %dev{'key'};      # just give me the value related to that key, like in P5
$value = %dev&lt;pm&gt;;         # &lt;&gt; autoquotes like qw() in P5
$value = %dev&lt;&lt;$name&gt;&gt;;    # same thing, just with eval
@values = %dev{'key1', 'key2'};
@values = %dev&lt;key1 key2&gt;;
@values = %dev&lt;&lt;key1 key2 $key3&gt;&gt;;
%compiler&lt;Parrot&gt;&lt;Rakudo&gt;; # value in a HoH, returns 'jnthn'
%compiler&lt;SMOP&gt;;           # returns the Pair: Mildew =&gt; 'ruoso'

%dev   {'audrey'};         # error, spaces between varname and braces (postcircumfix operator) are no longer allowed
%dev\  {'allison'};        # works, quote the space
%dev   .&lt;dukeleto&gt;;        # error
%dev\ .{'patrick'};        # works too, &quot;long dot style&quot;, because it's an object in truth
</code></pre><ul>
<li>Hash Methods</li>
</ul>
<pre><code class="language-raku" data-lang="raku">? %dev                     # bool context, true if hash has any pairs
+ %dev                     # numeric context, returns number of pairs(keys)
~ %dev                     # string context, nicely formatted 2 column table using \t and \n

$table = %dev;             # same as ~ %dev
%dev.say;                  # stringified, but only $key and $value are separated by \t
@pairs = %dev;             # list of all containing pairs
%dev.pairs                 # same thing in all context
%dev.elems                 # same as + %dev or + %dev.pairs
%dev.keys                  # returns a list of all keys
%dev.values                # list of all values
%dev.kv                    # flat list with key1, value1, key 2 ...
%dev.invert                # reverse all key =&gt; value relations
%dev.push (@pairs)         # inserts a list of pairs, if a key is already present in %dev, both values gets added to an array
</code></pre><ul>
<li>Callable</li>
</ul>
<p>Internally subroutines, methods and alike are variables with the sigil &amp; and stored in a fourth namespace. Unlike Perl 5, all subroutines can be overwritten or augmented with user defined routines. Of course scalars can also contain routines.</p>
<pre><code class="language-raku" data-lang="raku">&amp;function = sub { ... };         # store subroutine in callable namespace
function();                      # call/run it

$coderef = sub { ... };          # store it in a scalar
$coderef($several, $parameter);  # run that code
</code></pre><ul>
<li>Data Types</li>
</ul>
<p>In contrast to variable types (container types) every value has a type too. These are organized internally as classes or roles and can be categorized into 3 piles: the undefined, immutable, and the mutable types.</p>
<p>You can assign one of these types to scalar, array, or hash variables, which enforces the contents to be that type.</p>
<pre><code class="language-raku" data-lang="raku">my Int $a;
my Int @a;  # array of Int
</code></pre><ul>
<li>Pair</li>
</ul>
<p>Pairs are new and their syntax is used nearly everywhere in the language where there is an association between a name and a value.</p>
<pre><code class="language-raku" data-lang="raku">$pair = 'jakub' =&gt; 'helena';  # &quot;=&gt;&quot; is the pair constructor
$pair = :jakub('helena');     # same in adverbial notation
$pair = :jakub&lt;helena&gt;;       # same using &lt;&gt;, the new qw()
$pair.key                     # returns 'jakub'
$pair.value                   # returns 'helena'
$pair.isa(Pair)               # Bool::True
</code></pre><ul>
<li>Enumeration</li>
</ul>
<p>enum</p>
<ul>
<li>Capture</li>
</ul>
<p>Captures are also a new type, which holds the parameters a routine gets. Because Perl now knows both positional and named parameters, it is a mixture of a list and array.</p>
<pre><code class="language-raku" data-lang="raku">$cap = \(@a,$s,%h,'a'=&gt;3);    # creating a capture, &quot;\&quot; was free since there are no references anymore
|$cap                         # flatten into argument list (without |, it will pass it as a single value)
||$cap                        # flatten into semicolon list (meant for variadic functions that take list of lists)
</code></pre><p>One important difference between a capture and a compound structure of lists and hashes: While assignments with = will copy the complete content of the named variables, this is not so in the case of a capture. When I change sinthelastexample, thecontentofcap changes too, because when parameters to a routine are variables, they are also interpolated in the moment the routine is called, not when it&rsquo;s defined.</p>
<ul>
<li>Properties and Traits</li>
</ul>
<p>Properties</p>
<p>xxx</p>
<p>Traits</p>
<p>xxx</p>
<p>Scoping</p>
<p>scope declarator, scopes</p>
<pre><code class="language-raku" data-lang="raku">my $var;
state
temp
let
our $var;
$*var;
Twigils
</code></pre><p>xxx</p>
<ul>
<li>Assignment and Binding</li>
</ul>
<p>Assignment</p>
<p>As rightfully expected, assignments are done with the equal sign. But unlike Perl 5 you always get a copy of the right side data assigned to the left, no matter how nested the data structure was (lists of lists eg). You never get in Raku a reference with =. The only exception may be seen captures.</p>
<pre><code class="language-raku" data-lang="raku">my @original = [1,2],[3,4];
my $copy = @original[0]; # $copy points to [1,2]
@original[0][0] = 'fresh stuff'; # $copy[0] holds still 1
</code></pre><ul>
<li>Binding</li>
</ul>
<p>Since every variable in Raku is a reference, programmers can use binding to get 2 variables that point to the same memory location.</p>
<pre><code class="language-raku" data-lang="raku">$original = 5;
$original := $mirror;       # normal binding, done on runtime
$original ::= $mirror;      # same thing, but done during compile time
$original = 3;
say $mirror;                # prints 3
$original =:= $mirror       # true, because they're bound together
$original === $mirror       # also true, because content and type are equal
</code></pre><p>——-
问题描述：</p>
<p>给定 2 个整数， A 和 B。 求这两个数的和</p>
<pre><code>输入数据：
A 和 B 来自输入流， 以空格分割

输出数据：
两个数据的和

Example：

Input    Output
2   2      4
3   2      5
</code></pre>
<pre><code class="language-raku" data-lang="raku">say [+] .words for lines
</code></pre><p>——-</p>
<pre><code>任务：
以任意的顺序生成 含有 N 个开括号&quot;[&quot;  和 N 个闭括号&quot;]&quot; 的字符串

检查生成的字符串是否平衡
Example：
</code></pre>
<p>(empty)   OK</p>
<p>[]        OK   ][        NOT OK</p>
<p>[][]      OK   ][][      NOT OK</p>
<p>[[][]]    OK   []][[]    NOT OK</p>
<ul>
<li>Depth counter</li>
</ul>
<pre><code class="language-raku" data-lang="raku">sub balanced($s) {
    my $l = 0;
    for $s.comb {
        when &quot;]&quot; {
            --$l;
            return False if $l &lt; 0;
        }
        when &quot;[&quot; {
            ++$l;
        }
    }
    return $l == 0;
}

my $n = prompt &quot;Number of brackets&quot;;
my $s = (&lt;[ ]&gt; xx $n).pick(*).join;
say &quot;$s {balanced($s) ?? &quot;is&quot; !! &quot;is not&quot;} well-balanced&quot;
</code></pre><ul>
<li>FP oriented</li>
</ul>
<pre><code class="language-raku" data-lang="raku">sub balanced($s) {
    .none &lt; 0 and .[*-1] == 0
        given [\+] '\\' «leg« $s.comb;
}

my $n = prompt &quot;Number of bracket pairs: &quot;;
my $s = &lt;[ ]&gt;.roll($n*2).join;
say &quot;$s { balanced($s) ?? &quot;is&quot; !! &quot;is not&quot; } well-balanced&quot;
</code></pre><ul>
<li>String munging</li>
</ul>
<pre><code class="language-raku" data-lang="raku">sub balanced($_ is copy) {
    () while s:g/'[]'//;
    $_ eq '';
}

my $n = prompt &quot;Number of bracket pairs: &quot;;
my $s = &lt;[ ]&gt;.roll($n*2).join;
say &quot;$s is&quot;, ' not' xx not balanced($s)), &quot; well-balanced&quot;;
</code></pre><ul>
<li>Parsing with a grammar</li>
</ul>
<pre><code class="language-raku" data-lang="raku">grammar BalBrack { token TOP { '[' &lt;TOP&gt;* ']' } }

my $n = prompt &quot;Number of bracket pairs: &quot;;
my $s = ('[' xx $n, ']' xx $n).pick(*).join;
say &quot;$s { BalBrack.parse($s) ?? &quot;is&quot; !! &quot;is not&quot; } well-balanced&quot;;
</code></pre><p>——-</p>
<ul>
<li>凯撒加密</li>
</ul>
<p>实现一个凯撒加密， 编码和解码都要有</p>
<p>key 是一个 1 到 25 之间的整数</p>
<pre><code class="language-raku" data-lang="raku">my @alpha = 'A' .. 'Z';
sub encrypt ( $key where 1..25, $plaintext ) {
    $plaintext.trans( @alpha Z=&gt; @alpha.rotate($key) );
}
sub decrypt ( $key where 1..25, $cyphertext ) {
    $cyphertext.trans( @alpha.rotate($key) Z=&gt; @alpha );
}

my $original = 'THE FIVE BOXING WIZARDS JUMP QUICKLY';
my $en = encrypt( 13, $original );
my $de = decrypt( 13, $en );

.say for $original, $en, $de;

say 'OK' if $original eq all( map { .&amp;decrypt(.&amp;encrypt($original)) }, 1..25 );
</code></pre><pre><code>Output:
THE FIVE BOXING WIZARDS JUMP QUICKLY
GUR SVIR OBKVAT JVMNEQF WHZC DHVPXYL
THE FIVE BOXING WIZARDS JUMP QUICKLY
OK
</code></pre>
<p>——-</p>
<ul>
<li>日期格式化</li>
</ul>
<p>使用 &ldquo;2007-11-10&rdquo; 和 &quot; Sunday, November 10, 2007&quot; 日期格式显式当前日期</p>
<pre><code class="language-raku" data-lang="raku">use DateTime::Utils;

my $dt = DateTime.now;

say strftime('%Y-%m-%d', $dt);
say strftime('%A, %B %d, %Y', $dt);
</code></pre><p>——-</p>
<ul>
<li>阶乘</li>
</ul>
<p>n 的阶乘定义为 <code>n*(n-1)*(n-2)…*1</code>, 零的阶乘为1.</p>
<p>定义一个函数返回一个数字的阶乘。</p>
<ul>
<li>使用自定义后缀操作符</li>
</ul>
<pre><code class="language-raku" data-lang="raku">
sub postfix:&lt;!&gt;($n where $n &gt; 0) {
    [*] 2..$n
}
say 5!

</code></pre><ul>
<li>[*]</li>
</ul>
<pre><code class="language-raku" data-lang="raku">
my @a = 1, [\*] 1..*;
say @a[5];

</code></pre><p>——-</p>
<ul>
<li>动画</li>
</ul>
<pre><code class="language-raku" data-lang="raku">
my $row-count = 6;

constant $peg = &quot;*&quot;;
constant @coin-icons = &quot;\c[UPPER HALF BLOCK]&quot;, &quot;\c[LOWER HALF BLOCK]&quot;;

sub display-board(@positions, @stats is copy, $halfstep) {
    my $coin = @coin-icons[$halfstep.Int];

    state @board-tmpl = {
        # precompute a board
        my @tmpl;
        sub out(*@stuff) {
            @tmpl.push: @stuff&gt;&gt;.ords.item;
        }
        # three lines of space above
        for (1..3) {
            out &quot;  &quot;, &quot; &quot; x (2 * $row-count);
        }
        # $row-count lines of pegs
        for ($row-count...1) Z (1...$row-count) -&gt; $spaces, $pegs {
            out &quot;  &quot;, &quot; &quot; x $spaces, ($peg xx $pegs).join(&quot; &quot;), &quot; &quot; x $spaces;
        }
        # four lines of space below
        for (1..4) {
            out &quot;  &quot;, &quot; &quot; x (2 * $row-count);
        }
        @tmpl
    }();

    my $midpos = $row-count + 2;

    my @output;
    {
        # collect all the output and output it all at once at the end
        sub say(Str $foo) {
            @output.push: $foo, &quot;\n&quot;;
        }
        sub print(Str $foo) {
            @output.push: $foo;
        }

        # make some space above the picture
        say &quot;&quot; for ^10;

        my @output-lines = map { [map *.clone, @$_].item }, @board-tmpl;
        # place the coins
        for @positions.kv -&gt; $line, $pos {
            next unless $pos.defined;
            @output-lines[$line][$pos + $midpos] = $coin.ord;
        }
        # output the board with its coins
        for @output-lines -&gt; @line {
            say @line&gt;&gt;.chr.join(&quot;&quot;);
        }

        # show the statistics
        my $padding = 0;
        while any(@stats) &gt; 0 {
            $padding++;
            print &quot;  &quot;;
            @stats = do for @stats -&gt; $stat {
                given $stat {
                    when 1 {
                        print &quot;\c[UPPER HALF BLOCK]&quot;;
                        $stat - 1;
                    }
                    when * &lt;= 0 {
                        print &quot; &quot;;
                        0
                    }
                    default {
                        print &quot;\c[FULL BLOCK]&quot;;
                        $stat - 2;
                    }
                }
            }
            say &quot;&quot;;
        }
        say &quot;&quot; for $padding...^10;
    }
    say @output.join(&quot;&quot;);
}

sub simulate($coins is copy) {
    my $alive = True;

    sub hits-peg($x, $y) {
        if 3 &lt;= $y &lt; 3 + $row-count and -($y - 2) &lt;= $x &lt;= $y - 2 {
            return not ($x - $y) %% 2;
        }
        return False;
    }

    my @coins = Int xx (3 + $row-count + 4);
    my @stats = 0 xx ($row-count * 2);
    # this line will dispense coins until turned off.
    @coins[0] = 0;
    while $alive {
        $alive = False;
        # if a coin falls through the bottom, count it
        given @coins[*-1] {
            when *.defined {
                @stats[$_ + $row-count]++;
            }
        }

        # move every coin down one row
        for ( 3 + $row-count + 3 )...1 -&gt; $line {
            my $coinpos = @coins[$line - 1];

            @coins[$line] = do if not $coinpos.defined {
                Nil
            } elsif hits-peg($coinpos, $line) {
                # when a coin from above hits a peg, it will bounce to either side.
                $alive = True;
                ($coinpos - 1, $coinpos + 1).pick;
            } else {
                # if there was a coin above, it will fall to this position.
                $alive = True;
                $coinpos;
            }
        }
        # let the coin dispenser blink and turn it off if we run out of coins
        if @coins[0].defined {
            @coins[0] = Nil
        } elsif --$coins &gt; 0 {
            @coins[0] = 0
        }

        # smooth out the two halfsteps of the animation
        my $start-time;
        ENTER { $start-time = now }
        my $wait-time = now - $start-time;

        sleep 0.1 - $wait-time if $wait-time &lt; 0.1;
        for @coin-icons.keys {
            sleep $wait-time max 0.1;
            display-board(@coins, @stats, $_);
        }
    }
}

sub MAIN($coins = 20, $peg-lines = 6) {
    $row-count = $peg-lines;
    simulate($coins);
}

</code></pre><p>调用方式： raku Galton_box_animation.p6 50 8</p>
<p>——-</p>
<ul>
<li>列表和迭代</li>
</ul>
<p>Raku 中的列表扩展为惰性列表、无限列表、元素可变列表、元素不可变列表、类型列表、展开行为等等。</p>
<p>对于程序员来说，列表潜在是懒惰并含有无限元素的序列。列表是可变的，你可以通过诸如 push、pop、shift、unshift、splice等操作符来操作序列。列表中的元素可以是可变的或者不可变的。</p>
<p>列表对象是基于位置的，意味着它们能被绑定到数组变量上，并且支持 <code>.[]</code> 后缀操作符。</p>
<p>列表也是懒惰的，因为列表中的元素可以来自于能按需产生元素的生成函数（叫做迭代）。</p>
<p>数组就是一个所有元素都存储在标量容器的列表。</p>
<p>逗号操作符 <code>infix:&lt;,&gt;</code> 创建 Parcel 对象。这些不应该改和列表混淆； Parcel 是一种未经加工的元素序列。Parcel 是不可变的，尽管 Parcel中的元素可以是不可变的，也可是不可变的。</p>
<p>Parcel 来自于短语  &ldquo;parenthesis cell&rdquo;. 因为很多 Parcel 对象出现在圆括号里面。然而，除了空的 parcel，是逗号操作符创建了 Parcel 对象。</p>
<pre><code>()       # empty Parcel
(1)      # 一个整数
(1,2)    # a Parcel with two Ints
(1,)     # a Parcel with one Int
</code></pre>
<pre><code class="language-raku" data-lang="raku">&gt; (1).WHAT()
(Int)
&gt; (1,).WHAT()
(Parcel)
</code></pre><p>Parcel 也是位置的，并且对于诸如  <code>.[]</code> 和 <code>.elems</code> 列表操作会使用 展开上下文。查看下面的  &ldquo;Flattening contexts&rdquo;。访问没有展开的原始参数，你可以使用 <code>.arg($n)</code> 代替 <code>.[$n]</code>, 和 <code>.args</code> 代替 <code>.elems</code></p>
<pre><code class="language-raku" data-lang="raku">&gt; (1,2,3).elems
3
&gt; (1,2,3).[2]
3
&gt; (1,2,3).[1]
2

&gt; my $a =(1,2,3,(4,5,6),7).[3]
4 5 6
&gt; $a.WHAT.say
(Parcel)
&gt; $a.[2]
6
&gt; $a.[1]
5

&gt; [+] $a.list
15

</code></pre><p>列表和Parcel 对象都把其它容器对象作为元素。在一些上下文中，我们想把容器对象的值插入到列表或 parcel的周围，而在其它上下文中，我们想保留所有的子容器。这样的插值叫做 展开。</p>
<p>列表和Parcel都是可迭代的，可迭代表明它支持 <code>.iterator</code> 方法</p>
<p>标量容器中存储的对象不会在 flattening 上下文中插值，即使那个对象是可迭代的。</p>
<pre><code>my @a = 3,4,5;
for 1,2,@a  { .say }        # 5次迭代
</code></pre>
<p>1
2
3
4
5</p>
<pre><code>my $s = @a;
for 1,2,$s { ... }         # 3次迭代
</code></pre>
<p>1
2
3 4 5</p>
<p>这里，<code>$s</code> 和 <code>@a</code> 指向同一个数组对象，但是标量容器的出现阻止 <code>$s</code> 被展开到 for 循环中。</p>
<p>.list 和 .flat 方法能被用于还原展开行为：</p>
<pre><code class="language-raku" data-lang="raku">    for 1,2,$s.list { .say }    # 5次遍历
    for 1,2,@($s)   { .say  }   # 5次遍历，@()会强制为列表上下文
</code></pre><p>1
2
3
4
5</p>
<p>相反，<code>.item</code> 方法和 <code>$()</code> 能用于防止插值：</p>
<pre><code class="language-raku" data-lang="raku">    my @b = 1,2,@a;           # @b 有5个元素
    my @c = 1,2,@a.item;      # @c 有3个元素
    my @c = 1,2,$(@a);        # 同上

&gt; say +@c
3
</code></pre><p>迭代器</p>
<p><code>.reify($n)</code> 方法要求迭代器返回一个含有至少<code>$n</code>个具体元素的 Parcel，后面跟着序列中剩余元素的附加的迭代器，例如：</p>
<pre><code class="language-raku" data-lang="raku">   my $r = 10..50;
   say $r.iterator.reify(5).perl;  # (10, 11, 12, 13, 14, 15..50)
</code></pre><blockquote>
<p>say $r.iterator.reify(*).perl
(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 37, 48, 49, 50)</p>
</blockquote>
<ul>
<li>Feed operators</li>
</ul>
<p>feed操作符是完全懒惰的，意味着在使用者要求任何元素之前不会执行任何操作。这就是</p>
<p>my @a &lt;== grep { &hellip; } &lt;== map { &hellip; } &lt;== grep { &hellip; } &lt;== 1, 2, 3</p>
<p>是完全懒惰的。</p>
<p>——</p>
<ul>
<li>
<p>Grammars 文法</p>
<p>Named Regexes
Creating Grammars
Methods
method parse
method subparse
method parsefile
Action Classes</p>
</li>
</ul>
<p>文法是一种强大的工具, 用于拆解文本,并通常返回数据结构
例如, Raku 是使用 Raku 风格的文法解析和执行的.
对普通 Raku 用户来说,一个更实用的例子就是 JSON::Simple 模块, 这个模块能反序列化任何有效的 JSON 文件, 反序列化代码还写了不到 100 行, 简单,可扩展.</p>
<p>词法允许你组织正则, 就像类允许你组织普通代码的方法一样.</p>
<h2 id="命名正则-named-regexes">命名正则 Named Regexes</h2>
<hr>
<p>命名正则有特殊的语法, 与<strong>子例程</strong>的定义类似:</p>
<pre><code class="language-raku" data-lang="raku">my regex number { \d+ [ \. \d+ ]? }
</code></pre><p>这个例子中, 我们必须使用 ** my ** 关键词指定这个正则是词法作用域的, 因为 <strong>命名正则</strong> 通常用在 词法中.
给正则命名后有利于在其他地方<code>复用</code>正则:</p>
<pre><code class="language-raku" data-lang="raku">say &quot;32.51&quot;    ~~ &amp;number;
say &quot;15 + 4.5&quot; ~~ / &lt;number&gt; \s* '+' \s* &lt;number&gt; /
</code></pre><p>首先说下, 使用 <code>regex/token/rule</code> 定义了一个正则表达式后怎么去调用它:
就像调用一个子例程那样, 使用 <code>&amp;</code> 符号:
&amp; 后面跟正则表达式的名字,  即 &amp;regex_name
regex 不是命名正则仅有的标识符 &ndash; 实际上, 它用的不多. 大多数时候, 用的最多的是 <code>token</code> 和 <code>rule</code> 标识符. 它们都是<code>不能回溯</code>的, 这意味着正则引擎在匹配失败时不会备份和重试. 这通常是你想要的, 但不是对所有场合都合适:</p>
<pre><code class="language-raku" data-lang="raku">my regex works-but-slow { .+ q }
my token fails-but-fast { .+ q }
my $s = 'Tokens won\'t backtrack, which makes them fail quicker!'; # Tokens 不会沿原路返回, 这让它们更快地失败!
say so $s ~~ &amp;works-but-slow; # True
say so $s ~~ &amp;fails-but-fast; # False, the entire string get taken by the .+
</code></pre><p><code>token</code> 和 <code>rule</code> 标识符的不同之处在于 <code>rule</code> 标识符让 <code>Regex</code> 的 <code>:sigspace</code> 起作用了:</p>
<pre><code class="language-raku" data-lang="raku">my token non-space-y { once upon a time }
my rule space-y      { once upon a time }
say 'onceuponatime'    ~~ &amp;non-space-y;
say 'once upon a time' ~~ &amp;space-y;
</code></pre><h2 id="创建文法-creating-grammars">创建文法 Creating Grammars</h2>
<hr>
<pre><code class="language-raku" data-lang="raku">class Grammar is Cursor { }
</code></pre><p>使用 grammar 关键字而非 <code>class</code> 关键字声明文法. Grammars 应该只用于<code>解析文本</code>; 如果你想<code>提取</code>复杂的数据, 建议将 <code>action</code> 类 和 <code>grammar</code> 结合使用.</p>
<pre><code class="language-raku" data-lang="raku">grammar CSV {
    token TOP { [ &lt;line&gt; \n? ]+ }
    token line {
        ^^            # Beginning of a line
        &lt;value&gt;* % \, # Any number of &lt;value&gt;s with commas in `between` them
        $$            # End of a line
    }
    token value {
        [
        | &lt;-[&quot;,\n]&gt;     # Anything not a double quote, comma or newline
        | &lt;quoted-text&gt; # Or some quoted text
        ]*              # Any number of times
    }
    token quoted-text {
        \&quot;
        [
        | &lt;-[&quot;\\]&gt; # Anything not a &quot; or \
        | '\&quot;'     # Or \&quot;, an escaped quotation mark
        ]*         # Any number of times
        \&quot;
    }
}

say &quot;Valid CSV file!&quot; if CSV.parse( q:to/EOCSV/ );
    Year,Make,Model,Length
    1997,Ford,E350,2.34
    2000,Mercury,Cougar,2.38
    EOCSV
</code></pre><ul>
<li>
<p>方法	Methods</p>
</li>
<li>
<p>方法解析</p>
</li>
</ul>
<pre><code class="language-raku" data-lang="raku">method parse($str, :$rule = 'TOP', :$actions) returns Match:D
</code></pre><p>让 grammar 与 $str 匹配,使用 $rule 作为起始 rule, 选择性地将 $action 作为 action 对象应用.</p>
<p>如果 grammar 不能解析全部文本就会失败. 如果只想解析部分字符串, 使用 subparse
返回结果匹配对象, 并设置调用者的 <code>$/</code> 变量为结果匹配对象.</p>
<pre><code class="language-raku" data-lang="raku">say CSV.parse( q:to/EOCSV/ );
    Year,Make,Model,Length
    1997,Ford,E350,2.34
    2000,Mercury,Cougar,2.38
    EOCSV
</code></pre><pre><code class="language-raku" data-lang="raku">	This outputs:

｢Year,Make,Model,Length
1997,Ford,E350,2.34
2000,Mercury,Cougar,2.38
｣
 line =&gt; ｢Year,Make,Model,Length｣
  value =&gt; ｢Year｣
  value =&gt; ｢Make｣
  value =&gt; ｢Model｣
  value =&gt; ｢Length｣
 line =&gt; ｢1997,Ford,E350,2.34｣
  value =&gt; ｢1997｣
  value =&gt; ｢Ford｣
  value =&gt; ｢E350｣
  value =&gt; ｢2.34｣
 line =&gt; ｢2000,Mercury,Cougar,2.38 ｣
  value =&gt; ｢2000｣
  value =&gt; ｢Mercury｣
  value =&gt; ｢Cougar｣
  value =&gt; ｢2.38 ｣
</code></pre><h2 id="method-subparse">method subparse</h2>
<hr>
<pre><code class="language-raku" data-lang="raku"> method subparse($str, :$rule = 'TOP', :$actions) returns Match:D
</code></pre><p>将 <code>$str</code> 与 grammar 匹配, 使用 <code>$rule</code> 作为<code>起始 rule</code>, 选择性将 <code>$action</code> 作为 <code>action</code> 对象应用.
不像 <code>parse</code> , <code>subparse</code> 允许 <code>grammar</code> 只匹配所提供的字符串的一部分.</p>
<h2 id="method-parsefile">method parsefile</h2>
<hr>
<pre><code class="language-raku" data-lang="raku">    method parsefile(Cool $filename as Str, *%opts) 返回 Match:D
</code></pre><pre><code>使用 parse 方法解析 文件 $filename 的内容, 传递任何命名选项到 %opts
</code></pre>
<h2 id="action-classes">Action Classes</h2>
<hr>
<p>In fact, named regexes can even take extra arguments, using the same syntax as subroutine parameter lists
实际上, 命名正则甚至能接受额外的参数, 它使用的语法跟子例程参数列表的语法一样.</p>
<p>​写一个程序打印从 1  到 100 的整数，但是对 3 的倍数打印 &ldquo;Fizz&rdquo;, 对 5 的倍数打印 &ldquo;Buzz&rdquo;, 对于即是 3 的倍数，又是 5 的倍数的打印 &ldquo;FizzBuzz&rdquo;.</p>
<pre><code class="language-raku" data-lang="raku">for 1 .. 100 {
    when $_ %% (3 &amp; 5) { say 'FizzBuzz'; }
    when $_ %% 3       { say 'Fizz';     }
    when $_ %% 5       { say 'Buzz';     }
    default            { .say;           }
}
Or abusing multi subs:


```raku
multi sub fizzbuzz(Int $ where * %% 15) { 'FizzBuzz' }
multi sub fizzbuzz(Int $ where * %% 5)  { 'Buzz'     }
multi sub fizzbuzz(Int $ where * %% 3)  { 'Fizz'     }
multi sub fizzbuzz(Int $number )        { $number    }
(1 .. 100)».&amp;fizzbuzz.join(&quot;\n&quot;).say;
</code></pre><p>Most concisely:</p>
<pre><code class="language-raku" data-lang="raku">say 'Fizz' x $_ %% 3 ~ 'Buzz' x $_ %% 5 || $_ for 1 .. 100;
</code></pre><p>And here&rsquo;s an implementation that never checks for divisibility:</p>
<pre><code class="language-raku" data-lang="raku">.say for
    (('' xx 2, 'Fizz') xx * Z~
    ('' xx 4, 'Buzz') xx *) Z||1 .. 100;
</code></pre>

        
          <div class="blog-tags">
            
              <a href="https://ohmysummer.github.io//tags/%E7%89%B9%E6%80%A7/">特性</a>&nbsp;
            
              <a href="https://ohmysummer.github.io//tags/examples/">Examples</a>&nbsp;
            
          </div>
        

        

        
          
            
          

          
                  <h4 class="see-also"></h4>
                  <ul>
                
                
                    <li><a href="/post/2016-04-22-raku%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%80/">Raku 中的特性(一)</a></li>
                
                    <li><a href="/post/2016-02-14-raku-examples/">Raku Examples</a></li>
                
              </ul>

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://ohmysummer.github.io/post/2015-03-15-when%E5%92%8Cwhere/" data-toggle="tooltip" data-placement="top" title="When and Where">&larr; </a>
            </li>
          
          
            <li class="next">
              <a href="https://ohmysummer.github.io/post/2015-03-16-%E6%93%8D%E4%BD%9C%E7%AC%A6/" data-toggle="tooltip" data-placement="top" title="操作符"> &rarr;</a>
            </li>
          
        </ul>
      


      
        
          
          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ohmysummer" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
          
        
        
      

    </div>
  </div>
</div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            <a href="" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://ohmysummer.github.io/">焉知非鱼</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2021
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://ohmysummer.github.io/">Raku Programming</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://ohmysummer.github.io/js/main.js"></script>
<script src="https://ohmysummer.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://ohmysummer.github.io/js/load-photoswipe.js"></script>



<script>
  (function() {
    var cx = '009072066163920799339:qwme9vkotxk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>







    
  </body>
</html>

