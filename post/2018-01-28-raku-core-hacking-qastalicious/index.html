<!DOCTYPE html>
<html lang="zh" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Raku Core Hacking: QASTalicious - Raku Programming</title>
  <meta name="description" content="Overview of Q Abstract Syntax Trees &#43; bug fix tutorial">
  <meta name="author" content="焉知非鱼"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Raku Programming",
    
    "url": "https:\/\/ohmysummer.github.io\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/ohmysummer.github.io\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/ohmysummer.github.io\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/ohmysummer.github.io\/post\/2018-01-28-raku-core-hacking-qastalicious\/",
          "name": "Raku core hacking q a s talicious"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "焉知非鱼"
  },
  "headline": "Raku Core Hacking: QASTalicious",
  "description" : "在过去的一个月中，我在 Rakudo 的 QAST 地区花了一些时间写了一些优化，修复了包含警告的错误，并且用一个单一的提交压缩了一个10个thunk范围的bug的怪物蜂巢。 在今天的文章中，我们将详细介绍最后一个专长，以及了解QAST是什么以及如何使用它。",
  "inLanguage" : "zh",
  "wordCount":  5133 ,
  "datePublished" : "2018-01-28T10:54:24",
  "dateModified" : "2018-01-28T10:54:24",
  "image" : "https:\/\/ohmysummer.github.io\/img\/rakudo.png",
  "keywords" : [ "Raku" ],
  "mainEntityOfPage" : "https:\/\/ohmysummer.github.io\/post\/2018-01-28-raku-core-hacking-qastalicious\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/ohmysummer.github.io\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/ohmysummer.github.io\/img\/rakudo.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="Raku Core Hacking: QASTalicious" />
<meta property="og:description" content="Overview of Q Abstract Syntax Trees &#43; bug fix tutorial">
<meta property="og:image" content="https://ohmysummer.github.io/img/rakudo.png" />
<meta property="og:url" content="https://ohmysummer.github.io/post/2018-01-28-raku-core-hacking-qastalicious/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Raku Programming" />

  <meta name="twitter:title" content="Raku Core Hacking: QASTalicious" />
  <meta name="twitter:description" content="Overview of Q Abstract Syntax Trees &#43; bug fix tutorial">
  <meta name="twitter:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:card" content="summary" />
  <link href='https://ohmysummer.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.63.2" />
  <link rel="alternate" href="https://ohmysummer.github.io/index.xml" type="application/rss+xml" title="Raku Programming"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://ohmysummer.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://ohmysummer.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'ohmycloudy', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://ohmysummer.github.io/">Raku Programming</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="博客" href="/">博客</a>
            </li>
          
        
          
            <li>
              <a title="归档" href="/categories">归档</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/page/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        

        

        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span class="hidden-sm hidden-md hidden-lg"></span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Raku Programming" href="https://ohmysummer.github.io/">
            <img class="avatar-img" src="https://ohmysummer.github.io/img/rakudo.png" alt="Raku Programming" />
          </a>
        </div>
      </div>
    

  </div>
</nav>



  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title"></h4>
        </div>
        <div class="modal-body">
          <gcse:search></gcse:search>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal"></button>
        </div>
      </div>
    </div>
  </div>


    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>Raku Core Hacking: QASTalicious</h1>
              
              
              
                
                  <h2 class="post-subheading">Overview of Q Abstract Syntax Trees &#43; bug fix tutorial</h2>
                
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;25&nbsp;
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;5133&nbsp;
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;焉知非鱼
    
  
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <p>在过去的一个月中，我在 Rakudo 的 QAST 地区花了一些时间写了一些优化，修复了包含警告的错误，并且用一个单一的提交压缩了一个10个thunk范围的bug的怪物蜂巢。 在今天的文章中，我们将详细介绍最后一个专长，以及了解QAST是什么以及如何使用它。</p>
<h2 id="第一部分-qast">第一部分: QAST</h2>
<p>&ldquo;QAST&rdquo; 代表  &ldquo;Q&rdquo; Abstract Syntax Tree.(&ldquo;Q&rdquo; 抽象语法树.) 为什么会有个字母 &ldquo;Q&rdquo; 在那里呢, 因为 Q 是 P 的下一个字母, 而 &ldquo;P&rdquo; 过去是在 &ldquo;PAST&rdquo; 里面的, 代表 &ldquo;Parrot&rdquo;(鹦鹉), 是很早之前的一个实验性的 Raku 实现(或者说, 它的虚拟机). 我们来看看什么是 QAST!</p>
<h3 id="dumping-qast">Dumping QAST</h3>
<p>每个 Rakudo Raku 程序都编译到 QAST 节点树上，如果在编译程序或模块时给 <code>raku</code> 指定 <code>--target=ast</code> 或 <code>--target=optimize</code> 命令行选项，则可以转储该树:</p>
<pre><code>$ raku --target=ast -e 'say &quot;Hello, World!&quot;'
[...]
- QAST::Op(call &amp;say) &lt;sunk&gt; :statement_id&lt;?&gt; say \&quot;Hello, World!\&quot;
  - QAST::Want &lt;wanted&gt; Hello, World!
    - QAST::WVal(Str)
    - Ss
    - QAST::SVal(Hello, World!)
[...]
</code></pre><p><code>--target=ast</code> 和 <code>--target=optimize</code> 之间的区别在于，前者在生成后立即显示 QAST 树，而后者在静态优化器执行后显示 QAST 树。</p>
<p>虽然命令行选项为整个程序提供了 QAST（不包括单独预编译的模块），但是每个 <a href="https://github.com/raku/nqp/blob/master/src/QAST/Node.nqp">QAST::Node</a> 对象都有一个 <code>.dump</code> 方法，可用于从 Rakudo 的源代码中转储特定的 QAST 片段。</p>
<p>例如，为了检查由 <code>statement</code> 标记生成的 QAST，我会在 <code>src/Raku/Actions.nqp</code> 中找到<a href="https://github.com/rakudo/rakudo/blob/49dce163e8182ee726cd1e512a03c29551cc16da/src/Raku/Actions.nqp#L1396">method</a> 语句，并且在 <code>nqp::say('statement QAST: ' ~ $past.dump)</code> 方法。</p>
<p>由于 Rakudo 的编译需要花费几分钟的时间，所以我喜欢在 env 变量上键入我的调试转储，如下所示：</p>
<pre><code>nqp::atkey(nqp::getenvhash(),'ZZ1') &amp;&amp; nqp::say('ZZ1: something or other');
...
nqp::atkey(nqp::getenvhash(),'ZZ2') &amp;&amp; nqp::say('ZZ2: something else');
</code></pre><p>然后，我可以执行已编译的 <code>./raku</code>，就像我没有添加任何内容一样，通过运行 <code>ZZ1=1 ./raku</code>, <code>ZZ2=1 ./raku</code> 或者同时使用 <code>ZZ1=1 ZZ2=1 ./raku</code>。</p>
<h3 id="查看-qast">查看 QAST</h3>
<p>在终端中查看 <code>--target</code> 转储的输出就足以快速浏览树，但是为了获得额外的帮助，您可以安装带有 <code>q</code> 命令行工具的 <code>CoreHackers::Q</code> 模块。</p>
<p>只需在常规的 <code>raku</code> 调用前面加上  <code>q a</code> 或 <code>q o</code> 前缀以分别生成 <code>--target=ast</code> 和 <code>--target=optimize</code> QAST 转储。该程序将在当前目录中生成 <code>out.html</code> 文件：</p>
<pre><code class="language-raku" data-lang="raku">$ q a raku -e 'say &quot;Hello, World!&quot;'
$ firefox out.html
</code></pre><p>弹出打开生成的HTML文件，并获得这些好处：</p>
<ul>
<li>颜色编码的 QAST 节点</li>
<li>沉没节点的颜色提示</li>
<li>Ctrl + 点击任何节点来折叠它</li>
<li>静音的 QAST::Want 替代品，更容易忽略它们</li>
</ul>
<p>最后，我希望扩展这个工具，使其更有帮助，但在撰写本文时，就是这样。</p>
<h3 id="qast-森林">QAST 森林</h3>
<p>在 <a href="https://github.com/rakudo/rakudo/">rakudo 的源代码</a> 中有四个主要的文件，你可以期待它们使用 QAST 节点：<code>src/Raku/Grammar.nqp</code>, <code>src/Raku/Actions.nqp</code>, <code>src/Raku/World.nqp</code>, 和 <code>src/Raku/Optimizer.nqp</code>。如果您正在使用 <a href="https://github.com/zoffixznet/z">Z-Script</a> 工具，甚至可以运行 <code>z q</code> 命令在 <a href="https://github.com/raku/Atom-as-a-Raku-IDE">Atom 编辑器</a>中打开这四个文件。</p>
<p><code>Grammar.nqp</code> 是 Raku 语法。 <code>Actions.nqp</code> 是它的动作。 <code>World.nqp</code> 包含 <code>Grammar.nqp</code> 和 <code>Actions.nqp</code> 使用的各种有用的例程，它们通过包含 <code>Raku::World</code> 对象的 <code>$*W</code> 动态变量来访问它们。最后，<code>Optimizer.nqp</code> 包含 Rakudo 的静态优化器。</p>
<p>（所有邪恶的）根是 <a href="https://github.com/raku/nqp/blob/master/src/QAST/Node.nqp">QAST::Node</a>对象，所有其他 QAST 节点是它的子类。让我们来回顾一些流行的：</p>
<h3 id="qastop">QAST::Op</h3>
<p>QAST::Op 节点是 QAST 世界的主力。<code>:op</code> 命名参数指定 <a href="https://github.com/raku/nqp/blob/master/docs/ops.markdown">NQP op</a> 的名称或 <a href="https://github.com/rakudo/rakudo/blob/master/docs/ops.markdown">Rakudo的 NQP扩展操作</a>的名称，其孩子是参数：</p>
<p>下面是 <code>say</code> op 打印一个字符串值:</p>
<pre><code>QAST::Op.new: :op&lt;say&gt;,
  QAST::SVal.new: :value('Hello, World!');
</code></pre><p>这里是 <code>call</code> op 调用 Raku 的 <code>infix:&lt;+&gt;</code> 操作符的 QAST 节点， 请注意我们调用的例程的名称是如何通过 <code>:name</code> 命名的参数给出的：</p>
<pre><code>QAST::Op.new: :op&lt;call&gt;, :name('&amp;infix:&lt;+&gt;'),
  QAST::IVal.new( :value(2)),
  QAST::IVal.new: :value(2)
</code></pre><h3 id="qastval">QAST::*Val</h3>
<p><code>QAST::SVal</code>，<code>QAST::IVal</code>，<code>QAST::NVal</code> 和 <code>QAST::WVal</code> 节点分别指定字符串，整数，浮点数和 &ldquo;World&rdquo; 对象值。前三个是&quot;未装箱&quot;的原始值，而 World 对象是其他的东西，如 <a href="https://docs.raku.org/type/DateTime">DateTime</a>，<a href="https://docs.raku.org/type/Block">Block</a> 或 <a href="https://docs.raku.org/type/Block">Str</a> 对象。</p>
<h3 id="qastwant">QAST::WANT</h3>
<p>一些对象可以用多个 <code>QAST::*Val</code> 节点来表示，其中根据当前上下文中所需的内容使用最合适的值。 <code>QAST::Want</code> 节点包含这些替代方案，与字符串标记交错，指示替代方案是什么。</p>
<p>例如，Raku 中的数值 42 可能需要作为调用某个方法的对象，或者作为要分配给本地 <code>int</code> 变量的原始值。 <code>QAST::Want</code> 节点看起来像这样：</p>
<pre><code>QAST::Want.new:
  QAST::WVal.new(:value($Int-obj))),
  'Ii',
  QAST::IVal.new: :value(42)
</code></pre><p>上面的 <code>$Int-obj</code> 将包含一个 <a href="https://docs.raku.org/type/Int">Int 类型</a>的实例，其值被设置为 42。<code>Ii</code> 标记指示下面的替代是一个整数值，我们提供一个包含它的 <code>QAST::IVal</code> 对象。其他可能的标记是 <code>Nn</code>（float），<code>Ss</code>（string）和 <code>v</code>（void context）。</p>
<p>当这些节点稍后转换为字节码时，将选择最合适的值，第一个子元素为&quot;默认&quot;值，当没有可用的替代方法进行剪切时，将使用该值。</p>
<h3 id="qastvar">QAST::Var</h3>
<p>这些节点用于变量和参数。 <code>:name</code> 具名参数指定变量的名称, <code>:scope</code> 具名参数指定它的作用域:</p>
<pre><code class="language-raku" data-lang="raku">QAST::Op.new: :op('bind'),
  QAST::Var.new(:name&lt;$x&gt;, :scope&lt;lexical&gt;, :decl&lt;var&gt;, :returns(int)),
  QAST::IVal.new: :value(0)
</code></pre><p>当节点用于变量的声明（当它不存在时，我们简单地引用该变量）时，会出现 <code>:decl</code> 具名参数，它的值决定了变量的类型: <code>var</code> 表示变量，<code>param</code> 表示例程参数。其他几个 <code>:decl</code> 类型，以及指定变量的额外配置的可选参数存在。你可以在 <a href="https://github.com/raku/nqp/blob/master/docs/qast.markdown#qastvar">QAST 文档</a>中找到它们。</p>
<h3 id="qaststmt--qaststmts">QAST::Stmt / QAST::Stmts</h3>
<p>这些是语句分组结构。例如，在这里，<code>nqp::if</code> 的 truthy 分支包含三个 <code>nqp::say</code> 语句，所有这些语句都被分组在 <code>QAST::Stmts</code> 中:</p>
<pre><code class="language-raku" data-lang="raku">QAST::Op.new: :op&lt;if&gt;,
  QAST::IVal.new(:value(42)),
  QAST::Stmts.new(
    QAST::Op.new( :op&lt;say&gt;, QAST::SVal.new: :value&lt;foo&gt;),
    QAST::Op.new( :op&lt;say&gt;, QAST::SVal.new: :value&lt;bar&gt;),
    QAST::Op.new: :op&lt;say&gt;, QAST::SVal.new: :value&lt;ber&gt;),
  QAST::Op.new: :op&lt;say&gt;, QAST::SVal.new: :value&lt;meow&gt;,
</code></pre><p>单数 <code>QAST::Stmt</code> 是相似的。不同的是它标志着一个寄存器的分配界限，超出这个界限，任何临时对象都可以自由地被重用。如果使用正确，则此替代方法可以导致更好的代码生成。</p>
<h3 id="qastblock">QAST::Block</h3>
<p>这个节点既是一个调用单元，也是一个词法作用域单元。例如，代码 <code>sub foo { say &quot;hello&quot; }</code> 可能编译成 <code>QAST::Block</code>, 像这样:</p>
<pre><code class="language-raku" data-lang="raku">Block (:cuid(1)) &lt;wanted&gt; :IN_DECL&lt;sub&gt; { say \&quot;hello\&quot; }
[...]
  Stmts &lt;wanted&gt; say \&quot;hello\&quot;
    Stmt &lt;wanted final&gt; say \&quot;hello\&quot;
      Want &lt;wanted&gt;
        Op (call &amp;say) &lt;wanted&gt; :statement_id&lt;?&gt; say \&quot;hello\&quot;
          Want &lt;wanted&gt; hello
            WVal (Str)
            - Ss
            SVal (hello)
        - v
        Op (p6sink)
          Op (call &amp;say) &lt;wanted&gt; :statement_id&lt;?&gt; say \&quot;hello\&quot;
            Want &lt;wanted&gt; hello
              WVal (Str)
              - Ss
              SVal (hello)
[...]
</code></pre><p>每个块都划分了一个词法作用域边界 - 这个细节在本文的第二部分中有介绍，当我们将要修复一个 bug 的时候。</p>
<h3 id="其它">其它</h3>
<p>还有几个 QAST 节点存在。他们超出了本文的范围，但是您可能希望阅读<a href="https://github.com/raku/nqp/blob/master/docs/qast.markdown">文档</a>，或者由于其中一些文档没有出现在这些文档中，请直接找到<a href="https://github.com/raku/nqp/tree/master/src/QAST">源代码</a>。</p>
<h3 id="执行-qast-树">执行 QAST 树</h3>
<p>在与 QAST 合作时，与nqp操作（以及 <a href="https://github.com/rakudo/rakudo/blob/master/docs/ops.markdown">Rakudo 的 nqp 扩展</a>）相当相似。在QAST转储中，一个敏锐的眼睛会注意到许多 <code>QAST::Op</code> 节点对应于 <code>nqp::*op</code> 调用，其中 <code>:op</code> 命名参数指定操作的名称。</p>
<p>在编写大型 QAST 树时，首先使用纯 NQP 操作将其写下来，然后将结果转换为 QAST 节点对象树。我们来看一个简单的例子：</p>
<pre><code class="language-raku" data-lang="raku">nqp::if(
  nqp::isgt_n(nqp::rand_n(1e0), .5e0),
  nqp::say('Glass half full'),
  nqp::say('Glass half empty'));
</code></pre><p>我们有 NQP op，所以我们从 <code>QAST::Op</code> 节点开始，使用 <code>'if'</code> 作为 <code>:op</code> 的值。该 op 需要三个位置参数 - 三个 ops 用于有条件的，truthy 分支和 falsy 分支。有些操作符也会使用 float 和 string 的值，所以我们将使用 <code>QAST::NVal</code> 和 <code>QAST::SVal</code> 节点。结果是：</p>
<pre><code class="language-raku" data-lang="raku">QAST::Op.new(:op('if'),
  QAST::Op.new(:op('isgt_n'),
    QAST::Op.new(:op('rand_n'),
      QAST::NVal.new(:value(1e0))
    ),
    QAST::NVal.new(:value(.5e0))
  ),
  QAST::Op.new(:op('say'),
    QAST::SVal.new(:value('Glass half full'))
  ),
  QAST::Op.new(:op('say'),
    QAST::SVal.new(:value('Glass half empty'))
  )
)
</code></pre><p>我发现只有在必要时才使用括号来跟踪树的嵌套更容易，只要有可能就更喜欢使用冒号方法调用语法：</p>
<pre><code class="language-raku" data-lang="raku">QAST::Op.new: :op&lt;if&gt;,
  QAST::Op.new(:op&lt;isgt_n&gt;,
    QAST::Op.new(:op&lt;rand_n&gt;,
      QAST::NVal.new: :value(1e0)),
    QAST::NVal.new: :value(.5e0)),
  QAST::Op.new(:op&lt;say&gt;,
    QAST::SVal.new: :value('Glass half full')),
  QAST::Op.new: :op&lt;say&gt;,
    QAST::SVal.new: :value('Glass half empty')
</code></pre><p>如果.new之后是冒号，则同一级别上不会有更多的节点。如果.new之后是开头括号，那么还有更多的姐妹节点还未到来。</p>
<p>由于Rakudo冗长的编译，可以方便地执行你的QAST树，而不必先将它粘贴到src / Raku / Actions.nqp或类似的文件中。在某种程度上，用普通的Raku程序可以做到这一点。我们只需要在BEGIN块内的Perl * :: W变量中存取Raku :: World对象，然后调用.compile_time_evaluate方法，给它一个空变量作为第一个位置（它需要树的Match对象）和我们的QAST树作为第二个位置：</p>
<pre><code class="language-raku" data-lang="raku">use QAST:from&lt;NQP&gt;;
BEGIN $*W.compile_time_evaluate: $,
    QAST::Op.new: :op&lt;if&gt;,
      QAST::Op.new(:op&lt;isgt_n&gt;,
        QAST::Op.new(:op&lt;rand_n&gt;,
          QAST::NVal.new: :value(1e0)),
        QAST::NVal.new: :value(.5e0)),
      QAST::Op.new(:op&lt;say&gt;,
        QAST::SVal.new: :value('Glass half full')),
      QAST::Op.new: :op&lt;say&gt;,
        QAST::SVal.new: :value('Glass half empty')
</code></pre><p>这种方法的一个警告是我们使用成熟的Raku语言，而在src / Raku / Actions.nqp和相关文件中，正如.nqp扩展所示，我们只使用NQP语言。留意怪异的爆炸;有可能你的QAST树会在Raku中爆炸，在纯NQP的领域将会很好的编译。</p>
<h3 id="注解-qast-节点">注解 QAST 节点</h3>
<p>所有QAST节点都支持注释，允许您将任意值附加到节点，然后在别处读取该值。要添加注释，请使用.annotate方法，该方法接受两个位置参数 - 一个包含注释名称和附加值的字符串 - 并返回该值。最近版本的NQP也有.annotate_self方法，除了返回QAST节点本身外，</p>
<pre><code class="language-raku" data-lang="raku">$qast.annotate_self('foo', 42).annotate: 'bar', 'meow';
</code></pre><p>稍后，您可以使用.ann方法读取该值，该方法将注释的名称作为参数。如果注释不存在，则返回NQPMu：</p>
<pre><code class="language-raku" data-lang="raku">note($qast.ann: 'foo'); # OUTPUT: «42␤»
</code></pre><p>您还可以使用返回1（true）或0（false）的.has_ann方法来检查注释是否仅存在：</p>
<pre><code class="language-raku" data-lang="raku">note($qast.has_ann: 'bar'); # OUTPUT: «1␤»
</code></pre><p>或者转储节点上的所有注释（为了防止潜在的输出溢出，大多数值将被作为简单的问号转储）：</p>
<pre><code class="language-raku" data-lang="raku">note($qast.dump_annotations); # OUTPUT: « :bar&lt;?&gt; :foo&lt;?&gt;␤»);
</code></pre><p>最后，要清除节点上的所有注释，只需调用.clear_annotations方法即可。</p>
<h3 id="修改-qast-节点">修改 QAST 节点</h3>
<p>QAST节点对象的一个​​方便的事情是将它们变成更好的东西。这基本上是src / Raku / Optimizer.nqp中的所有静态优化器。命名参数可以通过调用方法和提供值来进行变异。例如，$ qast.op（&lsquo;callstatic&rsquo;）将把op的值从无论什么地方改为callstatic。位置参数可以通过重新分配位置索引来进行更改，也可以通过带有这些名称的方法调用或nqp :: ops进行移位，推送，非移位，弹出操作。有些节点也支持对它们的nqp :: elems调用，它比+ @（$ qast）的通用模式稍微快一些，可以在所有节点上使用它们来查找节点包含的子节点数量。</p>
<p>作为一个练习，让我们写一个小的优化：一些操作，比如$ foo &lt;$ bar &lt;$ ber编译为nqp :: chain操作。即使我们只有两个孩子，也是如此$ foo &lt;$ bar。在这种情况下，将op重写为nqp :: call具有性能优势：不仅nqp :: call比nqp :: chain快一点，静态优化器知道如何进一步优化nqp ::调用ops。</p>
<p>让我们来看看两个孩子和两个孩子的nqp :: chain链是什么样的：</p>
<pre><code class="language-raku" data-lang="raku">$ raku --target=ast -e '2 &lt; 3 &lt; 4; 2 &lt; 3'
</code></pre><p>第一个声明编译到这（我删除QAST ::希望清晰）：</p>
<pre><code class="language-raku" data-lang="raku">- QAST::Op(chain &amp;infix:«&lt;»)  :statement_id&lt;?&gt; &lt;
  - QAST::Op(chain &amp;infix:«&lt;») &lt;wanted&gt; &lt;
    - QAST::IVal(2)
    - QAST::IVal(3)
  - QAST::IVal(4)
</code></pre><p>第二个编译为:</p>
<pre><code class="language-raku" data-lang="raku">- QAST::Op(chain &amp;infix:«&lt;»)  :statement_id&lt;?&gt; &lt;
  - QAST::IVal(2)
  - QAST::IVal(3)
</code></pre><p>因此，要正确定位我们的优化，我们需要确保我们的连锁店的孩子都不是连锁店。另外，我们需要确保我们正在优化的操作本身不是另一个连锁操作系统的孩子。</p>
<p>剔除优化器的代码，我们可以发现链深度已经通过$！chain_depth属性进行了跟踪，所以我们只需要确保我们处于链的第一个链接。代码然后变成：</p>
<pre><code class="language-raku" data-lang="raku">$qast.op: 'call'
  if nqp::istype($qast, QAST::Op)
  &amp;&amp; $qast.op eq 'chain'
  &amp;&amp; $!chain_depth == 1
  &amp;&amp; ! (nqp::istype($qast[0], QAST::Op) &amp;&amp; $qast[0].op eq 'chain')
  &amp;&amp; ! (nqp::istype($qast[1], QAST::Op) &amp;&amp; $qast[1].op eq 'chain');
</code></pre><p>一旦我们找到一个链QAST :: Op，我们将它编入索引并使用nqp :: istype来检查kid节点的类型，如果这些节点碰巧是QAST :: Op节点，我们确保：op参数不是一个链运。如果满足所有的条件，我们只需在节点上调用.op方法，将值“call”转换为一个调用操作。</p>
<p>然后，我们把优化的时间放到优化器的.visit_op方法中，并且稍后的部分将进一步优化我们的调用。</p>
<p>一个相当简单和直接的优化，可以带来很多好处。</p>
<h1 id="part-ii-a-thunk-in-the-trunk">PART II: A Thunk in The Trunk</h1>
<hr>
<p><em>Note: it took me three evenings to debug and fix the following tickets. To learn the solution I tried many dead ends that I won&rsquo;t be covering, to keep you from getting bored, and instead will instantly jump to conclusions. The point I&rsquo;m making is that fixing core bugs is a lot easier than may seem from reading this article—you just need to be willing to spend some time on them.</em></p>
<p><em>注意：我花了三个晚上来调试和修复以下 tickets。为了学习解决方案，我尝试了许多我不会覆盖的死角，以防止你感到厌倦，而是立即跳到结论。我所做的一点是修复核心bug比读这篇文章容易得多 - 你只需要愿意花一些时间在他们身上。</em></p>
<hr>
<p>Now that we have some familiarity with QAST, let&rsquo;s try to fix a
bug that existed in <a href="https://github.com/rakudo/rakudo/tree/a5c2398cc744706eb81b3d73b181cb4233c85a17">Rakudo <code>v2018.01.30.ga.5.c.2398.cc</code></a>
and earlier. The ticket in question is
<a href="https://github.com/rakudo/rakudo/issues/1212">R#1212</a>, that shows
the following problem:</p>
<pre><code>$ raku -e 'say &lt;a b c&gt;[$_ xx 2] with 1'

Use of Nil in string context
  in block  at -e line 1
Unable to call postcircumfix [ (Any) ] with a type object
Indexing requires a defined object
  in block &lt;unit&gt; at -e line 1
</code></pre>
<p>It looks like the <code>$_</code> topical variable inside the indexing brackets fails to get the value from <code>with</code> statement modifier and ends up being undefined. 
Sounds like a challenge!
它看起来像索引括号内的 <code>$_</code> 主题变量无法从 <code>with</code> 语句修饰符中获取值，并且最终未定义。
听起来像是一个挑战！</p>
<h2 id="its-a-hive">It&rsquo;s A Hive!</h2>
<p>Both <code>with</code> and <code>xx</code> operator create thunks (thunks are like blocks of code, without having explicit blocks in the code; this, for example, lets <code>rand xx 10</code> to produce 10 different random values; <code>rand</code> is thunked and the thunk is called for each iteration). This reminded me of some other tickets I&rsquo;ve seen, so I went to <a href="https://fail.rakudo.party/">fail.rakudo.party</a> and looked through open tickets for anything that mentioned thunking or wrong scoping.</p>
<p>``和&rsquo;xx<code>运算符都创建thunks（thunks就像代码块一样，代码中没有明确的代码块;例如，这可以让</code>rand xx 10<code>产生10个不同的随机值;</code>rand`被thunked并且每次迭代调用thunk）。这让我想起了我见过的其他一些门票，所以我去了[fail.rakudo.party]（https://fail.rakudo.party/），并通过开放票查看任何提到thunking或错误范围界定的东西。</p>
<p>I ended up with a list of 7 tickets, and with the help of dogbert++ later increased the number to 9, which with the original Issue gives us a total of 10 different manifestations of a bug. The other tickets are</p>
<p>最后我列出了7张票，在dogbert ++的帮助下，后来增加了9个，与原来的Issue一起给了我们总共10个不同的错误表现。其他门票是</p>
<p><a href="https://rt.perl.org/Ticket/Display.html?id=130575">RT#130575</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=132337">RT#132337</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=131548">RT#131548</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=132211">RT#132211</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=126569">RT#126569</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=128054">RT#128054</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=126413">RT#126413</a>,
<a href="https://rt.perl.org/Ticket/Display.html?id=126984">RT#126984</a>, and
<a href="https://rt.perl.org/Ticket/Display.html?id=132172">RT#132172</a>.
Quite a bug hive!</p>
<h2 id="test-it-out">Test It Out</h2>
<p>Our starting point is to cover each manifestation of the bug with a test.
Make all the test pass and you know you&rsquo;ve fixed the bug, plus you already have something to place into <a href="https://github.com/raku/roast/">roast</a>, to cover the tickets. My tests ended up looking like this, where I&rsquo;ve used <a href="https://docs.raku.org/syntax/gather%20take"><code>gather</code>/<code>take</code></a> duo to capture what the tickets&rsquo; code printed to the screen:
我们的出发点是用一个测试来覆盖每个bug的表现。
让所有的测试通过，你知道你已经修复了错误，再加上你已经有一些东西要放在[烤]（https://github.com/raku/roast/），以涵盖门票。我的测试看起来像这样，我已经使用了[<code>collect</code> /<code>take</code>]（https://docs.raku.org/syntax/gather%20take）二重奏来捕获票据打印到屏幕：</p>
<pre><code>use Test;
plan 1;
subtest 'thunking closure scoping' =&gt; {
    plan 10;

    # https://github.com/rakudo/rakudo/issues/1212
    is-deeply &lt;a b c&gt;[$_ xx 2], &lt;b b&gt;.Seq, 'xx inside `with`' with 1;

    # RT #130575
    is-deeply gather {
        sub itcavuc ($c) { try {take $c} andthen 42 };
        itcavuc $_ for 2, 4, 6;
    }, (2, 4, 6).Seq, 'try with block and andthen';

    # RT #132337
    is-deeply gather {
        sub foo ($str) { { take $str }() orelse Nil }
        foo &quot;cc&quot;; foo &quot;dd&quot;;
    }, &lt;cc dd&gt;.Seq, 'block in a sub with orelse';

    # RT #131548
    is-deeply gather for ^7 {
        my $x = 1;
        1 andthen $x.take andthen $x = 2 andthen $x = 3 andthen $x = 4;
    }, 1 xx 7, 'loop + lexical variable plus chain of andthens';

    # RT #132211
    is-deeply gather for &lt;a b c&gt; { $^v.uc andthen $v.take orelse .say },
        &lt;a b c&gt;.Seq, 'loop + andthen + orelse';

    # RT #126569
    is-deeply gather { (.take xx 10) given 42 }, 42 xx 10,
        'parentheses + xx + given';

    # RT #128054
    is-deeply gather { take (&quot;{$_}&quot;) for &lt;aa bb&gt; }, &lt;aa bb&gt;.Seq,
        'postfix for + take + block in a string';

    # RT #126413
    is-deeply gather { take (* + $_)(32) given 10 }, 42.Seq,
        'given + whatever code closure execution';

    # RT #126984
    is-deeply gather {
        sub foo($x) { (* ~ $x)($_).take given $x }; foo(1); foo(2)
    }, (&quot;11&quot;, &quot;22&quot;).Seq, 'sub + given + whatevercode closure execution';

    # RT #132172
    is-deeply gather { sub {
        my $ver =.lines.uc with &quot;totally-not-there&quot;.IO.open
            orelse &quot;meow {$_ ~~ Failure}&quot;.take and return 42;
    }() }, 'meow True'.Seq, 'sub with `with` + orelse + block interpolation';
}
</code></pre>
<p>When I brought up the first bug in <a href="https://webchat.freenode.net/?channels=#raku-dev">our dev chatroom</a>, jnthn++ pointed out that such bugs are often due to mis-scoped blocks, as <code>p6capturelex</code> op that&rsquo;s involved needs to be called in the immediate outer of the block it references.</p>
<p>Looking through the tickets, I also spotted skids++'s note that changing a conditional for <code>statement_id</code> in <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9195-L9197">block migrator predicate</a> fixed one of the tickets.
This wasn&rsquo;t the full story of the fix, as the many still-failing tests showed, but it was a good start.
当我在[我们的开发聊天室]（https://webchat.freenode.net/?channels=#raku-dev）提出第一个错误时，jnthn ++指出这样的错误通常是由于错误的块，涉及的p6capturelex`需要在它引用的块的外部被调用。</p>
<p>通过查看票据，我还发现滑块++的注意到，在[block migrator predicate]中更改<code>statement_id</code>的条件（https://github.com/rakudo/rakudo/raklob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9195 -L9197）修正了一张门票。
这并不是解决问题的完整故事，因为许多仍然失败的测试显示，但这是一个好的开始。</p>
<h2 id="whats-your-problem">What&rsquo;s Your Problem?</h2>
<p>In order to find the best solution for a bug, it&rsquo;s important to understand what exactly is the problem. We know mis-scoped blocks are the cause of the bug, so lets grab each of our tests, dump their QAST (<code>--target=ast</code>), and write out <em>how</em> mis-scoped the blocks are.</p>
<p>To make it easier to match the <code>QAST::Block</code>s with the <code>QAST::WVal</code>s referencing them, I <a href="https://github.com/raku/nqp/commit/0264b237930f426f4cba744c55f10813869ac40b">made a modification</a> to <code>QAST::Node.dump</code> to include CUID numbers and <code>statement_id</code> annotations in the dumps.</p>
<p>Going through mosts of the buggy code chunks, we have these results:
为了找到一个错误的最佳解决方案，重要的是要明白究竟是什么问题。我们知道错误的块是错误的原因，所以让我们抓住我们的每个测试，转储他们的QAST（<code>--target = ast</code>），并且写出*块的错误范围。</p>
<p>为了使QAST :: Block与QAST :: WVal引用它们更加容易，我[做了修改]（https://github.com/raku/nqp/commit/0264b237930f426f4cba744c55f10813869ac40b） <code>QAST :: Node.dump</code>在转储中包含CUID号码和<code>statement_id</code>注释。</p>
<p>通过大部分的错误代码块，我们有这些结果：</p>
<pre><code>is-deeply &lt;a b c&gt;[$_ xx 2], &lt;b b&gt;.Seq, 'xx inside `with`' with 1;
# QAST for `xx` is ALONGSIDE RHS `andthen` thunk, but needs to be INSIDE

is-deeply gather {
    sub itcavuc ($c) { try {take $c} andthen 42 };
    itcavuc $_ for 2, 4, 6;
}, (2, 4, 6).Seq, 'try with block and andthen';
# QAST for try block is INSIDE RHS `andthen` thunk, but needs to be ALONGSIDE

is-deeply gather {
    sub foo ($str) { { take $str }() orelse Nil }
    foo &quot;cc&quot;; foo &quot;dd&quot;;
}, &lt;cc dd&gt;.Seq, 'block in a sub with orelse';
# QAST for block is INSIDE RHS `andthen` thunk, but needs to be ALONGSIDE

is-deeply gather for ^7 {
    my $x = 1;
    1 andthen $x.take andthen $x = 2 andthen $x = 3 andthen $x = 4;
}, 1 xx 7, 'loop + lexical variable plus chain of andthens';
# each andthen thunk is nested inside the previous one, but all need to be
# ALONGSIDE each other

is-deeply gather for &lt;a b c&gt; { $^v.uc andthen $v.take orelse .say },
    &lt;a b c&gt;.Seq, 'loop + andthen + orelse';
# andthen's block is INSIDE orelse's but needs to be ALONGSIDE each other

is-deeply gather { (.take xx 10) given 42 }, 42 xx 10,
    'parentheses + xx + given';
# .take thunk is ALONGSIDE given's thunk, but needs to be INSIDE of it

is-deeply gather { take (&quot;{$_}&quot;) for &lt;aa bb&gt; }, &lt;aa bb&gt;.Seq,
    'postfix for + take + block in a string';
# the $_ is ALONGSIDE `for`'s thunk, but needs to be INSIDE

is-deeply gather { take (* + $_)(32) given 10 }, 42.Seq,
    'given + whatever code closure execution';
# the WhateverCode ain't got no statement_id and is ALONGSIDE given
# block but needs to be INSIDE of it
</code></pre>
<p>So far, we can see a couple of patterns:
到目前为止，我们可以看到一些模式：</p>
<ul>
<li><a href="https://docs.raku.org/routine/xx"><code>xx</code></a> and
<a href="https://docs.raku.org/type/WhateverCode"><code>WhateverCode</code></a> thunks don&rsquo;t
get migrated, even though they should</li>
<li><a href="https://docs.raku.org/routine/andthen"><code>andthen</code></a> thunks get migrated,
even though they shouldn&rsquo;t</li>
</ul>
<p>The first one is fairly straightforward. Looking at the QAST dump, we see <code>xx</code> thunk has a higher <code>statement_id</code> than the block it was meant to be in.
This is what skids++'s hint addresses, so we&rsquo;ll change <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9196">the <code>statement_id</code> conditional</a> from <code>==</code> to <code>&gt;=</code> to look for statement IDs higher than our current one as well, since those would be from any substatements, such as our <code>xx</code> inside the positional indexing operator:
第一个很简单。查看QAST转储，我们看到<code>xx</code> thunk的&rsquo;statement_id<code>比它原本想要的块要高。 这是什么滑动++的提示地址，所以我们会改变[</code>statement_id<code>条件]（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9196）从== ````=``查找比我们当前的语句ID更高的语句ID，因为这些语句可能来自任何子语句，比如位置索引操作符中的</code>xx`：</p>
<pre><code>($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
</code></pre>
<p>The cause is very similar for the <code>WhateverCode</code> case, as it&rsquo;s missing <code>statement_id</code> annotation altogether, so we&rsquo;ll just annotate the generated <code>QAST::Block</code> with the statement ID. Some basic detective work gives us <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9574">the location where that node is created</a>: we search <code>src/Raku/Actions.nqp</code> for word <code>&quot;whatever&quot;</code> until we spot <code>whatever_curry</code> method and in its guts we find the <code>QAST::Block</code> we want. For the statement ID, we&rsquo;ll grep the source for <code>statement_id</code>:
原因与<code>WhateverCode</code>情况非常相似，因为它完全缺少了<code>statement_id</code>注释，所以我们只用语句ID注释生成的<code>QAST :: Block</code>。一些基本的侦探工作给了我们[创建该节点的位置]（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9574）：我们搜索<code>src / Raku / Actions.nqp</code>用于单词<code>“任何”，直到我们找到</code>whatever_curry<code>方法，并且在它的内核中我们找到我们想要的</code>QAST :: Block`。对于语句ID，我们将grep“statement_id”的源代码：</p>
<pre><code>$ grep -FIRn 'statement_id' src/Raku/
src/Raku/Actions.nqp:1497:            $past.annotate('statement_id', $id);
src/Raku/Actions.nqp:2326:                $_.annotate('statement_id', $*STATEMENT_ID);
src/Raku/Actions.nqp:2488:                -&gt; $b { ($b.ann('statement_id') // -1) == $stmt.ann('statement_id') });
src/Raku/Actions.nqp:9235:                &amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
src/Raku/Actions.nqp:9616:            ).annotate_self: 'statement_id', $*STATEMENT_ID;
src/Raku/World.nqp:256:            $pad.annotate('statement_id', $*STATEMENT_ID);
</code></pre>
<p>From the output, we can see the ID is stored in <code>$*STATEMENT_ID</code> dynamic variable, so we&rsquo;ll use that for our annotation <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9574">on the
<code>WhateverCode</code>'s <code>QAST::Block</code></a>:
从输出中，我们可以看到ID存储在<code>$ * STATEMENT_ID</code>动态变量中，所以我们将使用它作为我们的注释[在
<code>WhateverCode`` QAST :: Block</code>]（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9574）：</p>
<pre><code>my $block := QAST::Block.new(
    QAST::Stmts.new(), $past
).annotate_self: 'statement_id', $*STATEMENT_ID;
</code></pre>
<p>Let&rsquo;s compile and run our bug tests. If you&rsquo;re using <a href="https://github.com/zoffixznet/z">Z-Script</a>, you can re-compile Rakudo by running <code>z</code> command with no arguments:
让我们编译并运行我们的错误测试。如果你正在使用[Z-Script]（https://github.com/zoffixznet/z），你可以通过运行没有参数的“z”命令来重新编译Rakudo：</p>
<pre><code>$ z
[...]
$ ./raku bug-tests.t
1..1
    1..10
    ok 1 - xx inside `with`
    not ok 2 - try with block and andthen
    # Failed test 'try with block and andthen'
    # at bug-tests.t line 10
    # expected: $(2, 4, 6)
    #      got: $(2, 2, 4)
    not ok 3 - block in a sub with orelse
    # Failed test 'block in a sub with orelse'
    # at bug-tests.t line 16
    # expected: $(&quot;cc&quot;, &quot;dd&quot;)
    #      got: $(&quot;cc&quot;, &quot;cc&quot;)
    not ok 4 - loop + lexical variable plus chain of andthens
    # Failed test 'loop + lexical variable plus chain of andthens'
    # at bug-tests.t line 22
    # expected: $(1, 1, 1, 1, 1, 1, 1)
    #      got: $(1, 4, 3, 3, 3, 3, 3)
    not ok 5 - loop + andthen + orelse
    # Failed test 'loop + andthen + orelse'
    # at bug-tests.t line 28
    # expected: $(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
    #      got: $(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;)
    ok 6 - parentheses + xx + given
    ok 7 - postfix for + take + block in a string
    ok 8 - given + whatever code closure execution
    ok 9 - sub + given + whatevercode closure execution
    not ok 10 - sub with `with` + orelse + block interpolation
    # Failed test 'sub with `with` + orelse + block interpolation'
    # at bug-tests.t line 49
    # expected: $(&quot;meow True&quot;,)
    #      got: $(&quot;meow False&quot;,)
    # Looks like you failed 5 tests of 10
not ok 1 - thunking closure scoping
# Failed test 'thunking closure scoping'
# at bug-tests.t line 3
# Looks like you failed 1 test of 1
</code></pre>
<p>Looks like that fixed half of the issues already. That&rsquo;s pretty good!
看起来已经是固定的一半了。这很好！</p>
<h2 id="extra-debugging-额外的调试">Extra Debugging 额外的调试</h2>
<p>Let&rsquo;s now look at the remaining failures and figure out why block migration isn&rsquo;t how we want it in those cases. To assists with our sleuthing efforts,let&rsquo;s make a couple of changes to produce more debugging info.</p>
<p>First, let&rsquo;s modify <a href="https://github.com/raku/nqp/blob/d71bd7334c5c9363d49ddf20645e6041af15fa41/src/QAST/Node.nqp#L166"><code>QAST::Node.dump</code> method in NQP&rsquo;s repo</a> to dump the value of <code>in_stmt_mod</code> annotation, by telling it to dump out the value verbatim if the key is <code>in_stmt_mod</code>:
现在我们来看看其余的失败，并找出为什么在这种情况下块迁移不是我们想要的。为了协助我们的侦察工作，让我们做一些改变来产生更多的调试信息。</p>
<p>首先，我们来修改[NQP的repo中的<code>QAST :: Node.dump</code>方法]（https://github.com/raku/nqp/blob/d71bd7334c5c9363d49ddf20645e6041af15fa41/src/QAST/Node.nqp#L166） <code>in_stmt_mod</code>注释，通过告诉它如果键是<code>in_stmt_mod</code>就逐字转储出来的值：</p>
<pre><code>if $k eq 'IN_DECL' || $k eq 'BY' || $k eq 'statement_id'
|| $k eq 'in_stmt_mod' {
    ...
</code></pre>
<p>Next, let&rsquo;s go to <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L6535-L6560"><code>sub migrate_blocks</code> in <code>Actions.nqp</code></a> and add a bunch of debug dumps inside most of the conditionals.
This will let us track when a block is compared and to see whether migration occurs. As mentioned earlier, I like to key my dumps on env vars using <code>nqp::getenvhash</code> op, so after modifications my <code>migrate_blocks</code> routine looks like this; note the use of <code>.dump</code> method to dump QAST node guts (tip: <code>.dump</code> method also exists on <code>Raku::Grammar</code>'s match objects!):
接下来，我们来到[Actions.nqp<code>中的</code>migrate_blocks<code>]（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L6535-L6560），并添加一堆在大多数条件下调试转储。 这将让我们跟踪块的比较时间，并查看是否发生迁移。正如前面所提到的，我喜欢用</code>nqp :: getenvhash<code>运算符在env vars上输入密码，所以在修改后我的</code>migrate_blocks<code>例程看起来像这样;请注意使用</code>.dump<code>方法来转储QAST节点的内容（提示：</code>.dump`方法也存在于&rsquo;Raku :: Grammar'的匹配对象中！</p>
<pre><code>sub migrate_blocks($from, $to, $predicate?) {
    my @decls := @($from[0]);
    my int $n := nqp::elems(@decls);
    my int $i := 0;
    while $i &lt; $n {
        my $decl := @decls[$i];
        if nqp::istype($decl, QAST::Block) {
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: -----------------');
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: trying to grab ' ~ $decl.dump);
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: to move to ' ~ $to.dump);
            if !$predicate || $predicate($decl) {
                nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: grabbed');
                $to[0].push($decl);
                @decls[$i] := QAST::Op.new( :op('null') );
            }
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: -----------------');
        }
        elsif (nqp::istype($decl, QAST::Stmt) || nqp::istype($decl, QAST::Stmts)) &amp;&amp;
              nqp::istype($decl[0], QAST::Block) {
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: -----------------');
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: trying to grab ' ~ $decl[0].dump);
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: to move to ' ~ $to.dump);
            if !$predicate || $predicate($decl[0]) {
                nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: grabbed');
                $to[0].push($decl[0]);
                $decl[0] := QAST::Op.new( :op('null') );
            }
            nqp::atkey(nqp::getenvhash(),'ZZ') &amp;&amp; nqp::say('ZZ1: -----------------');
        }
        elsif nqp::istype($decl, QAST::Var) &amp;&amp; $predicate &amp;&amp; $predicate($decl) {
            $to[0].push($decl);
            @decls[$i] := QAST::Op.new( :op('null') );
        }
        $i++;
    }
}
</code></pre>
<p>After making the changes, we need to recompile both NQP and Rakudo. With <a href="https://github.com/zoffixznet/z">Z-Script</a>, we can just run <code>z n</code> to do that:
进行更改后，我们需要重新编译NQP和Rakudo。使用[Z-Script]（https://github.com/zoffixznet/z），我们可以运行<code>z n</code>来做到这一点：</p>
<pre><code>$ z n
[...]
</code></pre>
<p>Now, we&rsquo;ll grab the first failing code and take a look at its QAST. I&rsquo;m going to use the <a href="https://modules.raku.org/dist/CoreHackers::Q"><code>CoreHackers::Q</code> tool</a>:
现在，我们将抓住第一个失败的代码，并看看它的QAST。我打算使用[<code>CoreHackers :: Q</code>工具]（https://modules.raku.org/dist/CoreHackers::Q）：</p>
<pre><code>$ q a ./raku -e '
    sub itcavuc ($c) { try {say $c} andthen 42 };
    itcavuc $_ for 2, 4, 6;'
$ firefox out.html
</code></pre>
<p>We can see that our buggy <code>say</code> call lives in <code>QAST::Block</code> with <code>cuid 1</code>, which gets called from within <code>QAST::Block</code> with <code>cuid 3</code>, but is actually located within <code>QAST::Block</code> with <code>cuid 2</code>:
我们可以看到，我们的<code>say</code>调用运行在具有<code>cuid 1</code>的<code>QAST :: Block</code>中，该函数从<code>QAST :: Block</code>内用<code>cuid 3</code>调用，但实际上位于<code>QAST ::块</code>与<code>cuid 2</code>：</p>
<pre><code>- QAST::Block(:cuid(3)) &lt;wanted&gt; :statement_id&lt;1&gt;
        :count&lt;?&gt; :signatured&lt;?&gt; :IN_DECL&lt;sub&gt;
        :in_stmt_mod&lt;0&gt; :code_object&lt;?&gt;
        :outer&lt;?&gt; { try {say $c} andthen 42 }
    [...]
        - QAST::Block(:cuid(2)) &lt;wanted&gt; :statement_id&lt;2&gt;
                :count&lt;?&gt; :in_stmt_mod&lt;0&gt; :code_object&lt;?&gt; :outer&lt;?&gt;
            [...]
            - QAST::Block(:cuid(1)) &lt;wanted&gt; :statement_id&lt;2&gt;
                    :IN_DECL&lt;&gt; :in_stmt_mod&lt;0&gt; :code_object&lt;?&gt;
                    :also_uses&lt;?&gt; :outer&lt;?&gt; {say $c}
                [...]
                - QAST::Op(call &amp;say)  say $c
    [...]
    - QAST::Op(p6typecheckrv)
        [...]
        - QAST::WVal(Block :cuid(1))
</code></pre>
<p>Looks like <code>cuid 2</code> block steals our <code>cuid 1</code> block. Let&rsquo;s enable the debug env var and look at the dumps to see why exactly:
看起来像<code>cuid 2</code>块偷了我们的<code>cuid 1</code>块。让我们启用debug env var并查看转储，看看为什么：</p>
<pre><code>$ ZZ=1 ./raku -e '
    sub itcavuc ($c) { try {say $c} andthen 42 };
    itcavuc $_ for 2, 4, 6;'

ZZ1: -----------------
ZZ1: trying to grab - QAST::Block(:cuid(1)) &lt;wanted&gt;
    :statement_id&lt;2&gt; :IN_DECL&lt;&gt; :in_stmt_mod&lt;0&gt; :code_object&lt;?&gt;
    :also_uses&lt;?&gt; :outer&lt;?&gt; {say $c}
[...]

ZZ1: to move to - QAST::Block  :statement_id&lt;2&gt;
    :in_stmt_mod&lt;0&gt; :outer&lt;?&gt;

ZZ1: grabbed
ZZ1: -----------------
</code></pre>
<p>We can see the theft in progress. Let&rsquo;s take a look at our <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9196">migration predicate</a> again:
我们可以看到正在进行的盗窃。让我们再看看我们的[迁移谓词]（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9196）：</p>
<pre><code>! $b.ann('in_stmt_mod')
&amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
</code></pre>
<p>In the dump we can see <code>in_stmt_mod</code> is false. Were it set to a true value, the block would not be migrated—exactly what we&rsquo;re trying to accomplish.
Let&rsquo;s investigate the <code>in_stmt_mod</code> annotation, to see when it gets set:
在转储中，我们可以看到<code>in_stmt_mod</code>是错误的。如果它被设置为一个真正的价值，块将不会被迁移 - 正是我们想要完成的。
我们来研究<code>in_stmt_mod</code>注释，看看它什么时候被设置：</p>
<pre><code>$ G 'in_stmt_mod' src/Raku/Actions.nqp
2327:                $_.annotate('in_stmt_mod', $*IN_STMT_MOD);
9206:                !$b.ann('in_stmt_mod') &amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id

$ G '$*IN_STMT_MOD' src/Raku/Grammar.nqp
1200:        :my $*IN_STMT_MOD := 0;                    # are we inside a statement modifier?
1328:        :my $*IN_STMT_MOD := 0;
1338:        | &lt;EXPR&gt; :dba('statement end') { $*IN_STMT_MOD := 1 }
</code></pre>
<p>Looks like it&rsquo;s a marker for statement modifier conditions. Statement modifiers have a lot of relevance to our <code>andthen</code> thunks, because <code>$foo with $bar</code> gets turned into <code>$bar andthen $foo</code> during parsing. Since, as we can see in <code>src/Raku/Grammar.nqp</code>, <code>in_stmt_mod</code> annotation gets set for <code>with</code> statement modifiers, we can hypothesize that if we turn our buggy <code>andthen</code> into a <code>with</code>, the bug will disappear:
看起来这是语句修饰符条件的标记。语句修饰符与我们的'和&rsquo;thunk有很多相关性，因为<code>$ foo with $ bar</code>在解析过程中变成<code>$ bar并且$ foo</code>。正如我们在<code>src / Raku / Grammar.nqp</code>中可以看到的，&lsquo;in_stmt_mod<code>注释是为``with语句修饰符'设置的，我们可以假设如果我们把我们的bug和``然后``变成</code>with`，bug会消失：</p>
<pre><code>$ ./raku -e 'sub itcavuc ($c) { 42 with try {say $c} };
    itcavuc $_ for 2, 4, 6;'
2
4
6
</code></pre>
<p>And indeed it does! Then, we have a way forward: we need to set <code>in_stmt_mod</code> annotation to a truthy value for just <em>the first</em> argument of <code>andthen</code>
(and its relatives <code>notandthen</code> and <code>orelse</code>).</p>
<p>Glancing <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Grammar.nqp#L4650-L4651">at the Grammar</a> it doesn&rsquo;t look like it immediatelly offers a similar opportunity for how <code>in_stmt_mod</code> is set for the <code>with</code> statement modifier. Let&rsquo;s approach it differently. Since we care about this when thunks are created, let&rsquo;s watch for <code>andthen</code> QAST <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L7170">inside <code>sub thunkity_thunk</code> in Actions</a>, then descend into its first kid and add the <code>in_stmt_mod</code> annotation by cheating and using the <code>past_block</code> annotation on <code>QAST::WVal</code> with the thunk that contains the reference to <code>QAST::Block</code> we wish to annotate. The code will look something like this:
看着[在语法]（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Grammar.nqp#L4650-L4651）它看起来并不像它立即提供了一个类似的机会， in_stmt_mod<code>设置为</code>with<code>语句修饰符。让我们以不同的方式处理。由于我们在创建thunk的时候关心这个，所以让我们来看看在动作中的</code>subthunkity_thunk<code>内是否有</code>Qt<code>（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp ＃L7170），然后下降到它的第一个孩子，通过欺骗和使用</code>QAST :: WVal<code>上的</code>past_block<code>注释添加</code>in_stmt_mod`注释与包含&rsquo;QAST :: Block'引用的thunk我们希望注释。代码将如下所示：</p>
<pre><code>sub mark_blocks_as_andnotelse_first_arg($ast) {
    if $ast &amp;&amp; nqp::can($ast, 'ann') &amp;&amp; $ast.ann('past_block') {
        $ast.ann('past_block').annotate: 'in_stmt_mod', 1;
    }
    elsif nqp::istype($ast, QAST::Op)
    || nqp::istype($ast, QAST::Stmt)
    || nqp::istype($ast, QAST::Stmts) {
        mark_blocks_as_andnotelse_first_arg($_) for @($ast)
    }
}

sub thunkity_thunk($/,$thunky,$past,@clause) {
    [...]

    my $andnotelse_thunk := nqp::istype($past, QAST::Op)
      &amp;&amp; $past.op eq 'call'
      &amp;&amp; ( $past.name eq '&amp;infix:&lt;andthen&gt;'
        || $past.name eq '&amp;infix:&lt;notandthen&gt;'
        || $past.name eq '&amp;infix:&lt;orelse&gt;');

    while $i &lt; $e {
        my $ast := @clause[$i];
        $ast := $ast.ast if nqp::can($ast,'ast');
        mark_blocks_as_andnotelse_first_arg($ast)
            if $andnotelse_thunk &amp;&amp; $i == 0;
        [...]
</code></pre>
<p>First, we rake <code>$past</code> argument given to <code>thunkity_thunk</code> for a <code>QAST::Op</code> for <code>nqp::call</code> that calls one of our ops—when we found one, we set a variable to a truthy value. Then, in the loop, when we&rsquo;re iterating over the first child node (<code>$i == 0</code>) of these ops, we&rsquo;ll pass its QAST to our newly minted <code>mark_blocks_as_andnotelse_first_arg</code> routine, inside of which we recurse over any ops that can have kids and mark anything that has <code>past_block</code> annotation with truthy <code>in_stmt_mod</code> annotation.</p>
<p>Let&rsquo;s compile our concoction and give the tests another run. Once again, I&rsquo;m using <a href="https://github.com/zoffixznet/z">Z-Script</a> to recompile Rakudo:
首先，我们为&rsquo;nqp :: call<code>调用'thunkity_thunk</code>的<code>$ past</code>参数，调用<code>nqp :: call</code>调用我们的一个操作 - 当我们找到一个操作时，我们设置一个变量为真值。然后，在循环中，当我们遍历这些操作的第一个子节点（<code>$ i == 0）时，我们将把它的QAST传递给我们新建立的</code>mark_blocks_as_andnotelse_first_arg<code>例程，任何可以有孩子的操作，并用truthy</code>in_stmt_mod<code>注释标记任何具有</code>past_block`注解的东西。</p>
<p>让我们编写我们的调和，并再次运行测试。再次，我使用[Z-Script]（https://github.com/zoffixznet/z）重新编译Rakudo：</p>
<pre><code>$ z
[...]
$ ./raku bug-tests.t
1..1
    1..10
    ok 1 - xx inside `with`
    ok 2 - try with block and andthen
    ok 3 - block in a sub with orelse
    not ok 4 - loop + lexical variable plus chain of andthens
    # Failed test 'loop + lexical variable plus chain of andthens'
    # at bug-tests.t line 23
    # expected: $(1, 1, 1, 1, 1, 1, 1)
    #      got: $(1, 4, 3, 3, 3, 3, 3)
    ok 5 - loop + andthen + orelse
    ok 6 - parentheses + xx + given
    ok 7 - postfix for + take + block in a string
    ok 8 - given + whatever code closure execution
    ok 9 - sub + given + whatevercode closure execution
    not ok 10 - sub with `with` + orelse + block interpolation
    # Failed test 'sub with `with` + orelse + block interpolation'
    # at bug-tests.t line 50
    # expected: $(&quot;meow True&quot;,)
    #      got: $(&quot;meow False&quot;,)
    # Looks like you failed 2 tests of 10
not ok 1 - thunking closure scoping
# Failed test 'thunking closure scoping'
# at bug-tests.t line 4
# Looks like you failed 1 test of 1
</code></pre>
<p>We got closer to the goal, with 80% of the tests now passing! In the first remaining failure, we already know from our original examination that chained andthen thunks get nested when they should not—we haven&rsquo;t done anything to fix that yet. Let&rsquo;s take care of that first.
我们接近了目标，80％的测试通过了！在剩下的第一次失败中，我们从原来的检查中已经知道，当他们不应该的时候，我们已经把他们连在一起，然后把他们联系起来 - 我们还没有做任何事情来解决这个问题。先来照顾一下吧</p>
<h2 id="playing-chinese-food-mind-gameshttpswwwyoutubecomwatchvoqwzuisy9y0">Playing <a href="https://www.youtube.com/watch?v=oqwzuiSy9y0">Chinese Food Mind Games</a></h2>
<p>Looking back out at the fixes we applied already, we have a marker for when we&rsquo;re working with <code>andthen</code> or its sister ops: the <code>$andnotelse_thunk</code> variable. It seems fairly straight-forward that if we don&rsquo;t want the thunks of these ops to migrate, we just need to annotate them appropriately and stick the check for that annotation into the migration predicate.</p>
<p>In <code>Grammar.nqp</code>, <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Grammar.nqp#L4007-L4009">we can see our ops are configured</a> with the <code>.b</code> thunky, so we&rsquo;ll locate <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L7218-L7223">that branch</a> in <code>sub thunkity_thunk</code> and pass <code>$andnotelse_thunk</code> variable as a new named param to the <code>make_topic_block_ref</code> block maker:
回想一下我们已经应用的修复，我们有一个标记，当我们正在使用<code>andthen</code>或者它的姐妹操作时：<code>$ andnotelse_thunk</code>变量。看起来很简单，如果我们不希望这些操作符的迁移，我们只需要适当地注释它们，并将该注释的检查插入到迁移谓词中。</p>
<p>在<code>Grammar.nqp</code>中，[我们可以看到我们的操作已经配置]（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Grammar.nqp#L4007-L4009）与<code>.b </code>thunky，所以我们将找到[分支]（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L7218-L7223）在<code>sub thunkity_thunk</code>并通过$ andnotelse_thunk“变量作为”make_topic_block_ref“块制造商的新命名参数：</p>
<pre><code>...
elsif $type eq 'b' {  # thunk and topicalize to a block
    unless $ast.ann('bare_block') || $ast.ann('past_block') {
        $ast := block_closure(make_topic_block_ref(@clause[$i],
          $ast, :$andnotelse_thunk,
          migrate_stmt_id =&gt; $*STATEMENT_ID));
    }
    $past.push($ast);
}
...
</code></pre>
<p><a href="%5D(https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9189-L9198)">The block maker</a> will shove it into the migration predicate, so our block maker code becomes this:
[The block maker]（]（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9189-L9198））会将其推入到迁移谓词中，所以我们的块生成器代码变成这样：</p>
<pre><code> sub make_topic_block_ref(
    $/, $past, :$copy, :$andnotelse_thunk, :$migrate_stmt_id,
 ) {
    my $block := $*W.push_lexpad($/);

    # Add annotation to thunks of our ops:
    $block.annotate: 'andnotelse_thunk', 1 if $andnotelse_thunk;

    $block[0].push
        QAST::Var.new( :name('$_'), :scope('lexical'), :decl('var') );
    $block.push($past);
    $*W.pop_lexpad();
    if nqp::defined($migrate_stmt_id) {
        migrate_blocks($*W.cur_lexpad(), $block, -&gt; $b {
               ! $b.ann('in_stmt_mod')

            # Don't migrate thunks of our ops:
            &amp;&amp; ! $b.ann('andnotelse_thunk')

            &amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
        });
    }
    ...
</code></pre>
<p>One more compilation cycle and test run:
再一个编译周期和测试运行：</p>
<pre><code>$ z
[...]
$ ./raku bug-tests.t
1..1
    1..10
    ok 1 - xx inside `with`
    ok 2 - try with block and andthen
    ok 3 - block in a sub with orelse
    ok 4 - loop + lexical variable plus chain of andthens
    ok 5 - loop + andthen + orelse
    ok 6 - parentheses + xx + given
    ok 7 - postfix for + take + block in a string
    ok 8 - given + whatever code closure execution
    ok 9 - sub + given + whatevercode closure execution
    not ok 10 - sub with `with` + orelse + block interpolation
    # Failed test 'sub with `with` + orelse + block interpolation'
    # at bug-tests.t line 50
    # expected: $(&quot;meow True&quot;,)
    #      got: $(&quot;meow False&quot;,)
    # Looks like you failed 1 test of 10
not ok 1 - thunking closure scoping
# Failed test 'thunking closure scoping'
# at bug-tests.t line 4
# Looks like you failed 1 test of 1
</code></pre>
<p>So close! Just a single test failure remains. Let&rsquo;s give it a close look.
很近！只剩下一个测试失败。让我们仔细看看。</p>
<h2 id="within-and-without">Within and Without</h2>
<p>Let&rsquo;s repeat our procedure of dumping QASTs as well as enabing the <code>ZZ</code> env var and looking at what&rsquo;s causing the thunk mis-migration. I&rsquo;m going to run a slightly simplified version of the failing test, to keep the cruft out of QAST dumps. If you&rsquo;re following along, when looking at full QAST dump keep in mind what I mentioned earlier: <code>with</code> gets rewritten into <code>andthen</code> op call during parsing.
让我们重复我们的倾销QASTs的程序，并调用<code>ZZ</code> env var并查看导致thunk错误迁移的原因。我将运行一个稍微简化的失败测试版本，以防止QAST转储。如果你一直在跟踪，当看完整的QAST转储记住我刚才提到的：在分析过程中，<code>with</code>会被重写成<code>然后</code>调用。</p>
<pre><code>$ q a ./raku -e '.uc with +&quot;a&quot; orelse &quot;meow {$_ ~~ Failure}&quot;.say and 42'
$ firefox out.html

- QAST::Block(:cuid(4)) :in_stmt_mod&lt;0&gt;
    [...]
    - QAST::Block(:cuid(1))  :statement_id&lt;1&gt; :in_stmt_mod&lt;1&gt;
      [...]
      - QAST::Op(chain &amp;infix:&lt;~~&gt;) &lt;wanted&gt; :statement_id&lt;2&gt; ~~
        - QAST::Var(lexical $_) &lt;wanted&gt; $_
        - QAST::WVal(Failure) &lt;wanted&gt; Failure
    - QAST::Block(:cuid(2)) :statement_id&lt;1&gt;
        :in_stmt_mod&lt;1&gt; :andnotelse_thunk&lt;1&gt;
      [...]
      - QAST::Op(callmethod Stringy) &lt;wanted&gt;
        - QAST::Op(call) &lt;wanted&gt; {$_ ~~ Failure}
          - QAST::Op(p6capturelex) &lt;wanted&gt; :code_object&lt;?&gt;
            - QAST::Op(callmethod clone)
              - QAST::WVal(Block)

$ ZZ=1 ./raku -e '.uc with +&quot;a&quot; orelse &quot;meow {$_ ~~ Failure}&quot;.say and 42'
[...]
ZZ1: -----------------
ZZ1: trying to grab - QAST::Block(:cuid(1))
  :statement_id&lt;1&gt; :in_stmt_mod&lt;1&gt;
  [...]
ZZ1: to move to - QAST::Block
  :statement_id&lt;1&gt; :andnotelse_thunk&lt;1&gt; :in_stmt_mod&lt;1&gt;
  [...]
ZZ1: -----------------
</code></pre>
<p>Although <code>QAST::WVal</code> lacks <code>.past_block</code> annotation and so doesn&rsquo;t show the block&rsquo;s CUID in the dump, just by reading the code dumped around that QAST, we can see that the CUID-less block is our <code>QAST::Block :cuid(1)</code>, whose immediate outer is <code>QAST::Block :cuid(4)</code>, yet it&rsquo;s called from within <code>QAST::Block :cuid(2)</code>. It&rsquo;s supposed to get migrated, but that migration never happens, as we can see when we use the <code>ZZ</code> env var to enable our debug dumps in the <code>sub migrate_blocks</code>.</p>
<p>We can see why. Here&rsquo;s our current migration predicate (where <code>$b</code> is the examined block, which in our case is <code>QAST::Block :cuid(1)</code>):
虽然<code>QAST :: WVal</code>缺少<code>.past_block</code>注释，所以在转储中不显示块的CUID，只要读取QAST周围的代码，就可以看到CUID-less块是我们的<code>QAST： ：block：cuid（1）</code>，它的直接外部是<code>QAST :: Block：cuid（4）</code>，但是它在&rsquo;QAST :: Block：cuid（2）<code>中被调用。它应该被迁移，但是迁移从来没有发生过，就像我们使用'ZZ</code> env var&rsquo;sub migrate_blocks`启用调试转储时可以看到的那样。</p>
<p>我们可以看到为什么。这里是我们当前的迁移谓词（其中<code>$ b</code>是被检查的块，在我们的例子中是<code>QAST :: Block：cuid（1）</code>）：</p>
<pre><code>   ! $b.ann('in_stmt_mod')
&amp;&amp; ! $b.ann('andnotelse_thunk')
&amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
</code></pre>
<p>The very first condition prevents our migration, as our block has truthy <code>in_stmt_mod</code> annotation, because it&rsquo;s part of the <code>with</code>'s condition.
At the same time, it <em>does</em> need to be migrated because it&rsquo;s part of the <code>andthen</code> thunk that&rsquo;s inside the statement modifier!</p>
<p>Since we already have <code>$andnotelse_thunk</code> variable in the vicinity of the migration predicate we can use it to tell us whether we&rsquo;re migrating for the benefit of our <code>andthen</code> thunk and not the statement modifier. However, recall that we&rsquo;ve used the very same <code>in_stmt_mod</code> annotation to mark the first argument of <code>andthen</code> and its brother ops. We need to alter that first.</p>
<p>And so, the <code>sub mark_blocks_as_andnotelse_first_arg</code> we added earlier becomes:
第一个条件阻止了我们的迁移，因为我们的块有<code>in_stmt_mod</code>注释，因为它是&rsquo;with<code>条件的一部分。 同时，它*需要被迁移，因为它是语句修饰符中</code>和然`thunk的一部分！</p>
<p>由于我们已经在迁移谓词附近有<code>$ andnotelse_thunk</code>变量，所以我们可以用它来告诉我们是否为了我们的&rsquo;andthen&rsquo;thunk而不是语句修饰符的迁移。不过请记住，我们已经使用了相同的<code>in_stmt_mod</code>注释来标记<code>andthen</code>和它的兄弟操作符的第一个参数。我们需要先改变它。</p>
<p>因此，我们之前添加的<code>sub mark_blocks_as_andnotelse_first_arg</code>变成：</p>
<pre><code>sub mark_blocks_as_andnotelse_first_arg($ast) {
    if $ast &amp;&amp; nqp::can($ast, 'ann') &amp;&amp; $ast.ann('past_block') {
        $ast.ann('past_block').annotate: 'in_stmt_mod_andnotelse', 1;
    }
    ...
</code></pre>
<p>And then we tweak the <a href="https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9195-L9197">migration predicate</a> to watch for this altered annotation and to consider the value of <code>$andnotelse_thunk</code> variable:
然后我们调整[迁移谓词]（https://github.com/rakudo/rakudo/blob/a5c2398cc744706eb81b3d73b181cb4233c85a17/src/Raku/Actions.nqp#L9195-L9197）观察这个改变的注释，并考虑<code>$ andnotelse_thunk</code>变量：</p>
<pre><code>migrate_blocks($*W.cur_lexpad(), $block, -&gt; $b {
    (    (! $b.ann('in_stmt_mod_andnotelse') &amp;&amp;   $andnotelse_thunk)
      || (! $b.ann('in_stmt_mod')            &amp;&amp; ! $andnotelse_thunk)
    )
    &amp;&amp; ($b.ann('statement_id') // -1) &gt;= $migrate_stmt_id
    &amp;&amp; ! $b.has_ann('andnotelse_thunk')
});
</code></pre>
<p>Thus, we migrate all the blocks with <code>statement_id</code> equal to or higher than ours and are all of the following:
因此，我们迁移所有与<code>statement_id</code>等于或高于我们的块，并且都是以下内容：</p>
<ul>
<li><em>Not</em> thunks of actual <code>andthen</code>, <code>notandthen</code>, or <code>orelse</code></li>
<li><em>Not</em> thunks inside a statement modifier, unless they&rsquo;re inside thunks of <code>andthen</code> or related ops</li>
<li>If we&rsquo;re considering migrating them inside one of the <code>andthen</code>'s thunks, then also <em>not</em> part of the first argument to <code>andthen</code> (or related ops),.</li>
</ul>
<p>That&rsquo;s a fancy-pants predicate. Let&rsquo;s compile and see if it gets the job done:</p>
<ul>
<li><em>不是</em>实际的“和”，“不和然”或“orelse”的thunk</li>
<li><em>不是</em>在声明修饰符中的thunks，除非它们在<code>andthen</code>或相关操作符的内部
<em>如果我们正在考虑将它们迁移到<code>和</code>的其中一个thunk中，那么也可以</em> not *作为<code>andthen</code>（或相关操作）的第一个参数的一部分。</li>
</ul>
<p>这是一个花哨的谓词。让我们编译一下，看看它是否完成了工作：</p>
<pre><code>$ z
[...]
$ ./raku bug-tests.t
  1..1
    1..10
    ok 1 - xx inside `with`
    ok 2 - try with block and andthen
    ok 3 - block in a sub with orelse
    ok 4 - loop + lexical variable plus chain of andthens
    ok 5 - loop + andthen + orelse
    ok 6 - parentheses + xx + given
    ok 7 - postfix for + take + block in a string
    ok 8 - given + whatever code closure execution
    ok 9 - sub + given + whatevercode closure execution
    ok 10 - sub with `with` + orelse + block interpolation
ok 1 - thunking closure scoping
</code></pre>
<p>Success! Now, let&rsquo;s remove all of the debug statements we added. Then, recompile and run <code>make stresstest</code>, to ensure we did not break anything else.
With <a href="https://github.com/zoffixznet/z">Z-Script</a>, we can do all that by just running <code>z ss</code>:
成功！现在，让我们删除所有我们添加的调试语句。然后，重新编译并运行<code>make stresstest</code>，确保我们没有破坏别的东西。
使用[Z-Script]（https://github.com/zoffixznet/z），我们可以通过运行<code>z ss</code>来完成所有的工作：</p>
<pre><code>$ z ss
[...]
All tests successful.
Files=1287, Tests=153127, 159 wallclock secs (21.40 usr  3.27 sys + 3418.56 cusr 179.32 csys = 3622.55 CPU)
Result: PASS
</code></pre>
<p>All is green. We can now <a href="https://github.com/rakudo/rakudo/commit/1ee89b54074e80c0753a120d679c6265bd8d5d1f">commit</a>
our fix to <a href="https://github.com/rakudo/rakudo/">Rakudo&rsquo;s repo</a>, then <a href="https://github.com/raku/roast/commit/2f2998733a2d8132ce29a16008cc5b3a50d6567f">commit</a> our tests to the <a href="https://github.com/raku/roast">roast repo</a>, and all that remains is closing those 10 tickets we fixed!</p>
<p>Job well done.
一切都是绿色的。我们现在可以[提交]（https://github.com/rakudo/rakudo/commit/1ee89b54074e80c0753a120d679c6265bd8d5d1f）
我们修复了[Rakudo的回购]（https://github.com/rakudo/rakudo/），然后[提交]（https://github.com/raku/roast/commit/2f2998733a2d8132ce29a16008cc5b3a50d6567f）我们的测试到[roast回购]（https://github.com/raku/roast），剩下的就是关闭我们修复的10张门票！</p>
<p>做得好。</p>
<h1 id="conclusion">Conclusion</h1>
<p>Today, we learned quite a bit about QAST: the Abstract Syntax Trees Raku code compiles to in the Rakudo compiler. We examined the common types of QAST and how to create, annotate, mutate, execute, and dump them for examination.</p>
<p>In the second part of the article, we applied our new knowledge to fix a hive of mis-scoped thunking bugs that plagued various Raku constructs.
We introspected the generated QAST nodes to specially annotate them, and then used those annotations to reconfigure migration predicate, so that it migrates the blocks correctly.</p>
<p>Hopefully, this knowledge inspires you to fix the many other bugs we <a href="https://fail.rakudo.party/">have on the RT tracker</a> as well as <a href="https://github.com/rakudo/rakudo/issues">our GitHub Issue tracker</a></p>
<p>今天，我们了解了QAST：抽象语法树Raku代码编译到Rakudo编译器中。我们研究了QAST的常见类型，以及如何创建，注释，变异，执行和转储它们以供检查。</p>
<p>在本文的第二部分，我们应用了我们的新知识来修复困扰各种Raku结构的错误的thunking bug。
我们内置了生成的QAST节点来专门注释它们，然后使用这些注释来重新配置迁移谓词，以便正确地迁移块。</p>
<p>希望这个知识能够激发你去修复我们在RT追踪器（https://fail.rakudo.party/）和我们的GitHub问题追踪器（https://github.com/） rakudo / rakudo /问题）</p>


        
          <div class="blog-tags">
            
              <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
            
          </div>
        

        

        
          
            
          

          
                  <h4 class="see-also"></h4>
                  <ul>
                
                
                    <li><a href="/post/2020-06-30-sequence/">数列</a></li>
                
                    <li><a href="/post/2019-07-31-parse-with-raku-regexes-and-grammars/">Parse with Raku Regexes and Grammars</a></li>
                
                    <li><a href="/post/2019-07-16-encode-decode/">Encode-Decode</a></li>
                
                    <li><a href="/post/2019-06-29-odd-even-sort-in-raku/">Raku 中的 奇偶排序</a></li>
                
                    <li><a href="/post/2019-06-27-pancake-sort-in-raku/">Raku 中的煎饼排序</a></li>
                
              </ul>

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://ohmysummer.github.io/post/2018-01-28-perl-6-logo/" data-toggle="tooltip" data-placement="top" title="Raku logo">&larr; </a>
            </li>
          
          
            <li class="next">
              <a href="https://ohmysummer.github.io/post/2018-01-29-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/" data-toggle="tooltip" data-placement="top" title="Raku Rakudo 和 NQP 内部研讨(二)"> &rarr;</a>
            </li>
          
        </ul>
      


      
        
          
          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ohmysummer" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
          
        
        
      

    </div>
  </div>
</div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            <a href="" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://ohmysummer.github.io/">焉知非鱼</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2020
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://ohmysummer.github.io/">Raku Programming</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://ohmysummer.github.io/js/main.js"></script>
<script src="https://ohmysummer.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://ohmysummer.github.io/js/load-photoswipe.js"></script>



<script>
  (function() {
    var cx = '009072066163920799339:qwme9vkotxk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>







    
  </body>
</html>

