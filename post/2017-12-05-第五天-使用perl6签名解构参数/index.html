<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="ohmysummer">
    <meta name="description" content="ohmysummer&#39;s personal website">
    <meta name="keywords" content="Perl6,Rakudo">

    <base href="http://ohmysummer.github.io/">
    <title>
  第五天 - 使用 Perl 6 签名解构参数 · 焉知非鱼
</title>

    <link rel="canonical" href="http://ohmysummer.github.io/post/2017-12-05-%E7%AC%AC%E4%BA%94%E5%A4%A9-%E4%BD%BF%E7%94%A8perl6%E7%AD%BE%E5%90%8D%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.cd087ace86754b082dec94545567f8361cba42e84f8e15edbc4a9f6e52bd1f6a.css" integrity="sha256-zQh6zoZ1Swgt7JRUVWf4Nhy6QuhPjhXtvEqfblK9H2o=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://ohmysummer.github.io/css/style.css">
    

    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://ohmysummer.github.io/">
      焉知非鱼
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/post">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/categories">归档</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/page/about/">关于</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/tags">标签</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>第五天 - 使用 Perl 6 签名解构参数</h1>
    </header>

    

<h1 id="第五天-使用-perl-6-签名解构参数">第五天 - 使用 Perl 6 签名解构参数</h1>

<p>在许多其他关键的 Perl 6 特性中，我认为 <a href="https://docs.perl6.org/type/Signature">Signatures</a> 是众多&rdquo;杀手级&rdquo;特性之一。 它们的功能如此丰富而强大，我怀疑关于如何使用它们可以写一整本书。 我想探索一下我原来忽略但是非常珍惜的一些特定功能。</p>

<p>您可能已经看到了基本的子程序签名：</p>

<pre><code class="language-perl">sub myfunc($x, $y, $z) {...}
</code></pre>

<p>它给函数声明了 3 个标量参数, 并在函数体里面给了它们 <strong>$x</strong>, <strong>$y</strong>, <strong>$z</strong> 的名字。</p>

<p>太简单了。</p>

<p>你可以更有爱心, 给它们加上指定的类型:</p>

<pre><code class="language-perl">sub myfunc(Str $x, Int $y, Rat $z) {...}
</code></pre>

<p>你可以使用笑脸符号 <code>:D</code> 让参数值是有定义的:</p>

<pre><code class="language-perl">sub myfunc(Str:D $x, Int:D $y, Rat:D $z) {...}
</code></pre>

<p>还有很多其它花哨的说明符你可以使用，在这里我不深入了。</p>

<p>但是如果你的参数更复杂呢？ （不是 <a href="https://docs.perl6.org/type/Complex">Complex</a> - 虽然它也起作用..）</p>

<p>For example, you might want to restrict a specific parameter to a Positional argument like an Array, or an Associative one like a Hash using the respective sigils, @ or %.
例如，你可能想要将特定的参数限制为像 Array 这样的 Positional 参数，或者使用相应的 @ 或 ％ 符号将这个参数限制为像 Hash 这样的关联参数。</p>

<pre><code class="language-perl">sub myfunc(%h) {...}
</code></pre>

<p>现在我可以使用一个散列来调用该函数:</p>

<pre><code class="language-perl">myfunc(%( a =&gt; 1, b =&gt; 'this', c =&gt; 2.2));
</code></pre>

<p>如果我想验证那些特定的字段是否存在，我可以把代码放在函数的顶部来做到这一点：</p>

<pre><code class="language-perl">sub myfunc(%h) {
    die &quot;a must be an Int&quot; unless %h&lt;a&gt; ~~ Int;
    die &quot;b must be a Str&quot;  unless %h&lt;b&gt; ~~ Str;
    die &quot;c must be a Rat&quot;  unless %h&lt;c&gt; ~~ Rat;
}
</code></pre>

<p>如果我还想简化引用那些字段的方式，我可以将它们赋值给其他变量：</p>

<pre><code class="language-perl">sub myfunc(%h) {
    die &quot;a must be an Int&quot; unless %h&lt;a&gt; ~~ Int;
    die &quot;b must be a Str&quot;  unless %h&lt;b&gt; ~~ Str;
    die &quot;c must be a Rat&quot;  unless %h&lt;c&gt; ~~ Rat;

    my $a = %h&lt;a&gt;;
    my $b = %h&lt;b&gt;;
    my $c = %h&lt;c&gt;;
}
</code></pre>

<p>有点无聊，对吗？</p>

<p>Perl 签名参数解构来拯救你了！ 我们可以在子例程签名自身中做所有的事情 - 只要放一个子签名(sub-signature)在后面即可。</p>

<pre><code class="language-perl">sub myfunc(%h (Int :$a, Str :$b, Rat :$c)) {...}
</code></pre>

<h2 id="解构-json">解构 JSON</h2>

<p>相当不错，但如果你有<strong>更</strong>复杂的东西呢？</p>

<p>假如说一块儿有嵌套结构的 JSON，某些部分可能缺失了, 它们需要默认值, 等等。</p>

<pre><code class="language-perl">use JSON::Fast;
my $item = from-json(q:to/END/);
    {
        &quot;book&quot; : {
            &quot;title&quot;  : &quot;A Christmas Carol&quot;,
            &quot;author&quot; : &quot;Charles Dickens&quot;
        },
        &quot;count&quot; : 12,
        &quot;tags&quot; : [ &quot;christmas&quot;, &quot;santa&quot;]
    }
    END
</code></pre>

<p><code>q:to/END/</code> 是一个 Perl 6 <a href="https://docs.perl6.org/language/quoting#index-entry-quote_heredocs_%3Ato-Heredocs%3A_%3Ato">heredoc</a>，它直接在文本中直到 END，然后我们可以使用 <a href="https://github.com/timo/json_fast">JSON::Fast</a> 的 <code>from-json()</code> 将其解析为 perl 中的数据结构。 你可以在函数签名中描述整个 JSON 结构，以便接收以下内容：</p>

<pre><code class="language-perl">sub myfunc(% (:%book (Str:D :$title, Str:D :$author), Int :$count,
              :@tags ($first-tag, *@other-tags)) )
{...}
</code></pre>

<p>现在，在函数体中，我可以将这些部分引用为 <code>$title</code>，<code>$author</code>，<code>$count</code>和 <code>@tags</code>。 为了方便起见，我还将标签分成了 <code>$first-tag</code> 和 <code>@other-tags</code>。</p>

<h2 id="在块儿中使用签名">在块儿中使用签名</h2>

<p>当然，签名对于子程序来说是幻想的，但是你也可以在块儿(Block)中使用签名和解构。 假设你有一个上面的 JSON 条目的数组，并希望通过一个 <code>for</code> 循环遍历它们？ 只需在 <code>for</code> 的尖号块中使用解构签名即可：</p>

<pre><code class="language-perl">for @itemlist -&gt; % (:%book (Str:D :$title, Str:D :$author), Int :$count,
                    :@tags ($first-tag, *@other-tags))
{
    say &quot;$title, $author, $count, @tags[], $first-tag, @other-tags[]&quot;
}
</code></pre>

<p>注意在这种情况下，我甚至不需要散列本身，所以我省略了散列的名称，仅使用 <code>％</code> 作为匿名散列（关联）。</p>

<h2 id="你甚至可以解构对象">你甚至可以解构对象!</h2>

<p>你有没有试过遍历一组对象，你所做的第一件事是调用一些访问器来获取一些属性？ 当然，你可以使用 <code>.attribute</code> 和 主题化的迭代器，但是使用子签名，你可以做更多。</p>

<pre><code class="language-perl">class Book {
    has $.title;
    has $.author;
    has $.count;
    has @.tags;
}

my @booklist =
    Book.new(title =&gt; 'A Christmas Carol',
             author =&gt; 'Charles Dickens',
             count =&gt; 12,
             tags =&gt; &lt;ghost christmas&gt;),

    Book.new(title =&gt; 'A Visit from St. Nicholas',
             author =&gt; 'Clement Clarke Moore',
             count =&gt; 4,
             tags =&gt; &lt;santa christmas&gt;);

for @booklist -&gt; Book $b (:$title,:$author, :$count, :@tags) {
    say &quot;$title, $author, $count, @tags[]&quot;;
}
</code></pre>

<p>如果您想检查类型或定义，或设置默认值，您都可以在签名中正确地执行。 如果您不喜欢对象属性的名称，则可以使用别名来重命名它们, 你开心就行。</p>

<h2 id="结论">结论</h2>

<p>我发现解构参数在与数据库查询结果和 JSON 交互中非常有用。 您可以使用任何其他签名特性，包括指定类型，定义，可选性，默认值，使用别名重命名，使用子集约束或“where”从句，slurpies等。</p>

<p>节日快乐！</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>ohmysummer ❤ Perl 6</p>
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
