<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="ohmysummer">
    <meta name="description" content="ohmysummer&#39;s personal website">
    <meta name="keywords" content="Perl6,Rakudo">

    <base href="http://ohmysummer.github.io/">
    <title>
  第八天 — 让你的 Perl 6 grammar 紧凑一点 · 焉知非鱼
</title>

    <link rel="canonical" href="http://ohmysummer.github.io/post/2018-12-08-make-your-perl6-grammar-compact/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.cd087ace86754b082dec94545567f8361cba42e84f8e15edbc4a9f6e52bd1f6a.css" integrity="sha256-zQh6zoZ1Swgt7JRUVWf4Nhy6QuhPjhXtvEqfblK9H2o=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://ohmysummer.github.io/css/style.css">
    

    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://ohmysummer.github.io/">
      焉知非鱼
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/post">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/categories">归档</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/page/about/">关于</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/tags">标签</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>第八天 — 让你的 Perl 6 grammar 紧凑一点</h1>
    </header>

    

<p>欢迎来到今年的 Perl 6 Advent Calendar 的第8天！</p>

<p>Grammars 是使 Perl 6 成为一种优秀编程语言的众多因素之一。 我甚至不会尝试预测轮询的结果，以便在 grammars，Unicode 支持，并发功能，超运算符或集合语法之间进行选择，或者选择 Whatever star。 谷歌发现了自己在互联网上发布的最好的 Perl 6 功能列表。</p>

<p><img src="https://perl6advent.files.wordpress.com/2018/12/screen-shot-2018-12-01-at-13-15-01.png" alt="img" /></p>

<p>无论如何，今天我们将讨论 Perl 6 grammars，我将分享一些技巧，用于使 grammars 更紧凑。</p>

<h2 id="1-拆分-actions">1.拆分 actions</h2>

<p>假设您正在编写 grammar 来解析 Perl 的变量声明。 您希望它与以下语句匹配：</p>

<pre><code class="language-perl6">my $s; my @a;
</code></pre>

<p>它们都声明了一个变量，因此我们可以制定一个通用规则来解析这两种情况。 下面是完整的程序：</p>

<pre><code class="language-perl6">grammar G {
    rule TOP {
        &lt;variable-declaration&gt;* %% ';'
    }

    rule variable-declaration {
        | &lt;scalar-declaration&gt;
        | &lt;array-declaration&gt;
    }

    rule scalar-declaration {
        'my' '$' &lt;variable-name&gt;
    }

    rule array-declaration {
        'my' '@' &lt;variable-name&gt;
    }

    token variable-name {
        \w+
    }
}

class A {
    has %!var;

    method TOP($/) {
        dd %!var;
    }

    method variable-declaration($/) {
        if $&lt;scalar-declaration&gt; {
            %!var{$&lt;scalar-declaration&gt;&lt;variable-name&gt;} = 0;
        }
        elsif $&lt;array-declaration&gt; {
            %!var{$&lt;array-declaration&gt;&lt;variable-name&gt;} = [];
        }
    }
}

G.parse('my $s; my @a;', :actions(A.new));
</code></pre>

<p>我不解释这个程序的每一点; 如果您有兴趣，可以在最近的 <a href="http://perl.nl/amsterdam">Amsterdam.pm</a> 会议上观看<a href="https://www.youtube.com/watch?v=YWTmd4Hdfa4">80分钟的视频</a>。</p>

<p>现在感兴趣的对象是规则 <code>variable-declaration</code> 及其相应的 action。</p>

<p>该规则包含两个选项：是否声明了标量或数组。 该 action 还在选项之间进行选择，并使用 <code>if-else</code> 块执行该 action 操作。 Perl 6 允许你省略布尔条件周围的括号，但是，整个结构仍然很大。 例如，想想如果添加哈希声明，则需要添加另一个 <code>elsif</code> 分支。</p>

<p>为每个子分支分别采取 action 操作会更清楚：</p>

<pre><code class="language-perl6">method scalar-declaration($/) {
    %!var{$&lt;variable-name&gt;} = 0;
}

method array-declaration($/) {
    %!var{$&lt;variable-name&gt;} = [];
}
</code></pre>

<p>现在，每个方法的主体包含单行代码，你可以立即看到它正在做什么。 更不用说它变得不那么容易出错了。</p>

<p>在我们继续讨论下一个技巧之前，你可能需要实现另一个优化：<code>my</code> 关键字出现在任一声明中，因此请使用非捕获括号并将公用字符串从它们之中移出：</p>

<pre><code class="language-perl6">rule variable-declaration {
    'my' [
        | &lt;scalar-declaration&gt;
        | &lt;array-declaration&gt;
    ]
}

rule scalar-declaration {
    '$' &lt;variable-name&gt;
}

rule array-declaration {
    '@' &lt;variable-name&gt;
}
</code></pre>

<h2 id="使用-multi-方法">使用 multi 方法</h2>

<p>让我们改进 grammar 以允许使用目标语言进行赋值：</p>

<pre><code class="language-perl6">my $s; my @a; $s = 3; $a[1] = 4;
</code></pre>

<p>请注意，赋值是以 Perl 5 样式完成的，数组元素为 sigil。 有了这个，可以使用以美元开头的单个规则来完成赋值：</p>

<pre><code class="language-perl6">grammar G {
    rule TOP {
        [
            | &lt;variable-declaration&gt;
            | &lt;assignment&gt;
        ]
        * %% ';'
    }

    # . . .

    rule assignment {
        '$' &lt;variable-name&gt; &lt;index&gt;? '=' &lt;value&gt;
    }

    rule index {
        '[' &lt;value&gt; ']'
    }

    token value {
        \d+
    }
}
</code></pre>

<p>因此，<code>assignment</code> action 操作必须推断出它目前正在处理的赋值类型。</p>

<p>同样，您可以使用我们的老朋友，action 操作中的 <code>if-else</code> 块。 根据索引的存在，您可以确定这是一个简单的标量还是数组的元素：</p>

<pre><code class="language-perl6">method assignment($/) {
    if $&lt;index&gt; {
        %!var{$&lt;variable-name&gt;}[$&lt;index&gt;&lt;value&gt;] = +$&lt;value&gt;;
    }
    else {
        %!var{$&lt;variable-name&gt;} = +$&lt;value&gt;;
    }
}
</code></pre>

<p>此代码也可以轻松简化，但这次使用 multi 方法：</p>

<pre><code class="language-perl6">multi method assignment($/ where !$&lt;index&gt;) {
    %!var{$&lt;variable-name&gt;} = +$&lt;value&gt;;
}

multi method assignment($/ where $&lt;index&gt;) {
    %!var{$&lt;variable-name&gt;}[$&lt;index&gt;&lt;value&gt;] = +$&lt;value&gt;;
}
</code></pre>

<p><code>where</code> 子句允许 Perl 6 决定哪个候选方法在给定情况下更适合。</p>

<p>另请注意在第二个 multi 方法中如何使用 <code>&lt;value&gt;</code> 键两次。 <code>&lt;value&gt;</code> 的每个条目指的是目标代码的不同部分：一个用于索引值，另一个用于右侧值。</p>

<h2 id="3-让-perl-完成这项工作">3. 让 Perl 完成这项工作</h2>

<p>有时，Perl 可以为我们完成工作，特别是如果你想实现 Perl 熟悉的东西。 例如，让我们在赋值中允许不同类型的数字：</p>

<pre><code class="language-perl6">my $a; my $b; $a = 3; $b = -3.14;
</code></pre>

<p>在 grammar 中引入浮点数比较容易：</p>

<pre><code class="language-perl6">token value {
    | '-'? \d+
    | '-'? \d+ '.' \d+
}
</code></pre>

<p>您想添加其他类型的数字，请参阅 <a href="https://www.perl.com/article/perl-6-grammers-part-1/">perl.com</a> 上的文章。 现在，我们可以用上面两个选项限制 grammar，因为这足以阐明这个技巧。</p>

<p>如果您使用更改运行代码，您可能会对获得所需结果感到惊讶。 两个变量都接收值：</p>

<pre><code class="language-perl6">Hash %!var = {:a(3), :b(-3.14)}
</code></pre>

<p>在这两种情况下，都触发了相同的 action 操作：</p>

<pre><code class="language-perl6">multi method assignment($/ where !$&lt;index&gt;) {
    %!var{$&lt;variable-name&gt;} = +$&lt;value&gt;;
}
</code></pre>

<p>在赋值的右侧，我们看到 <code>+$&lt;value&gt;</code>，这是从 Match 对象转换为数字的类型。 grammar 将 <code>3</code> 或 <code>-3.14</code> 放在 <code>$&lt;value&gt;</code> 中，两者都作为字符串。 <code>+</code> 这个一元运算符尝试将字符串转换为数字。 两个字符串都是有效数字，因此 Perl 6 不会抱怨。</p>

<p>自己编写代码将字符串转换为数字会更加困难，因为需要考虑数值的所有不同形式。 要了解 Perl 6 知道的其他格式，请查看 <a href="https://github.com/rakudo/rakudo/blob/master/src/Perl6/Grammar.nqp">Perl 6 grammar</a> 中 <code>numish</code> 标记的定义：</p>

<pre><code class="language-perl6">token numish {
    [
    | 'NaN' &gt;&gt;
    | &lt;integer&gt;
    | &lt;dec_number&gt;
    | &lt;rad_number&gt;
    | &lt;rat_number&gt;
    | &lt;complex_number&gt;
    | 'Inf' &gt;&gt;
    | $&lt;uinf&gt;='∞'
    | &lt;unum=:No+:Nl&gt;
    ]
}
</code></pre>

<p>如果您在自己的 grammar 中允许任何上述类型，Perl 将能够为您转换它们。</p>

<h2 id="4-使用-multi-rules-和-multi-tokens">4. 使用 multi-rules 和 multi-tokens</h2>

<p>它不仅是方法，也可以是 multi-things。 grammar 的规则和标记也是方法，您也可以创建它们的多个变体。</p>

<p>让我们更新我们的 grammar，以允许在赋值的右侧使用数学表达式：</p>

<pre><code class="language-perl6">my $a; $a = 6 + 5 * (4 - 3);
</code></pre>

<p>这里的新问题是解析表达式并处理运算符优先级和括号。 您可以通过以下方式描述任何表达式：</p>

<p>1、表达式是由 <code>+</code> 或 <code>-</code> 分隔的项的序列。<br />
2、上一个规则中的任何项都是由 <code>*</code> 或 <code>/</code> 分隔的项的序列。<br />
3、括号内的任何内容都是另一个表达式，因此请转到规则1。</p>

<p>话虽如此，您最终会得到以下 grammar 变更：</p>

<pre><code class="language-perl6">grammar G {
    # . . .

    rule assignment {
        '$' &lt;variable-name&gt; &lt;index&gt;? '=' &lt;expression&gt;
    }

    multi token op(1) {
        '+' | '-'
    }

    multi token op(2) {
        '*' | '/'
    }

    rule expression {
        &lt;expr(1)&gt;
    }

    multi rule expr($n) {
        &lt;expr($n + 1)&gt;+ %% &lt;op($n)&gt;
    }

    multi rule expr(3) {
        | &lt;value&gt;
        | '(' &lt;expression&gt; ')'
    }

    # . . .
}
</code></pre>

<p>这里，rules 和 tokes 都是 multi 方法，它采用反映表达式深度的单个整数值。 操作符也是如此：在第一级，你期望 <code>+</code> 和 <code>-</code> ，在第二级 -  <code>*</code> 和 <code>/</code>。</p>

<p>不要忘记 Perl 6 中的 multi 方法（以及 multi-subs）可以基于常量进行调度，这就是为什么你可以, 例如, 使用你在 <code>multi token op(2)</code> 中看到的签名。</p>

<p><code>expr($n)</code> 规则通过 <code>expr($n + 1)</code> 递归定义。 <code>$n</code> 达到3时递归停止，Perl 6 选择最后一个候选 <code>multi rule expr(3)</code>。</p>

<p>让我懒惰，并使用以前的建议让 Perl 计算表达式：</p>

<pre><code class="language-perl6">multi method assignment($/ where !$&lt;index&gt;) {
    use MONKEY-SEE-NO-EVAL;
    %!var{$&lt;variable-name&gt;} = EVAL($&lt;expression&gt;);
}
</code></pre>

<p>一般来说，我建议只在神奇的圣诞节期间使用 <code>EVAL</code>。 在今年余下的时间里，请自己计算表达式并使用抽象语法树和 <code>make</code> 和 <code>made</code> 方法对儿保存部分结果。 例如，请参阅此处的<a href="https://github.com/ash/lingua/blob/master/LinguaActions.pm">示例</a>。</p>

<p>我还建议一些额外的阅读，以便更好地了解如何使用 <code>multi</code> 和 <code>proto</code> 关键字：</p>

<p>1、<a href="https://perl6.online/2017/12/21/the-proto-keyword/">Perl 6 中的 proto 关键字</a><br />
2、<a href="https://perl6.online/2018/02/21/63-more-on-the-proto-keyword-in-perl-6/">有关 Perl 6 中 proto 关键字的更多信息</a></p>

<p>此时此刻，令人惊叹的 Perl 6 grammar 之旅就要结束了。 你可以在 <a href="https://github.com/ash/advent-2018-day8">GitHub</a> 上找到今天帖子的完整例子。 祝你读完其余的 Perl Advent Calendars，祝你愉快！</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>ohmysummer ❤ Perl 6</p>
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
