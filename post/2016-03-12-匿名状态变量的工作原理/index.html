<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="ohmysummer">
    <meta name="description" content="ohmysummer&#39;s personal website">
    <meta name="keywords" content="Perl6,Rakudo">

    <base href="http://ohmysummer.github.io/">
    <title>
  匿名状态变量的工作原理 · 焉知非鱼
</title>

    <link rel="canonical" href="http://ohmysummer.github.io/post/2016-03-12-%E5%8C%BF%E5%90%8D%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.cd087ace86754b082dec94545567f8361cba42e84f8e15edbc4a9f6e52bd1f6a.css" integrity="sha256-zQh6zoZ1Swgt7JRUVWf4Nhy6QuhPjhXtvEqfblK9H2o=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://ohmysummer.github.io/css/style.css">
    

    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://ohmysummer.github.io/">
      焉知非鱼
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/post">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/categories">归档</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/page/about/">关于</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/tags">标签</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>匿名状态变量的工作原理</h1>
    </header>

    

<h2 id="anonymous-state-variables-and-how-they-work">Anonymous State Variables And How They Work</h2>

<p>当调试代码的时候, 我经常添加一个计数变量以用于循环, 所以我能跟踪发生了什么, 或我能在代码片段中处理正迭代的部分数据集:</p>

<pre><code class="language-perl6">my $event-no = 0;
for get_events() -&gt; $event {
    $event-no++;
    process-event($event);
    last if $event-no &gt;= 5;
}
</code></pre>

<p>如果你正在调试, 或者你正尝试在单行中节省空间, Perl  6 实际上有一个匿名状态变量(<em>anonymous state variables</em>)标记, 用不含名字的 <code>$</code>符号来标示(你还可以在很多可迭代对象身上使用 kv 方法来完成类似的东西, 但是匿名的 <code>$</code> 更普遍。)</p>

<pre><code class="language-perl6">for get_events() -&gt; $event {
    process-event($event);
    last if ++$ &gt;= 5;
}
</code></pre>

<p>然而, 注意; 下面这样的用法是没有效果的:</p>

<pre><code class="language-perl6">for get_events() -&gt; $event {
    process-event($event);
    $++;
    last if $ &gt;= 5;
}
</code></pre>

<p>好了, 为什么是那样的？</p>

<h2 id="use-the-source">Use the Source</h2>

<p>好吧, 让我们来看看 Rakudo 源代码, 可以吗?</p>

<p>如你所想, 在 Perl 6 Grammar 中查找 <code>$</code> 是怎样被解析的将会是一个很困难的任务。所以我们让编译器自己来帮助我们! 我们会使用一个小例子:</p>

<pre><code class="language-perl6">for ^10 { $++ }
</code></pre>

<p>并让 Rakudo 吐出它生成的 <strong>AST</strong>, 专门用于查找变量:</p>

<pre><code class="language-perl">  $ perl6 --target=ast -e 'for ^10 { $++ }' | grep Var
      - QAST::Var(attribute $!do)
      - QAST::Var(attribute $!do)
    - QAST::Var(local __args__ :decl(param))
          - QAST::Var(lexical $¢ :decl(contvar))
          - QAST::Var(lexical $! :decl(contvar))
          - QAST::Var(lexical $/ :decl(contvar))
          - QAST::Var(lexical $_ :decl(contvar))
          - QAST::Var(lexical GLOBALish :decl(static))
          - QAST::Var(lexical EXPORT :decl(static))
          - QAST::Var(lexical $?PACKAGE :decl(static))
          - QAST::Var(lexical ::?PACKAGE :decl(static))
          - QAST::Var(lexical $=finish :decl(static))
                - QAST::Var(lexical $ANON_VAR__1 :decl(statevar))
                - QAST::Var(lexical $_ :decl(param))
                      - QAST::Var(lexical $ANON_VAR__1) :BY&lt;EXPR/POSTFIX W&gt; :nosink&lt;?&gt; :WANTED $
                        - QAST::Var(lexical $ANON_VAR__1) :BY&lt;EXPR/POSTFIX W&gt; :nosink&lt;?&gt; :WANTED $
          - QAST::Var(lexical $=pod :decl(static))
          - QAST::Var(lexical !UNIT_MARKER :decl(static))
            - QAST::Var(local ctxsave :decl(var))
            - QAST::Var(contextual $*CTXSAVE)
              - QAST::Var(local ctxsave)
                - QAST::Var(local ctxsave)
                - QAST::Var(local ctxsave)
</code></pre>

<p>你可能不会立即看到它, 但是那儿有一个可疑的声明: <code>$ANON_VAR__1</code>。现在我们有了一个搜索字符串并想得到更多相关的结果, 用 <a href="http://beyondgrep.com/">ack</a> 这样的工具搜索源代码, 我们会找到 <code>src/Perl6/Actions.nqp</code>这个文件。让我们深入进去!</p>

<pre><code class="language-perl"># taken from rakudo@85d20f3
sub declare_variable($/, $past, $sigil, $twigil, $desigilname, $trait_list, $shape?, :@post) {
    ...
    elsif $desigilname eq '' {
        if $twigil {
            $/.CURSOR.panic(&quot;Cannot have an anonymous variable with a twigil&quot;);
        }
        $name    := QAST::Node.unique($sigil ~ 'ANON_VAR_');
        $varname := $sigil;
    }
    ...
}
</code></pre>

<p>所以这部分代码(搜索 <code>ANON_VAR</code> 时唯一的结果)告诉我们当我们声明一个符号后面没有名字的变量时, 我们应该生成一个唯一的名字。</p>

<h2 id="how-did-we-get-here">How Did We Get Here?</h2>

<p>那很好, 但是我们怎么从 grammar 中到达那里? 这种情况下我使用的小技巧就是抛出一个异常并查看回溯发生在哪?</p>

<pre><code class="language-perl">sub declare_variable($/, $past, $sigil, $twigil, $desigilname, $trait_list, $shape?, :@post) {
    ...
    elsif $desigilname eq '' {
        if $twigil {
            $/.CURSOR.panic(&quot;Cannot have an anonymous variable with a twigil&quot;);
        }
+       if nqp::atkey(nqp::getenvhash(), 'ROB_DEBUG') {
+           $/.CURSOR.panic(&quot;here I am!&quot;);
+       }
        $name    := QAST::Node.unique($sigil ~ 'ANON_VAR_');
        $varname := $sigil;
    }
    ...
}
</code></pre>

<p>重新编译之后, 打开 <code>ROB_DEBUG</code> 环境变量并运行,  并使用 <code>--ll-exception</code>, 来确保内部构件被包含进了堆栈跟踪中:</p>

<pre><code class="language-perl6">$ ROB_DEBUG=1 perl6 --ll-exception -e 'for ^10 { $++ }'
</code></pre>

<p>我不会临时包含这个堆栈跟踪, 但是你可以自己生成它如果你愿意追随的话。通过查看出现在提到 <code>Actions.nqp:3160</code>（我插入异常的地方） 后面提到 <code>Grammar.nqp</code> 的第一个堆栈跟踪项, 我们来到 <code>Grammar.nqp</code>中的 <code>token variable</code>:</p>

<pre><code class="language-perl"># also taken from rakudo@85d20f3
token variable {
    :my $*IN_META := '';
    [
    | :dba('infix noun') '&amp;[' ~ ']' &lt;infixish('[]')&gt;
    | &lt;sigil&gt; &lt;twigil&gt;? &lt;desigilname&gt;
      [ &lt;?{ !$*IN_DECL &amp;&amp; $*VARIABLE &amp;&amp; $*VARIABLE eq $&lt;sigil&gt; ~ $&lt;twigil&gt; ~ $&lt;desigilname&gt; }&gt;
        { self.typed_panic: 'X::Syntax::Variable::Initializer', name =&gt; $*VARIABLE } ]?
    | &lt;special_variable&gt;
    | &lt;sigil&gt; $&lt;index&gt;=[\d+]                              [&lt;?{ $*IN_DECL }&gt; &lt;.typed_panic: &quot;X::Syntax::Variable::Numeric&quot;&gt;]?
    | &lt;sigil&gt; &lt;?[&lt;]&gt; &lt;postcircumfix&gt;                      [&lt;?{ $*IN_DECL }&gt; &lt;.typed_panic('X::Syntax::Variable::Match')&gt;]?
    | &lt;?before &lt;sigil&gt; &lt;?[ ( [ { ]&gt;&gt; &lt;!RESTRICTED&gt; &lt;?{ !$*IN_DECL }&gt; &lt;contextualizer&gt;
    | $&lt;sigil&gt;=['$'] $&lt;desigilname&gt;=[&lt;[/_!¢]&gt;]
    | {} &lt;sigil&gt; &lt;!{ $*QSIGIL }&gt; &lt;?MARKER('baresigil')&gt;   # try last, to allow sublanguages to redefine sigils (like &amp; in regex)
    ]
    [ &lt;?{ $&lt;twigil&gt; &amp;&amp; $&lt;twigil&gt; eq '.' }&gt;
        [ &lt;.unsp&gt; | '\\' | &lt;?&gt; ] &lt;?[(]&gt; &lt;!RESTRICTED&gt; &lt;arglist=.postcircumfix&gt;
    ]?
    { $*LEFTSIGIL := nqp::substr(self.orig(), self.from, 1) unless $*LEFTSIGIL }
}
</code></pre>

<p>这段代码对你没有什么意义如果你初学 Perl 6的话, 更不用说 Rakudo 源代码了。我认为这一句是最重要的:</p>

<pre><code class="language-perl6">| {} &lt;sigil&gt; &lt;!{ $*QSIGIL }&gt; &lt;?MARKER('baresigil')&gt; # try last, to allow sublanguages to redefine sigils (like &amp; in regex)
</code></pre>

<p>这个分支接受由符号唯一组成的变量。所以 <code>token variable</code> 匹配源代码中的每个裸的 <code>$</code> 实例, 并且每次发生都会调用 <code>Actions::declare_variable</code>, 生成不同的变量, 我用这个片段来说没明:</p>

<pre><code class="language-perl6">for ^3 {
    say ++$;
    say ++$;
}
=output
1
1
2
2
3
3
</code></pre>

<p>所以, 对于匿名状态变量你只能执行非常简单的操作。记住你也可以使用匿名数组或匿名散列变量来处理东西:</p>

<pre><code class="language-perl">for ^10 {
    say((@).push($_));
}
</code></pre>

<p>但是在正式代码中不建议这么用。</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>ohmysummer ❤ Perl 6</p>
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
