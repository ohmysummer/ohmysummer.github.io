<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="ohmysummer">
    <meta name="description" content="ohmysummer&#39;s personal website">
    <meta name="keywords" content="Perl6,Rakudo">

    <base href="http://ohmysummer.github.io/">
    <title>
  feed 操作符 · 焉知非鱼
</title>

    <link rel="canonical" href="http://ohmysummer.github.io/post/2016-09-18-feed%E6%93%8D%E4%BD%9C%E7%AC%A6/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.cd087ace86754b082dec94545567f8361cba42e84f8e15edbc4a9f6e52bd1f6a.css" integrity="sha256-zQh6zoZ1Swgt7JRUVWf4Nhy6QuhPjhXtvEqfblK9H2o=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://ohmysummer.github.io/css/style.css">
    

    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://ohmysummer.github.io/">
      焉知非鱼
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/post">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/categories">归档</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/page/about/">关于</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/tags">标签</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>feed 操作符</h1>
    </header>

    

<p><a href="https://docs.perl6.org/language/operators#Sequencer_Precedence">Sequencer Precedence</a></p>

<h3 id="infix">infix ==&gt;</h3>

<p>这个流操作符(feed operator)从它的左侧接收结果并把结果作为最后一个参数传递给下一个(右侧的)例程(routine)。</p>

<p>这个操作符的优先级很松散所以你需要使用圆括号把结果赋值给其它变量, 或者你甚至可以使用另外一个流操作符! 在接收单个参数或第一个参数为 block 的程序/方法的例子中, 你必须经常使用圆括号来调用(尽管这对于最后一个例程/方法不是必须的)。</p>

<pre><code class="language-perl6"># Traditional structure, read bottom-to-top
my @result =
    sort               # (4) Sort, result is &lt;Earth People&gt;
    grep { /&lt;[PE]&gt;/ }, # (3) Look for P or E
    map { .tc },       # (2) Capitalize the words
    &lt;people of earth&gt;; # (1) Start with the input

# Feed (left-to-right) with parentheses, read top-to-bottom
@result = (
    &lt;people of earth&gt;  # (1) Start with the input
    ==&gt; map({ .tc })   # (2) Capitalize the words
    ==&gt; grep /&lt;[PE]&gt;/  # (3) Look for P or E
    ==&gt; sort           # (4) Sort, result is &lt;Earth People&gt;
);

# For illustration, method chaining equivalent, read top-to-bottom
@result =
    &lt;people of earth&gt;  # (1) Start with the input
    .map({ .tc })      # (2) Capitalize the words
    .grep(/&lt;[PE]&gt;/)    # (3) Look for P or E
    .sort;             # (4) Sort, result is &lt;Earth People&gt;

# To assign without the need of parentheses use another feed operator
&lt;people of earth&gt;
    ==&gt; map({ .tc })
    ==&gt; grep /&lt;[PE]&gt;/
    ==&gt; sort()
    ==&gt; @result;

# It can be useful to capture a partial result, however, unlike
# the leftward feed operator, it does require parentheses or a semicolon
&lt;people of earth&gt;
    ==&gt; map({ .tc })
    ==&gt; my @caps; @caps # also could wrap in parentheses instead
    ==&gt; grep /&lt;[PE]&gt;/
    ==&gt; sort()
    ==&gt; @result;
</code></pre>

<p>这个流操作符能让你在例程之外构建方法链那样的模式并且方法的结果能在不相关的数据上调用。在方法链中, 你被限制于使用数据身上可用的方法或使用之前的方法调用的结果。使用流操作符, 那个限制没有了。写出来的代码比一系列用多个换行符打断的方法调用更加可读。</p>

<p>注: 在将来, 这个操作符会在它获得并行地运行列表操作的能力之后有所变化。它会强制左侧的操作数作为一个闭包(它能被克隆并运行在子线程中)变得可闭合。</p>

<h2 id="infix-1">infix &lt;==</h2>

<p>这个向左的流操作符从右侧接收结果并把结果作为最后的一个参数传递给它前面的(左侧的)例程。这为一系列列表操作函数阐明了从右到左的数据流。</p>

<pre><code class="language-perl6"># Traditional structure, read bottom-to-top
my @result =
    sort                   # (4) Sort, result is &lt;Earth People&gt;
    grep { /&lt;[PE]&gt;/ },     # (3) Look for P or E
    map { .tc },           # (2) Capitalize the words
    &lt;people of earth&gt;;     # (1) Start with the input

# Feed (right-to-left) with parentheses, read bottom-to-top
@result = (
    sort()                 # (4) Sort, result is &lt;Earth People&gt;
    &lt;== grep({ /&lt;[PE]&gt;/ }) # (3) Look for P or E
    &lt;== map({ .tc })       # (2) Capitalize the words
    &lt;== &lt;people of earth&gt;  # (1) Start with the input
);

# To assign without parentheses, use another feed operator
@result
    &lt;== sort()             # (4) Sort, result is &lt;Earth People&gt;
    &lt;== grep({ /&lt;[PE]&gt;/ }) # (3) Look for P or E
    &lt;== map({ .tc })       # (2) Capitalize the words
    &lt;== &lt;people of earth&gt;; # (1) Start with the input

# It can be useful to capture a partial result
@result
    &lt;== sort()
    &lt;== grep({ /&lt;[PE]&gt;/ })
    &lt;== my @caps # unlike ==&gt;, there is no need for additional statement
    &lt;== map({ .tc })
    &lt;== &lt;people of earth&gt;;
</code></pre>

<p>和向右的流操作符不一样, 这个结果不能严格地映射为方法链。然而, 和上面传统的结构中每个参数使用一行分割相比,  feed 操作符写出的代码比逗号更具描述性。向左的流操作符也允许你打断语句并捕获一个可能对调试来说极其方便的中间结果或者接收那个结果并在最终结果身上创建另外一个变种。</p>

<p>注意: 在将来, 这个操作符会在它获得并行地运行列表操作的能力之后有所变化。它会强制右侧的操作数作为一个闭包变得可闭合(它能被克隆并运行在子线程中)</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>ohmysummer ❤ Perl 6</p>
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
