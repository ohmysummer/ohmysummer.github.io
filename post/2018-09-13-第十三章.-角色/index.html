<!DOCTYPE html>
<html lang="en-us">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="ohmysummer">
    <meta name="description" content="ohmysummer&#39;s personal website">
    <meta name="keywords" content="Perl6,Rakudo">

    <base href="http://ohmysummer.github.io/">
    <title>
  第十三章. 角色 · 焉知非鱼
</title>

    <link rel="canonical" href="http://ohmysummer.github.io/post/2018-09-13-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0.-%E8%A7%92%E8%89%B2/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="/css/coder.min.cd087ace86754b082dec94545567f8361cba42e84f8e15edbc4a9f6e52bd1f6a.css" integrity="sha256-zQh6zoZ1Swgt7JRUVWf4Nhy6QuhPjhXtvEqfblK9H2o=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="http://ohmysummer.github.io/css/style.css">
    

    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://ohmysummer.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.49" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://ohmysummer.github.io/">
      焉知非鱼
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="/post">博客</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/categories">归档</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/page/about/">关于</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="/tags">标签</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>第十三章. 角色</h1>
    </header>

    

<h1 id="声明">声明</h1>

<p>本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或<a href="https://www.amazon.co.uk/Learning-Perl-6-Brian-Foy/dp/149197768X/ref=sr_1_1?ie=UTF8&amp;qid=1536753267&amp;sr=8-1&amp;keywords=Learning+Perl+6">纸质版</a>。</p>

<h1 id="第十三章-角色">第十三章. 角色</h1>

<p>角色是 mixins，可以增强你的类，就像它们的内容被定义在类里一样。一旦定义，它们的源实际上会被遗忘（与父类不同）。你可以使用角色来更改类，从现有类创建新类，以及增强单个对象。它们比继承更灵活，通常是更好的解决方案。角色用于代码重用，而类用于管理对象。</p>

<h1 id="给类添加行为">给类添加行为</h1>

<p>构造一个空的 <code>Butterfly</code> 类。即使没有属性接收参数的值，你也可以为 <code>.new</code> 提供参数：</p>

<pre><code>class Butterfly {}
my $butterfly = Butterfly.new: :common-name('Perly Cracker');
</code></pre>

<p>现在给你的蝴蝶命名。名字应该是 <code>Butterfly</code> 类的一部分吗？名字不是对象. <em>Hamadryas guatemalena</em> 是蝴蝶的名字。 Guatemalan Cracker，Calicó 和 Soñadoracomún 也是蝴蝶的名字。这些都是同一只蝴蝶的名字。</p>

<h6 id="注意">注意</h6>

<p>最终，你编写的代码必须在该语言框架内运行。语法有时会让你在认知上将事物分开。</p>

<p>A name is not a more specific version of something the class already does and it’s not limited to butterflies or butterfly-like things. Many dissimilar things can have a common name—animals, cars, food. Not only that, but different people, cultures, or even sections of your office may choose different names. This fact does not define your thingy or its behavior. It’s not something that makes a butterfly what it is.</p>

<p>名字不是该类已经做过的更具体的版本，它不仅限于蝴蝶或蝴蝶般的东西。许多不同的东西可以有一个共同的名字 - 动物，汽车，食物。不仅如此，不同的人，文化，甚至办公部门都可以选择不同的名字。这个事实并没有定义你的东西或它的行为。这不是让蝴蝶成为现实的东西。</p>

<p>Create a role that contains everything you need for a common name. Everything about a name (and nothing else!) can show up in that role. The role doesn’t care what sort of thingy uses it, whether that’s a butterfly, a car, or a pizza. Declare it with <code>role</code> just as you would a class:</p>

<p>创建一个包含公共名字所需内容的角色。关于名字的所有内容（没有别的！）都可以显示在该角色中。这个角色并不关心什么样的东西使用它，无论是蝴蝶，汽车还是披萨。用 <code>role</code> 声明一个角色就像声明类一样：</p>

<pre><code>role CommonName {
    has $.common-name is rw = 'An unnamed thing';
}
</code></pre>

<p>In fact, a role can act just like a class. You can make an object from a role. This puns the role into a class:</p>

<p>事实上，角色就像类一样。你可以从角色创建对象。这个角色变成了一个类：</p>

<pre><code>role CommonName {
    has $.common-name is rw = 'An unnamed thing';
}

my $name = CommonName.new: :common-name('Perly Cracker');
put $name.common-name; # Perly Cracker
</code></pre>

<p>Apply a role to a class with <code>does</code> after the class name in the same way you used <code>is</code> for inheritance:</p>

<p>在类名之后使用 <code>does</code> 以类似于继承使用 <code>is</code> 的方式将角色应用于类：</p>

<pre><code>class Butterfly does CommonName {};
</code></pre>

<p>Every <code>Butterfly</code> object now has a <code>$.common-name</code> attribute and <code>.new</code> now sets the <code>:common-name</code> using either the default or the name you provide:</p>

<p>每个 <code>Butterfly</code> 对象现在都有一个 <code>$.common-name</code> 属性，而 <code>.new</code> 现在使用默认名称或你提供的名称设置 <code>:common-name</code>：</p>

<pre><code>my $unnamed-butterfly = Butterfly.new;
put $unnamed-butterfly.common-name;   # An unnamed thing

my $butterfly = Butterfly.new: :common-name('Perly Cracker');
put $butterfly.common-name;   # Perly Cracker
</code></pre>

<p>You can use the same role for something completely different. An SSL certificate has a common name, although its semantic meaning is different:</p>

<p>对于完全不同的东西，你可以使用相同的角色。 SSL 证书具有常用名，但其语义含义不同：</p>

<pre><code>class SSLCertificate does CommonName {}
</code></pre>

<p>Butterflies and SSL certificates are completely different things and it wouldn’t make sense for them to inherit from the same thing. However, they can use the same role.</p>

<p>蝴蝶和 SSL 证书是完全不同的东西，它们从同一个东西继承是没有意义的。但是，他们可以使用相同的角色。</p>

<p>EXERCISE 13.1Create a <code>ScientificName</code> role that adds an attribute to store a <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> for the scientific name. Apply that role to <code>Butterfly</code>, create an object, and output the scientific name.</p>

<p>练习13.1 创建一个 <code>ScientificName</code> 角色，添加一个属性来存储学名的<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>。将该角色应用于 <code>Butterfly</code>，创建对象并输出学名。</p>

<h2 id="applying-multiple-roles">Applying Multiple Roles</h2>

<p>You can give a butterfly a scientific name as well as a common name by creating a different role for that. This one has several attributes:</p>

<p>你可以通过为蝴蝶创建不同的角色，为蝴蝶提供学名和常用名。这只蝴蝶有几个属性：</p>

<pre><code>role ScientificName {
    has $.kingdom is rw;
    has $.phylum is rw;
    has $.class is rw;
    has $.order is rw;
    has $.family is rw;
    has $.genus is rw;
    has $.species is rw;
    }
</code></pre>

<p>You can replace the <code>CommonName</code> role with <code>ScientificName</code> and things work as before:</p>

<p>你可以使用 <code>ScientificName</code> 替换 <code>CommonName</code> 角色，并且事情像以前一样工作：</p>

<pre><code>class Butterfly does ScientificName {};
my $butterfly = Butterfly.new: :genus('Hamadryas');
put $butterfly.genus;  # Hamadryas;
</code></pre>

<p>Multiple <code>does</code> expressions apply multiple roles:</p>

<p>多个 <code>does</code> 表达式应用多个角色：</p>

<pre><code>class Butterfly does ScientificName does CommonName {};
my $butterfly = Butterfly.new:
    :genus('Hamadryas'),
    :common-name('Perly Cracker')
    ;
put $butterfly.genus;
put $butterfly.common-name;
</code></pre>

<p>Each role inserts its code into <code>Butterfly</code> so it can respond to methods from either source:</p>

<p>每个角色都将其代码插入 <code>Butterfly</code> 中，以便它可以响应来自任何一个源的方法：</p>

<pre><code>Hamadryas
Perly Cracker
</code></pre>

<p>EXERCISE 13.2Create a role <code>Lepidoptera</code> to represent butterflies. Fill in everything from kingdom <em>Animalia</em>, phylum <em>Athropoda</em>, class <em>Insecta</em>, and order <em>Lepidoptera</em>. Allow the role to change the family, genus, and species. Use that role in your own <code>Butterfly</code> class. After you get that working add the <code>CommonName</code> role.</p>

<p>练习13.2 创建一个 <code>Lepidoptera</code> 代表蝴蝶的角色。填写动物界，动物门，昆虫纲和鳞翅目的一切。允许角色改变族，属和物种。在你自己的 <code>Butterfly</code> 类中使用该角色。完成后，添加 <code>CommonName</code> 角色。</p>

<h1 id="methods-in-roles">Methods in Roles</h1>

<p>You can define methods in roles too. Give the <code>ScientificName</code> role a <code>.gist</code> method to create your own human-readable text version of the object:</p>

<p>你也可以在角色中定义方法。为 <code>Scientific Name</code> 角色提供一个 <code>.gist</code> 方法，以创建自己的对象的人类可读文本版本：</p>

<pre><code>role ScientificName {
    ...; # all the attributes specified earlier

    method gist {
        join ' &gt; ', $.kingdom, $.genus;
        }
    }

role CommonName {
    has $.common-name is rw;
    }

class Butterfly does ScientificName does CommonName {};

my $butterfly = Butterfly.new:
    :genus('Hamadryas'),
    :common-name('Perly Cracker')
    ;
put $butterfly.genus;
put $butterfly.common-name;
put $butterfly.gist;
</code></pre>

<p>EXERCISE 13.3Update your <code>Lepidoptera</code> role to have a <code>binomial-name</code> method that returns a <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> that combines the genus and species of the butterfly (in biospeak that’s the “binomial name”).</p>

<p>练习13.3 更新你的 <code>Lepidoptera</code> 角色以拥有 <code>binomial-name</code> 方法，它返回一个结合蝴蝶属和种类的<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>（在biospeak中是“二项式名称”）。</p>

<p>To reuse these roles you want to make them available for any code to find and load. You can store roles by themselves in files just as you can with classes. Load them with <code>use</code> and they are available in that scope.</p>

<p>要重用这些角色，你需要使它们可供任何代码查找和加载。你可以像在类中一样将文件存储在文件中。使用 <code>use</code> 加载它们，它们在该范围内可用。</p>

<p>EXERCISE 13.4Separate the <code>Lepidoptera</code> and <code>CommonName</code> roles and the <code>Butterfly</code> class into their own files. Load those files into your program where you create your <code>Butterfly</code> object. Make this program work:<code>use Butterfly;  my $butterfly = Butterfly.new:     :family(  'Nymphalidae' ),     :genus(   'Hamadryas' ),     :species( 'perlicus' ),     ;  put $butterfly.binomial-name;</code></p>

<p>练习13.4 将 <code>Lepidoptera</code> 和 <code>CommonName</code> 角色还有 <code>Butterfly</code>类分开到它们自己的文件中。在你要创建 <code>Butterfly</code> 的地方加载这些文件到你的程序中。使这个程序能工作：</p>

<pre><code>use Butterfly;  
my $butterfly = Butterfly.new:     
    :family(  'Nymphalidae' ),     
    :genus(   'Hamadryas' ),     
    :species( 'perlicus' ), 
;  
put $butterfly.binomial-name;
</code></pre>

<h1 id="de-conflicting-roles">De-Conflicting Roles</h1>

<p>If two roles try to insert the same names you may have to do extra work. Suppose that both <code>ScientificName</code>and <code>CommonName</code> had a <code>.gist</code> method:</p>

<p>如果两个角色尝试插入相同的名称，则可能需要执行额外的工作。假设 <code>ScientificName</code> 和 <code>CommonName</code> 都有.gist方法：</p>

<pre><code>role ScientificName {
    ...; # all the attributes specified earlier

    method gist {
        join ' &gt; ', $.kingdom, $.genus;
        }
    }

role CommonName {
    has $.common-name is rw;

    method gist { &quot;Common name: $.common-name&quot; }
    }

class Butterfly does ScientificName does CommonName {};
</code></pre>

<p>The <code>.gist</code> method has an explicit signature and isn’t marked with <code>multi</code>. When you try to compile this you get an error telling you that two roles tried to insert the same method:</p>

<p><code>.gist</code> 方法具有显式签名，并且未标记为 <code>multi</code>。当你尝试编译它时，你会收到一个错误，告诉你两个角色尝试插入相同的方法：</p>

<pre><code>Method 'gist' must be resolved by class Butterfly because
it exists in multiple roles (CommonName, ScientificName)
</code></pre>

<p>You can add a <code>.gist</code> method to <code>Butterfly</code>. Neither role replaces a method already in the class:</p>

<p>你可以向 <code>Butterfly</code> 添加 <code>.gist</code> 方法。这两个角色都不替换类中已有的方法：</p>

<pre><code>role ScientificName {
    ...; # all the attributes specified earlier

    method gist {
        join ' &gt; ', $.kingdom, $.genus;
        }
    }

role CommonName {
    has $.common-name is rw;

    method gist { &quot;Common name: $.common-name&quot; }
    }

class Butterfly does ScientificName does CommonName {
    method gist {
        join &quot;\n&quot;,
            join( ' &gt; ', $.kingdom, $.genus ),
            &quot;Common name: $.common-name&quot;;
        }
    };
</code></pre>

<p>Or if you want both methods from the roles you can distinguish them with different signatures (and use <code>multi</code>). Their role names as a type might do:</p>

<p>或者，如果你想要角色中的两种方法，则可以使用不同的签名区分它们（并使用 <code>multi</code> ）。他们的角色名称作为类型可能是：</p>

<pre><code>role ScientificName {
    ...; # all the attributes specified earlier

    multi method gist ( ScientificName ) {
        &quot;$.genus $.species&quot;;
        }
    }

role CommonName {
    has $.common-name is rw;

    multi method gist ( CommonName ) {
        &quot;Common name: $.common-name&quot;;
        }
    }

class Butterfly does ScientificName does CommonName {};

my $butterfly = Butterfly.new:
    :genus('Hamadryas' ),
    :species('perlicus'),
    :common-name( 'Perly Cracker' ),
    ;

put '1. ', $butterfly.gist( CommonName );
put '2. ', $butterfly.gist( ScientificName );
</code></pre>

<p>This way you get both methods:</p>

<p>这样你就得到了两种方法：</p>

<pre><code>1. Common name: Perly Cracker
2. Hamadryas perlicus
</code></pre>

<p>You can have the same method in the <code>Butterfly</code> class as long as you declare it with <code>multi</code> and give it a unique signature:</p>

<p>你可以在 <code>Butterfly</code> 类中使用相同的方法，只要用 <code>multi</code> 声明它并给它一个唯一的签名：</p>

<pre><code>class Butterfly does ScientificName does CommonName {
    multi method gist {
        join &quot;\n&quot;, map { self.gist: $_ },
            ( ScientificName, CommonName );
        }
    };
my $butterfly = Butterfly.new:
    :genus('Hamadryas'),
    :species('perlicus'),
    :common-name('Perly Cracker')
    ;

put '1. ', $butterfly.gist( CommonName );
put '2. ', $butterfly.gist( ScientificName );
put '3. ', $butterfly.gist;
</code></pre>

<p>Your output shows all three and you can pick whichever you like:</p>

<p>你的输出显示全部三个，你可以选择你喜欢的任何一个：</p>

<pre><code>1. Common name: Perly Cracker
2. Hamadryas perlicus
3. Hamadryas perlicus
Common name: Perly Cracker
</code></pre>

<h1 id="anonymous-roles">Anonymous Roles</h1>

<p>Not every role needs a name. If you want a role that you don’t expect to use again you can add it directly with <code>but</code>. You can apply that directly to a class name. This actually creates a new class with the role applied to it. The new class inherits from the original:</p>

<p>并非每个角色都需要一个名字。如果你想要一个不希望再次使用的角色，可以用 <code>but</code> 直接添加它。你可以将其直接应用于类名。这实际上创建了一个应用了角色的新类。新类继承自原始：</p>

<pre><code>class Butterfly {};
my $class-role = Butterfly but role { has $.common-name };

put $class-role.^name; # Butterfly+{&lt;anon|140470326869504&gt;}
say $class-role.^mro; # ((...) (Butterfly) (Any) (Mu))

my $butterfly = $class-role.new:
    :common-name( 'Perly Cracker' );

put $butterfly.common-name;
</code></pre>

<p>You can do the same thing with less work by removing the variables that stored the classes:</p>

<p>通过删除存中储类的变量，你可以用更少的工作做同样的事情：</p>

<pre><code>my $butterfly2 = ( Butterfly but role { has $.common-name } ).new:
    :common-name('Perlicus Cracker');
put $butterfly2.^name;
put $butterfly2.common-name;
</code></pre>

<p>That’s still messy. You can apply it to the object directly:</p>

<p>那仍然很混乱。你可以直接将角色应用于对象：</p>

<pre><code>my $butterfly = Butterfly.new;
my $butterfly2 = $butterfly
    but role { has $.common-name is rw };
$butterfly2.common-name = 'Perlicus Cracker';
put $butterfly2.^name;
put $butterfly2.common-name;
</code></pre>

<p>You can even skip the variable to store the first object. Without the variable to store the initial object you get something a little shorter:</p>

<p>你甚至可以跳过变量来存储第一个对象。如果没有用于存储初始对象的变量，你可以获得更短的内容：</p>

<pre><code>my $butterfly = Butterfly.new
    but role { has $.common-name is rw };
$butterfly.common-name = 'Perlicus Cracker';
put $butterfly.^name;
put $butterfly.common-name;
</code></pre>

<p>This has the drawback that the original object doesn’t know about the roles, so you can’t set the common name in the constructor. Your role has to allow the object to change the value to set a value.</p>

<p>这样做的缺点是原始对象不知道角色，因此你无法在构造函数中设置公共名称。你的角色必须允许对象更改值以设置值。</p>

<p>Adding a role to an object is handy when you have an object that you may not have created; perhaps it was an argument to your method or the return value from a method you don’t control. In this example you take an argument (and make it <code>is copy</code> so you can add the role). You call <code>show-common-name</code> once with a plain <code>Butterfly</code>. The subroutine sees that the object doesn’t know about <code>common-name</code>, so it adds it. In your second call to <code>show-common-name</code> your argument already has the <code>common-name</code> attribute so it doesn’t need <code>show-common-name</code> to add it:</p>

<p>当你有一个你可能没有创建的对象时，为一个对象添加一个角色很方便;也许这是你的方法的参数或你不能控制的方法的返回值。在这个例子中，你接受一个参数（并使它可拷贝(<code>is copy</code>)，这样你就可以添加角色）。你用普通的 <code>Butterfly</code> 调用一次 <code>show-common-name</code>。子例程看到对象不知道 <code>common-name</code>，所以它添加了它。在第二次调用 <code>show-common-name</code> 时，你的参数已经有了 <code>common-name</code> 属性，所以它不需要 <code>show-common-name</code> 来添加它：</p>

<pre><code>sub show-common-name ( $butterfly is copy ) {
    unless $butterfly.can: 'common-name' {
        put &quot;Adding role!&quot;;
        $butterfly = $butterfly
            but role { has $.common-name is rw };
        $butterfly.common-name = 'Perlicus Cracker';
        }

    put $butterfly.common-name;
    }

# an object without the role
my $butterfly = Butterfly.new;
show-common-name( Butterfly.new );

# an object that already has the role
my $class-role = Butterfly but role { has $.common-name };
show-common-name( $class-role.new: :common-name( 'Camelia' ) );
</code></pre>

<p>The output shows that you added the role in your first call but not the second:</p>

<pre><code>Adding role!
Perlicus Cracker
Camelia
</code></pre>

<p>When should you apply your role? Whenever it makes sense for your problem.</p>

<p>你应该在什么时候应用你的角色？每当它对你的问题有意义时。</p>

<p>EXERCISE 13.5Take your <code>Lepidoptera</code> role to its logical conclusion. Start with a new <code>Animalia</code> role to represent only the kingdom. Create an <code>Arthropoda</code> role to include the <code>Animalia</code> role and represent the phylum. Do this all the way down to the <em>Hamadryas</em> genus. From there, create a <code>Hamadrayas</code> class that inherits from <code>Butterfly</code>but does all the taxonomic roles down to the genus. From the <code>Hamadrayas</code> class you should be able to set a species. Make this program work:<code>use lib &lt;.&gt;; use Hamadryas;  my $cracker = Hamadryas.new:     :species( 'perlicus' ),     :common-name( 'Perly Cracker' ),     ;  put $cracker.binomial-name; put $cracker.common-name;</code></p>

<p>练习13.5 将你的 <code>Lepidoptera</code> 角色归结为合乎逻辑的结论。从新的 <code>Animalia</code> 角色开始，仅代表王国。创建 <code>Arthropoda</code> 角色以包括 <code>Animalia</code> 角色并代表门。一直这样做到 <em>Hamadryas</em> 属。从那里，创建一个继承自<code>Butterfly</code> 的 <code>Hamadrayas</code> 类，但将所有的分类角色归结为属。从 <code>Hamadrayas</code> 类，你应该能够设置一个物种。使这个程序工作：</p>

<pre><code>use lib &lt;.&gt;; 
use Hamadryas;  
my $cracker = Hamadryas.new:     
    :species( 'perlicus' ),     
    :common-name( 'Perly Cracker' ),     
    ;  
put $cracker.binomial-name; put $cracker.common-name;
</code></pre>

<h1 id="summary">Summary</h1>

<p>You can define common code in a role and reuse it with disparate things. Since it doesn’t create an inheritance relationship it’s perfectly suited for features that don’t define the basic idea of the type.</p>

<p>你可以在角色中定义公共代码，并将其重用于不同的东西。由于它不创建继承关系，因此非常适合未定义类型基本概念的功能。</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>ohmysummer ❤ Perl 6</p>
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
