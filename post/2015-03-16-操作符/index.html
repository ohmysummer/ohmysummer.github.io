<!DOCTYPE html>
<html lang="zh" itemscope itemtype="http://schema.org/WebPage">
  <head>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>操作符 - Raku Programming</title>
  <meta name="description" content="操作符 操作符优先级 在像 1 &#43; 2 * 3 这样的表达式中， 2 * 3 被首先计算， 因为中缀操作符 * 的优先级比 &#43; 的优先级高。下面的表中总结了 Perl 6 中 的优先级级别， 从最牢固到最松散：">
  <meta name="author" content="焉知非鱼"/><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "Raku Programming",
    
    "url": "https:\/\/ohmysummer.github.io\/"
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "",
  "url": "https:\/\/ohmysummer.github.io\/"
  
  
  
  
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "https:\/\/ohmysummer.github.io\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "https:\/\/ohmysummer.github.io\/post\/2015-03-16-%E6%93%8D%E4%BD%9C%E7%AC%A6\/",
          "name": "操作符"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "焉知非鱼"
  },
  "headline": "操作符",
  "description" : "操作符 操作符优先级 在像 1 \x2b 2 * 3 这样的表达式中， 2 * 3 被首先计算， 因为中缀操作符 * 的优先级比 \x2b 的优先级高。下面的表中总结了 Perl 6 中 的优先级级别， 从最牢固到最松散：",
  "inLanguage" : "zh",
  "wordCount":  3829 ,
  "datePublished" : "2015-03-16T13:16:00",
  "dateModified" : "2015-03-16T13:16:00",
  "image" : "https:\/\/ohmysummer.github.io\/img\/rakudo.png",
  "keywords" : [ "操作符" ],
  "mainEntityOfPage" : "https:\/\/ohmysummer.github.io\/post\/2015-03-16-%E6%93%8D%E4%BD%9C%E7%AC%A6\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "https:\/\/ohmysummer.github.io\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "https:\/\/ohmysummer.github.io\/img\/rakudo.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>

<meta property="og:title" content="操作符" />
<meta property="og:description" content="操作符 操作符优先级 在像 1 &#43; 2 * 3 这样的表达式中， 2 * 3 被首先计算， 因为中缀操作符 * 的优先级比 &#43; 的优先级高。下面的表中总结了 Perl 6 中 的优先级级别， 从最牢固到最松散：">
<meta property="og:image" content="https://ohmysummer.github.io/img/rakudo.png" />
<meta property="og:url" content="https://ohmysummer.github.io/post/2015-03-16-%E6%93%8D%E4%BD%9C%E7%AC%A6/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="Raku Programming" />

  <meta name="twitter:title" content="操作符" />
  <meta name="twitter:description" content="操作符 操作符优先级 在像 1 &#43; 2 * 3 这样的表达式中， 2 * 3 被首先计算， 因为中缀操作符 * 的优先级比 &#43; 的优先级高。下面的表中总结了 Perl 6 中 的优先级级别， 从最牢固到最松散：">
  <meta name="twitter:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:card" content="summary" />
  <link href='https://ohmysummer.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.63.2" />
  <link rel="alternate" href="https://ohmysummer.github.io/index.xml" type="application/rss+xml" title="Raku Programming"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><link rel="stylesheet" href="https://ohmysummer.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://ohmysummer.github.io/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'ohmycloudy', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://ohmysummer.github.io/">Raku Programming</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="博客" href="/">博客</a>
            </li>
          
        
          
            <li>
              <a title="归档" href="/categories">归档</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/page/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        

        

        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span class="hidden-sm hidden-md hidden-lg"></span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="Raku Programming" href="https://ohmysummer.github.io/">
            <img class="avatar-img" src="https://ohmysummer.github.io/img/rakudo.png" alt="Raku Programming" />
          </a>
        </div>
      </div>
    

  </div>
</nav>



  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title"></h4>
        </div>
        <div class="modal-body">
          <gcse:search></gcse:search>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal"></button>
        </div>
      </div>
    </div>
  </div>


    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>操作符</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;
  
  
    &nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;18&nbsp;
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;3829&nbsp;
  
  
    
      &nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;焉知非鱼
    
  
  
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        <h2 id="操作符httpsdocsrakuorglanguageoperators"><a href="https://docs.raku.org/language/operators">操作符</a></h2>
<h3 id="操作符优先级">操作符优先级</h3>
<p>在像 <code>1 + 2 * 3</code> 这样的表达式中， <code>2 * 3</code> 被首先计算， 因为中缀操作符  <code>*</code> 的优先级比 <code>+</code> 的优先级高。下面的表中总结了 Perl  6 中  的优先级级别， 从最牢固到最松散：</p>
<pre><code class="language-raku" data-lang="raku">A	Level	           Examples
N	Terms	           42 3.14 &quot;eek&quot; qq[&quot;foo&quot;] $x :!verbose @$array
L	方法后缀	        .meth .+ .? .* .() .[] .{} .&lt;&gt; .«» .:: .= .^ .:
N	自增	              ++ --
R	求幂	              **
L	Symbolic unary	   ! + - ~ ? | || +^ ~^ ?^ ^
L	乘法	              * / % %% +&amp; +&lt; +&gt; ~&amp; ~&lt; ~&gt; ?&amp; div mod gcd lcm
L	加法	              + - +| +^ ~| ~^ ?| ?^
L	重复	              x xx
X	连结                ~
X	Junctive and	   &amp;
X	Junctive or	       | ^
L	Named unary	       temp let
N	Structural infix   but does &lt;=&gt; leg cmp .. ..^ ^.. ^..^
C	Chaining infix	   != == &lt; &lt;= &gt; &gt;= eq ne lt le gt ge ~~ === eqv !eqv
X	Tight and	       &amp;&amp;
X	Tight or	       || ^^ // min max
R	Conditional	       ?? !! ff fff
R	Item assignment	   = =&gt; += -= **= xx= .=
L	Loose unary	       so not
X	Comma operator	   , :
X	List infix	       Z minmax X X~ X* Xeqv ...
R	List prefix	       print push say die map substr ... [+] [*] any Z=
X	Loose and	       and andthen
X	Loose or	       or xor orelse
X	Sequencer	       &lt;==, ==&gt;, &lt;&lt;==, ==&gt;&gt;
N	Terminator	       ; {...}, unless, extra ), ], }
</code></pre><p>下面使用的两处 <code>!</code> 符号一般代表任何一对儿拥有相同优先级的操作符， 上表指定的二元操作符的结合性解释如下(其中 A 代表结合性， associativities )：</p>
<pre><code class="language-raku" data-lang="raku">A	Assoc	Meaning of $a ! $b ! $c
L	left	($a ! $b) ! $c
R	right	$a ! ($b ! $c)
N	non	    ILLEGAL
C	chain	($a ! $b) and ($b ! $c)
X	list	infix:&lt;!&gt;($a; $b; $)
</code></pre><p>对于一元操作符， 这解释为:</p>
<pre><code class="language-raku" data-lang="raku">A	Assoc	Meaning of !$a!
L	left	(!$a)!
R	right	!($a!)
N	non	    ILLEGAL
</code></pre><p>下面描述的操作符， 默认假定为 left 结合性。</p>
<h3 id="操作符种类">操作符种类</h3>
<hr>
<p>操作符能出现在相对于 term 的几个位置处：</p>
<pre><code class="language-raku" data-lang="raku">+term	        prefix         (后缀)
term1 + term2	infix          (中缀)
term++	        postfix        (后缀)
(term)	        circumfix      (环缀)
term1[term2]	postcircumfix  (后环缀)
</code></pre><p>每个操作符也可以用作子例程。 这样的子例程的名字由操作符的种类， 然后后跟一个冒号，再加上一组引号结构， 引号结构中是组成操作符的符号(s):</p>
<pre><code class="language-raku" data-lang="raku">infix:&lt;+&gt;(1, 2)                           # same as 1 + 2
circumfix:«( )»('a', 'b', 'c')            # same as ('a', 'b', 'c'), 目前编译错误。
circumfix:&lt;[ ]&gt;('a', 'b', 'c').perl.say   # [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre><p>作为一种特殊情况， listop(列表操作符)既能作为 term 又能作为前缀。子例程调用是最常见的列表操作符。其它情况包括元运算中缀操作符 <code>[+]| 1, 2, 3</code> 和 <code>prefix</code> 等 stub 操作符。</p>
<p>定义自定义操作符在 <a href="http://doc.raku.org/language/functions#Defining_Operators"> /language/functions#Defining_Operators.</a>  中有涉及。</p>
<h3 id="term-优先级">Term 优先级</h3>
<hr>
<p>Term 怎么翻译才合适？ 我觉得翻译成 <code>项</code> 更合适， 表明这是一个名词。</p>
<h4 id="环缀--">环缀 &lt; &gt;</h4>
<hr>
<p>引起单词的结构。以空白隔开内容， 并返回一个单词的 <code>Parcel</code>。 如果单词看起来像数字字面量或 <code>Pair</code> 字面量， 那么它会被转为合适的数字。</p>
<pre><code class="language-raku" data-lang="raku">say &lt;a b c&gt;[1]  # b
</code></pre><p>(Rakudo 当前总是返回一块儿字符串)。</p>
<h3 id="环缀---1">环缀 ( )</h3>
<hr>
<p>分组操作符。</p>
<p>空的分组 <code>()</code> 创建一个空的 <code>Pracel</code>。 非空表达式周围的圆括号只是构建了表达式， 而没有额外的语义。</p>
<p>在参数列表中，在参数周围放上圆括号防止了参数被解释为具名参数。</p>
<pre><code class="language-raku" data-lang="raku">multi sub p(:$a!) { say 'named'      }
multi sub p($a)   { say 'positional' }
p a =&gt; 1;       # named
p (a =&gt; 1);     # positional
</code></pre><h3 id="环缀---2">环缀 { }</h3>
<hr>
<p>Block 或 散列构造器。</p>
<p>如果<code>{}</code> 里面的内容看起来像一组 pairs 并且没有 <code>$_</code> 或其它占位符参数，就返回一个散列， 这个散列由逐项逐项的 pair 组成。</p>
<p>否则就返回一个 Block。</p>
<p>注意，这个结构没有重新解析内容； 而里面的内容总是被解析为一组句子（例如，像一个 block）， 并且如果后面的分析表明它需要被解析成一个散列， 那么 block 就会被执行并强转为散列。</p>
<h3 id="环缀---3">环缀 [ ]</h3>
<hr>
<p>数组构造器。在列表上下文中返回一个不会展平的 item 化的数组。</p>
<h2 id="方法后缀优先级">方法后缀优先级</h2>
<hr>
<h3 id="后环缀--">后环缀 [ ]</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub postcircumfix:&lt;[ ]&gt;(@container, **@index,
                        :$k, :$v, :$kv, :$p, :$exists, :$delete)
</code></pre><p><code>:$k</code> 会创建一个 pair， 它是散列中的一个条目。 键是 <code>k</code>， 键值为 <code>$kv</code>。 所以， <code>$k</code> 等价于 <code>k</code> =&gt; <code>$k</code></p>
<p>访问 <code>@container</code>  中的一个或多个元素，即数组索引操作：</p>
<pre><code class="language-raku" data-lang="raku">my @alphabet = 'a' .. 'z';
say @alphabet[0];                   #-&gt; a
say @alphabet[1];                   #-&gt; b
say @alphabet[*-1];                 #-&gt; z
say @alphabet[100]:exists;          #-&gt; False
say @alphabet[15, 4, 17, 11].join;  #-&gt; perl
say @alphabet[23 .. *].perl;        #-&gt; (&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)

@alphabet[1, 2] = &quot;B&quot;, &quot;C&quot;;
say @alphabet[0..3].perl            #-&gt; (&quot;a&quot;, &quot;B&quot;, &quot;C&quot;, &quot;d&quot;)
</code></pre><p>查看 <a href="http://doc.raku.org/language/subscripts">Subscripts</a> 获取关于该操作符行为的更详细的解释， 还有怎么在自定义类型中实现对它的支持。</p>
<h3 id="后环缀---1">后环缀 { }</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub postcircumfix:&lt;{ }&gt;(%container, **@key,
                        :$k, :$v, :$kv, :$p, :$exists, :$delete)
</code></pre><p>访问 <code>%container</code> 的一个或多个元素， 即散列索引操作：</p>
<pre><code class="language-raku" data-lang="raku">my  %color = kiwi =&gt; &quot;green&quot;, banana =&gt; &quot;yellow&quot;, cherry =&gt; &quot;red&quot;;
say %color{&quot;banana&quot;};               #-&gt; yellow
say %color{&quot;cherry&quot;, &quot;kiwi&quot;}.perl;  #-&gt; (&quot;red&quot;, &quot;green&quot;)
say %color{&quot;strawberry&quot;}:exists;    #-&gt; False

%color{&quot;banana&quot;, &quot;lime&quot;} = &quot;yellowish&quot;, &quot;green&quot;;
%color{&quot;cherry&quot;}:delete;
say %color;  #-&gt; banana =&gt; yellowish, kiwi =&gt; green, lime =&gt; green
</code></pre><p>查看 <code>后环缀 &lt; &gt;</code> 和 <code>后环缀 « »</code> 作为便捷形式， 查看 <code>Subscripts</code> 获取这个操作符行为的更详细解释， 还有怎么在自定义类型中实现对它的支持。</p>
<h3 id="后环缀---2">后环缀 &lt; &gt;</h3>
<hr>
<p><code>后环缀 { }</code> 的简写形式， 它会引起它的参数。</p>
<pre><code class="language-raku" data-lang="raku">my %color = kiwi =&gt; &quot;green&quot;, banana =&gt; &quot;yellow&quot;, cherry =&gt; &quot;red&quot;;
say %color&lt;banana&gt;;             #-&gt; yellow
say %color&lt;cherry kiwi&gt;.perl;   #-&gt; (&quot;red&quot;, &quot;green&quot;)
say %color&lt;strawberry&gt;:exists;  #-&gt; False
</code></pre><p>这不是一个真正的操作符， 它仅仅是一个在编译时把 <code>&lt; &gt;</code> 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
<h3 id="后环缀---3">后环缀 « »</h3>
<hr>
<p><code>后环缀 { }</code> 的简写形式。它会引起它的参数，并且 « » 中能进行变量插值。</p>
<pre><code class="language-raku" data-lang="raku">my %color = kiwi =&gt; &quot;green&quot;, banana =&gt; &quot;yellow&quot;, cherry =&gt; &quot;red&quot;;
my $fruit = &quot;kiwi&quot;;
say %color«cherry $fruit».perl;   #-&gt; (&quot;red&quot;, &quot;green&quot;)
</code></pre><p>这不是一个真正的操作符， 它仅仅是一个在编译时把 « » 变成 <code>{}</code> 后环缀操作符的语法糖。</p>
<h3 id="后环缀---4">后环缀 ( )</h3>
<hr>
<p>调用操作符。把调用者当作 <code>Callable</code> 并引用它，它使用圆括号之间的表达式作为参数。</p>
<p>注意，标识符后面直接跟着一对儿圆括号总是被解析为子例程调用。</p>
<p>如果你想要你的对象响应该调用操作符， 你需要实现 <code>CALL-ME</code> 方法。</p>
<h3 id="postfix-">postfix .</h3>
<hr>
<p>该操作符用于调用一个方法， <code>$invocant.method</code>。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--1">postfix .=</h3>
<hr>
<p>可变的方法调用。 <code>$invocant.=method</code> ， 脱去语法糖后就是 <code>$invocant = $invocant.method</code> , 这与 <a href="http://doc.raku.org/routine/op%3D">op=.</a> 类似。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--2">postfix .^</h3>
<hr>
<p>元方法调用。 <code> $invocant.^method</code> 在  <code>$invocant</code> 的元类身上调用方法。脱去语法糖后， 它就是 <code>$invocant.HOW.method($invocant, ...)</code> 。 查看 <a href="http://doc.raku.org/type/HOW">HOW</a> 获取更多信息。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--3">postfix .?</h3>
<hr>
<p><code>有可能被调用</code>的方法调用。如果有名为 <code>method</code> 的方法，  <code>$invocant.?method</code> 就在 <code>$invocant</code> 上调用 <code>method</code> 方法。否则它就返回 <code>Nil</code>。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--4">postfix .+</h3>
<hr>
<p><code>$invocant.+method </code> 从 <code>$invocant</code> 身上调用所有叫做 	<code>method</code> 的方法， 并返回一个 Parcel 作为结果。 如果没有找到这个名字的方法， 就会死掉。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--5">postfix .*</h3>
<hr>
<p><code>$invocant.*method</code> <code>从</code>$invocant<code>身上调用所有叫做</code>method` 的方法， 并返回一个 Parcel 作为结果。 如果没有找到这个名字的方法，则返回一个空的 Parcel。</p>
<p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-postfix">postfix .postfix</h3>
<hr>
<p>大多数情况下， 可以在后缀或后环缀前面放上一个点：</p>
<pre><code class="language-raku" data-lang="raku">@a[1, 2, 3];
@a.[1, 2, 3]; # Same
</code></pre><p>这对于视觉清晰或简洁很有帮助。例如，如果对象的属性是一个函数，在属性名后面放置一对儿圆括号会变成方法调用的一部分。 所以要么使用两对儿圆括号， 要么在圆括号前面放上一个点来阻止方法调用。</p>
<pre><code class="language-raku" data-lang="raku">class Operation {
    has $.symbol;
    has &amp;.function;
}
my $addition = Operation.new(:symbol&lt;+&gt;, :function{ $^a + $^b });
say $addition.function()(1, 2); # 3
</code></pre><p>或者</p>
<pre><code class="language-raku" data-lang="raku">say $addition.function.(1,2); # 3
</code></pre><p>然而，如果后缀是一个标识符， 那么它会被解释为一个普通的方法调用。</p>
<pre><code class="language-raku" data-lang="raku">1.i # No such method 'i' for invocant of type 'Int'
</code></pre><p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix-prefix">postfix .:<!-- raw HTML omitted --></h3>
<hr>
<p>前缀能够像方法那样， 使用冒号对儿标记法来调用。例如：</p>
<pre><code class="language-raku" data-lang="raku">my $a = 1;
say ++$a;     # 2
say $a.:&lt;++&gt;; # 3
</code></pre><p>技术上讲， 这不是一个操作符，而是编译器中特殊情况下的语法。</p>
<h3 id="postfix--6">postfix .::</h3>
<hr>
<p>一个类限定的方法调用， 用于调用一个定义在父类或 role 中的方法， 甚至在子类中重新定义了之后。</p>
<pre><code class="language-raku" data-lang="raku">class Bar {
    method baz { 42 }
}

class Foo is Bar {
    method baz { &quot;nope&quot; }
}
say Foo.Bar::baz; # 42
</code></pre><h2 id="自增优先级">自增优先级</h2>
<hr>
<h3 id="prefix-">prefix ++</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;++&gt;($x is rw) is assoc&lt;none&gt;
</code></pre><p>把它的参数增加 1， 并返回增加后的值。</p>
<pre><code class="language-raku" data-lang="raku">my $x = 3;
say ++$x;    # 4
say $x;      # 4
</code></pre><p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法， 这可以让自定义类型自由地实现它们自己的增量语义。</p>
<h3 id="prefix---">prefix &ndash;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;--&gt;($x is rw) is assoc&lt;none&gt;
</code></pre><p>把它的参数减少 1， 并返回减少后的值。</p>
<pre><code class="language-raku" data-lang="raku">my $x = 3;
say --$x;       # 2
say $x;         # 2
</code></pre><p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法， 这可以让自定义类型自由地实现它们自己的减量语义。</p>
<h3 id="postfix--7">postfix ++</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub postfix:&lt;++&gt;($x is rw) is assoc&lt;none&gt;
</code></pre><p>把它的参数增加 1， 并返回<code>unincremented</code>的那个值。</p>
<pre><code class="language-raku" data-lang="raku">my $x = 3;
say $x++;       # 3
say $x;         # 4
</code></pre><p>它的工作原理是在它的参数身上调用 <code>succ</code> 方法， 这可以让自定义类型自由地实现它们自己的增量语义。</p>
<p>注意这并不一定返回它的参数。 例如，对于未定义的值， 它返回 0:</p>
<pre><code class="language-raku" data-lang="raku">my $x;
say $x++;       # 0
say $x;         # 1
</code></pre><h3 id="postfix---">postfix &ndash;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub postfix:&lt;--&gt;($x is rw) is assoc&lt;none&gt;
</code></pre><p>把它的参数减少 1， 并返回<code>undecremented</code>的那个值。</p>
<pre><code class="language-raku" data-lang="raku">my $x = 3;
say $x--;       # 3
say $x;         # 2
</code></pre><p>它的工作原理是在它的参数身上调用 <code>pred</code> 方法， 这可以让自定义类型自由地实现它们自己的减量语义。</p>
<p>注意这并不一定返回它的参数。 例如，对于未定义的值， 它返回 0:</p>
<pre><code class="language-raku" data-lang="raku">my $x;
say $x--;       # 0
say $x;         # -1
</code></pre><h2 id="求幂优先级">求幂优先级</h2>
<hr>
<h3 id="infix-">infix **</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;**&gt;(Any, Any) returns Numeric:D is assoc&lt;right&gt;
</code></pre><p>求幂操作符把它的两个参数都强制转为 <code>Numeric</code> , 然后计算，右侧为幂。</p>
<p>如果 <code>**</code> 右边是一个非负整数，并且左侧是任意精度类型(Int, FatRat)，那么计算不会损失精度。</p>
<h2 id="象形一元操作符的优先级">象形一元操作符的优先级</h2>
<hr>
<h3 id="prefix--1">prefix ?</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;?&gt;(Mu) returns Bool:D
</code></pre><p>布尔上下文操作符。</p>
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool。注意， 这会使 Junctions 失效。</p>
<h3 id="prefix--2">prefix !</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;!&gt;(Mu) returns Bool:D
</code></pre><p>否定的布尔上下文操作符。</p>
<p>通过在参数身上调用 <code>Bool</code> 方法强制它的参数为 Bool， 并返回结果的否定值。注意， 这会使 Junctions 失效。</p>
<h3 id="prefix--3">prefix +</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;+&gt;(Any) returns Numeric:D
</code></pre><p>Numeric 上下文操作符。</p>
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型。</p>
<h3 id="prefix--">prefix -</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;-&gt;(Any) returns Numeric:D
</code></pre><p>否定的 Numeric 上下文操作符。</p>
<p>通过在参数身上调用 Numeric 方法强制将参数转为 Numeric 类型， 并返回结果的否定值。</p>
<h3 id="prefix--4">prefix ~</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;-&gt;(Any) returns Str:D
</code></pre><p>字符串上下文操作符。</p>
<p>通过在参数身上调用 <code>Str</code> 方法强制把参数转为 <code>Str</code> 类型。</p>
<h3 id="prefix--5">prefix |</h3>
<hr>
<p>将  Capture, Enum, Pair, List, Parcel, EnumMap 和 Hash 展平到参数列表中。</p>
<p>（在 Rakudo 中，这不是作为一个合适的操作符来实现的，而是编译器中的一种特殊情况， 这意味着它只对参数列表有效，而非在任意代码中都有效。）</p>
<h3 id="prefix--6">prefix +^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;+^&gt;(Any) returns Int:D
</code></pre><p>Integer bitwise negation</p>
<p>整数按位取反。</p>
<p>将参数强转为 Int 类型并对结果按位取反， 假设两者互补。</p>
<h3 id="prefix--7">prefix ?^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;?^&gt;(Mu) returns Bool:D
</code></pre><p>布尔按位取反。</p>
<p>将参数强转为 Bool， 然后按位反转，这使它和 prefix:&lt;!&gt;  一样。</p>
<h3 id="prefix--8">prefix ^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;^&gt;(Any) returns Range:D
</code></pre><p>upto 操作符.</p>
<p>强制把它的参数转为 Numeric， 生成一个从 0 直到（但是排除） 参数为止的范围。</p>
<pre><code class="language-raku" data-lang="raku">say ^5;         # 0..^5
for ^5 { }      # 5 iterations
</code></pre><h2 id="乘法优先级">乘法优先级</h2>
<hr>
<h3 id="infix--1">infix *</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;*&gt;(Any, Any) returns Numeric:D
</code></pre><p>把两边的参数都强转为 Numeric 并把它们相乘。 结果是一个更宽的类型。 查看 Numeric 获取更详细信息。</p>
<h3 id="infix--2">infix /</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;/&gt;(Any, Any) returns Numeric:D
</code></pre><p>把两边的参数都强制为 Numeric， 并用左边除以右边的数。整数相除返回 Rat， 否则返回&quot;更宽类型” 的结果。</p>
<h3 id="infix-div">infix div</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;div&gt;(Int:D, Int:D) returns Int:D
</code></pre><p>整除。向下取整。</p>
<h3 id="infix--3">infix %</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;%&gt;($x, $y) return Numeric:D
</code></pre><p>模操作符。首先强制为 Numeric。</p>
<p>通常，下面的等式是成立的：</p>
<pre><code class="language-raku" data-lang="raku">$x % $y == $x - floor($x / $y) * $y
</code></pre><h3 id="infix--4">infix %%</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;%%&gt;($a, $b) returns Bool:D
</code></pre><p>整除操作符， 如果 <code> $a % $b == 0</code> 则返回 True.</p>
<h3 id="infix-mod">infix mod</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;mod&gt;(Int:D $a, Int:D $b) returns Int:D
</code></pre><p>整数取模操作符。 返回整数取模操作的剩余部分。</p>
<h3 id="infix--5">infix +&amp;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;+&amp;&gt;($a, $b) returns Int:D
</code></pre><p>Numeric 按位 <code>AND</code>。 把两个参数都强转为 Int 并执行按位 AND 操作，假定两者是互补的。</p>
<h3 id="infix--6">infix +&lt;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;&lt; +&lt; &gt;&gt;($a, $b) returns Int:D
</code></pre><p>向左移动整数个位。</p>
<h3 id="infix--7">infix +&gt;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;&lt; +&gt; &gt;&gt;($a, $b) returns Int:D
</code></pre><p>向右移动整数个位。</p>
<h3 id="infix-gcd">infix gcd</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;gcd&gt;($a, $b) returns Int:D
</code></pre><p>强制两个参数都为 Int 并返回最大公分母（greatest common denominator）。</p>
<h3 id="infix-lcm">infix lcm</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;lcm&gt;($a, $b) returns Int:D
</code></pre><p>强制两个参数为 Int 并返回最小公倍数(least common multiple)</p>
<h2 id="加法优先级">加法优先级</h2>
<hr>
<h3 id="infix--8">infix +</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;+&gt;($a, $b) returns Numeric:D
</code></pre><p>强制两个参数为 Numeric 并把它们相加。</p>
<h3 id="infix--">infix -</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;-&gt;($a, $b) returns Numeric:D
</code></pre><p>强制两个参数为 Numeric 并用第一个参数减去第二个参数。</p>
<h3 id="infix--9">infix +|</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;+|&gt;($a, $b) returns Int:D
</code></pre><p>强制两个参数为 Int 并执行按位 OR（包括 OR）</p>
<h3 id="infix--10">infix +^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;+^&gt;($a, $b) returns Int:D
</code></pre><p>强制两个参数为 Int 并执行按位 XOR（不包括 OR）</p>
<h3 id="infix--11">infix ?|</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;?|&gt;($a, $b) returns Bool:D
</code></pre><p>强制两个参数为 Bool 并执行逻辑 OR（不包括 OR）</p>
<h2 id="重复操作符优先级">重复操作符优先级</h2>
<hr>
<h3 id="infix-x">infix x</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;x&gt;(Any, Any) returns Str:D
multi sub infix:&lt;x&gt;(Any, Any)
multi sub infix:&lt;x&gt;(Str:D, Int:D)
</code></pre><p>把 <code>$a</code> 强转为 Str ， 把 <code>$b</code> 强转为 Int， 并重复字符串 <code>$b</code> 次。 如果 <code>$b &lt;= 0</code> 则返回空字符串。</p>
<pre><code class="language-raku" data-lang="raku">say 'ab' x 3;       # ababab
say 42 x 3;         # 424242
</code></pre><h3 id="infix-xx">infix xx</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;xx&gt;($a, $b) returns List:D
</code></pre><p>返回一组重复的 <code>$a</code> 并计算 <code>$b</code> 次（<code>$b</code> 被强转为 Int）。 如果 <code>$b &lt;= 0</code> ,则返回一个空列表。</p>
<p>每次重复都会计算左侧的值， 所以</p>
<pre><code class="language-raku" data-lang="raku">[1, 2] xx 5
</code></pre><p>返回 5 个不同的数组（但是每次都是相同的内容）并且</p>
<pre><code class="language-raku" data-lang="raku">rand xx 3
</code></pre><p>返回 3 个独立的伪随机数。右侧可以是 <code>*</code>, 这时会返回一个惰性的，无限的列表。</p>
<h2 id="连结">连结</h2>
<hr>
<h3 id="infix--12">infix ~</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;~&gt;(Any, Any) returns Str:D
multi sub infix:&lt;~&gt;(Any,   Any)
multi sub infix:&lt;~&gt;(Str:D, Str:D)
</code></pre><p>强制两个参数为 Str 并连结它们。</p>
<pre><code class="language-raku" data-lang="raku">say 'ab' ~ 'c';     # abc
</code></pre><h2 id="junctive-and-all-优先级">Junctive AND (all) 优先级</h2>
<hr>
<h3 id="infix--13">infix &amp;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;&amp;&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;
</code></pre><p>用它的参数创建一个 <code>all</code> Junction。查看 Junctions 获取更多详情。</p>
<h2 id="junctive-or-any-precedence">Junctive OR (any) Precedence</h2>
<hr>
<h3 id="infix--14">infix |</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;|&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;
</code></pre><p>用它的参数创建一个 <code>any</code> Junction。查看 Junctions 获取更多详情。</p>
<h3 id="infix--15">infix ^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;^&gt;($a, $b) returns Junction:D is assoc&lt;list&gt;
</code></pre><p>用它的参数创建一个 <code>one</code> Junction。查看 Junctions 获取更多详情。</p>
<h2 id="named-unary-precedence">Named Unary Precedence</h2>
<hr>
<h3 id="prefix-temp">prefix temp</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub prefix:&lt;temp&gt;(Mu $a is rw)
</code></pre><p>temporizes 传入的变量作为参数， 这意味着退出作用域后它被重置为旧值。（这和 Perl 5 中的 local 操作符类似， 除了 temp 不重置值之外。）</p>
<h3 id="prefix-let">prefix let</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub prefix:&lt;let&gt;(Mu $a is rw)
</code></pre><p>假定重置：如果通过异常或 fail()退出当前作用域, 旧值就会被恢复。</p>
<h2 id="nonchaining-binary-precedence">Nonchaining Binary Precedence</h2>
<hr>
<h3 id="infix-does">infix does</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;does&gt;(Mu $obj, Mu $role) is assoc&lt;none&gt;
</code></pre><p>在运行时把 <code>$role</code> 混合进 <code>$obj</code> 中。 要求 <code>$obj</code> 是可变的。</p>
<p>参数 <code>$role</code> 不一定要求是一个 role， 它可以表现的像是一个 role， 例如枚举值。</p>
<h3 id="infix-but">infix but</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;but&gt;(Mu $obj, Mu $role) is assoc&lt;none&gt;
</code></pre><p>把 <code>$role</code> 混合进 <code>$obj</code> 并创建一个 <code>$obj</code> 的副本。因为 <code>$obj</code> 是不能修改的，但是能使用 mixins 用于创建不可变值。</p>
<p>参数 <code>$role</code> 不一定要求是一个 role， 它可以表现的像是一个 role， 例如枚举值。</p>
<h3 id="infix-cmp">infix cmp</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;cmp&gt;(Any, Any) returns Order:D is assoc&lt;none&gt;
multi sub infix:&lt;cmp&gt;(Any,       Any)
multi sub infix:&lt;cmp&gt;(Real:D,    Real:D)
multi sub infix:&lt;cmp&gt;(Str:D,     Str:D)
multi sub infix:&lt;cmp&gt;(Enum:D,    Enum:D)
multi sub infix:&lt;cmp&gt;(Version:D, Version:D)
</code></pre><p>一般的， “智能的” 三路比较器。</p>
<p>比较字符串时使用字符串语义， 比较数字时使用数字语义， 比较 Pair 对象时， 先比较键， 再比较值，等等。</p>
<pre><code class="language-raku" data-lang="raku">if $a eqv $b, then $a cmp $b always returns Order::Same.
say (a =&gt; 3) cmp (a =&gt; 4);      # Less
say 4        cmp 4.0;           # Same
say 'b'      cmp 'a';           # More
</code></pre><h3 id="infix-leg">infix leg</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;leg&gt;($a, $b) returns Order:D is assoc&lt;none&gt;
multi sub infix:&lt;leg&gt;(Any,   Any)
multi sub infix:&lt;leg&gt;(Str:D, Str:D)
</code></pre><p>字符串三路比较器。 leg 是  less, equal 还有 greater 的简写形式？</p>
<p>把两个参数都强转为 <code>Str</code> , 然后按照字母次序比较。</p>
<pre><code class="language-raku" data-lang="raku">say 'a' leg 'b';        Less
say 'a' leg 'a';        Same
say 'b' leg 'a';        More
</code></pre><h3 id="infix--16">infix &lt;=&gt;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:«&lt;=&gt;»($a, $b) returns Order:D is assoc&lt;none&gt;
</code></pre><p>Numeric 三路比较器。</p>
<p>把两个参数强转为 Real， 并执行数值比较。</p>
<h3 id="infix--17">infix ..</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;..&gt;($a, $b) returns Range:D is assoc&lt;none&gt;
</code></pre><p>由参数创建一个  Range。</p>
<h3 id="infix--18">infix ..^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;..^&gt;($a, $b) returns Range:D is assoc&lt;none&gt;
</code></pre><p>由参数创建一个 Range， 不包含末端。</p>
<h3 id="infix--19">infix ^..</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;^..&gt;($a, $b) returns Range:D is assoc&lt;none&gt;
</code></pre><p>由参数创建一个 Range， 不包含开始端点。</p>
<h3 id="infix--20">infix ^..^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;^..^&gt;($a, $b) returns Range:D is assoc&lt;none&gt;
</code></pre><p>由参数创建一个 Range， 不包含开端和末端。</p>
<h2 id="chaining-binary-precedence">Chaining Binary Precedence</h2>
<hr>
<h3 id="infix--21">infix ==</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;==&gt;($, $) returns Bool:D is assoc:&lt;chain&gt;
multi sub infix:&lt;==&gt;(Any, Any)
multi sub infix:&lt;==&gt;(Int:D, Int:D)
multi sub infix:&lt;==&gt;(Num:D, Num:D)
multi sub infix:&lt;==&gt;(Rational:D, Rational:D)
multi sub infix:&lt;==&gt;(Real:D, Real:D)
multi sub infix:&lt;==&gt;(Complex:D, Complex:D)
multi sub infix:&lt;==&gt;(Numeric:D, Numeric:D)
</code></pre><p>强转两个参数为 Numeric（如果必要）， 并返回 True 如果它们相等。</p>
<h3 id="infix--22">infix !=</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;!=&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
</code></pre><p>强转两个参数为 Numeric（如果必要）， 并返回 True 如果它们不相等。</p>
<h3 id="infix--23">infix &lt;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:«&lt;»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&lt;»(Int:D, Int:D)
multi sub infix:«&lt;»(Num:D, Num:D)
multi sub infix:«&lt;»(Real:D, Real:D)
</code></pre><p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
<h3 id="infix--24">infix &lt;=</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:«&lt;=»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&lt;=»(Int:D, Int:D)
multi sub infix:«&lt;=»(Num:D, Num:D)
multi sub infix:«&lt;=»(Real:D, Real:D)
</code></pre><p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
<h3 id="infix--25">infix &gt;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:«&gt;»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&gt;»(Int:D, Int:D)
multi sub infix:«&gt;»(Num:D, Num:D)
multi sub infix:«&gt;»(Real:D, Real:D)
</code></pre><p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
<h3 id="infix--26">infix &gt;=</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:«&gt;=»(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:«&gt;=»(Int:D, Int:D)
multi sub infix:«&gt;=»(Num:D, Num:D)
multi sub infix:«&gt;=»(Real:D, Real:D)
</code></pre><p>强转两个参数为 Real （如果必要）， 并返回 True 如果第一个参数大于或等于第二个参数。</p>
<h3 id="infix-eq">infix eq</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;eq&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;eq&gt;(Any,   Any)
multi sub infix:&lt;eq&gt;(Str:D, Str:D)
</code></pre><p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数等于第二个参数。</p>
<p>助记法: equal</p>
<h3 id="infix-ne">infix ne</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;ne&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;ne&gt;(Mu,    Mu)
multi sub infix:&lt;ne&gt;(Str:D, Str:D)
</code></pre><p>强转两个参数为 Str（如果必要）， 并返回 False 如果第一个参数等于第二个参数。</p>
<p>助记法: not equal</p>
<h3 id="infix-gt">infix gt</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;gt&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;gt&gt;(Mu,    Mu)
multi sub infix:&lt;gt&gt;(Str:D, Str:D)
</code></pre><p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
<p>助记法: greater than</p>
<h3 id="infix-ge">infix ge</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;ge&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;ge&gt;(Mu,    Mu)
multi sub infix:&lt;ge&gt;(Str:D, Str:D)
</code></pre><p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数大于第二个参数。</p>
<p>助记法: greater or equal</p>
<h3 id="infix-lt">infix lt</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;lt&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;lt&gt;(Mu,    Mu)
multi sub infix:&lt;lt&gt;(Str:D, Str:D)
</code></pre><p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数小于第二个参数。</p>
<p>助记法: less than</p>
<h3 id="infix-le">infix le</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;le&gt;(Mu, Mu) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;le&gt;(Mu,    Mu)
multi sub infix:&lt;le&gt;(Str:D, Str:D)
</code></pre><p>强转两个参数为 Str（如果必要）， 并返回 True 如果第一个参数小于或等于第二个参数。</p>
<p>助记法: less or equal</p>
<h3 id="infix-before">infix before</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;before&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;before&gt;(Any,       Any)
multi sub infix:&lt;before&gt;(Real:D,    Real:D)
multi sub infix:&lt;before&gt;(Str:D,     Str:D)
multi sub infix:&lt;before&gt;(Enum:D,    Enum:D)
multi sub infix:&lt;before&gt;(Version:D, Version:D)
</code></pre><p>一般的排序， 使用和 cmp 相同的语义。 如果第一个参数小于第二个参数则返回 True。</p>
<h3 id="infix-after">infix after</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;after&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;after&gt;(Any,       Any)
multi sub infix:&lt;after&gt;(Real:D,    Real:D)
multi sub infix:&lt;after&gt;(Str:D,     Str:D)
multi sub infix:&lt;after&gt;(Enum:D,    Enum:D)
multi sub infix:&lt;after&gt;(Version:D, Version:D)
</code></pre><p>一般的排序， 使用和 cmp 相同的语义。 如果第一个参数大于第二个参数则返回 True。</p>
<h3 id="infix-eqv">infix eqv</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;eqv&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
proto sub infix:&lt;eqv&gt;(Any, Any)
</code></pre><p>等值操作符。如果两个参数在结构上相同就返回 True。例如， 相同类型（并且递归）包含相同的值。</p>
<pre><code class="language-raku" data-lang="raku">say [1, 2, 3] eqv [1, 2, 3];        # True
say Any eqv Any;                    # True
say 1 eqv 2;                        # False
say 1 eqv 1.0;                      # False
</code></pre><p>对于任意对象使用默认的 eqv 操作是不可能的。例如， eqv 不认为同一对象的两个实例在结构上是相等的：</p>
<pre><code class="language-raku" data-lang="raku">class A {
    has $.a;
}

say A.new(a =&gt; 5) eqv A.new(a =&gt; 5);  #=&gt; False
</code></pre><p>要得到这个类的对象相等（eqv）语义， 需要实现一个合适的中缀 eqv 操作符：</p>
<pre><code class="language-raku" data-lang="raku">class A {
    has $.a;
}

multi infix:&lt;eqv&gt;(A $l, A $r) { $l.a eqv $r.a }
say A.new(a =&gt; 5) eqv A.new(a =&gt; 5);  #=&gt; True
</code></pre><h3 id="infix--27">infix ===</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;===&gt;(Any, Any) returns Bool:D is assoc&lt;chain&gt;
proto sub infix:&lt;===&gt;(Any, Any)
</code></pre><p>值相等。如果两个参数都是同一个对象则返回 True。</p>
<pre><code class="language-raku" data-lang="raku">class A { };

my $a = A.new;
say $a === $a;              # True
say A.new === A.new;        # False
say A === A;                # True
</code></pre><p>对于值的类型，  <code>===</code> 表现的和 eqv 一样:</p>
<pre><code class="language-raku" data-lang="raku">say 'a' === 'a';            # True
say 'a' === 'b';            # False

# different types
say 1 === 1.0;              # False
</code></pre><p><code>===</code> 使用 <code>WHICH</code> 方法来获取对象相等， 所以所有的值类型必须重写方法 <code>WHICH</code>。</p>
<h3 id="infix--28">infix =:=</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">proto sub infix:&lt;=:=&gt;(Mu \a, Mu \b) returns Bool:D is assoc&lt;chain&gt;
multi sub infix:&lt;=:=&gt;(Mu \a, Mu \b)
</code></pre><p>容器相等。返回 True 如果两个参数都绑定到同一个容器上。 如果它返回 True， 那通常意味着修改一个参数也会同时修改另外一个。</p>
<pre><code class="language-raku" data-lang="raku">my ($a, $b) = (1, 3);
say $a =:= $b;      # False
$b = 2;
say $a;             # 1
$b := $a;
say $a =:= $b;      # True
$a = 5;
say $b;             # 5
</code></pre><h3 id="infix--29">infix ~~</h3>
<hr>
<p>智能匹配操作符。把左侧参数起别名为 <code>$_</code> , 然后计算右侧的值， 并在它身上调用 <code>.ACCEPTS($_)</code> 。 匹配的语义由右侧操作数的类型决定。</p>
<p>这儿有一个内建智能匹配函数的摘要：</p>
<pre><code class="language-raku" data-lang="raku">右侧      比较语义
Mu:U	  类型检查
Str	      字符串相等
Numeric	  数值相等
Regex	  正则匹配
Callable  调用的布尔结果
Any:D	  对象相等
</code></pre><h2 id="tight-and-precedence">Tight AND Precedence</h2>
<hr>
<h3 id="infix--30">infix &amp;&amp;</h3>
<hr>
<p>在布尔上下文中返回第一个求值为 False 的参数， 否则返回最后一个参数。</p>
<p>注意这是短路操作符，如果其中的一个参数计算为 false 值， 那么该参数右侧的值绝不会被计算。</p>
<pre><code class="language-raku" data-lang="raku">sub a { 1 }
sub b { 0 }
sub c { die &quot;never called&quot; };
say a() &amp;&amp; b() &amp;&amp; c();      # 0
</code></pre><h2 id="tight-or-precedence">Tight OR Precedence</h2>
<hr>
<h3 id="infix--31">infix ||</h3>
<hr>
<p>在布尔上下文中返回第一个求值为 True 的参数， 否则返回最后一个参数。</p>
<p>注意这是短路操作符，如果其中的一个参数计算为 true 值， 那么该参数右侧的值绝不会被计算。</p>
<pre><code class="language-raku" data-lang="raku">sub a { 0 }
sub b { 1 }
sub c { die &quot;never called&quot; };
say a() || b() || c();      # 1
</code></pre><h3 id="infix--32">infix ^^</h3>
<hr>
<p>返回第一个值为 true 的参数如果只有一个的话， 否则返回 Nil。只要找到两个值为 true 的参数就发生短路。</p>
<pre><code class="language-raku" data-lang="raku">say 0 ^^ 42;                # 42
say 0 ^^ 42 ^^ 1 ^^ die 8;  # (empty line)
</code></pre><p>注意， 这个操作符的语义可能不是你假想的那样： infix ^^ 翻到它找到的第一个 true 值， 找到第二个 true 值后永远地反转为 Nil 值， 不管还有多少 true 值。（换句话说，它的语义是”找到一个真值”， 而不是布尔起奇偶校验语义）</p>
<h3 id="infix--33">infix //</h3>
<hr>
<p>Defined-or  操作符。返回第一个定义了的操作数， 否则返回最后一个操作数。短路操作符。</p>
<pre><code class="language-raku" data-lang="raku">say Any // 0 // 42;         # 0
</code></pre><h3 id="infix-min">infix min</h3>
<hr>
<p>返回参数的最小值。语义由 cmp 语义决定。</p>
<pre><code class="language-raku" data-lang="raku">$foo min= 0  # read as: $foo decreases to 0
</code></pre><h3 id="infix-max">infix max</h3>
<hr>
<p>返回参数的最大值。</p>
<pre><code class="language-raku" data-lang="raku">$foo max= 0  # read as: $foo increases to 0
</code></pre><h2 id="conditional-operator-precedence">Conditional Operator Precedence</h2>
<hr>
<h3 id="infix---1">infix ?? !!</h3>
<hr>
<p>三目操作符， 条件操作符。</p>
<p><code>$condition ?? $true !! $false</code> 计算并返回 <code>$true</code> 表达式，如果 <code>$condition</code> 为真的话。 否则计算并返回 <code>$false</code> 分支。</p>
<h3 id="infix-ff">infix ff</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;ff&gt;(Mu $a, Mu $b)
</code></pre><p>Flipflop operator. 触发器操作符。</p>
<p>把两个参数都跟 <code>$_</code> 进行比较（即，<code>$_ ~~ $a</code> 和 <code>$_ ~~ $b</code>）。求值为 False 直到左侧的智能匹配为真， 这时，它求值为真， 直到右侧的智能匹配为真。</p>
<p>实际上，左边的参数是&quot;开始”条件， 右侧的参数是”停止” 条件。 这种结构一般用于收集只在特定区域的行。 例如：</p>
<pre><code class="language-raku" data-lang="raku">my $excerpt = q:to/END/;
Here's some unimportant text.
=begin code
    This code block is what we're after.
    We'll use 'ff' to get it.
=end code
More unimportant text.
END

my @codelines = gather for $excerpt.lines {
    take $_ if &quot;=begin code&quot; ff &quot;=end code&quot;
}

# this will print four lines,
# starting with &quot;=begin code&quot; and ending with &quot;=end code&quot;
say @codelines.join(&quot;\n&quot;);
</code></pre><p>匹配开始条件之后，操作符会继续将停止条件与 <code>$_</code> 进行匹配， 如果成功就做相应地表现。在这个例子中， 只有第一个元素被打印了：</p>
<pre><code class="language-raku" data-lang="raku">for &lt;AB C D B E F&gt; {
    say $_ if /A/ ff /B/;  # prints only &quot;AB&quot;
}
</code></pre><p>如果你想测试开始条件， 并且没有结束条件， <code>*</code> 能用作 “停止” 条件。</p>
<pre><code class="language-raku" data-lang="raku">for &lt;A B C D E&gt; {
    say $_ if /C/ ff *; # prints C, D, and E
}
</code></pre><p>对于 sed-like 版本， 在开始条件匹配成功之后，它不会使用停止条件与 <code>$_</code> 进行匹配。</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-1">infix ^ff</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;^ff&gt;(Mu $a, Mu $b)
</code></pre><p>像 ff 那样工作，除了它不会在条目匹配开始条件时返回真。（包括匹配停止条件的条目）</p>
<p>一个比较:</p>
<pre><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ ff /C/ for @list;  # prints A, B, and C
say $_ if /A/ ^ff /C/ for @list; # prints B and C
</code></pre><p>sed-like 版本 可以在 ^fff 中找到.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-2">infix ff^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;ff^&gt;(Mu $a, Mu $b)
</code></pre><p>像 ff 那样工作，除了它不会在条目匹配停止条件时返回真。（包括第一次匹配开始条件的条目）</p>
<pre><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ ff /C/ for @list;  # prints A, B, and C
say $_ if /A/ ff^ /C/ for @list; # prints A and B
</code></pre><p>sed-like 版本 可以在 fff^ 中找到.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-ff-3">infix ^ff^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;^ff^&gt;(Mu $a, Mu $b)
</code></pre><p>像 ff 那样工作，除了它不会在条目匹配停止条件时返回真, 也不会在条目匹配开始时返回真。（或者两者）</p>
<pre><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ ff /C/ for @list;  # prints A, B, and C
say $_ if /A/ ^ff^ /C/ for @list; # prints B
</code></pre><p>sed-like 版本 可以在 ^fff^ 中找到.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff">infix fff</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;fff&gt;(Mu $a, Mu $b)
</code></pre><p>执行 sed-like 那样的 flipflop 操作，在其中，它返回 False 直到左侧的参数与 <code>$_</code> 智能匹配， 并且在那之后返回 True 直到右侧的参数和 <code>$_</code>  智能匹配。</p>
<p>像 ff 那样工作， 除了它每次调用只尝试一个参数之外。即， 如果 <code>$_</code> 和左侧的参数智能匹配， fff 随后不会尝试将同一个 <code>$_</code> 和右侧的参数进行匹配。</p>
<pre><code class="language-raku" data-lang="raku">for &lt;AB C D B E F&gt; {
    say $_ if /A/ fff /B/;  # Prints &quot;AB&quot;, &quot;C&quot;, &quot;D&quot;, and &quot;B&quot;
}
</code></pre><p>对于 non-sed-like 版本， 查看 <code>ff</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-1">infix ^fff</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;^fff&gt;(Mu $a, Mu $b)
</code></pre><p>像 fff那样， 除了它对于左侧的匹配不返回真之外。</p>
<pre><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ fff /C/ for @list;  # prints A, B, and C
say $_ if /A/ ^fff /C/ for @list; # prints B and C
</code></pre><p>对于 non-sed 版本， 查看 <code>^ff</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-2">infix fff^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;fff^&gt;(Mu $a, Mu $b)
</code></pre><p>像 fff 那样， 除了它对于右侧的匹配不返回真之外。</p>
<pre><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ fff /C/ for @list;  # prints A, B, and C
say $_ if /A/ fff^ /C/ for @list; # prints A and B
</code></pre><p>对于 non-sed 版本， 查看 <code>ff^</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h3 id="infix-fff-3">infix ^fff^</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;^fff^&gt;(Mu $a, Mu $b)
</code></pre><p>像 fff 那样， 除了它对于左侧和右侧的匹配都不返回真之外。</p>
<pre><code class="language-raku" data-lang="raku">my @list = &lt;A B C&gt;;
say $_ if /A/ fff /C/ for @list;  # prints A, B, and C
say $_ if /A/ ^fff^ /C/ for @list; # prints B
</code></pre><p>对于 non-sed 版本， 查看 <code>^ff^</code>.</p>
<p>这个操作符不能被重载， 因为它被编译器特殊处理过。</p>
<h2 id="item-assignment-precedence">Item Assignment Precedence</h2>
<hr>
<h3 id="infix--34">infix =</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;=&gt;(Mu $a is rw, Mu $b)
</code></pre><p>Item 赋值.</p>
<p>把 = 号右侧的值放入左侧的容器中。 它真正的语义是由左侧的容器类型决定的。</p>
<p>（注意 item 赋值和列表赋值的优先级级别不同， 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符）。</p>
<h3 id="infix--35">infix =&gt;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:«=&gt;»($key, Mu $value) returns Pair:D
</code></pre><p>Pair 构造器.</p>
<p>使用左侧值作为键， 右侧值作为值，构造一个 Pair 对象。</p>
<p>注意 <code>=&gt;</code> 操作符是语法上的特例，在这个结构中， 它允许左侧是一个未被引起的标识符。</p>
<pre><code class="language-raku" data-lang="raku">my $p = a =&gt; 1;
say $p.key;         # a
say $p.value;       # 1
</code></pre><p>在参数列表中，在 <code>=&gt;</code> 左侧使用未被引起的标识符构建的 Pair 会被解释为一个具名参数。</p>
<p>查看 Terms 语言文档了解更多创建 Pair 对象的方式。</p>
<h2 id="loose-unary-precedence">Loose Unary Precedence</h2>
<hr>
<h3 id="prefix-not">prefix not</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;not&gt;(Mu $x) returns Bool:D
</code></pre><p>在布尔上下文中计算它的参数（因此使 Junctions 失效）， 并返回否定的结果。</p>
<h3 id="prefix-so">prefix so</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub prefix:&lt;so&gt;(Mu $x) returns Bool:D
</code></pre><p>在布尔上下文中计算它的参数（因此使 Junctions 失效）， 并返回结果。</p>
<h2 id="逗号操作符优先级">逗号操作符优先级</h2>
<hr>
<h3 id="infix--36">infix ,</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;,&gt;(*@a) is assoc&lt;list&gt; returns Parcel:D
</code></pre><p>从它的参数宏构建一个 Parcel。也在语法构成上用作函数用的参数的分隔符。</p>
<h3 id="infix--37">infix :</h3>
<hr>
<p>就像中缀操作符  <code>,</code> 那样， <code>:</code> 用作参数分隔符， 并把它左侧的参数标记为调用者。</p>
<p>那会把函数调用转为方法调用。</p>
<pre><code class="language-raku" data-lang="raku">substr('abc': 1);       # same as 'abc'.substr(1)
</code></pre><p><code>Infix :</code> 只允许出现在非方法调用的第一个参数后面。 在其它位置它会是语法错误。</p>
<h2 id="list-infix-precedence">List Infix Precedence</h2>
<hr>
<h3 id="infix-z">infix Z</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;Z&gt;(**@lists) returns List:D is assoc&lt;chain&gt;
</code></pre><p>Zip operator.</p>
<p>Z 像一个拉链那样把列表插入进来， 只要第一个输入列表耗尽就停止：</p>
<pre><code class="language-raku" data-lang="raku">say (1, 2 Z &lt;a b c&gt; Z &lt;+ -&gt;).perl;  # ((1, &quot;a&quot;, &quot;+&quot;), (2, &quot;b&quot;, &quot;-&quot;)).list
</code></pre><p><code>Z</code> 操作符也作为元操作符存在， 此时内部的 parcels 被应用了元操作符的列表替换：</p>
<pre><code class="language-raku" data-lang="raku">say 100, 200 Z+ 42, 23;             # 142, 223
say 1..3 Z~ &lt;a b c&gt; Z~ 'x' xx 3;    # 1ax 2bx 3cx
</code></pre><h3 id="infix-x-1">infix X</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">sub infix:&lt;X&gt;(**@lists) returns List:D is assoc&lt;chain&gt;
</code></pre><p>从所有列表创建一个外积。最右边的元素变化得最迅速。</p>
<pre><code class="language-raku" data-lang="raku">1..3 X &lt;a b c&gt; X 9

# produces   (1, 'a', 9), (1, 'b', 9), (1, 'c', 9),
         (2, 'a', 9), (2, 'b', 9), (2, 'c', 9),
         (3, 'a', 9), (3, 'b', 9), (3, 'c', 9)

</code></pre><p>X 操作符也可以作为元操作符， 此时内部的 parcels 被应用了元操作符的列表的值替换：</p>
<pre><code class="language-raku" data-lang="raku">1..3 X~ &lt;a b c&gt; X~ 9

# produces   '1a9', '1b9', '1c9',

         '2a9', '2b9', '2c9',
         '3a9', '3b9', '3c9'
</code></pre><h3 id="infix--38">infix &hellip;</h3>
<hr>
<pre><code class="language-raku" data-lang="raku">multi sub infix:&lt;...&gt;(**@) is assoc&lt;list&gt;
multi sub infix:&lt;...^&gt;(**@) is assoc&lt;list&gt;
</code></pre><p>序列操作符是一个用于产生惰性列表的普通操作符。</p>
<p>它可以有一个初始元素和一个生成器在 <code>…</code> 的左侧， 在右侧是一个端点。</p>
<p>序列操作符会使用尽可能多的参数来调用生成器。参数会从初始元素和已生成元素中获取。</p>
<p>默认的生成器是 <code>*.succ</code> 或 <code>*.pred</code> ， 取决于末端怎么比较：</p>
<pre><code class="language-raku" data-lang="raku">say 1 ... 4;        # 1 2 3 4
say 4 ... 1;        # 4 3 2 1
say 'a' ... 'e';    # a b c d e
say 'e' ... 'a';    # e d c b a
</code></pre><p><code>*</code>  (Whatever) 末端生成一个无限序列，使用的是默认的生成器 <code>*.succ</code>。</p>
<pre><code class="language-raku" data-lang="raku">say (1 ... *)[^5];  # 1 2 3 4 5
</code></pre><p>自定义生成器是在 <code>…</code> 操作符之前的最后一个参数。下面这个自定义生成器接收两个参数， 生成了斐波纳契数。</p>
<pre><code class="language-raku" data-lang="raku">say (1, 1, -&gt; $a, $b { $a + $b } ... *)[^8];    # 1 1 2 3 5 8 13 21
# same but shorter
say (1, 1, *+* ... *)[^8];                      # 1 1 2 3 5 8 13 21
</code></pre><p>当然自定义生成器也能只接收一个参数。</p>
<pre><code class="language-raku" data-lang="raku">say 5, { $_ * 2 } ... 40;                       # 5 10 20 40
</code></pre><p>生成器的参数个数至少要和初始元素的个数一样多。</p>
<p>如果没有生成器，并且有不止一个初始元素，所有的初始元素都是数值，那么序列操作符会尝试推导出生成器。它知道数学和几何序列。</p>
<pre><code class="language-raku" data-lang="raku">say 2, 4, 6 ... 12;     # 2 4 6 8 10 12
say 1, 2, 4 ... 32;     # 1 2 4 8 16 32
</code></pre><p>如果末端不是 <code>*</code>， 它会和每个生成的元素进行智能匹配，当智能匹配成功的时候序列就被终止。对于 <code>...</code>  操作符， 会包含最后一个元素， 对于 <code>...^</code> 操作符，会排除最后的那个元素。</p>
<p>这允许你这样写：</p>
<pre><code class="language-raku" data-lang="raku">say 1, 1, *+* ...^ *&gt;= 100;
</code></pre><p>来生成所有直到 100 但不包括 100 的斐波纳契数。</p>
<p><code>...</code> 操作符还会把初始值看作”已生成的元素”，所以它们也会对末端进行检查：</p>
<pre><code class="language-raku" data-lang="raku">my $end = 4;
say 1, 2, 4, 8, 16 ... $end;
# outputs 1 2 4
</code></pre><h2 id="list-prefix-precedence">List Prefix Precedence</h2>
<hr>
<h3 id="infix--39">infix =</h3>
<hr>
<p>列表赋值。  它真正的语义是由左侧的容器类型决定的。查看 Array 和 Hash 获取普通案例。</p>
<p>item 赋值和列表赋值的优先级级别不同， 并且等号左侧的语法决定了等号是被解析为 item 赋值还是列表赋值操作符。</p>
<h3 id="infix--40">infix :=</h3>
<hr>
<p>绑定。 而 <code>$x = $y</code> 是把 <code>$y</code> 中的值放到 <code>$x</code> 里面， <code>$x := $y</code> 会让 <code>$x</code> 和 <code>$y</code> 引用同一个值。</p>
<pre><code class="language-raku" data-lang="raku">my $a = 42;
my $b = $a;
$b++;
say $a;
</code></pre><p>这会输出 42， 因为 $a 和 $b 都包含了数字 42， 但是容器是不同的。</p>
<pre><code>my $a = 42;
my $b := $a;
$b++;
say $a;
</code></pre><p>这会打印 43， 因为 <code>$b</code> 和 <code>$a</code> 都代表着<code>同一个对象</code>。</p>
<h3 id="infix--41">infix ::=</h3>
<hr>
<p>只读绑定. 查看  infix :=.</p>
<h3 id="listop-">listop &hellip;</h3>
<hr>
<p>这是yada, yada, yada 操作符 或 stub 操作符。如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>...</code> 语句被执行了， 它会调用 <code>&amp;fail</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h3 id="listop--1">listop !!!</h3>
<hr>
<p>如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>!!!</code> 语句被执行了， 它会调用 <code>&amp;die</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h3 id="listop--2">listop ???</h3>
<hr>
<p>如果它在子例程或类型中是唯一的语句，它会把子例程或类型标记为 stub（这在预声明类型和组成 roles 上下文中是有意义的）</p>
<p>如果 <code>???</code> 语句被执行了， 它会调用 <code>&amp;warn</code> , 伴随着默认的消息 stub 代码的执行。</p>
<h2 id="loose-and-precedence">Loose AND precedence</h2>
<hr>
<h3 id="infix-and">infix and</h3>
<hr>
<p>和中缀操作符 <code>&amp;&amp;</code> 一样，除了优先级更宽松。</p>
<p>在布尔上下文中返回第一个求值为 False 的操作数， 否则返回最后一个操作数。短路操作符。</p>
<h3 id="infix-andthen">infix andthen</h3>
<hr>
<p>返回第一个未定义的参数，否则返回最后一个参数。短路操作符。左侧的结果被绑定到 <code>$_</code> 身上， 在右侧中使用， 或者作为参数被传递，如果右侧是一个 block 或 pointy block.</p>
<h2 id="loose-or-precedence">Loose OR Precedence</h2>
<hr>
<h3 id="infix-or">infix or</h3>
<hr>
<p>和中缀操作符 <code>||</code> 一样，除了优先级更宽松。</p>
<p>在布尔上下文中返回第一个求值为 True 的参数， 否则返回最后一个参数。短路操作符。</p>
<h3 id="infix-orelse">infix orelse</h3>
<hr>
<p>和中缀操作符 <code>//</code> 一样，除了优先级更宽松之外。</p>
<p>返回第一个定义过的参数， 否则返回最后一个参数。短路操作符。</p>


        
          <div class="blog-tags">
            
              <a href="https://ohmysummer.github.io//tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/">操作符</a>&nbsp;
            
          </div>
        

        

        
          
            
          

          
                  <h4 class="see-also"></h4>
                  <ul>
                
                
                    <li><a href="/post/2016-05-02-raku%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BA%8C/">Raku 中的操作符(二)</a></li>
                
                    <li><a href="/post/2016-03-23-raku%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%89/">Raku 中的操作符(三)</a></li>
                
                    <li><a href="/post/2015-08-31-raku%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%80/">Raku 中的操作符(一)</a></li>
                
              </ul>

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://ohmysummer.github.io/post/2015-03-16-raku%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%BA%8C/" data-toggle="tooltip" data-placement="top" title="Raku 中的特性(二)">&larr; </a>
            </li>
          
          
            <li class="next">
              <a href="https://ohmysummer.github.io/post/2015-03-19-subset/" data-toggle="tooltip" data-placement="top" title="Subset"> &rarr;</a>
            </li>
          
        </ul>
      


      
        
          
          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ohmysummer" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
          
        
        
      

    </div>
  </div>
</div>

      
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            <a href="" title="RSS">
              <span class="fa-stack fa-lg">
                <i class="fas fa-circle fa-stack-2x"></i>
                <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://ohmysummer.github.io/">焉知非鱼</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2019
          

          
            &nbsp;&bull;&nbsp;
            <a href="https://ohmysummer.github.io/">Raku Programming</a>
            with <span style="color: red;">❤</span>
          
        </p>
        
        <p class="credits theme-by text-muted">
          
          
        </p>
      </div>
    </div>
  </div>
</footer><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="https://ohmysummer.github.io/js/main.js"></script>
<script src="https://ohmysummer.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="https://ohmysummer.github.io/js/load-photoswipe.js"></script>



<script>
  (function() {
    var cx = '009072066163920799339:qwme9vkotxk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>







    
  </body>
</html>

