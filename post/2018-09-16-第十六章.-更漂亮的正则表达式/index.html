<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>第十六章. 更漂亮的正则表达式</title>
  <meta property="og:title" content="第十六章. 更漂亮的正则表达式" />
  <meta name="twitter:title" content="第十六章. 更漂亮的正则表达式" />
  <meta name="description" content="Fancier Regular Expressions">
  <meta property="og:description" content="Fancier Regular Expressions">
  <meta name="twitter:description" content="Fancier Regular Expressions">
  <meta name="author" content="焉知非鱼"/>
  <link href='https://ohmysummer.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://ohmysummer.github.io/post/2018-09-16-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0.-%E6%9B%B4%E6%BC%82%E4%BA%AE%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Rakudo Perl 6" />

  <meta name="generator" content="Hugo 0.53" />
  <link rel="canonical" href="https://ohmysummer.github.io/post/2018-09-16-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0.-%E6%9B%B4%E6%BC%82%E4%BA%AE%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" />
  <link rel="alternate" href="https://ohmysummer.github.io/index.xml" type="application/rss+xml" title="Rakudo Perl 6">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://ohmysummer.github.io/css/codeblock.css" />



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'ohmycloudy', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://ohmysummer.github.io/">Rakudo Perl 6</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="博客" href="/">博客</a>
            </li>
          
        
          
            <li>
              <a title="归档" href="/categories">归档</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/page/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        

        

        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span class="hidden-sm hidden-md hidden-lg">Search</span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
          <a title="Rakudo Perl 6" href="https://ohmysummer.github.io/">
            <img class="avatar-img" src="https://ohmysummer.github.io/img/rakudo.png" alt="Rakudo Perl 6" />
          </a>
        
      </div>
    </div>

  </div>
</nav>



  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title">Search Rakudo Perl 6</h4>
        </div>
        <div class="modal-body">
          <gcse:search></gcse:search>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>


    
  
  
  




  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              <h1>第十六章. 更漂亮的正则表达式</h1>
                
                  
                    <h2 class="post-subheading">Fancier Regular Expressions</h2>
                  
                
                
                  <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on September 16, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 31 minutes (6410 words)
  
  
</span>

                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main">
  <div class="row">
    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        

<h1 id="声明">声明</h1>

<p>本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或<a href="https://www.amazon.co.uk/Learning-Perl-6-Brian-Foy/dp/149197768X/ref=sr_1_1?ie=UTF8&amp;qid=1536753267&amp;sr=8-1&amp;keywords=Learning+Perl+6">纸质版</a>。</p>

<h1 id="第十六章-更漂亮的正则表达式">第十六章. 更漂亮的正则表达式</h1>

<p>You won’t see all the rest of the regular expression syntax in this chapter, but you’ll see the syntax you’ll use the most. There’s much more to patterns, but this should get you most of the way through common problems. With grammars (<a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch17.html#camelia-grammars">Chapter 17</a>), the power of even simple patterns will become apparent.</p>

<p>在本章中，你不会看到所有其他正则表达式语法，但你将看到最常用的语法。模式有很多，但这应该可以解决常见问题。使用 grammars（第17章），即使是简单模式的威力也会变得明显。</p>

<h1 id="量词">量词</h1>

<p>Quantifiers allow you to repeat a part of a pattern. Perhaps you want to match several of the same letter in a row—an <em>a</em> followed by one or more *b*’s then another <em>a</em>. You don’t care how many *b*’s there are as long as there’s at least one of them. The <code>+</code> quantifier matches the immediately preceding part of the pattern one or more times:</p>

<p>量词允许你重复模式的一部分。也许你想要连续匹配几个相同的字母 - 一个 <em>a</em> 后跟一个或多个 *b*，然后是另一个*a*。你不在乎有多少 *b*，只要有至少一个 <em>b</em> 就好了。 <code>+</code> 量词与紧接其前的部分模式匹配一次或多次：</p>

<pre><code>my @strings = &lt; Aa Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, ' ', m/ :i ab+ a / ?? 'Matched!' !! 'Missed!';
}
</code></pre>

<p>The first <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> here doesn’t match because there isn’t at least one <em>b</em>. All of the others have an <em>a</em> followed by one or more *b*s and another <em>a</em>:</p>

<p>这里的第一个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>不匹配，因为没有至少一个 *b*。所有其他字符串都有一个 <em>a</em> 后跟一个或多个 *b*，还有另一个 *a*：</p>

<pre><code>Aa Missed!
Aba Matched!
Abba Matched!
Abbba Matched!
Ababa Matched!
</code></pre>

<p>A quantifier only applies to the part of the pattern immediately in front of it—that’s the <code>b</code>, not the <code>ab</code>. Group the <code>ab</code> and apply the quantifier to the group (which counts as one thingy):</p>

<p>量词仅适用于紧接在其前的部分模式 - 即 <code>b</code>，而不是 <code>ab</code>。将 <code>ab</code> 分组并将量词应用于组（计为一个东西）：</p>

<pre><code>my @strings = &lt; Aa Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, ' ', m/ :i [ab]+ a / ?? 'Matched!' !! 'Missed!';
}
</code></pre>

<p>Now different <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>s match. The ones with repeated *b*’s don’t match because the quantifier applies to the <code>[ab]</code>group. Only two of the <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>s have repeated *ab*’s:</p>

<p>现在匹配的是不同的<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>了。重复 <em>b</em> 的那些不匹配，因为量词应用于 <code>[ab]</code> 组。只有两个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>重复了 *ab*：</p>

<pre><code>Aa Missed!
Aba Matched!
Abba Missed!
Abbba Missed!
Ababa Matched!
</code></pre>

<p>EXERCISE 16.1Using <em>butterfly_census.txt</em> (the file you made at the end of <a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch09.html#camelia-hashes">Chapter 9</a>), use a regex to count the number of distinct butterfly species whose names have two or more consecutive *i*’s. Use the <code>+</code> quantifier in your pattern.</p>

<p>练习16.1使用 *butterfly_census.txt*（你在第9章末尾创建的文件），使用正则表达式来计算名称有两个或更多个连续 <em>i</em> 的不同蝴蝶物种的数量。在模式中使用 <code>+</code> 量词。</p>

<h2 id="zero-or-more">Zero or More</h2>

<p>The <code>*</code> quantifier is like <code>+</code> but matches <em>zero</em> or more times. This makes that part of the pattern optional. If it matches it can repeat as many times as it likes. Perhaps you want to allow the letter <em>a</em> between *b*’s. The *a*’s can be there or not be there:</p>

<p><code>*</code> 量词类似于 <code>+</code> 但匹配零次或多次。这使得该模式的一部分可选。如果它匹配，它可以重复任意次数。也许你想允许 <em>b</em> 之间有字母 *a*。 <em>a</em> 可以在那里或不在那里：</p>

<pre><code>my @strings = &lt; Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, ' ', m/ :i ba*b / ?? 'Matched!' !! 'Missed!';
}
</code></pre>

<p>The <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>s with consecutive *b*’s match because they have zero *a*’s between the *b*’s, but the <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> with <em>bab</em> also matches because it has zero or more *a*’s between them:</p>

<p>带有连续 <em>b</em> 的<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>匹配了，因为它们在 <em>b</em> 之间没有 *a*，但是带有 <em>bab</em> 的<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>也匹配了，因为它们之间有零或多个 *a*：</p>

<pre><code>Aba Missed!
Abba Matched!
Abbba Matched!
Ababa Matched!
</code></pre>

<p>EXERCISE 16.2Adapt your solution from the previous exercise to find the butterfly species names that have consecutive *a*’s that may be separated by either <em>n</em> or <em>s</em>.</p>

<p>练习16.2 从上一个练习中获取解决方案，找到具有连续 <em>a</em> 的蝴蝶种类名称，这些名称可以用 <em>n</em> 或 <em>s</em> 分隔。</p>

<h2 id="greediness">Greediness</h2>

<p>The <code>+</code> and <code>*</code> quantifiers are greedy; they match as much of the text as they can. Sometimes that’s too much. Change the earlier example to match another <em>b</em> after the quantifier. Now there must be at least two *b*’s in a row:</p>

<p><code>+</code> 和 <code>*</code> 量词是贪婪的;他们尽可能多地匹配文本。有时匹配太多了。更改前面的示例以匹配量词后的另一个 *b*。现在必须连续至少有两个 *b*：</p>

<pre><code>my @strings = &lt; Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, ' ', m/ :i ab+ ba / ?? 'Matched!' !! 'Missed!';
}
</code></pre>

<p>The first <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> doesn’t match because it doesn’t have one or more *b*’s followed by another <em>b</em>. It’s the same for the last <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>. The middle two <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>s have enough *b*’s to satisfy both parts of the pattern:</p>

<p>第一个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>不匹配，因为它没有一个或多个 *b*，后面再跟另一个 *b*。对于最后一个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>来说也是如此。中间的两个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>有足够的 <em>b</em> 来满足模式的两个部分：</p>

<pre><code>Aba Missed!
Abba Matched!
Abbba Matched!
Ababa Missed!
</code></pre>

<p>But think about how this works inside the matcher. When it sees the <code>b+</code> it matches as many *b*’s as it can. In <code>Abbba</code>, the <code>b+</code> starts by matching <code>bbb</code>. The <code>b+</code> part of the pattern is satisfied. The matcher moves on to the next part of the pattern, which is another <code>b</code>. The text doesn’t have any leftover *b*’s to satisfy that part because the greedy quantifier matched them all.</p>

<p>The match doesn’t fail because of another tactic the matcher can use: it can backtrack on the quantifier that just matched to force it to give up some of the text. The <code>b+</code> needs one or more *b*’s. Whether it matched two or three doesn’t matter, because either satisfies that. Backing up one position in the text leaves a <em>b</em> for the next part to match. Once it backs up it tries the next part of the pattern.</p>

<p>但想想在匹配器中如何工作。当它看到 <code>b+</code> 时，它尽可能多地匹配 *b*。在 <code>Abbba</code> 中，<code>b+</code> 从匹配 <code>bbb</code> 开始。满足模式的 <code>b+</code> 部分。匹配器移动到模式的下一部分，这是另一个 <code>b</code>。该文本没有任何剩余的 <em>b</em> 来满足该部分，因为贪婪的量词把它们全部匹配完了。</p>

<p>匹配不会因为匹配器可以使用的另一种策略而失败：它可以回溯刚刚匹配的量词，迫使它放弃一些文本。 <code>b+</code> 需要一个或多个 *b*。它是否匹配两个或三个并不重要，因为要么满足这一点。在文本中回退一个位置会空出一个 <em>b</em> 以供下一部分匹配。一旦它回退它就会尝试模式的下一部分。</p>

<h2 id="zero-or-one">Zero or One</h2>

<p>The <code>?</code> quantifier matches zero or once only; it makes the preceding part of the pattern optional. In this pattern you can have one or two *b*’s because you used <code>?</code> to make one of them optional:</p>

<p><code>?</code> 量词匹配零或一次;它使模式的前一部分可选。在这种模式中，你可以使用一个或两个 *b*，因为你使用过 <code>?</code> 使其中一个可选：</p>

<pre><code>my @strings = &lt; Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, ' ', m/ :i ab? ba / ?? 'Matched!' !! 'Missed!';
}
</code></pre>

<p>Now the first <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> can match because the first <em>b</em> can match zero times. The third <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> can’t match because there is more than one <em>b</em> and the <code>?</code> can’t match more than one of them:</p>

<p>现在第一个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>可以匹配，因为第一个 <em>b</em> 可以匹配零次。第三个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>无法匹配，因为有多个 <em>b</em> 并且 <code>?</code> 不能匹配多个 *b*：</p>

<pre><code>Aba Matched!
Abba Matched!
Abbba Missed!
Ababa Matched!
</code></pre>

<h2 id="minimal-and-maximal">Minimal and Maximal</h2>

<p>If you want to match an exact number of times use <code>**</code>. With a single number after it the <code>**</code> matches exactly that number of times. This matches exactly three *b*’s:</p>

<p>如果要匹配确切的次数，请使用 <code>**</code>。在它之后有一个数字，<code>**</code> 恰好匹配那个次数。这恰好与三个 <em>b</em> 匹配：</p>

<pre><code>my @strings = &lt; Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, ' ', m/ :i ab**3 a / ?? 'Matched!' !! 'Missed!';
}
</code></pre>

<p>There’s only one <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> that matches:</p>

<p>只有一个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>匹配：</p>

<pre><code>Aba Missed!
Abba Missed!
Abbba Matched!
Ababa Missed!
</code></pre>

<p>You can use a range after the <code>**</code>. The quantified part must match at least the range minimum and will only match as many repetitions as the range maximum:</p>

<p>你可以在 <code>**</code> 之后使用范围。量化部分必须至少匹配范围最小值，并且只匹配范围最大值的重复次数：</p>

<pre><code>my @strings = &lt; Aba Abba Abbba Ababa Abbbba &gt;;
for @strings {
    put $_, ' ', m/ :i a b**2..3 a / ?? 'Matched!' !! 'Missed!';
}
</code></pre>

<p>Two <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>s match—the ones with two or three consecutive *b*’s:</p>

<p>两个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>匹配 - 具有两个或三个连续 <em>b</em> 的那个：</p>

<pre><code>Aba Missed!
Abba Matched!
Abbba Matched!
Ababa Missed!
Abbbba Missed!
</code></pre>

<p>An exclusive range works too. Match two or three times by excluding the <code>1</code> and <code>4</code> endpoints to get the same output:</p>

<p>排除范围也有效。通过排除 <code>1</code> 和 <code>4</code> 端点来匹配两到三次以获得相同的输出：</p>

<pre><code>my @strings = &lt; Aba Abba Abbba Ababa &gt;;
for @strings {
    put $_, ' ', m/ :i ab**1^..^4 a / ?? 'Matched!' !! 'Missed!';
    }
</code></pre>

<p>EXERCISE 16.3Output all the lines from the butterfly census file that have four vowels in a row.</p>

<p>EXERCISE 16.4Output all the lines from the butterfly census file that have exactly four repetitions of an <em>a</em> followed by a nonvowel (such as in <em>Paralasa</em>).</p>

<p>练习16.3 输出蝴蝶人口普查文件中连续有四个元音的所有行。</p>

<p>练习16.4 输出蝴蝶人口普查文件中的所有行，这些行恰好有四个重复的 <em>a</em> 后跟一个非元音（例如在 <em>Paralasa</em> 中）。</p>

<h1 id="controlling-quantifiers">Controlling Quantifiers</h1>

<p>Adding a <code>?</code> after any quantifier makes it match as little as possible—the greedy quantifiers become nongreedy. The modified quantifier stops matching when the next part of the pattern can match.</p>

<p>These two patterns look for an <em>H</em>, some stuff, and then an <em>s</em>. The first one is greedy and matches all the way to the final <em>s</em>. The second one is nongreedy and stops at the first <em>s</em> it encounters. The greedy case matches the entire text but the nongreedy case matches only the first word:</p>

<p>在任何量词后面添加 <code>?</code> 使得它尽可能少地匹配 - 贪婪的量词变得不贪婪。当模式的下一部分可以匹配时，修改的量词停止匹配。</p>

<p>这两个模式寻找 *H*，然后是一些东西，然后是一个 *s*。第一个是贪婪的，一直匹配到最后的 *s*。第二个是非贪婪的，并在它遇到的第一个 <em>s</em> 后停止。贪婪的案例匹配整个文本，但非贪婪的案例只匹配第一个单词：</p>

<pre><code>$_ = 'Hamadryas perlicus';

say &quot;Greedy: &quot;,    m/ H .*  s /;  # Greedy: ｢Hamadryas perlicus｣
say &quot;Nongreedy: &quot;, m/ H .*? s /;  # Nongreedy: ｢Hamadryas｣
</code></pre>

<p>You’ll probably find that you often want to make the quantifiers nongreedy.</p>

<p>EXERCISE 16.5Output all the text in the input that appears between underscores. The <em>Butterflies_and_Moths.txt</em> file has some interesting nongreedy matches.</p>

<p>你可能会发现你经常想让量词不贪婪。</p>

<p>练习16.5 输出输入中出现在下划线之间的所有文本。 <em>Butterflies_and_Moths.txt</em> 文件有一些有趣的非贪婪匹配。</p>

<h2 id="turning-off-backtracking">Turning Off Backtracking</h2>

<p>The <code>:</code> modifier lets you turn off backtracking by preventing a quantifier from unmatching what it has already matched. In both of these patterns the <code>.+</code> can match everything to the end of the <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>. The first one has to unmatch some of that to allow the rest of the pattern to match. The second one uses <code>.+:</code>, which means it can’t give back any of the text to allow the first <em>s</em> to match, so that match fails:</p>

<p><code>:</code> 修饰符允许你通过阻止量词取消匹配已匹配的内容来关闭回溯。在这两种模式中，<code>.+</code> 可以匹配所有东西直到<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>的末尾。第一个必须与其中一些取消匹配，以允许模式的其余部分匹配。第二个使用 <code>.+:</code> ,这意味着它无法归还任何文本以允许第一个匹配，因此匹配失败：</p>

<pre><code>$_ = 'Hamadryas perlicus';
say &quot;Backtracking: &quot;,
    m/ H .+  s \s perlicus/;  # Backtracking: ｢Hamadryas perlicus｣
say &quot;Nonbacktracking: &quot;,
    m/ H .+: s \s perlicus/;  # Nonbacktracking: Nil
</code></pre>

<p>The <code>:</code> can go immediately after the <code>**</code>. Each tries to match groups of three characters with a <em>def</em> at the end. The first one matches the entire <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> because it’s greedy, but then backs up enough to allow <em>def</em> to match. The second one uses <code>**:</code>, so it refuses to unmatch the <em>def</em> and the pattern fails:</p>

<p><code>:</code> 可以直接跟在 <code>**</code> 后面。每个尝试匹配三个字符的组然后是末尾的 *def*。第一个匹配整个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>，因为它是贪婪的，但后来回退足够多的字符以允许 <em>def</em> 匹配。第二个使用 <code>**:</code>,因此它拒绝取消匹配 <em>def</em> , 模式就失败了：</p>

<pre><code>$_ = 'abcabcabcdef';
say &quot;Backtracking: &quot;,
    m/ [ ... ] **  3..4 def /;  # ｢abcabcabcdef｣
say &quot;Nonbacktracking: &quot;,
     m/ [ ... ] **: 3..4 def /;  # Nil
</code></pre>

<p><a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2-TABLE-regex_summary">Table 16-1</a> summarizes the behavior of the different types of quantifiers.</p>

<p><a href="https://www.safaribooksonline.com/library/view/learning-perl-6/9781491977675/ch16.html#camelia-regex2-TABLE-regex_summary">表16-1</a>总结了不同类型量词的行为。</p>

<table>
<thead>
<tr>
<th>Quantifier</th>
<th>Example</th>
<th>Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>?</code></td>
<td><code>b?</code></td>
<td>零个或一个 <em>b</em></td>
</tr>

<tr>
<td><code>*</code></td>
<td><code>b*</code></td>
<td>零个或多个 <em>b</em></td>
</tr>

<tr>
<td><code>+</code></td>
<td><code>b+</code></td>
<td>一个或多个 <em>b</em></td>
</tr>

<tr>
<td><code>** N</code></td>
<td><code>b ** 4</code></td>
<td>正好 4 个 <em>b</em></td>
</tr>

<tr>
<td><code>** M..N</code></td>
<td><code>b ** 2..4</code></td>
<td>两到四个 <em>b</em></td>
</tr>

<tr>
<td><code>** M^..^N</code></td>
<td><code>b ** 1^..^5</code></td>
<td>带有排除范围的两到四个 <em>b</em></td>
</tr>

<tr>
<td><code>??</code></td>
<td><code>b??</code></td>
<td>零个 <em>b</em> (不常见的情况)</td>
</tr>

<tr>
<td><code>*?</code></td>
<td><code>b*?</code></td>
<td>零个或多个 *b*，非贪婪的</td>
</tr>

<tr>
<td><code>+?</code></td>
<td><code>b+?</code></td>
<td>一个或多个 *b*，非贪婪的</td>
</tr>

<tr>
<td><code>?:</code></td>
<td><code>b?:</code></td>
<td>零个或多个 *b*，没有回溯</td>
</tr>

<tr>
<td><code>*:</code></td>
<td><code>b*?</code></td>
<td>零个或多个 *b*，贪婪的，没有回溯</td>
</tr>

<tr>
<td><code>+:</code></td>
<td><code>b+?</code></td>
<td>一个或多个 *b*，没有回溯</td>
</tr>

<tr>
<td><code>**: M..N</code></td>
<td><code>b ** 2..4</code></td>
<td>两到四个 *b*，贪婪的，没有回溯</td>
</tr>
</tbody>
</table>

<h1 id="captures">Captures</h1>

<p>When you group with parentheses instead of square brackets you capture parts of the text:</p>

<p>当你使用圆括号而不是方括号分组时，你可以捕获文本的一部分：</p>

<pre><code>say 'Hamadryas perlicus' ~~ / (\w+) \s+ (\w+) /;
</code></pre>

<p>In the <code>.gist</code> output you see the captures labeled with whole numbers starting from zero. The captures are numbered by their position in their subpattern from left to right:</p>

<p>在 <code>.gist</code> 输出中，你会看到标记从零开始的整数的捕获。捕获按照从左到右的子模式中的位置进行编号：</p>

<pre><code>｢Hamadryas perlicus｣
 0 =&gt; ｢Hamadryas｣
 1 =&gt; ｢perlicus｣
</code></pre>

<p>You can access the captures with postcircumfix indices (but only if the match succeeds). This looks like a <a href="https://docs.perl6.org/type/Positional.html"><code>Positional</code></a> but isn’t, but that’s a distinction you don’t need to worry about here. The output shows the same captures you saw before:</p>

<p>你可以使用 postcircumfix 索引访问捕获（但仅在匹配成功时）。这看起来像一个 <a href="https://docs.perl6.org/type/Positional.html"><code>Positional</code></a>，但不是，但这是一个区别，这里你不需要担心。输出显示你之前看到的相同捕获：</p>

<pre><code>my $match = 'Hamadryas perlicus' ~~ / (\w+) \s+ (\w+) /;

if $match {
    put &quot;Genus: $match[0]&quot;;   # Genus: Hamadryas
    put &quot;Species: $match[1]&quot;; # Species: perlicus
}
</code></pre>

<p>The special variable <code>$/</code> already stores the result of the last successful match. You can access elements in it directly:</p>

<p>特殊变量 <code>$/</code> 已经存储了上次成功匹配的结果。你可以直接访问其中的元素：</p>

<pre><code>$_ = 'Hamadryas perlicus';
if / (\w+) \s+ (\w+) / {
    put &quot;Genus: $/[0]&quot;;    # Genus: Hamadryas
    put &quot;Species: $/[1]&quot;;  # Species: perlicus
};
</code></pre>

<p>It gets better. There’s a shorthand to access the captures in <code>$/</code>. The number variables <code>$0</code> and <code>$1</code> are actually <code>$/[0]</code> and <code>$/[1]</code> (and this is true for as many captures as you create):</p>

<p>它变得更好了。有一个简写来访问 <code>$/</code> 中的捕获。数字变量 <code>$0</code> 和 <code>$1</code> 实际上是 <code>$/[0]</code> 和 <code>$/[1]</code> (对于你创建的捕获次数，这是正确的)：</p>

<pre><code>$_ = 'Hamadryas perlicus';
if / (\w+) \s+ (\w+) / {
    put &quot;Genus: $0&quot;;   # Genus: Hamadryas
    put &quot;Species: $1&quot;; # Species: perlicus
};
</code></pre>

<p>If a previous match fails then <code>$/</code> is empty and you don’t see the values from the previous successful match. An unsuccessful match resets to <code>$/</code> to nothing:</p>

<p>如果先前的匹配失败，则 <code>$/</code> 为空，并且你看不到上一次成功匹配的值。不成功的匹配将 <code>$/</code> 重置为空：</p>

<pre><code>my $string = 'Hamadryas perlicus';

my $first-match = $string ~~ m/(perl)(.*)/;
put &quot;0: $0 | 1: $1&quot;;  # 0: perl | 1: icus

my $second-match = $string ~~ m/(ruby)(.*)/;
put &quot;0: $0 | 1: $1&quot;;  # 0:  | 1: -- nothing in these variables
</code></pre>

<h2 id="named-captures">Named Captures</h2>

<p>Instead of relying on the numbered captures, you can give them names. These become keys in a <a href="https://docs.perl6.org/type/Hash.html"><code>Hash</code></a> in the <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a> object. Label a capture with a <code>$&lt;</code><em>LABEL</em><code>&gt;=</code> in front of the capturing parentheses:</p>

<p>你可以为它们命名，而不是依赖于编号的捕获。这些成为 <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a> 对象中 <a href="https://docs.perl6.org/type/Hash.html"><code>Hash</code></a> 的键。在捕获的圆括号前用 <code>$ &lt;LABEL&gt;=</code> 标记捕获：</p>

<pre><code>$_ = 'Hamadryas perlicus';
if / $&lt;genus&gt;=(\w+) \s+ $&lt;species&gt;=(\w+) / {
    put &quot;Genus: $/&lt;genus&gt;&quot;;      # Genus: Hamadryas
    put &quot;Species: $/&lt;species&gt;&quot;;  # Species: perlicus
};
</code></pre>

<p>The output is often much easier to understand when you label the captures. It’s also easier to modify the pattern without disrupting later code, since the positions of labels don’t matter.</p>

<p>As before, you can leave off the slash in <code>$/</code> but only if you use the angle brackets. This looks like <a href="https://docs.perl6.org/type/Associative.html"><code>Associative</code></a> indexing even though the <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a> isn’t an <a href="https://docs.perl6.org/type/Associative.html"><code>Associative</code></a> type:</p>

<p>标记捕获时，输出通常更容易理解。在不破坏后续代码的情况下修改模式也更容易，因为标签的位置无关紧要。</p>

<p>和以前一样，只要使用尖括号，就可以省略 <code>$/</code> 中的斜杠。即使 <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a> 不是<a href="https://docs.perl6.org/type/Associative.html"><code>关联</code></a>类型，这看起来像<a href="https://docs.perl6.org/type/Associative.html"><code>关联</code></a>索引：</p>

<pre><code>$_ = 'Hamadryas perlicus';
if / $&lt;genus&gt;=(\w+) \s+ $&lt;species&gt;=(\w+) / {
    put &quot;Genus: $&lt;genus&gt;&quot;;      # Genus: Hamadryas
    put &quot;Species: $&lt;species&gt;&quot;;  # Species: perlicus
};
</code></pre>

<p>A label name in a variable works, but in that case you can’t leave off the <code>/</code>:</p>

<p>变量中的标签名称有效，但在这种情况下，你不能省略 <code>/</code>：</p>

<pre><code>$_ = 'Hamadryas perlicus';
my $genus-key = 'genus';
my $species-key = 'species';
if / $&lt;genus&gt;=(\w+) \s+ $&lt;species&gt;=(\w+) / {
    put &quot;Genus: $/{$genus-key}&quot;;      # Genus: Hamadryas
    put &quot;Species: $/{$species-key}&quot;;  # Species: perlicus
};
</code></pre>

<p>If you save the result the names are in your <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a> in the same way they show up in <code>$/</code>:</p>

<p>如果你将结果保存，则名称在你的<a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a>中的方式与它们在 <code>$/</code> 中显示的方式相同：</p>

<pre><code>my $string = 'Hamadryas perlicus';
my $match = $string ~~ m/ $&lt;genus&gt;=(\w+) \s+ $&lt;species&gt;=(\w+) /;

if $match {
    put &quot;Genus: $match&lt;genus&gt;&quot;;       # Genus: Hamadryas
    put &quot;Species: $match&lt;species&gt;&quot;;   # Species: perlicus
};
</code></pre>

<p>You don’t even need to know the names because you can get those from the <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a>. Calling <code>.pairs</code> returns all the names:</p>

<p>你甚至不需要知道这些名字，因为你可以从<a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a>中得到这些名字。调用 <code>.pairs</code> 返回所有名称：</p>

<pre><code>my $string = 'Hamadryas perlicus';
my $match = $string ~~ m/ $&lt;genus&gt;=(\w+) \s+ $&lt;species&gt;=(\w+) /;

put &quot;Keys are:\n\t&quot;,
    $match
        .pairs
        .map( { &quot;{.key}: {.value}&quot; } )
        .join( &quot;\n\t&quot; );
</code></pre>

<p>The <code>put</code> shows everything without knowing the names in advance:</p>

<p><code>put</code> 会在事先不知道名字的情况下显示所有内容：</p>

<pre><code>Keys are:
    species: perlicus
    genus: Hamadryas
</code></pre>

<p>When patterns get too complex (say, something that you have to spread over multiple lines) the numbered <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a> variables will probably proliferate beyond your ability to track them. Names do a much better job of reminding you which capture contains what.</p>

<p>当模式变得过于复杂时（比如，你必须分散在多行上），编号的<a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a>变量可能会超出你跟踪它们的能力。名称可以更好地提醒你哪个捕获包含什么。</p>

<h2 id="a-capture-tree">A Capture Tree</h2>

<p>Inside capture parentheses you can have additional capture parentheses. Each group gets its own numbering inside the group that contains it:</p>

<p>在捕获圆括号内，你可以使用其他捕获圆括号。每个组在包含它的组内获得自己的编号：</p>

<pre><code>my $string = 'Hamadryas perlicus';
say $string ~~ m/(perl (&lt;[a..z]&gt;+))/;
</code></pre>

<p>The output shows that there are two <code>$0</code>s and one of them is subordinate to the other. The captures are nested so the results are nested:</p>

<p>输出显示有两个 <code>$0</code>，其中一个从属于另一个。捕获是嵌套的，因此结果是嵌套的：</p>

<pre><code>｢perlicus｣
 0 =&gt; ｢perlicus｣
  0 =&gt; ｢icus｣
</code></pre>

<p>To access the top-level match, use <code>$/[0]</code> or <code>$0</code>. To get the nested matches you access the next level with the appropriate subscript:</p>

<p>要访问顶级匹配，请使用 <code>$/[0]</code> 或 <code>$0</code>。要获取嵌套匹配，你可以使用相应的下标访问下一级别：</p>

<pre><code>my $string = 'Hamadryas perlicus';
$string ~~ m/(perl (&lt;[a..z]&gt;+))/;

# explicit $/
say &quot;Top match: $/[0]&quot;;       # Top match: perlicus
say &quot;Inner match: $/[0][0]&quot;;  # Inner match: icus

# or skip the $/
say &quot;Top match: $0&quot;;          # Top match: perlicus
say &quot;Inner match: $0[0]&quot;;     # Inner match: icus
</code></pre>

<p>This works for named captures in the same way. The outer captures include the inner text as well as the inner captures:</p>

<p>这适用于以相同方式命名的捕获。外部捕获包括内部文本以及内部捕获：</p>

<pre><code>my $string = 'Hamadryas perlicus';
$string ~~ m/
    $&lt;top&gt; = (perl
        $&lt;inner&gt; = (&lt;[a..z]&gt;+)
        )
    /;

# explicit $/
say &quot;Top match: $/&lt;top&gt;&quot;;           # Top match: perlicus
say &quot;Inner match: $/&lt;top&gt;&lt;inner&gt;&quot;;  # Inner match: icus

# or skip the $/
say &quot;Top match: $&lt;top&gt;&quot;;            # Top match: perlicus
say &quot;Inner match: $&lt;top&gt;&lt;inner&gt;&quot;;   # Inner match: icus
</code></pre>

<p>It’s not one or the other. You can mix number variables and labels if that makes sense:</p>

<p>它不是一个或另一个。如果有意义，你可以混合数字变量和标签：</p>

<pre><code>my $string = 'Hamadryas perlicus';
$string ~~ m/
    ( perl $&lt;inner&gt; = (&lt;[a..z]&gt;+) )
    /;

# explicit $/
say &quot;Top match: $/[0]&quot;;           # Top match: perlicus
say &quot;Inner match: $/[0]&lt;inner&gt;&quot;;  # Inner match: icus

# or skip the $/
say &quot;Top match: $0&quot;;            # Top match: perlicus
say &quot;Inner match: $0&lt;inner&gt;&quot;;   # Inner match: icus
</code></pre>

<p>This nesting makes it very easy to construct your pattern. The numbering is localized to the level you are in. If you add other captures to the pattern they only disturb their level.</p>

<p>EXERCISE 16.6Extract from the <em>Butterflies_and_Moths.txt</em> file all the scientific names between underscores (such as <code>_Crocallis elinguaria_</code>). Capture the genus and species separately. Which genus has the most species?</p>

<p>这种嵌套使得构建模式变得非常容易。编号已本地化到你所在的层级。如果你在模式中添加其他捕获，则只会影响其层级。</p>

<p>练习16.6 从 <em>Butterflies_and_Moths.txt</em> 文件中提取下划线之间的所有科学名称（例如 <code>_Crocallis elinguaria_</code>）。分别捕获属和种。哪个属种类最多？</p>

<h2 id="backreferences">Backreferences</h2>

<p>The result of a capture is available inside your patterns. You can use that to match something else in the same pattern. Use the <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a> variables to refer to the part that you want:</p>

<p>捕获的结果可在模式中使用。你可以使用它来匹配相同模式中的其他内容。使用<a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a>变量来引用所需的部分：</p>

<pre><code>my $line = 'abba';
say $line ~~ / a (.) $0 a  /;
</code></pre>

<p>The output shows the entire match and the capture:</p>

<p>输出显示整个匹配和捕获：</p>

<pre><code>｢abba｣
 0 =&gt; ｢b｣
</code></pre>

<p>Refer to captures at the same level with the number variables. The <code>$0</code> and <code>$1</code> are backreferences to parts of the pattern that have already matched:</p>

<p>请参阅与数字变量在同一级别的捕获。 <code>$0</code> 和 <code>$1</code> 是对已经匹配的模式部分的反向引用：</p>

<pre><code>my $line = 'abccba';
say $line ~~ / a (.)(.) $1 $0 a  /;
</code></pre>

<p>There are only two captures in the output:</p>

<p>输出中只有两个捕获：</p>

<pre><code>｢abccba｣
 0 =&gt; ｢b｣
 1 =&gt; ｢c｣
</code></pre>

<p>If the capture is nested you have to do a bit more work. You might think you can subscript the capture variable, but can you see why it fails silently?</p>

<p>如果捕获是嵌套的，则必须做更多的工作。你可能认为可以下标捕获变量，但是你能看到它为什么会无声地失败吗？</p>

<pre><code>my $line = 'abcca';
say $line ~~ / a (.(.)) $0[0] a  /;  # does not match!
</code></pre>

<p>Those square brackets are pattern metacharacters and not postcircumfix indexers! You think that you have an element in <code>$0</code>, but it’s really <code>$0</code> stringified followed by a group that is the literal text <code>0</code>.</p>

<p>To get around this parsing problem surround the subscript access in <code>$()</code> so the pattern sees it as one thing. There’s one more trick to make it work out. Backreferences are only valid at a sequence point where the match operator has filled in all the details. An empty code block can force that:</p>

<p>那些方括号是模式元字符而不是 postcircumfix 索引器！你认为你在 <code>$0</code> 有一个元素，但它实际上是 <code>$0</code> 字符串化后跟一个文字文本 <code>0</code> 的组。</p>

<p>为了解决这个解析问题围绕 <code>$()</code> 中的下标访问，所以模式将其视为一件事。还有一个技巧可以让它成功。反向引用仅在匹配运算符填充了所有详细信息的序列点有效。空代码块可以强制执行：</p>

<pre><code>my $line = 'abcca';
say  $line ~~ / a (.(.)) {} $($0[0]) a  /;  # matches
</code></pre>

<p>Now the <code>$0[0]</code> can match the <em>c</em>:</p>

<p>现在 <code>$0[0]</code> 可以匹配 *c*：</p>

<pre><code>｢abcca｣
 0 =&gt; ｢bc｣
  0 =&gt; ｢c｣
</code></pre>

<h1 id="surrounders-and-separators">Surrounders and Separators</h1>

<p>To match something that has prefix and suffix characters, you could type out the pattern in the order it appears in the <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>. Here’s an example that matches a word in literal parentheses:</p>

<p>要匹配具有前缀和后缀字符的内容，你可以按照它在<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>中出现的顺序输出模式。这是一个与字面括号中的单词匹配的示例：</p>

<pre><code>my $line = 'outside (pupa) outside';
say $line ~~ / '(' \w+ ')'  /;         # ｢(pupa)｣
</code></pre>

<p>That’s not the best way to communicate that you want to match something in parentheses, though. The start and end characters aren’t next to each other in the pattern; you have to read ahead then surmise that the parentheses are circumfix parts of the same idea.</p>

<p>Instead, connect the beginning and end patterns with <code>~</code>, then put the interior pattern after that. This describes something surrounded by parentheses subordinate to the structure:</p>

<p>不过，这不是你想要在括号中匹配内容的最佳沟通方式。开始和结束字符在模式中不是彼此相邻的;你必须提前阅读，然后推测括号是同一个想法的一部分。</p>

<p>相反，用 <code>~</code> 连接开始和结束模式，然后在之后放置内部模式。这描述了从属于结构的括号所包围的东西：</p>

<pre><code>my $line = 'outside (pupa) outside';
say $line ~~ / '(' ~ ')' \w+ /;
</code></pre>

<p>This is automatically nongreedy; it does not grab everything until the last closing parenthesis:</p>

<p>这是自动非贪婪的;在最后一个右括号之前它不会抓取所有内容：</p>

<pre><code>my $line = 'outside (pupa) space (pupa) outside';
say $line ~~ m/ '(' ~ ')' \w+ /; # ｢(pupa)｣
</code></pre>

<p>A global match will still find all the instances:</p>

<p>全局匹配仍将找到所有实例：</p>

<pre><code>my $line = 'outside (pupa) space (pupa) outside';
say $line ~~ m:global/ '(' ~ ')' \w+ /; # (｢(pupa)｣ ｢(pupa)｣)
</code></pre>

<p>Going the other way, suppose that you want to match a series of things that are separated by other characters. A line of comma-separated values is such a thing:</p>

<p>换句话说，假设你想要匹配由其他字符分隔的一系列事物。一行以逗号分隔的值是这样的：</p>

<pre><code>my $line = 'Hamadryas,Leptophobia,Vanessa,Gargina';
</code></pre>

<p>To match the letters separated by commas, you could match the first group of letters then every subsequent occurrence of a comma and another group of letters:</p>

<p>要匹配用逗号分隔的字母，你可以匹配第一组字母，然后匹配每个后续的逗号和另一组字母：</p>

<pre><code>say $line ~~ / (\w+) [ ',' (\w+) ]+ /;
</code></pre>

<p>That works, but it’s annoying because you have to use <code>\w+</code> twice even though it’s describing the same thing. The <code>%</code> modifies a quantifier so that the pattern on the right comes between each group:</p>

<p>这是有效的，但它很烦人，因为你必须使用 <code>\w+</code> 两次，即使它描述同样的事情。 <code>%</code> 修饰量词，使右侧的模式位于每个组之间：</p>

<pre><code>say $line ~~ / (\w+)+ % ',' /;
</code></pre>

<p>The output shows that you matched each group of letters:</p>

<p>输出显示你匹配了每组字母：</p>

<pre><code>｢Hamadryas,Leptophobia,Vanessa,Gargina｣
 0 =&gt; ｢Hamadryas｣
 0 =&gt; ｢Leptophobia｣
 0 =&gt; ｢Vanessa｣
 0 =&gt; ｢Gargina｣
</code></pre>

<p>A double percent allows a trailing separator in the overall match:</p>

<p>双百分号允许在整体匹配中使用尾分隔符：</p>

<pre><code>my $line = 'Hamadryas,Leptophobia,Vanessa,';
say $line ~~ / (\w+)+ %% ',' /;
</code></pre>

<p>Notice that it matches that comma that follows <em>Vanessa</em> but does not create an empty capture after it:</p>

<p>请注意，它与 <em>Vanessa</em> 后面的逗号匹配，但不会在其后创建空捕获：</p>

<pre><code>｢Hamadryas,Leptophobia,Vanessa,｣
 0 =&gt; ｢Hamadryas｣
 0 =&gt; ｢Leptophobia｣
 0 =&gt; ｢Vanessa｣
</code></pre>

<h6 id="note">NOTE</h6>

<p>Although you’d think that CSV files should be simple, they aren’t. In the wild all sorts of weird things happen. The <a href="https://modules.perl6.org/dist/Text::CSV:cpan:HMBRAND"><code>Text::CSV</code></a> module handles all of those tricky bits. Use that instead of doing it yourself.</p>

<p>虽然你认为 CSV 文件应该很简单，但事实并非如此。在野外，各种各样奇怪的事情都会发生。 <a href="https://modules.perl6.org/dist/Text::CSV:cpan:HMBRAND"><code>Text::CSV</code></a> 模块处理所有这些棘手的部分。使用它而不是自己做。</p>

<h1 id="断言">断言</h1>

<p>Assertions don’t match text; they require that a certain condition be true at the current position in the text. They match a context instead of characters. Specify these in your pattern to allow the matcher to fail faster. You don’t need to scan the entire text if the pattern should only work at the beginning of the text.</p>

<p>断言不匹配文本;他们要求在文本的当前位置某个条件为真。它们匹配上下文而不是字符。在模式中指定这些以允许匹配器更快地失败。如果模式仅适用于文本的开头，则无需扫描整个文本。</p>

<h2 id="锚点">锚点</h2>

<p>An anchor prevents the pattern from floating over the text to find a place where it can start matching. It requires that a pattern match at a particular position. If the pattern doesn’t match at that position the match can immediately fail and save itself the work of scanning the text.</p>

<p>The <code>^</code> forces your pattern to match at the absolute beginning of the text. This matches because the <em>Hama</em> comes at the beginning of the text:</p>

<p>锚点可防止模式浮动在文本上以找到可以开始匹配的位置。它要求在特定位置匹配模式。如果模式在该位置不匹配，则匹配可能立即失败并自行保存扫描文本的工作。</p>

<p><code>^</code> 强制你的模式在文本的绝对开头匹配。下面这个会匹配，因为 <em>Hama</em> 出现在文本的开头：</p>

<pre><code>say 'Hamadryas perlicus' ~~ / ^ Hama /;  # ｢Hama｣
</code></pre>

<p>Trying to match <em>perl</em> after <code>^</code> fails because that pattern is not at the beginning of the text:</p>

<p>尝试匹配 <code>^</code> 后面的 <em>perl</em> 会失败，因为该模式不在文本的开头：</p>

<pre><code>say 'Hamadryas perlicus' ~~ / ^ perl /;  # Nil (fails)
</code></pre>

<p>Without the anchor the match would drift over the text looking at each position to check for <em>perl</em>. That’s extra work (and probably incorrect) if you know that you want to match at the beginning. Once the match fails at the beginning it’s immediately done.</p>

<p>The <code>$</code> is the end-of-string anchor and does something similar at the end of the text:</p>

<p>没有锚点，匹配将漂移在文本上，查看每个位置以检查 *perl*。如果你知道你想在开始时匹配，这是额外的工作（可能是不正确的）。一旦匹配在开始时失败，匹配立即结束。</p>

<p><code>$</code> 是字符串结尾的锚点，并在文本末尾执行类似的操作：</p>

<pre><code>say 'Hamadryas perlicus' ~~ / icus $ /;  # ｢icus｣
</code></pre>

<p>This one doesn’t match because there’s more text after <em>icus</em>:</p>

<p>这个不匹配，因为 <em>icus</em> 之后有更多的文本：</p>

<pre><code>say 'Hamadryas perlicus navitas' ~~ / icus $ /;  # Nil (fails)
</code></pre>

<p>There are anchors for the beginning and end of a line; that could be different from the beginning and end of the text. A line ends with a newline and that newline might be in the middle of your multiline text, like in this one (remember that the here doc strips the indention):</p>

<p>行的开头和结尾都有锚点;这可能与文本的开头和结尾不同。行以换行符结尾，换行符可能位于多行文本的中间，就像在这一行中一样（请记住，here doc 删除了缩进）：</p>

<pre><code>$_ = chomp q:to/END/;   # chomp removes last newline
    Chorinea amazon
    Hamadryas perlicus
    Melanis electron
    END
</code></pre>

<p>The beginning-of-line anchor, <code>^^</code>, matches after the absolute beginning of the text or immediately after any newline. These both work because <em>Chorinea</em> is at the start of the text and the start of the first line:</p>

<p>行首的锚点 <code>^^</code> 在文本的绝对开头之后或在任何换行符之后立即匹配。下面这两者都有效，因为 <em>Chorinea</em> 位于文本的开头和第一行的开头：</p>

<pre><code>say m/ ^  Chorinea /;  # ｢Chorinea｣
say m/ ^^ Chorinea /;  # ｢Chorinea｣
</code></pre>

<p>Likewise, the end-of-line anchor, <code>$$</code>, matches before any newline or at the absolute end of the text. These also both work because <em>electron</em> is at the end of the text and the end of the last line:</p>

<p>同样，行尾锚点 <code>$$</code> 在任何换行符之前或文本的绝对末尾匹配。下面这些也都有效，因为 <em>electron</em> 在文本的末尾和最后一行的结尾：</p>

<pre><code>say m/ electron $  /;  # ｢electron｣
say m/ electron $$ /;  # ｢electron｣
</code></pre>

<p><em>Hamadryas</em> can’t match at the absolute beginning of the text but it can match at the beginning of a line:</p>

<p><em>Hamadryas</em> 在文本的绝对开头不能匹配，但它可以在一行的开头匹配：</p>

<pre><code>say m/ ^  Hamadryas /; # Nil
say m/ ^^ Hamadryas /; # ｢Hamadryas｣
</code></pre>

<p>Similarly, <em>perlicus</em> can’t match at the absolute end of the text but it can match at the end of a line:</p>

<p>同样，<em>perlicus</em> 在文本的绝对末尾不能匹配，但它可以在一行的末尾匹配：</p>

<pre><code>say m/ perlicus $  /;  # Nil
say m/ perlicus $$ /;  # ｢perlicus｣
</code></pre>

<h2 id="conditions">Conditions</h2>

<p><em>Word boundaries</em> exist when a non-“word” character is next to a “word” character (in either order). Those terms are a bit fuzzy, since you likely think of word characters as the alphabetic characters. They are, however, the ones that match <code>\w</code>, which includes numbers and other things. The beginning and the end of the <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a> count as nonword characters.</p>

<p>EXERCISE 16.7Output all the “word” characters that are not alphabetic characters. How many of them are there? The <a href="https://docs.perl6.org/type/Range.html">Range</a><code>0 .. 0xFFFF</code> and the <code>.chr</code> method should be helpful.</p>

<p>Assert a word boundary with <code>&lt;|w&gt;</code>. Suppose that you want to match the name <em>Hamad</em>. Without a word boundary that would match in <em>Hamadryas</em>, but that’s not what you want. The word boundary keeps it from showing up in the middle of another word:</p>

<p>*当非“单词”字符紧邻“单词”字符时（以任一顺序），则存在单词边界。这些术语有点模糊，因为你可能会将单词字符视为字母字符。然而，它们是匹配 <code>\w</code> 的，包括数字和其他东西。 <a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>的开头和结尾计为非单词字符。</p>

<p>练习16.7 输出所有非字母字符的“单词”字符。他们中有多少个？ <a href="https://docs.perl6.org/type/Range.html">Range</a> <code>0 .. 0xFFFF</code> 和 <code>.chr</code> 方法应该会有所帮助。</p>

<p>用 <code>&lt;|w&gt;</code> 断言单词边界。假设你想要匹配 <em>Hamad</em> 这个名字。没有在 <em>Hamadryas</em> 中匹配的单词边界，但这不是你想要的。单词边界使它不会出现在另一个单词的中间：</p>

<pre><code>$_ = 'Hamadryas';
say m/ Hamad /;       # ｢Hamad｣
say m/ Hamad &lt;|w&gt; /;  # Nil
</code></pre>

<p>That second pattern can’t match because <em>Hamadryas</em> has a word character (a letter) following <em>Hamad</em>. The next example matches because a space follows <em>Hamad</em>:</p>

<p>第二种模式无法匹配，因为 <em>Hamadryas</em> 在 <em>Hamad</em> 之后有一个单词字符（一个字母）。下一个例子匹配，因为 <em>Hamad</em> 后面有一个空格：</p>

<pre><code>my $name = 'Ali Hamad bin Perliana';
say $name ~~ / Hamad &lt;|w&gt; /;  # ｢Hamad｣
</code></pre>

<p>Word boundaries on each side isolate a word. These matches look for <code>dry</code> as its own word because it has word boundaries on each side. The first one fails because it’s in the middle of a bigger word:</p>

<p>每一边的单词边界隔离一个单词。这些匹配寻找 <code>day</code> 作为它们自己的单词，因为它的每一边都有单词边界。第一个失败，因为它在一个更大的单词的中间：</p>

<pre><code>$_ = 'Hamadryas';
say m/ &lt;|w&gt; dry &lt;|w&gt; /;  # Nil

$_ = 'The flower is dry';
say m/ &lt;|w&gt; dry &lt;|w&gt; /;  # ｢dry｣
</code></pre>

<p>Instead of <code>&lt;|w&gt;</code> you can use the <code>&lt;&lt;</code> or <code>&gt;&gt;</code> to point to where the nonword characters should be:</p>

<p>你可以使用 <code>&lt;&lt;</code> 或 <code>&gt;&gt;</code> 代替 <code>&lt;|w&gt;</code> 来指向非单词字符的位置：</p>

<pre><code>$_ = 'The flower is dry';
say m/ &lt;&lt; dry &gt;&gt; /;  # ｢dry｣
</code></pre>

<p>The arrows can point either way, but always toward the nonword characters:</p>

<p>箭头可以指向任一方向，但始终指向非单词字符：</p>

<pre><code>$_ = 'a!bang';
say m/ &lt;&lt; .+ &gt;&gt; /;   # ｢a!bang｣   - greedy
say m/ &lt;&lt; .+? &gt;&gt; /;  # ｢a｣        - nongreedy
say m/ &gt;&gt; .+ &gt;&gt; /;   # ｢!bang｣
say m/ &gt;&gt; .+ &lt;&lt; /;   # ｢!｣
</code></pre>

<p>The opposite of a word boundary assertion is <code>&lt;!|w&gt;</code>. That means that both sides of the assertion must be the same type of character—either both word characters or both nonword characters. Now the results are flipped:</p>

<p>单词边界断言的反义词是 <code>&lt;!|w&gt;</code>。这意味着断言的两边必须是相同类型的字符 - 两个单词字符或两个非单词字符。现在翻转结果：</p>

<pre><code>$_ = 'Hamadryas';
say m/ &lt;!|w&gt; dry &lt;!|w&gt; /;  # ｢dry｣

$_ = 'The flower is dry';
say m/ &lt;!|w&gt; dry &lt;!|w&gt; /;  # Nil
</code></pre>

<h2 id="代码断言">代码断言</h2>

<p>Code assertions are perhaps the most amazing and powerful part of regular expressions. You can inspect what’s happened so far and use arbitrarily complex code to decide if you accept that. If your code evaluates to <code>True</code>you satisfy the assertion and the pattern can keep matching. Otherwise, your pattern fails.</p>

<p>Your code for the assertion shows up in <code>&lt;?{}&gt;</code>. You can put almost anything you like in there:</p>

<p>代码断言可能是正则表达式中最令人惊讶和最强大的部分。你可以检查到目前为止发生了什么，并使用任意复杂的代码来决定你是否接受。如果你的代码求值为 <code>True</code> 则你满足断言，并且模式可以保持匹配。否则，你的模式将失败。</p>

<p>你的断言代码显示在 <code>&lt;?{}&gt;</code> 中。你可以把几乎任何你喜欢的东西放在那里：</p>

<pre><code>'Hamadryas' ~~ m/ &lt;?{ put 'Hello!' }&gt; /;   # Hello!
</code></pre>

<p>This matches no characters in <em>Hamadryas</em> but is also not the null pattern (which is not valid). From inside the assertion you get <code>Hello!</code> as output:</p>

<p>这与 <em>Hamadryas</em> 中的任何字符都不匹配，但也不是空模式（它是无效的）。从断言内你得到 <code>Hello!</code> 作为输出：</p>

<pre><code>put
    'Hamadryas' ~~ m/ &lt;?{ put 'Hello!' }&gt; /
        ?? 'Worked' !! 'Failed';
</code></pre>

<p>This first outputs from inside the assertion:</p>

<p>这首先从断言内部输出：</p>

<pre><code>Hello!
Worked!
</code></pre>

<p>Change the assertion so that <code>False</code> is the last expression:</p>

<p>更改断言，以便 <code>False</code> 是最后一个表达式：</p>

<pre><code>put
    'Hamadryas' ~~ m/ &lt;?{ put 'Hello!'; False }&gt; /
        ?? 'Worked' !! 'Failed';
</code></pre>

<p>You get much more output. As the code assertion fails the match cursor moves along the text and tries again. Each time the code assertion returns <code>False</code> it tries again. It keeps doing that until it gets to the end of the <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>:</p>

<p>你得到更多的输出。由于代码断言失败，匹配游标沿文本移动并再次尝试。每次代码断言返回 <code>False</code> 时，它再次尝试。它一直这样做，直到它到达<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>的结尾：</p>

<pre><code>Hello!
Hello!
Hello!
Hello!
Hello!
Hello!
Hello!
Hello!
Hello!
Hello!
Failed
</code></pre>

<p>Here’s something more complex. Suppose you want to match even numbers only. You could create a pattern that looks for an even digit at an end of a <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>:</p>

<p>这是更复杂的事情。假设你只想匹配偶数。你可以创建一个模式，在<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>的末尾查找偶数：</p>

<pre><code>say '538' ~~ m/ ^ \d* &lt;[24680]&gt; $ /;   # ｢538｣
</code></pre>

<p>With a code assertion you don’t care which digits you match as long as they are even. This makes the pattern a bit simpler by showing the complexity as code. Your intent may be clearer this way:</p>

<p>使用代码断言，只要它们是偶数，就不关心匹配哪些数字。通过将复杂性显示为代码，这使得模式更简单。你的意图可能会更加清晰：</p>

<pre><code>say '538' ~~ m/ ^ (\d+) &lt;?{ $0 %% 2 }&gt; /;
</code></pre>

<p>There’s a capture and that text also is divisible by two, so that match succeeds:</p>

<p>有一个捕获，该文本也可被 2 整除，因此匹配成功：</p>

<pre><code>｢538｣
 0 =&gt; ｢538｣
</code></pre>

<p>It stills works if the characters aren’t the ASCII decimal digits:</p>

<p>如果字符不是 ASCII 十进制数字，它仍然有效：</p>

<pre><code>say '١٣٨' ~~ m/ ^ (\d+) &lt;?{ $0 %% 2 }&gt; /;
</code></pre>

<p>Or even:</p>

<p>甚至：</p>

<pre><code>say '١٣٨' ~~ m/ ^ (\d+) &lt;?{ $0 %% ٢ }&gt; /;
</code></pre>

<h3 id="匹配ipv4-地址">匹配IPV4 地址</h3>

<p>Consider a pattern to match a dotted-decimal IP address. There are four decimal numbers from 0 to 255, such as 127.0.0.1 (the loopback address). You could write a pattern without an assertion, but you have to figure out how to restrict the range of the number:</p>

<p>考虑匹配点分十进制 IP 地址的模式。从 0 到 255 有四个十进制数，例如 127.0.0.1（环回地址）。你可以编写一个没有断言的模式，但你必须弄清楚如何限制数字的范围：</p>

<pre><code>my $dotted-decimal = rx/ ^
    [
    || [ &lt;[ 0 1 ]&gt; &lt;[ 0 .. 9 ]&gt; ** 0..2 ]  # 0 to 199
    || [
        2
        [
        || &lt;[ 0 .. 4 ]&gt; &lt;[ 0 .. 9 ]&gt;       # 200 to 499
        || 5 &lt;[ 0 .. 5 ]&gt;                  # 250 to 255
        ]
       ]
    ] ** 4 % '.'
    $
    /;

say '127.0.0.1' ~~ $dotted-decimal;  # ｢127.0.0.1｣
</code></pre>

<p>Matching on text to suss out numerical values means careful handling of each character position. That’s a lot of work and uses a feature you haven’t seen yet (alternations are coming up). You could reduce that to almost nothing with a code assertion that looks at the text you just matched and tells the pattern if you want to accept it:</p>

<p>匹配文本以取代数值意味着仔细处理每个字符位置。这是很多工作，并使用了你还没有看到的功能（备选分支即将到来）。你可以使用代码断言将其减少到几乎为零，该代码断言查看你刚匹配的文本并告诉模式你是否要接受它：</p>

<pre><code>my $easier = rx/
    ^
    ( &lt;[0..9]&gt;+: &lt;?{ 0 &lt;= $/ &lt;= 255 }&gt; ) ** 4 % '.'
    $
    /;
</code></pre>

<p>The assertion is <code>&lt;?{ 0 &lt;= $/ &lt;= 255 }&gt;</code>. That <code>$/</code> is the <a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a> for only that level of parentheses. This allows you to be sloppy in the pattern for matching digits. You don’t care if you match 4, 5, or 20 digits because the code assertion will check that.</p>

<p>If that code assertion fails after matching digits, you don’t want to give back some of the digits to try again. You know the next thing must be the <code>.</code> between groups of digits. To prevent any backtracking you use the <code>:</code> on that <code>+</code>quantifier. You don’t need this to get the right match but it creates less work to ultimately fail.</p>

<p>The <code>%</code> modifies the <code>** 4</code> quantifier so a literal <code>.</code> shows up between each of the four groups of digits.</p>

<p>断言是 <code>&lt;?{ 0 &lt;= $/ &lt;= 255 }&gt;</code> 那个 <code>$/</code> 是只有那个括号级别的<a href="https://docs.perl6.org/type/Match.html"><code>Match</code></a>。这允许你在匹配数字的模式中马虎。你不关心是否匹配 4, 5 或 20 位数字，因为代码断言将检查该数字。</p>

<p>如果代码断言在匹配数字后失败，则你不希望归还一些数字再次尝试。你知道下一件事必须是数字组之间的  <code>.</code> 。要防止任何回溯，请在量词 <code>+</code> 上使用 <code>:</code>。你不需要这个来获得正确的匹配，但它创造的工作量最少，最终失败。</p>

<p><code>%</code> 修饰 <code>** 4</code> 量词，所以字面 <code>.</code> 显示在四组数字中的每一组之间。</p>

<h1 id="alternations">Alternations</h1>

<p>Sometimes there are several distinct patterns that might match at the same position. An alternation is a way to specify that. There are two ways to do this: it can match the first alternative that succeeds or it can match the longest one.</p>

<p>有时，有几种不同的模式可能在同一位置匹配。交替是一种指定它的方式。有两种方法可以做到这一点：它可以匹配成功的第一个选项，也可以匹配最长的选项。</p>

<h2 id="first-match">First Match</h2>

<p>If you’ve used regexes in other languages you’re probably used to alternations where the leftmost alternative that can match is the one that wins. Set up this type of alternation with a <code>||</code> between the possibilities:</p>

<p>如果你已经在其他语言中使用了正则表达式，那么你可能会习惯于可以匹配的最左侧备选分支胜出的备选分支。使用 <code>||</code> 在可能的备选分支之间设置此类备选分支：</p>

<pre><code>my $pattern = rx/ abc || xyz || 1234 /;
</code></pre>

<p>Either <code>abc</code>, <code>xyz</code>, or <code>1234</code> can match:</p>

<pre><code>my @strings = &lt; 1234 xyz abc 789 &gt;;
for @strings {
    put &quot;$_ matches&quot; if $_ ~~ $pattern;
}
</code></pre>

<p>The first three <a href="https://docs.perl6.org/type/Str.html"><code>Str</code></a>s match because they have at least one of the alternatives:</p>

<p>前三个<a href="https://docs.perl6.org/type/Str.html"><code>字符串</code></a>匹配，因为他们至少有一个备选分支：</p>

<pre><code>1234 matches
xyz matches
abc matches
</code></pre>

<p>The alternation has an interesting feature: you can start it with a <code>||</code> with nothing before it. This is the same pattern and does not create an empty alternative at the beginning:</p>

<p>备选分支有一个有趣的特点：你可以以一个前面什么都没有的 <code>||</code> 开始。这是相同的模式，并且不会在开头创建一个空的备选分支：</p>

<pre><code>my $pattern = rx/ || abc || xyz || 1234 /;
</code></pre>

<p>This looks better spread out so each alternation gets its own line. The reformatted pattern starts with <code>||</code> and has a more pleasing parallel structure that allows you to remove lines without disturbing the other alternatives:</p>

<p>这看起来更好地展开，因此每个备选分支单独占一行。重新格式化的模式以 <code>||</code> 开头并且有一个更令人愉悦的并行结构，允许你删除行而不会打扰其他备选分支：</p>

<pre><code>my $pattern = rx/
    || abc
    || xyz
    || 1234
    /;
</code></pre>

<p>Instead of placing a <code>||</code> between each alternative, you can put it before a bunch of alternatives. Do that with an <a href="https://docs.perl6.org/type/Array.html"><code>Array</code></a> directly in your pattern:</p>

<p>你可以把 <code>||</code> 放在一堆备选分支之前而不是在每个备选分支之间放置 <code>||</code>。直接在你的模式中使用<a href="https://docs.perl6.org/type/Array.html"><code>数组</code></a>执行此操作：</p>

<pre><code>my $pattern = rx/ || @(&lt;abc xyz 1234&gt;) /;
</code></pre>

<p>An existing variable after the <code>||</code> does the same thing:</p>

<p><code>||</code> 之后的现有变量做同样的事情：</p>

<pre><code>my @variable = &lt;abc xyz 1234&gt;;
my $pattern = rx/ || @variable /;
</code></pre>

<p>You aren’t interpolating that <a href="https://docs.perl6.org/type/Array.html"><code>Array</code></a>. The pattern uses the current value of the <a href="https://docs.perl6.org/type/Array.html"><code>Array</code></a> when it matches. In this example the <a href="https://docs.perl6.org/type/Array.html"><code>Array</code></a> has <code>1234</code> as the last element when you define the pattern. Before you use the pattern you change that last element:</p>

<p>你没有插值该<a href="https://docs.perl6.org/type/Array.html"><code>数组</code></a>。该模式在匹配时使用<a href="https://docs.perl6.org/type/Array.html"><code>数组</code></a>的当前值。在此示例中，<a href="https://docs.perl6.org/type/Array.html"><code>数组</code></a> 在定义模式时将 <code>1234</code> 作为最后一个元素。在使用该模式之前，你需要更改最后一个元素：</p>

<pre><code>my @strings = &lt; 1234 xyz abc 56789 &gt;;
my @variable = &lt;abc xyz 1234&gt;;
my $pattern = rx/ || @variable /;

put &quot;Before:&quot;;
for @strings {
    put &quot;\t$_ matches&quot; if $_ ~~ $pattern;
}

# change the array after making the pattern
@variable[*-1] = 789;

put &quot;After:&quot;;
for @strings {
    put &quot;\t$_ matches&quot; if $_ ~~ $pattern;
}
</code></pre>

<p>The output shows that you matched with the current value of the variable instead of its value when you created the pattern. Different values match after you change the <a href="https://docs.perl6.org/type/Array.html"><code>Array</code></a>:</p>

<p>输出显示你匹配的变量的当前值，而不是匹配该模式创建时的值。更改<a href="https://docs.perl6.org/type/Array.html"><code>数组</code></a>后，匹配到不同的值：</p>

<pre><code>Before:
    1234 matches
    xyz matches
    abc matches
After:
    xyz matches
    abc matches
    56789 matches
</code></pre>

<p>EXERCISE 16.8Output all the lines from the butterfly census file that have the genus <em>Lycaena</em>, <em>Zizeeria</em>, or <em>Hamadryas</em>. How many different species did you find?</p>

<p>练习16.8 输出蝴蝶人口普查文件中有 *Lycaena*，<em>Zizeeria</em> 或 <em>Hamadryas</em> 属的所有行。你找到了多少种不同的物种？</p>

<h2 id="longest-token-matching">Longest Token Matching</h2>

<p>Some alternations might have “better” possibilities that could match. Rather than choosing the first specified possibility you can tell the match operator to try all of them, then choose the “best” one. This is generally calledlongest token matching (LTM), but it finds the best, not longest, match.</p>

<p>LTM alternation uses a single <code>|</code>. In this pattern all of the alternatives can match. The first possibility it could match is the single <code>a</code>. The “best” match is <code>abcd</code>, though. That’s the match you see in the output:</p>

<p>一些备选分支可能具有可以匹配的“更好”的可能性。你可以告诉匹配操作符尝试所有这些，然后选择“最佳”的可能性，而不是选择第一个指定的可能性。这通常称为最长令牌匹配（LTM），但它找到最佳匹配，而不是最长匹配。</p>

<p>LTM 备选分支使用单个 <code>|</code>。在这种模式中，所有备选分支都可以匹配。它可以匹配的第一种可能性是单个 <code>a</code>。不过，“最佳”匹配是 <code>abcd</code>。这是你在输出中看到的匹配：</p>

<pre><code>my $pattern = rx/
    | a
    | ab
    | abcd
    /;

say 'abcd' ~~ $pattern;  # ｢abcd｣
</code></pre>

<p>An <a href="https://docs.perl6.org/type/Array.html"><code>Array</code></a> variable works just like it did in the <code>||</code> examples:</p>

<p><a href="https://docs.perl6.org/type/Array.html"><code>数组</code></a>变量就像在 <code>||</code> 例子中一样工作：</p>

<pre><code>my @variable = &lt;a ab abcd&gt;;
my $pattern = rx/ | @variable /;

say 'abcd' ~~ $pattern;  # ｢abcd｣
</code></pre>

<p>What makes one possibility better than another? There are some rules that decide this. Better patterns have longer tokens, and that’s where the confusion comes in. It’s not actually about how much text it matches; it’s about the pattern.</p>

<p>This next part will probably be more than you’ll ever want to know. A pattern can have both declarative and procedural elements. In short, some parts of the pattern merely describe some text and other parts force the match operator to do something. The <code>abc</code> is declarative. The <code>{}</code> inline code is an action.</p>

<p>Consider this example. The longest text that might match is <em>Hamadry</em>. That alternative has the <code>{True}</code> inline code block in it, though. The second alternative is simply <code>Hamad</code>, and that is the one that matches:</p>

<p>是什么让一种可能性比另一种更好？有一些规则可以决定这一点。更好的模式有更长的令牌，这就是困惑的来源。实际上并不是它匹配多少文本;这是关于模式的。</p>

<p>下一部分可能比你想知道的要多。模式可以同时具有声明和过程元素。简而言之，模式的某些部分仅描述一些文本，而其他部分则强制匹配操作符执行某些操作。 <code>abc</code> 是声明性的。 <code>{}</code> 内联代码是一个动作。</p>

<p>请看这个例子。可能匹配的最长文本是 *Hamadry*。但是，该备选分支中包含 <code>{True}</code> 内联代码块。第二个备选分支只是 <code>Hamad</code>，那是匹配的：</p>

<pre><code>say 'Hamadryas perlicus sixus' ~~ m/
    | Hama{True}dry
    | Hamad
    /;  # ｢Hamad｣
</code></pre>

<p>When the match operator is deciding which one has priority it looks for the pattern that has the longest declarative part. The first one has <code>Hama</code>; the second one has <code>Hamad</code>. That makes the second one the longer token. It’s about the pattern, not the target text. (Ignore that you haven’t read a definition of a token yet.)</p>

<p>Sometimes the two patterns can have the same size tokens, like these two alternatives. One has a character class and the other a literal <em>d</em>. The more specific one (the literal) wins:</p>

<p>当匹配运算符决定哪一个具有优先级时，它会查找具有最长声明部分的模式。第一个有 <code>Hama</code>;第二个有 <code>Hamad</code>。这使得第二个有更长的令牌。它是关于模式，而不是关于目标文本。 （忽略你还没有读过令牌的定义。）</p>

<p>有时这两种模式可以具有相同大小的令牌，就像这两个备选分支一样。一个有字符类，另一个有字面值 *d*。更具体的一个（字面的）获胜：</p>

<pre><code>$_ = 'Hamadryas perlicus sixus';

say 'Hamadryas perlicus sixus' ~~ m/
    | Hama&lt;[def]&gt;{put &quot;first&quot;}
    | Hamad      {put &quot;second&quot;}
    /;  # ｢Hamad｣
</code></pre>

<p>The code <a href="https://docs.perl6.org/type/Block.html"><code>Block</code></a>s are only there to show which alternative was “best”:</p>

<p>代码<a href="https://docs.perl6.org/type/Block.html"><code>块</code></a>仅用于显示哪种备选分支“最佳”：</p>

<pre><code>second
｢Hamad｣
</code></pre>

<p>Change that around to see it still choose the more specific one:</p>

<p>改变它，看它仍然选择更具体的一个：</p>

<pre><code>$_ = 'Hamadryas perlicus sixus';

say 'Hamadryas perlicus sixus' ~~ m/
    | Hamad      {put &quot;first&quot;}
    | Hama&lt;[def]&gt;{put &quot;second&quot;}
    /;  # ｢Hamad｣
</code></pre>

<p>Now the first alternative is more specific and it is “best”:</p>

<p>现在第一个备选分支更具体，它是“最好的”：</p>

<pre><code>first
｢Hamad｣
</code></pre>

<p>So what counts as a <em>token</em>? It’s the longest stretch of things that aren’t procedural. As I write this, however, the documentation avoids defining that. It requires deep knowledge of what happens in the guts of the language. It’s a big ugly topic that I’ll now ignore, although the book <em>Mastering Regular Expressions</em> by Jeffrey E.F. Friedl(O’Reilly) will tell you most of what you need to know. Perhaps the confusion will sort itself out by the time you read this.</p>

<p>什么算作 <em>token</em> 呢？这是最长的一些不是程序性的东西。然而，当我写这篇文章时，文档避免了定义它。它需要深入了解语言的内容。虽然 Jeffrey E.F.Friedl（O&rsquo;Reilly）的“掌握正则表达式”这本书将告诉你大部分你需要知道的东西，但我现在忽略了一个很大的丑陋主题。也许当你读到这篇文章时，这种困惑会自行解决。</p>

<p>All of that is to say that the match operator looks at each <code>|</code> alternative and can choose to do the one it thinks provides the best match. The match operator does not have to do them in the order that you typed them.</p>

<p>所有这一切都是说匹配运算符会查看每个 <code>|</code> 备选分支，并可以选择做它认为提供最佳匹配的那个。匹配运算符不必按你键入的顺序执行它们。</p>

<h1 id="summary">Summary</h1>

<p>In this chapter you saw the common regex features that will solve most of your pattern problems. You can repeat parts of a pattern, capture and extract parts of the text, define alternate patterns that can match, and specify conditions within the pattern. There is much more that patterns can do for you. Practice what you’ve read here and delve into the documentation to discover more.</p>

<p>在本章中，你看到了可以解决大多数模式问题的常见正则表达式功能。你可以重复模式的某些部分，捕获和提取文本的某些部分，定义可以匹配的备选分支模式，以及指定模式中的条件。模式可以为你做更多的事情。练习你在这里阅读的内容并深入研究文档以发现更多信息。</p>


        
          <div class="blog-tags">
            
              <a href="https://ohmysummer.github.io//tags/learningperl6/">LearningPerl6</a>&nbsp;
            
          </div>
        

        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="https://ohmysummer.github.io/post/2018-09-15-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-toggle="tooltip" data-placement="top" title="第十五章. 正则表达式">&larr; Previous Post</a>
            </li>
          
          
            <li class="next">
              <a href="https://ohmysummer.github.io/post/2018-09-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0.-grammars/" data-toggle="tooltip" data-placement="top" title="第十七章. Grammars">Next Post &rarr;</a>
            </li>
          
        </ul>
      


      
        
          <div class="disqus-comments">
            <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "ohmysummer" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
        
        
      

    </div>
  </div>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            
            <a href="https://ohmysummer.github.io/index.xml" title="RSS">
            
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://ohmysummer.github.io/">焉知非鱼</a>
            
          

          <span style="color: red;">❤</span>&nbsp;Perl 6
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.53</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://ohmysummer.github.io/js/main.js"></script>
<script src="https://ohmysummer.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script>
<script src="https://ohmysummer.github.io/js/load-photoswipe.js"></script>


<script>
  (function() {
    var cx = '009072066163920799339:qwme9vkotxk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>





  </body>
</html>

