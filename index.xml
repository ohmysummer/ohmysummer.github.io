<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rakudo Perl 6</title>
    <link>https://ohmysummer.github.io/</link>
    <description>Recent content on Rakudo Perl 6</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 31 Jul 2019 20:22:08 +0800</lastBuildDate>
    
        <atom:link href="https://ohmysummer.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Parse with Perl6 Regexes and Grammars</title>
      <link>https://ohmysummer.github.io/post/2019-07-31-parse-with-perl6-regexes-and-grammars/</link>
      <pubDate>Wed, 31 Jul 2019 20:22:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-07-31-parse-with-perl6-regexes-and-grammars/</guid>
      <description>&lt;p&gt;启动翻译。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Encode-Decode</title>
      <link>https://ohmysummer.github.io/post/2019-07-16-encode-decode/</link>
      <pubDate>Tue, 16 Jul 2019 18:56:48 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-07-16-encode-decode/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://blogs.perl.org/users/damian_conway/2019/07/vigenere-vs-vigenere.html&#34;&gt;http://blogs.perl.org/users/damian_conway/2019/07/vigenere-vs-vigenere.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;第&lt;a href=&#34;https://perlweeklychallenge.org/blog/perl-weekly-challenge-015/&#34;&gt;15 届 Perl 每周挑战赛&lt;/a&gt;的第二项任务是为 &lt;em&gt;Vigenère Cipher&lt;/em&gt; 实现编码器和解码器。但这比看起来要复杂得多，因为以 Blaisede Vigenère 命名的密码实际上并不是由他发明的，而 Vigenère 实际发明的密码并不是以他的名字命名的。&lt;/p&gt;

&lt;p&gt;那么我们应该实现 &lt;em&gt;Vigenère Cipher&lt;/em&gt; 加密&amp;hellip;还是 Vigenère 加密？为什么不两个都要呢！&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Vigenère Cipher&lt;/em&gt; 是由吉奥万·巴蒂斯塔·贝拉索于 1553 年制定的，然后错误归因到约三百年后的 Vigenère 身上。它使用&lt;a href=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Vigen%C3%A8re_square_shading.svg/800px-Vigen%C3%A8re_square_shading.svg.png&#34;&gt;&lt;em&gt;tabularēcta&lt;/em&gt;&lt;/a&gt; 把消息文本转换为密文，然后再转回去。&lt;/p&gt;

&lt;p&gt;给定用户提供的密钥（&lt;em&gt;例如&lt;/em&gt; &amp;ldquo;BELLASO&amp;rdquo;），我们通过匹配密钥和消息的相应字母来加密消息（&lt;em&gt;例如&lt;/em&gt; &lt;code&gt;&amp;quot;VIGENEREDIDNOTINVENTTHIS&amp;quot;&lt;/code&gt;），然后将它们用作两个索引以在 &lt;em&gt;rēcta&lt;/em&gt; 表的适当列和行中&lt;a href=&#34;https://s3-eu1.ixquick.com/cgi-bin/serveimage?url=http:%2F%2Fcrypto.interactive-maths.com%2Fuploads%2F1%2F1%2F3%2F4%2F11345755%2F2756220_orig.jpg&amp;amp;sp=66e4579b7c3e415cfddd9ad0ff0a31ca&#34;&gt;查找&lt;/a&gt;对应的密码字符。如果密钥短于消息，我们只需根据需要多次循环密钥。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Key:  B E L L A S O B E L L A S O B E L L A S O B E L L A...
       Text:  V I G E N E R E D I D N O T I N V E N T T H I S
      Table:  ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓↓ ↓ ↓
     Cipher:  W M R P N W F F H T O N G H J R G P N L H I M D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换句话说，&lt;em&gt;tabularēcta&lt;/em&gt; 的每一列是单独的&lt;a href=&#34;https://en.wikipedia.org/wiki/Caesar_cipher&#34;&gt;&lt;em&gt;Caesar Cipher&lt;/em&gt;&lt;/a&gt; （或&lt;a href=&#34;https://en.wikipedia.org/wiki/ROT13&#34;&gt;&lt;em&gt;ROT-N&lt;/em&gt;&lt;/a&gt;转录），其中每个连续的密钥字母选择在消息中的相应字母上执行哪个替换。&lt;/p&gt;

&lt;p&gt;这种方法在 16 世纪被广泛认为是*“难以理解的”*，尽管查尔斯·巴贝奇在 1854 年“重新发现”的两周内打破了它的一个例子，弗里德里希·卡基斯基在不到十年之后发表了可靠的一般攻击。尽管如此，&lt;em&gt;Vigenère Cipher&lt;/em&gt; 提供合理的安全性，提供的选择的关键是足够长的时间和不同寻常，足以防止简单的字典攻击。讽刺的是，我们稍后会看到，Vigenère’ 的实际密码优雅解决了这两个问题。&lt;/p&gt;

&lt;p&gt;为了实现 *VigenèreCipher*，我们首先需要构建一个 *tabularēcta*。在 Perl 6 中，这只是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;constant @alphabet = [&#39;A&#39;...&#39;Z&#39;];

    constant @𝑡𝑎𝑏𝑢𝑙𝑎-𝑟𝑒̄𝑐𝑡𝑎
        = @alphabet, *.rotate ... *.head eq @alphabet.tail;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该表只是一个数组序列，其中第一个是原始字母表，其余的是通过获取前一个数组并循环旋转一个字符（&lt;code&gt;*.rotate&lt;/code&gt;）来构造的。所以 &lt;code&gt;[&#39;A&#39;...&#39;Z&#39;]&lt;/code&gt; 后面跟着 &lt;code&gt;[&#39;B&#39;...&#39;Z&#39;, &#39;A&#39;]&lt;/code&gt;，其后依次跟着 &lt;code&gt;[&#39;C&#39;...&#39;Z&#39;, &#39;A&#39;...&#39;B&#39;]&lt;/code&gt;。清洗并重复，直到我们最终生成一个旋转，其中第一个字母（&lt;code&gt;*.head&lt;/code&gt;）是原始字母表的最后一个字母（&lt;code&gt;@alphabet.tail&lt;/code&gt;）。换句话说， 我们生成每个轮换直到达到 &lt;code&gt;[&#39;Z&#39;, &#39;A&#39;...&#39;Y&#39;]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;请注意，我们可以通过替换 &lt;code&gt;@alphabet&lt;/code&gt; 的内容来更改我们正在使用的字母表。例如，如果我们想用密钥 &lt;code&gt;&amp;quot;I❤️Bellaso&amp;quot;&lt;/code&gt; 编码 &lt;code&gt;&amp;quot;Vigenère did NOT invent this!&amp;quot;&lt;/code&gt; 那样的消息一样 ，那么我们就像这样重新配置字母：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;    # Valid message characters are all printable Latin-1 + lurve...
    constant @alphabet = [&#39; &#39;...&#39;ÿ&#39;, &#39;❤️&#39;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 6 是一种现代语言，在数据和源代码中内置支持完整的 Unicode 字符集，所以完全可以使用带表情符号的字符串 &lt;code&gt;&amp;quot;I❤️Bellaso&amp;quot;&lt;/code&gt;，或者声明像 &lt;code&gt;@𝑡𝑎𝑏𝑢𝑙𝑎-𝑟𝑒̄𝑐𝑡𝑎&lt;/code&gt; 这样的变量，其名称包含那些奇怪的 &lt;a href=&#34;https://unicode-search.net/unicode-namesearch.pl?term=MATHEMATICAL%20ITALIC&#34;&gt;Unicode 数学斜体&lt;/a&gt; 字符甚至是组合的标记(ēvēn ā cōmbīnīng mārk)。&lt;/p&gt;

&lt;p&gt;使用斜体的 Unicode 变量名称可能看起来很疯狂，但这也意味着我们不再受英语国家语言帝国主义的限制。 我们可以用我们通常所说的语言自然地命名它，而不是被迫命名一个关键变量 &lt;code&gt;$cipher-text&lt;/code&gt;。&lt;code&gt;$texte-chiffré&lt;/code&gt; 或 &lt;code&gt;$النص-المشفر&lt;/code&gt; 或 &lt;code&gt;$加密文字&lt;/code&gt; 或 &lt;code&gt;$Κρυπτογραφημένο-κείμενο&lt;/code&gt; 甚至 &lt;code&gt;$ĉifrita- teksto&lt;/code&gt;。 Perl 6 旨在为全球 100％ 的程序员提供支持。&lt;/p&gt;

&lt;p&gt;我们可以直接使用我们的 &lt;code&gt;@𝑡𝑎𝑏𝑢𝑙𝑎-𝑟𝑒̄𝑐𝑡𝑎&lt;/code&gt; 数组来查找给定文本/键字符对的密码字符，但这样做有点笨拙。我们需要将每个字符转换回整数 ASCII 码（通过内置的 &lt;code&gt;.ord&lt;/code&gt; 方法），然后将其归一化为 0..25 范围的表索引，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;    my $key-index   = $key-char.ord  - &#39;A&#39;.ord;
    my $text-index  = $text-char.ord - &#39;A&#39;.ord;

    my $cipher-char = @𝑡𝑎𝑏𝑢𝑙𝑎-𝑟𝑒̄𝑐𝑡𝑎[$key-index][$text-index];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们后面切换到包含 &lt;code&gt;&#39;❤️&#39;&lt;/code&gt; 的非连续字母表，那么代码会变得更加复杂。&lt;/p&gt;

&lt;p&gt;如果 2D 查找表是 2D 字典（在 Perl 6 行话：*哈希*）中会更简单，并且可以直接用我们字母表中的实际字符索引，而不是从零开始的整数。&lt;/p&gt;

&lt;p&gt;这很容易安排：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;    constant %encoder
        = @𝑡𝑎𝑏𝑢𝑙𝑎-𝑟𝑒̄𝑐𝑡𝑎.map:
             { @^cipher.head =&amp;gt; hash @alphabet Z=&amp;gt; @^cipher }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，对于 &lt;em&gt;tabula rēcta&lt;/em&gt; 中的每个密码行（&lt;code&gt;@^cipher&lt;/code&gt;），我们构建一个哈希条目， 其键是旋转字母表的第一个字母（&lt;code&gt;@^cipher.head&lt;/code&gt;）， 其值是嵌套的哈希，它映射每个字母的每个字母。字母到密码行中的对应字母（&lt;code&gt;@alphabet Z=&amp;gt; @^cipher&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Z=&amp;gt;&lt;/code&gt; 操作者拉链一起相应的它的两个列表元素 参数，每两个传递到一对的构造，所以 操作产生像散列条目：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;  # Key     Text-&amp;gt;Cipher, etc.

    &#39;M&#39; =&amp;gt; %(&#39;A&#39;=&amp;gt;&#39;M&#39;, &#39;B&#39;=&amp;gt;&#39;N&#39;, &#39;C&#39;=&amp;gt;&#39;O&#39; ... &#39;Y&#39;=&amp;gt;&#39;K&#39;, &#39;Z&#39;=&amp;gt;&#39;L&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以现在当我们想要查找适当的密码字符时，顶级哈希索引选择键列，而第二级哈希索引选择明文字符的行。像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;my $ciphertext-char = %encoder{$key-char}{$plaintext-char};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更好的是，使用这种基于散列的方法来构建2D *解码*字典同样简单，只需将嵌套映射从字母字符反转为密码字符即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;constant %decoder
        = @𝑡𝑎𝑏𝑢𝑙𝑎-𝑟𝑒̄𝑐𝑡𝑎.map: 
            { @^cipher.head =&amp;gt; hash @^cipher Z=&amp;gt; @alphabet }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后我们可以像这样解码一个加密的字符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;my $plaintext-char = %encoder{$key-char}{$ciphertext-char};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们有了这两个2D词典，*VigenèreCipher*就很容易实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub Vigenère (Str :$text!, Str :$key!, Bool :$decode --&amp;gt; Str) {

        # Extract lists of table indices from the two strings...
        my @textchars =  $text.comb;
        my @keychars  = |$key.comb xx ∞;

        # Chose our trancoder...
        my %recoder = $decode ?? %decoder !! %encoder;

        # Pair up indices, transcode, and concatenate the results...
        (@keychars Z=&amp;gt; @textchars)
            .map({ %recoder{.key}{.value} // 0.chr })
            .join;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子例程采用两个命名字符串参数：文本（明文或加密）和加密/解密密钥。该感叹号两个参数名称后告诉Perl 6的编译器所需要的两个参数。还有一个可选的命名 boolean参数（没有尾随感叹号），指示我们是否要解码。signature （）末尾的长箭头指定子例程返回一个字符串。&lt;code&gt;--&amp;gt; Str&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在子例程中，我们首先将文本字符串和键分成单个字符（和）的列表。我们还 需要重复键字符序列，以便键至少 与文本字符串一样长。我们可以准确地计算出 需要多少次重复，但是只需要 经常无限地重复键（）就更容易了。 需要在开头的垂直条来展平关键字符列表。否则， 我们最终会得到一个重复的键列表列表，而不是重复的键字符列表 。&lt;code&gt;$text.comb&lt;/code&gt;&lt;code&gt;$key.comb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|$key.comb xx ∞
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们根据我们是否正在解码来选择我们需要的两个编码字典中的哪一个。在Perl 6中，三元选择运算符是&lt;code&gt;*真值*&lt;/code&gt;&lt;code&gt;*假值*&lt;/code&gt;， 而不是&lt;code&gt;*真值*&lt;/code&gt;&lt;code&gt;*假值*&lt;/code&gt;。&lt;code&gt;*test* ??&lt;/code&gt;``` !!&lt;/p&gt;

&lt;p&gt;一旦我们完成了所有设置，实际的编码或解码是微不足道的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (@keychars Z=&amp;gt; @textchars)
        .map({ %recoder{.key}{.value} // 0.chr })
        .join;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们首先从下一个文本的每个字符匹配的连续字符从重复键，再次使用的*拉链成-A-列表中，对*运营商（间） 两个列表：&lt;code&gt;Z=&amp;gt;&lt;/code&gt;&lt;code&gt;(@keychars Z=&amp;gt; @textchars)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后，我们通过查找查找表中的每个关键字符（）和每个 对应的文本字符（），将该对列表映射到加密/解密字符列表。如果 字符组合没有可用的转换，我们只 使用空字符（）作为占位符。这可确保 指定字母表外的任何字符都清晰地映射 到加密字符串之外，而不会影响其将来的解密。&lt;code&gt;.key&lt;/code&gt;&lt;code&gt;.value&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;转换完所有字符后，只需连接列表（）即可生成最终字符串。&lt;code&gt;.join&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这就是*VigenèreCipher*。&lt;/p&gt;

&lt;p&gt;那么Vigenère的密码呢？&lt;/p&gt;

&lt;p&gt;上面讨论的加密技术作为密码具有一些严重的缺点。1863年，Friedrich Kasiski观察到重复密钥字符串以生成足够长的密钥意味着单个加密消息有时可以重复使用*表格rēcta*的相同列来编码稍后在原始消息中重现的相同序列的明文字符。&lt;/p&gt;

&lt;p&gt;所以，如果我们拦截一个加密的字符串，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LLGMMZWRGIIVATJVVBKRVMMZWRGIILLEDCIVATJVV
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;然后，相对容易发现两个地方，明文消息中的重复单词显然是使用相同关键字符的两个单独副本加密的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LLGMMZWRGIIVATJVVBKRVMMZWRGIILLEDCIVATJVV

LLGMMZWRGIIVATJVVBKRVMMZWRGIILLEDCIVATJVV
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个明显的单词重复发生在18个字符之间，所以如果这两个单词使用相同的关键字符编码，则密钥必须在18个字符后重复。这意味着密钥长度必须是18或某个18的整数因子（&lt;em&gt;即&lt;/em&gt; 9,6,3,2或1）。第二次重复发生间隔24个字符，因此密钥长度必须同时为24的某个因子（&lt;em&gt;即&lt;/em&gt; 12,8,6,4,3,2或1）。由于在两种情况下它都是相同的密钥，因此密钥长度必须是18和24 的*共同*因子：6,3,2或1。&lt;/p&gt;

&lt;p&gt;考虑到这些可能性，关键字很可能是6个字符长，因为从心理上讲，其他长度太短。在这种情况下，我们可以简单地通过使用所有17706英语六字母单词尝试字典攻击来解码消息。&lt;/p&gt;

&lt;p&gt;要做到这一点，我们首先需要知道最可能的密钥长度是什么：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub large-factors ($n) { set (4..$n).grep($n %% *) }

    my $gap
        = any keys [∩] map {large-factors(.&amp;lt;gap&amp;gt;.chars)},
          $encoded ~~ m:ex/$&amp;lt;gap&amp;gt;=[ $&amp;lt;seq&amp;gt;=[. ** 3..*] .+] $&amp;lt;seq&amp;gt;/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，我们穷尽地匹配（）编码文本与正则表达式匹配，该正则表达式 定位三个或更多连续字符 （）的任何序列，然后是空格（），然后是前一个字符 序列（）。然后我们确定每个间隙的长度 （），建立一个集合每个长度 （）的重要因子，并采取这些 集合的交集（）来找到共同的因素。最后，我们 使用结点将得到的公共因子集转换为单个值。 随后，我们将能够将字长与该结相匹配， 以选择适当长度的潜在关键字。&lt;code&gt;m:ex&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一旦我们知道解密密钥有多长，我们就可以加载一个合适的字典并过滤它以获得合适的候选密钥：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @candidate-keys
        = &#39;/usr/share/dict/words&#39;.IO.lines.grep(*.chars==$gap)».uc;

    my @common-words
        = &#39;/usr/share/dict/common&#39;.IO.lines.grep(*.chars &amp;gt; 2)».uc;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们只保留适当长度的单词： 我们还加载了第二个较小的常用单词词典，我们将用它 来检测合理的解密。&lt;code&gt;.grep(*.chars==$gap)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后我们用适当长度的每个可能的密钥解密密文，并打印出任何似乎包含可信数量的英文单词的解密：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;# Request text to be deciphered...
    my $encoded = prompt &amp;quot;Ciphertext: &amp;quot;;

    # Try each potential key...
    for @candidate-keys -&amp;gt; $key {

        # Decrypt with that key...
        my $candidate = Vigenère( :text($encoded), :$key, :decode);

        # Count any real words found in the decryption...
        my $found = 0;
        for @common-words -&amp;gt; $word {

            # Report any plausible decryptions found...
            if $candidate.contains($word) &amp;amp;&amp;amp; ++$found &amp;gt; 3 {
                say &amp;quot;$key --&amp;gt; $candidate&amp;quot;;
                last;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在不到20秒的时间内产生：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ciphertext: LLGMMZWRGIIVATJVVBKRVMMZWRGIILLEDCIVATJVV

HYDROA --&amp;gt; ENDVYZPTDRUVTVGEHBDTSVYZPTDRULEGALUVTVGEH
HYDROA --&amp;gt; ENDVYZPTDRUVTVGEHBDTSVYZPTDRULEGALUVTVGEH
HOGGIE --&amp;gt; EXAGEVPDACARTFDPNXDDPGEVPDACAHEQXWARTFDPN
SECRET --&amp;gt; THEVIGENERECIPHERISNTVIGENERESTABLECIPHER
STRICH --&amp;gt; TSPEKSEYPAGOIASNTUSYEEKSEYPAGETLMUGOIASNT
WAGGIE --&amp;gt; PLAGEVARACARETDPNXORPGEVARACAHPEXWARETDPN
WEDGIE --&amp;gt; PHDGEVANDCAREPGPNXONSGEVANDCAHPAAWAREPGPN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的根本问题（与许多密码技术一样）是密钥*太短*。我们可以坚持要求用户提供至少与实际消息一样长的密钥：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub Vigenère (
        Str  :$text!,
        Str  :$key! where { $key.chars &amp;gt;= $text.chars },
        Bool :$decode
        --&amp;gt; Str)
        {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而，在1586年，BlaisedeVigenère找到了一个更容易的解决方案：拿出他们提供的任何密钥，而不是用自己的额外副本扩展它，用消息的“随机”字符扩展密钥。&lt;/p&gt;

&lt;p&gt;也就是说，而不是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       Key: SECRETSECRETSECRETSECRETSECRETSECRETSECRET...
      Text: THEVIGENERECIPHERISNTVIGENERESTABLECIPHER
     Table: ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
    Cipher: LLGMMZWRGIIVATJVVBKRVMMZWRGIILLEDCIVATJVV
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;我们用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       Key: SECRETTHEVIGENERECIPHERISNTVIGENERESTABLECIPHER
      Text: THEVIGENERECIPHERISNTVIGENERESTABLECIPHER
     Table: ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
    Cipher: LLGMMZXUIMMIMCLVVKACAZZOWAXMMYXNFCIUBPIPV
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这在密文中不会产生明显的重复，因为明文中的重复单词不再被重复单个短键加密。这种方法被称为一个&lt;a href=&#34;https://en.wikipedia.org/wiki/Autokey_cipher&#34;&gt;&lt;em&gt;自动密钥密码&lt;/em&gt;&lt;/a&gt;，因为完整的关键是对我们产生从消息本身自动。&lt;/p&gt;

&lt;p&gt;假设我们想扩展我们之前的&lt;code&gt;Vigenère&lt;/code&gt;子程序以提供自动密钥加密。我们可能只是在签名中添加另一个参数，然后根据实际提供的参数选择适当的行为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub Vigenère (
        Str :$text!,
        Str :$key,
        Str :$autokey,
        Bool :$decode
        --&amp;gt; Str
    ) {
        if    $autokey {...}
        elsif $key     {...}
        else           { fail &#39;Must specify :key or :autokey&#39; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是Perl 6支持多个调度，因此有一种更清晰的方法可以向&lt;code&gt;Vigenère&lt;/code&gt;子例程添加另一个互斥行为。我们简单地将现有代码从a &lt;code&gt;sub&lt;/code&gt;更改为&lt;code&gt;multi&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;**multi**&lt;/code&gt;&lt;code&gt;的V @ genere&lt;/code&gt;&lt;code&gt;(Str :$text!, Str :$key!, Bool :$decode --&amp;gt;Str)&lt;/code&gt;
&lt;code&gt;{&lt;/code&gt;
        &lt;em&gt;# Body exactly as before&lt;/em&gt;
&lt;code&gt;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后我们添加第二个multiply dispatched *变体*，带有一组不同的参数和一个不同的主体：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;multi Vigenère (Str :$text!, Str :$key!, Bool :$decode --&amp;gt; Str)
    {
        # Body exactly as before
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此版本需要参数，而不是参数。 然后立即重新分配到原始（Bellaso）变体，将文本 直接传递给未更改的（），但 通过将提供的自动键与文本连接来构造新的（非自动）键：&lt;code&gt;:autokey&lt;/code&gt;&lt;code&gt;:key&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;multi Vigenère (Str :$text!, Str :$autokey! --&amp;gt; Str) {
    Vigenère( :$text, :key($autokey ~ $text) );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释器总是知道&lt;code&gt;Vigenère的&lt;/code&gt;哪个变体在任何时候调用，因为它检查传递给每个调用的实际参数，并且不考虑任何其参数列表不接受那些特定参数的变体。这意味着，如果我们传递一个参数，解释器 将始终调用原始（Bellaso）变体，而如果我们传递一个 参数，则解释器将始终调用我们的新（Vigenère）变体。&lt;code&gt;:key&lt;/code&gt;&lt;code&gt;:autokey&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，这种新的自动密钥变种&lt;code&gt;的V @ genere&lt;/code&gt;子程序不允许一个说法。这是因为，虽然使用 自动键对文本进行编码只是Bellaso算法的一个小变化， 但再次解码它会稍微复杂一些。&lt;code&gt;:decode&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;要解码已自动加密的文本，我们显然需要原始加密密钥。但是在自动键系统中，大部分键都是由原始未加密的文本提供的。因此，为了取回未加密的文本，我们必须向解码器提供&amp;hellip;&amp;hellip;未加密的文本。Hmmmmm。&lt;/p&gt;

&lt;p&gt;当然，除了自动键的最初几个字符不是原始明文的一部分; 他们是仅有的人物经常键（&lt;em&gt;例如&lt;/em&gt; &lt;code&gt;&amp;quot;BELLASO&amp;quot;&lt;/code&gt;，&lt;code&gt;&amp;quot;SECRET&amp;quot;&lt;/code&gt;，*等*指定了）。&lt;/p&gt;

&lt;p&gt;鉴于此部分密钥，我们至少可以解密加密文本的许多初始字符。这给我们的前几个字符的原始邮件，所以我们可以立即使用这些字符作为关键的下一部分，使我们能够解密多一点的加密文本，从而给我们一些更多的信息字符，这给我们一些额外的关键字符，我们可以用它们提取几个明文字符，*等等等等*，直到整个文本被解码。&lt;/p&gt;

&lt;p&gt;在Perl 6中，看起来像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;    multi Vigenère (Str :$text!, Str :$autokey!, :$decode! --&amp;gt; Str)
    {
        # Break out text that was enciphered by the original key...
        my ($cipherkey, $ciphertext)
            = $text.split: /&amp;lt;?at: $autokey.chars&amp;gt;/;

        # Decipher that key-enciphered initial text...
        my @autokey
            = Vigenère( :text($cipherkey), :key($autokey), :decode )
                 .comb;

        # Progressively decipher the rest...
        [~] flat gather for $ciphertext.comb {
            FIRST take @autokey;
            @autokey.push:
               take %decoder{@autokey.shift}{$^cipherchar} // 0.chr;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Vigenèremultiisub的&lt;/code&gt;第三个变体需要三个必需的参数：文本，原始自动键和标志。所以这个变体 将*仅*解码自动密钥加密时被调用。&lt;code&gt;:decode&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们首先需要将文本分成两个字符串： 使用原始密钥（）加密的初始*N个*字符，以及 使用未加密的 消息本身（）加密的文本的其余部分。为此，我们调用文本字符串的方法，并将其传递给正则表达式。 在正则表达式匹配的地方，文本将被拆分，因此我们在正则表达式中使用断言，强制它仅匹配原始键的长度：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;/&amp;lt;?at: $autokey.chars&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们有了前*N个*字符&lt;code&gt;$cipherkey&lt;/code&gt;，我们可以通过调用原始 （Bellaso）解码变体简单地用原始密钥（in &lt;code&gt;$autokey&lt;/code&gt;）解密它们，我们通过将原始密钥作为参数传递而不是作为参数来调用。像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;Vigenère( :text($cipherkey), :key($autokey), :decode )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们使用该方法将解密的明文 转换为我们存储的字符列表。&lt;code&gt;.comb&lt;/code&gt;&lt;code&gt;@autokey&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;现在我们已经解密了明文的前*N个*字符，我们可以开始遍历剩余加密文本（）中的字符列表，使用下一个 已知的自动键字符（）来解密下一个 消息字符（）。 然后保存新解码的字符以用作后续的 自动键字符（）。&lt;/p&gt;

&lt;p&gt;当我们解密时，我们还需要捕获每个解码的字符，因此我们最终可以连接并将它们作为解密文本返回。最简单的方法是使用一个&lt;code&gt;gather&lt;/code&gt;块，它可以自动记住我们&lt;code&gt;take&lt;/code&gt;在其中的任何内容。&lt;/p&gt;

&lt;p&gt;在这种情况下，我们首先必须收集用原始密钥解密然后存储的所有初始字符&lt;code&gt;@autokey&lt;/code&gt;。所以我们讲的&lt;code&gt;for&lt;/code&gt;环路&lt;code&gt;take&lt;/code&gt;他们，但仅在其第一个迭代：&lt;/p&gt;

&lt;p&gt;然后每次我们解密循环中的另一个字符时，我们也必须&lt;code&gt;take&lt;/code&gt;这样做，就在我们将它推入&lt;code&gt;@autokey&lt;/code&gt;数组之前：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;@autokey.push:
        take %decoder{@autokey.shift}{$^cipherchar} // 0.chr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦解密&lt;code&gt;for&lt;/code&gt;循环终止，&lt;code&gt;gather&lt;/code&gt;它将返回我们传递给的所有内容的列表&lt;code&gt;take&lt;/code&gt;。我们将这些字符（）连接成一个字符串&amp;hellip;&amp;hellip;我们就完成了。&lt;code&gt;[~] flat&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所以现在，当我们想要*VigenèreCipher时*，我们写道：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;   $ciphertext
      = Vigenère( :text($plaintext), :key($secret) );

    # and later...

    $plaintext
      = Vigenère( :text($ciphertext), :key($secret), :decode );

And when we want Vigenère’s actual cipher, we write:

    $ciphertext
      = Vigenère( :text($plaintext), :autokey($secret) );

    # and later...

    $plaintext
      = Vigenère( :text($ciphertext), :autokey($secret), :decode );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们想要Vigenère的*实际*密码时，我们写道：&lt;/p&gt;

&lt;p&gt;如果你接受现代&lt;a href=&#34;https://en.wikipedia.org/wiki/Linguistic_relativity#Renewed_examination&#34;&gt;语言相对论&lt;/a&gt;，那么我们认为的语言可以塑造我们思考的方式。也许甚至限制在我们的方式*可以*考虑。&lt;/p&gt;

&lt;p&gt;编程语言是程序员思考解决方案的工具。所以，你的编程语言的选择，可以塑造你是怎么想的解决方案，甚至可能限制它是如何*可能*的，你想想他们。&lt;/p&gt;

&lt;p&gt;当你在思考世界上的解决方案时，语言模糊，计算复杂，如Vigenère（或我们的！），你需要一种语言足够复杂，计算机表达能力强的语言，使你能够清晰有效地思考。&lt;/p&gt;

&lt;p&gt;这就是我在Perl 6中编程的原因。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl 6 中的 奇偶排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-29-odd-even-sort-in-perl6/</link>
      <pubDate>Sat, 29 Jun 2019 19:37:39 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-29-odd-even-sort-in-perl6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Perl 6 中的煎饼排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-27-pancake-sort-in-perl6/</link>
      <pubDate>Sat, 29 Jun 2019 19:36:02 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-27-pancake-sort-in-perl6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Perl 6 中的 Gnome sort</title>
      <link>https://ohmysummer.github.io/post/2019-06-28-gnome-sort-in-perl6/</link>
      <pubDate>Fri, 28 Jun 2019 19:37:18 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-28-gnome-sort-in-perl6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Perl 6 中的 Stooge Sort</title>
      <link>https://ohmysummer.github.io/post/2019-06-26-stooge-sort-in-perl6/</link>
      <pubDate>Wed, 26 Jun 2019 19:35:43 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-26-stooge-sort-in-perl6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Perl 6 中的合并排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-25-merge-sort-in-perl6/</link>
      <pubDate>Tue, 25 Jun 2019 19:35:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-25-merge-sort-in-perl6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Perl 6 中的插入排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-24-insertion-sort-in-perl6/</link>
      <pubDate>Mon, 24 Jun 2019 19:19:06 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-24-insertion-sort-in-perl6/</guid>
      <description>&lt;p&gt;今天，我们研究插入排序算法及其在 Perl 6 中的可能实现。算法的复杂性是 O(n2)，但它是练习 Perl 6 的一个很好的选择。&lt;/p&gt;

&lt;p&gt;这个想法很简单。您可以在数组中找到最小值并将其放在第一个位置。然后从第二个位置开始扫描数据（因为第一个位置已经被最低元素占用）。然后你向右走，找到最小值并将它们放到当前位置直到你到达终点。&lt;/p&gt;

&lt;p&gt;它类似于选择排序，但不是交换两个元素，而是插入一个（因此，移动其他元素）。让我们从简单的方法和两个嵌套循环开始：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub insertion-sort(@data) {
    for ^@data -&amp;gt; $i {
        for ^$i -&amp;gt; $j {
            if @data[$i] &amp;lt; @data[$j] {
                @data.splice($j, 0, @data[$i]);
                @data.splice($i + 1, 1);
            }
        }
    }
}

my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10;
insertion-sort @data;
say @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Perl 6中，数组的拼接方法可以完成两个任务：用另一个元素列表替换数组的一部分，或者只是删除元素或一行中的一些元素。&lt;/p&gt;

&lt;p&gt;在上面的代码中，使用了该方法的两个应用程序。首先，将新找到的元素插入当前位置。其次，它从之前的位置删除（数组刚刚增长，因此索引变为$ i + 1）。&lt;/p&gt;

&lt;p&gt;由于splice方法也返回已删除的元素，我们可以将第二个调用放到正在读取元素的位置：@data [$ i]。因此，可以使用以下嵌套调用替换这两行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;@data.splice($j, 0, @data.splice($i, 1))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意，索引现在只是$ i，因为数组尚未修改。&lt;/p&gt;

&lt;p&gt;您应该已经熟悉了第二个可能的技巧：如果出现以下情况，请使用 &lt;code&gt;if&lt;/code&gt; 后缀：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub insertion-sort(@data) {
    for ^@data -&amp;gt; $i {
        for ^$i -&amp;gt; $j {
            @data.splice($j, 0, @data.splice($i, 1)) 
                if @data[$i] &amp;lt; @data[$j];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以在这一点上停下来，但我希望你还不满意。至少，两个嵌套的fors似乎是进一步思考的好领域。&lt;/p&gt;

&lt;p&gt;不幸的是，不可能直接使用交叉运算符来获得类似^ @ data X ^ @ data的东西，因为第二个列表依赖于第一个列表，但是有一种完全不同的简化代码的方法。&lt;/p&gt;

&lt;p&gt;最内部for循环的主要目标是找到数组中的第一个最小元素。 Perl 6为我们提供了第一种方法，它就是这样做的。&lt;/p&gt;

&lt;p&gt;默认情况下，它返回元素，但我们需要它的索引。您可以通过添加：k命名参数来实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;@data.first(* &amp;gt;= @data[$_], :k)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;裸：k相当于将参数设置为True :: k（True）或k =&amp;gt; True。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub insertion-sort(@data) {
    for ^@data -&amp;gt; $i {
        @data.splice(
            @data.first(* &amp;gt;= @data[$i], :k), 
            0,
            @data.splice($i, 1)
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，让剩下的for循环成为一个postfix子句，并且你完成了一个很好的单行函数（这里显示在不同的行上分成较短的部分）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub insertion-sort(@data) {
    @data.splice(
        @data.first(* &amp;gt;= @data[$_], :k), 
        0,
        @data.splice($_, 1)
    ) for ^@data;
}

my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10;
insertion-sort @data;
say @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一切都是现在，但如果你发现可以改进的东西，请在下面的评论中告诉我们。&lt;a href=&#34;https://github.com/ash/perl6-algorithms/blob/master/sort/insertion-sort-3.pl6&#34;&gt;源代码&lt;/a&gt;可在GitHub上获得。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&#34;https://perl6.online/2019/06/24/102-insertion-sort-in-perl-6/&#34;&gt;https://perl6.online/2019/06/24/102-insertion-sort-in-perl-6/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl 6 中的快速排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-23-quick-sort-in-perl6/</link>
      <pubDate>Sun, 23 Jun 2019 19:16:15 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-23-quick-sort-in-perl6/</guid>
      <description>&lt;p&gt;今天，我们来看看另一个，也许是最着名的数据排序方法，快速排序。&lt;/p&gt;

&lt;p&gt;该算法要求您选择所谓的枢轴，其中一个元素来自数据，并将其余部分分成两部分：小于枢轴的元素，以及大于或等于枢轴的元素。然后再次递归地对每个部分进行排序。在每次迭代中，部件变得越来越小，直到子列表是一个或甚至零个元素的平凡数据集。&lt;/p&gt;

&lt;p&gt;一个单独的理论是如何选择正确的枢轴。有几种方法，例如，从列表中间取值，或取第一项，或最后一项，或随机项。还有更复杂的方法，您可以调整它以在您的数据集类型上实现最佳性能。&lt;/p&gt;

&lt;p&gt;为简单起见，让我们选择第一个元素作为轴点，这是代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub quick-sort(@data) {    
    return @data if @data.elems &amp;lt;= 1;

    my $pivot = @data[0];

    my @left;
    my @right;

    for @data[1..*] -&amp;gt; $x {
        if $x &amp;lt; $pivot {
            push @left, $x;
        }
        else {
            push @right, $x;
        }
    }

    return flat(quick-sort(@left), $pivot, quick-sort(@right));
}

my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10;
@data = quick-sort @data;
say @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与之前的&lt;a href=&#34;https://perl6.online/2019/06/21/100-bubble-sort-in-perl-6/&#34;&gt;冒泡排序示例&lt;/a&gt;不同，此程序不会就地排序，而是返回新列表。&lt;/p&gt;

&lt;p&gt;现在是时候将代码转换为更具 Perl 6 风格代码的时候了。&lt;/p&gt;

&lt;p&gt;Multi-subs 再次来救援，在增加代码行数的同时，使整个算法在第一眼更容易捕捉到:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;multi sub quick-sort(@data where @data.elems &amp;lt;= 1) {
    return @data;
}

multi sub quick-sort(@data where @data.elems &amp;gt; 1) {
    my $pivot = @data[0];

    . . .
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，看看这两部分：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;my $pivot = @data[0];

. . .

for @data[1..*] -&amp;gt; $x {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要采用第一个元素，算法的其余部分仅处理列表的其余部分。目前，这是通过获取元素和切片来实现的，但是有一种切换方法可以完全满足我们的需要，并从数据中删除元素。所以，让我们使用它&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;my $pivot = @data.shift;

. . .

for @data -&amp;gt; $x {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来是 &lt;code&gt;if-else&lt;/code&gt; 选择，可以有效地（尽管可能效率稍差）用两个 &lt;code&gt;grep&lt;/code&gt; 替换：一个选择枢轴之前的部分，另一个选择其余部分。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;my @left = @data.grep(* &amp;lt; $pivot);
my @right = @data.grep(* &amp;gt;= $pivot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本上就是这样。你还可以做的是摆脱临时变量并将过滤器放到 &lt;code&gt;return&lt;/code&gt; 语句中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;return flat(
    quick-sort(@data.grep(* &amp;lt; $pivot)),
    $pivot,
    quick-sort(@data.grep(* &amp;gt;= $pivot))
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一切都在最后一次改变之前发挥作用，但现在已经 broken 了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ perl6 quick-sort.pl 
Cannot call &#39;pop&#39; on an immutable &#39;List&#39;
   in sub quick-sort at 3.pl line 6
   in sub quick-sort at 3.pl line 8
   in block &amp;lt;unit&amp;gt; at 3.pl line 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题是你需要返回一个数字列表，但每个快速排序子类都返回它自己的列表。&lt;/p&gt;

&lt;p&gt;您可以通过在函数参数之前放置*来啜饮元素来轻松解决问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;multi sub quick-sort(*@data where @data.elems &amp;gt; 1) {
    . . .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终代码如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;multi sub quick-sort(*@data where @data.elems &amp;lt;= 1) {
    return @data;
}

multi sub quick-sort(*@data where @data.elems &amp;gt; 1) {
    my $pivot = @data.shift;

    return flat(
        quick-sort(@data.grep(* &amp;lt; $pivot)),
        $pivot,
        quick-sort(@data.grep(* &amp;gt;= $pivot))
    );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;您也可以使用 &lt;code&gt;|&lt;/code&gt; 来独立平展每个列表，而不是使用 &lt;code&gt;flat&lt;/code&gt; 例程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;return
    |quick-sort(@data.grep(* &amp;lt; $pivot)),
    $pivot,
    |quick-sort(@data.grep(* &amp;gt;= $pivot));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但我认为有两个可理解的中间变量以避免标点符号噪音仍然更好：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;multi sub quick-sort(@data where @data.elems &amp;lt;= 1) {
    return @data;
}

multi sub quick-sort(@data where @data.elems &amp;gt; 1) {
    my $pivot = @data.shift;

    my @left = @data.grep(* &amp;lt; $pivot);
    my @right = @data.grep(* &amp;gt;= $pivot);

    return flat(quick-sort(@left), $pivot, quick-sort(@right));
}

my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10;
@data = quick-sort @data;
say @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为家庭作业，创建快速排序算法的实现，该算法可就地对数据进行排序。&lt;/p&gt;

&lt;p&gt;该代码可在 &lt;a href=&#34;https://github.com/ash/perl6-algorithms/tree/master/sort&#34;&gt;GitHub 上获得&lt;/a&gt;，欢迎您加入此旅程！&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&#34;https://perl6.online/2019/06/23/101-quick-sort-in-perl-6/&#34;&gt;https://perl6.online/2019/06/23/101-quick-sort-in-perl-6/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl 6 中的冒泡排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-22-bubble-sort-in-perl6/</link>
      <pubDate>Sat, 22 Jun 2019 10:59:47 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-22-bubble-sort-in-perl6/</guid>
      <description>&lt;p&gt;嘿大家好，让我们在 Perl 6 中实现一些算法。&lt;/p&gt;

&lt;p&gt;第一个将是经典的冒泡排序。实质上，您从左到右扫描数据并交换两个相邻的项（如果它们尚未正确排序）。重复这个过程，直到整个数据列表被排序。&lt;/p&gt;

&lt;p&gt;这是最初的直接实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub bubble-sort(@data) {
    my Bool $done = False;
    while !$done {
        $done = True;
        for 1 .. @data.elems - 1 -&amp;gt; $n {
            if @data[$n - 1] &amp;gt; @data[$n] {
                (@data[$n - 1], @data[$n]) = 
                    (@data[$n], @data[$n - 1]);
                $done = False;
            }
        }
    }
}

my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10;
bubble-sort @data;
say @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此实现执行就地排序，但您不需要将函数参数声明为 &lt;code&gt;is rw&lt;/code&gt;。实际上，编译器会告诉您这是多余的，并将停止进一步编译:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;For parameter &#39;@data&#39;, &#39;@&#39; sigil containers don&#39;t need &#39;is rw&#39; to be writable
Can only use &#39;is rw&#39; on a scalar (&#39;$&#39; sigil) parameter, not &#39;@data&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个我想更精确地看一下的地方是交换两个数组元素：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;(@data[$n - 1], @data[$n]) = (@data[$n], @data[$n - 1]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，随着程序准备就绪，我们可以确认它是否正常工作，让我们对其进行转换以使其更具表现力（尽管效率可能稍低）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ perl6 bubble-sort.pl6 
[1 1 2 2 4 5 7 9 10 46 78]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一步是简化交换代码。在等号的两边，我们使用相同的两个元素，索引 &lt;code&gt;$n&lt;/code&gt; 和 &lt;code&gt;$n  -  1&lt;/code&gt;。可以在两个元素的列表上调用 &lt;code&gt;reverse&lt;/code&gt; 方法并将其赋值给它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;(@data[$n - 1], @data[$n]).=reverse;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用数组切片可以进一步简化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;@data[$n - 1, $n].=reverse;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如您所见，不再需要括号。你必须自己回答的唯一问题是，是否用空格包围 &lt;code&gt;.=&lt;/code&gt; 运算符。一方面，这是一个方法调用（因此，没有空格），另一方面，它是一个赋值（因此，空格）。&lt;/p&gt;

&lt;p&gt;好的，下一步是什么？当然，&lt;code&gt;if&lt;/code&gt; 语句可以写为后缀条件，但 &lt;code&gt;if&lt;/code&gt; 块中有两行代码。在这一点上，我可以决定在代码之美和效率之间进行权衡，并摆脱布尔 &lt;code&gt;$done&lt;/code&gt; 标志。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub bubble-sort(@data) {
    for 1 .. @data.elems - 1 -&amp;gt; $n {
        if @data[$n - 1] &amp;gt; @data[$n] {
            @data[$n - 1, $n].=reverse;
        }
    }
    bubble-sort(@data) unless [&amp;lt;=] @data;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此步骤还允许删除 &lt;code&gt;while&lt;/code&gt; 块。在函数结束时，完成递归调用（再次，可能效率较低，但是谁在乎），并且检查数组是否已经排序的条件现在是显式的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;unless [&amp;lt;=] @data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;毕竟，现在可以附加 &lt;code&gt;if&lt;/code&gt; 后缀：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;@data[$n - 1, $n].=reverse if @data[$n - 1] &amp;gt; @data[$n]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;甚至 &lt;code&gt;for&lt;/code&gt; 后缀：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;@data[$_ - 1, $_].=reverse
    if @data[$_ - 1] &amp;gt; @data[$_]
        for 1 .. @data.elems - 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，为什么不像使用函数的其他部分那样使用切片和简化运算符来创建条件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;@data[$_ - 1, $_].=reverse
    if [&amp;gt;] @data[$_ - 1, $_]
        for 1 .. @data.elems - 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一步是减小范围 &lt;code&gt;1 .. @ data.elems  -  1&lt;/code&gt;，这是可行的，但包含的元素太多，可以删除。 &lt;code&gt;-1&lt;/code&gt; 部分可以用开口范围代替：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;for 1 ..^ @data.elems;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后 &lt;code&gt;elems&lt;/code&gt; 调用就不需要了，Perl 6 可以为我们做到这一点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;for 1 ..^ @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是代码的当前状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub bubble-sort(@data) {
    @data[$_ - 1, $_] .= reverse
        if [&amp;gt;] @data[$_ - 1, $_]
            for 1 ..^ @data;
        
    bubble-sort(@data) unless [&amp;lt;=] @data;
}

my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10;
bubble-sort @data;
say @data;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们暂停之前，下面是另一种可能的修改。通常，Perl 6 中的递归可以通过 multi-subs 实现。让编译器根据数据完成工作，而不是在函数内部进行分支：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;multi sub bubble-sort(@data where [&amp;lt;=] @data) {}

multi sub bubble-sort(@data where ![&amp;lt;=] @data) {
    @data[$_ - 1, $_] .= reverse
        if [&amp;gt;] @data[$_ - 1, $_]
            for 1 ..^ @data;
    bubble-sort(@data);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果您不喜欢 &lt;code&gt;[&amp;lt;=]&lt;/code&gt; 检查（因为它应该扫描整个列表），这里是一个带有另一个循环层的暴力版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub bubble-sort(@data) {
    for ^@data {
        @data[$_ - 1, $_] .= reverse
            if [&amp;gt;] @data[$_ - 1, $_] for 1 ..^ @data;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用交叉运算符连接两个 &lt;code&gt;for&lt;/code&gt; 循环：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl6&#34;&gt;sub bubble-sort(@data) {
    for ^@data X 1 ..^ @data {
        my $n = $_[1];
        @data[$n - 1, $n] .= reverse if [&amp;gt;] @data[$n - 1, $n];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们邀请您进一步处理此代码。我真的好奇是否以及如何做得更短（例如，如何重用切片）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ash/perl6-algorithms/tree/master/sort&#34;&gt;GitHub&lt;/a&gt; 上提供了上述程序的源代码。&lt;/p&gt;

&lt;p&gt;原文： &lt;a href=&#34;https://perl6.online/2019/06/21/100-bubble-sort-in-perl-6/&#34;&gt;https://perl6.online/2019/06/21/100-bubble-sort-in-perl-6/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>