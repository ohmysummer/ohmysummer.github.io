<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rakudo Perl 6</title>
    <link>https://ohmysummer.github.io/</link>
    <description>Recent content on Rakudo Perl 6</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 16 Jul 2019 18:56:48 +0800</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Encode-Decode</title>
      <link>https://ohmysummer.github.io/post/2019-07-16-encode-decode/</link>
      <pubDate>Tue, 16 Jul 2019 18:56:48 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-07-16-encode-decode/</guid>
      <description>http://blogs.perl.org/users/damian_conway/2019/07/vigenere-vs-vigenere.html
第15 届 Perl 每周挑战赛的第二项任务是为 Vigenère Cipher 实现编码器和解码器。但这比看起来要复杂得多，因为以 Blaisede Vigenère 命名的密码实际上并不是由他发明的，而 Vigenère 实际发明的密码并不是以他的名字命名的。
那么我们应该实现 Vigenère Cipher 加密&amp;hellip;还是 Vigenère 加密？为什么不两个都要呢！
Vigenère Cipher 是由吉奥万·巴蒂斯塔·贝拉索于 1553 年制定的，然后错误归因到约三百年后的 Vigenère 身上。它使用tabularēcta 把消息文本转换为密文，然后再转回去。
给定用户提供的密钥（例如 &amp;ldquo;BELLASO&amp;rdquo;），我们通过匹配密钥和消息的相应字母来加密消息（例如 &amp;quot;VIGENEREDIDNOTINVENTTHIS&amp;quot;），然后将它们用作两个索引以在 rēcta 表的适当列和行中查找对应的密码字符。如果密钥短于消息，我们只需根据需要多次循环密钥。
例如：
 Key: B E L L A S O B E L L A S O B E L L A S O B E L L A... Text: V I G E N E R E D I D N O T I N V E N T T H I S Table: ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓↓ ↓ ↓ Cipher: W M R P N W F F H T O N G H J R G P N L H I M D  换句话说，tabularēcta 的每一列是单独的Caesar Cipher （或ROT-N转录），其中每个连续的密钥字母选择在消息中的相应字母上执行哪个替换。</description>
    </item>
    
    <item>
      <title>Perl 6 中的 奇偶排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-29-odd-even-sort-in-perl6/</link>
      <pubDate>Sat, 29 Jun 2019 19:37:39 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-29-odd-even-sort-in-perl6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Perl 6 中的煎饼排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-27-pancake-sort-in-perl6/</link>
      <pubDate>Sat, 29 Jun 2019 19:36:02 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-27-pancake-sort-in-perl6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Perl 6 中的 Gnome sort</title>
      <link>https://ohmysummer.github.io/post/2019-06-28-gnome-sort-in-perl6/</link>
      <pubDate>Fri, 28 Jun 2019 19:37:18 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-28-gnome-sort-in-perl6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Perl 6 中的 Stooge Sort</title>
      <link>https://ohmysummer.github.io/post/2019-06-26-stooge-sort-in-perl6/</link>
      <pubDate>Wed, 26 Jun 2019 19:35:43 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-26-stooge-sort-in-perl6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Perl 6 中的合并排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-25-merge-sort-in-perl6/</link>
      <pubDate>Tue, 25 Jun 2019 19:35:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-25-merge-sort-in-perl6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Perl 6 中的插入排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-24-insertion-sort-in-perl6/</link>
      <pubDate>Mon, 24 Jun 2019 19:19:06 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-24-insertion-sort-in-perl6/</guid>
      <description>今天，我们研究插入排序算法及其在 Perl 6 中的可能实现。算法的复杂性是 O(n2)，但它是练习 Perl 6 的一个很好的选择。
这个想法很简单。您可以在数组中找到最小值并将其放在第一个位置。然后从第二个位置开始扫描数据（因为第一个位置已经被最低元素占用）。然后你向右走，找到最小值并将它们放到当前位置直到你到达终点。
它类似于选择排序，但不是交换两个元素，而是插入一个（因此，移动其他元素）。让我们从简单的方法和两个嵌套循环开始：
sub insertion-sort(@data) { for ^@data -&amp;gt; $i { for ^$i -&amp;gt; $j { if @data[$i] &amp;lt; @data[$j] { @data.splice($j, 0, @data[$i]); @data.splice($i + 1, 1); } } } } my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10; insertion-sort @data; say @data;  在Perl 6中，数组的拼接方法可以完成两个任务：用另一个元素列表替换数组的一部分，或者只是删除元素或一行中的一些元素。
在上面的代码中，使用了该方法的两个应用程序。首先，将新找到的元素插入当前位置。其次，它从之前的位置删除（数组刚刚增长，因此索引变为$ i + 1）。
由于splice方法也返回已删除的元素，我们可以将第二个调用放到正在读取元素的位置：@data [$ i]。因此，可以使用以下嵌套调用替换这两行
@data.splice($j, 0, @data.splice($i, 1))  请注意，索引现在只是$ i，因为数组尚未修改。</description>
    </item>
    
    <item>
      <title>Perl 6 中的快速排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-23-quick-sort-in-perl6/</link>
      <pubDate>Sun, 23 Jun 2019 19:16:15 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-23-quick-sort-in-perl6/</guid>
      <description>今天，我们来看看另一个，也许是最着名的数据排序方法，快速排序。
该算法要求您选择所谓的枢轴，其中一个元素来自数据，并将其余部分分成两部分：小于枢轴的元素，以及大于或等于枢轴的元素。然后再次递归地对每个部分进行排序。在每次迭代中，部件变得越来越小，直到子列表是一个或甚至零个元素的平凡数据集。
一个单独的理论是如何选择正确的枢轴。有几种方法，例如，从列表中间取值，或取第一项，或最后一项，或随机项。还有更复杂的方法，您可以调整它以在您的数据集类型上实现最佳性能。
为简单起见，让我们选择第一个元素作为轴点，这是代码
sub quick-sort(@data) { return @data if @data.elems &amp;lt;= 1; my $pivot = @data[0]; my @left; my @right; for @data[1..*] -&amp;gt; $x { if $x &amp;lt; $pivot { push @left, $x; } else { push @right, $x; } } return flat(quick-sort(@left), $pivot, quick-sort(@right)); } my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10; @data = quick-sort @data; say @data;  与之前的冒泡排序示例不同，此程序不会就地排序，而是返回新列表。
现在是时候将代码转换为更具 Perl 6 风格代码的时候了。</description>
    </item>
    
    <item>
      <title>Perl 6 中的冒泡排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-22-bubble-sort-in-perl6/</link>
      <pubDate>Sat, 22 Jun 2019 10:59:47 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-22-bubble-sort-in-perl6/</guid>
      <description>嘿大家好，让我们在 Perl 6 中实现一些算法。
第一个将是经典的冒泡排序。实质上，您从左到右扫描数据并交换两个相邻的项（如果它们尚未正确排序）。重复这个过程，直到整个数据列表被排序。
这是最初的直接实现：
sub bubble-sort(@data) { my Bool $done = False; while !$done { $done = True; for 1 .. @data.elems - 1 -&amp;gt; $n { if @data[$n - 1] &amp;gt; @data[$n] { (@data[$n - 1], @data[$n]) = (@data[$n], @data[$n - 1]); $done = False; } } } } my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10; bubble-sort @data; say @data;  此实现执行就地排序，但您不需要将函数参数声明为 is rw。实际上，编译器会告诉您这是多余的，并将停止进一步编译:</description>
    </item>
    
    <item>
      <title>Perl 6 中的选择排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-21-selection-sort-in-perl6/</link>
      <pubDate>Fri, 21 Jun 2019 16:26:46 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-21-selection-sort-in-perl6/</guid>
      <description>sub find-smallest(@arr) { my $smallest = @arr[0]; my $smallest_index = 0; for @arr.kv -&amp;gt; $k, $v { if $v &amp;lt; $smallest { $smallest = $v; # 存储最小的值 $smallest_index = $k; # 存储最小元素的索引 } } return $smallest_index } sub selection-sort(@arr) { my @new-arr = []; for @arr.clone.kv -&amp;gt; $k, $v { # 对数组进行排序 my $smallest_index = find-smallest(@arr); @new-arr.append(@arr.splice($smallest_index,1).head); # 找出数组中最小的元素,并将其加入到新数组中 } return @new-arr } say selection-sort([5, 3, 6, 2, 10]);  </description>
    </item>
    
    <item>
      <title>Perl 6 实现二分查找</title>
      <link>https://ohmysummer.github.io/post/2019-06-01-binary-search-in-perl6/</link>
      <pubDate>Sat, 01 Jun 2019 14:09:49 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-01-binary-search-in-perl6/</guid>
      <description>sub binary_search(@list, $item) { my $low = 0; # low 和 high 用于跟踪要在其中查找的列表部分 my $high = @list.elems -1; # while $low &amp;lt;= $high { # 只要范围没有缩小到只包含一个元素 my $mid = ($low + $high) / 2; # 就检查中间的元素 my $guess = @list[$mid]; return $mid if $guess == $item; # 找到了就返回 if $guess &amp;gt; $item { # 猜的数字大了 $high = $mid -1 } else { # 才的数字小了 $low = $mid + 1 } } } my @list = [1, 3, 5, 7, 9]; say binary_search(@list, 3); say binary_search(@list, -1);  </description>
    </item>
    
    <item>
      <title>Perl 6 Colonoscopy</title>
      <link>https://ohmysummer.github.io/post/2019-03-26-perl6-colonoscopy/</link>
      <pubDate>Tue, 26 Mar 2019 09:33:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-03-26-perl6-colonoscopy/</guid>
      <description>Perl 6 Colonoscopy I promise, this will not hurt. Much&amp;hellip;
In this article we&amp;rsquo;ll look into colons in Perl 6, where to place them, and what they mean. 我保证，这不会受到伤害。许多&amp;hellip;
在本文中，我们将研究Perl 6中的冒号，放置它们的位置以及它们的含义。
Sigils But first a short detour. A newcomer to the Perl 6 universe cannot miss the significance of sigils when dealing with variables. They are:
 $ (Anything) @ (Array) % (Hash) &amp;amp; (Callable)  The sigil is part of the variable name, and is not changed depending on the context (as in Perl 5):</description>
    </item>
    
    <item>
      <title>Perl 5 to Perl 6 guide - special variables</title>
      <link>https://ohmysummer.github.io/post/2019-02-24-special-variables/</link>
      <pubDate>Mon, 25 Feb 2019 13:33:26 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-02-24-special-variables/</guid>
      <description>描述 一个（希望）全面的 Perl 5 特殊变量列表及其 Perl 6 等价物，并在必要时记录它们之间的变化。
注意 本文档试图引导读者从 Perl 5 中的特殊变量到 Perl 6 中的等效变量。有关 Perl 6 特殊变量的完整文档，请参阅每个变量的 Perl 6 文档。
特殊变量 通用变量  $ARG
 $_
  值得庆幸的是， $_ 是 Perl 5 中的常规默认变量。Perl 6 的主要区别在于现在你可以在它身上调用方法。 例如，Perl 5 的 say $_ 可以在 Perl 6 中以 $_.say 表示。 此外，因为它是默认变量，您甚至不需要使用变量名称。 前面的例子也可以 通过使用 .say 实现。
 @ARG
 @_
  由于 Perl 6 现在具有函数签名，您的参数可以去那里，而不是依赖于 @_。 事实上，如果你使用函数签名，使用 @_ 会吐出你告诉它不能覆盖一个现有签名。
但是，如果您不使用函数签名，则 @_ 将包含您传递给函数的参数, 就像它在Perl 5中那样。再次，与 $_ 一样 ，您可以在其上调用方法。 与 $_ 不同，你不能假设 @_ 为 这些方法的默认变量（即 @_.</description>
    </item>
    
    <item>
      <title>Python to Perl6 - nutshell</title>
      <link>https://ohmysummer.github.io/post/2019-02-25-python-to-perl6-nutshell/</link>
      <pubDate>Mon, 25 Feb 2019 09:41:35 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-02-25-python-to-perl6-nutshell/</guid>
      <description>此页面试图为来自 Python 背景的人们提供学习 Perl 6 的方法。我们在 Perl 6 中讨论了许多 Python 构造和惯用法的等价语法。
基本语法 Hello, world 让我们从打印 &amp;ldquo;Hello, world!&amp;rdquo; 开始吧。 Perl 6 中的 put 关键字相当于 Python 中的 print。与 Python 2 一样，括号是可选的。换行符添加到行尾。
 Python 2  print &amp;quot;Hello, world!&amp;quot;   Python 3  print(&amp;quot;Hello, world!&amp;quot;)   Perl 6  put &amp;quot;Hello, world!&amp;quot;  还有 say 关键字，其行为类似，但会调用其参数的 gist 方法。
 Perl 6  my $hello = &amp;quot;Hello, world!&amp;quot;; say $hello; # also prints &amp;quot;Hello, world!</description>
    </item>
    
    <item>
      <title>第二十五天 - 以数之名</title>
      <link>https://ohmysummer.github.io/post/2018-12-25-calling-number-names/</link>
      <pubDate>Tue, 25 Dec 2018 08:55:57 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-25-calling-number-names/</guid>
      <description>这个学期学期我参加了我的第一个校对课程，题为“数学证明研讨会简介”。在学习了其他数学课程（微积分，矩阵代数等）之后，我觉得我没有那么多的数学基础，到目前为止，我所做的只是纯粹的计算数学，到处撒上了一些证明。回想起来，我发现课程非常有趣，并且学习不同的定理及其证明，主要来自数论，给了我一个新的数学视角。
你可能会问，“这与 Perl 6 有什么关系？”。正如我所提到的，课堂上讨论的大多数证明或家庭作业都与数论有关。如果 Perl 6 和数论有一个共同点就是它们的可访问性。类似于数论的内容如何具体和熟悉，Perl 6 对初学者来说非常平易近人。事实上，鼓励初学者写出所谓的“婴儿 Perl”。
似乎他们分享的另一件事是他们的浩瀚。例如，在 Perl 6 中可以找到许多运算符，而在数论中，可以找到从偶数到可爱数字的过多不同类型的数字。在大多数情况下，这些数字很容易理解，如果有一个数字的定义，那么很容易检查该类别中是否包含给定的整数。例如，素数正式定义如下：
 如果整数p&amp;gt; 1的唯一正数除数为1且p为p，则称p为素数，或简称为素数。否则，称整数p为合数。
 通过使用这个定义，我们可以非常简单地弄清楚某个数字是否是素数。例如，在前十个正整数中，2,3,5和7是素数。对于小数字来说这是微不足道的，但是用更大的数字手工完成它会很快变得单调乏味。这就是 Perl 6 的用武之地。Perl 6 提供了许多构造/函数，即使它们不能简化工作，它们也可以简化它。例如，考虑到素数的定义，我们可以轻松实现在 Perl 6 中测试素数的算法：
sub isPrime( $number ) { return $number &amp;gt; 1 if $number ≤ 3; loop (my $i = 2; $i² ≤ $number; $i++) { return False if $number %% $i; } return True; }  请记住，这不是关于编写高性能代码。如果代码以这种方式拒绝，那么它将是优秀的，但它不是目标。我的目的是展示初学者在 Perl 6 中表达数学结构的容易程度。值得一提的是，Perl 6 已经包含了is-prime测试素数的子程序（或方法）。然而，尽管对于素数这是正确的，但对于你可能遇到的另一种类型的数字可能并非如此，例如阶乘，因子或甚至加泰罗尼亚数字。在这种情况下，Perl 6 会很有帮助。</description>
    </item>
    
    <item>
      <title>第二十四天 - 使用 Perl 6 进行主题建模</title>
      <link>https://ohmysummer.github.io/post/what-is-advent/</link>
      <pubDate>Mon, 24 Dec 2018 08:09:24 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/what-is-advent/</guid>
      <description>嗨，大家好。
今天，让我介绍Algorithm :: LDA。 该模块是用于主题建模的Latent Dirichlet Allocation（即LDA）实现。
介绍 什么是LDA？LDA是一种流行的无监督机器学习方法。 它模拟文档生成过程，并将每个文档表示为主题的混合。
那么，“混合主题”是什么意思呢？图1显示了一篇文章，其中一些单词以三种颜色突出显示：黄色，粉红色和蓝色。关于遗传学的词语用黄色标出; 关于进化生物学的文字用粉红色标出; 有关数据分析的文字标有蓝色。想象一下，本文中的所有单词都是彩色的，然后我们可以将这篇文章表示为主题（即颜色）的混合。
图1 :( 此图片来自“概率主题模型”。（David Blei 2012）） 
好的，那么我将在下一节中演示如何使用Algorithm :: LDA。
建模报价 在本文中，我们将探索Wikiquote。Wikiquote是一个提供源代码报价的云源平台。 通过使用Wikiquote API，我们获得用于LDA估计的报价。之后，我们执行LDA并绘制结果。 最后，我们使用生成的模型创建信息检索应用程序。
初步 Wikiquote API Wikiquote具有动作API，提供获取Wikiquote资源的方法。 例如，您可以按如下方式获取主页面的内容：
$ curl &amp;quot;https://en.wikiquote.org/w/api.php?action=query&amp;amp;prop=revisions&amp;amp;titles=Main%20Page&amp;amp;rvprop=content&amp;amp;format=json&amp;quot;  上述命令的结果是：
{&amp;quot;batchcomplete&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;warnings&amp;quot;:{&amp;quot;main&amp;quot;:{&amp;quot;*&amp;quot;:&amp;quot;Subscribe to the mediawiki-api-announce mailing list at &amp;lt;https://lists.wikimedia.org/mailman/listinfo/mediawiki-api-announce&amp;gt; for notice of API deprecations and breaking changes. Use [[Special:ApiFeatureUsage]] to see usage of deprecated features by your application.&amp;quot;},&amp;quot;revisions&amp;quot;:{&amp;quot;*&amp;quot;:&amp;quot;Because \&amp;quot;rvslots\&amp;quot; was not specified, a legacy format has been used for the output.</description>
    </item>
    
    <item>
      <title>第二十三天 - Blin，很快就到圣诞节了！</title>
      <link>https://ohmysummer.github.io/post/2018-12-23-blin-it-is-christmas-soon/</link>
      <pubDate>Sun, 23 Dec 2018 09:02:45 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-23-blin-it-is-christmas-soon/</guid>
      <description>两年前我已经在出现一篇 advent 文章里提到过 Bisectable，但自那时以来发生了很多变化，所以我觉得是时候简要介绍一下 bisectable 机器人和它的朋友们了。
首先，让我们来定义正在解决的问题。有时会发生提交引入意外更改行为（错误）。通常我们称之为回归，在某些情况下，找出错误并修复它的最简单方法是首先找到引入回归的提交。
Rakudo 2015.12 和 2018.12 之间有9000个提交，尽管它不*超过9000*，但仍然很多。
幸运的是，我们不需要测试所有修改。假设行为不是一直来回变化，我们可以使用二分法查找。
git bisect 和二分法查找 基本上，给定任何提交范围，我们在范围的“中间”取一个提交提交并测试它。如果它是“坏”或者它显示“新”（现在是不正确的）行为，那么我们就可以抛弃我们范围的后半部分（因为我们知道更改必须在该提交之前发生或完全在该提交之后）。同样，如果它是“好”（或“旧”），我们会扔掉另一半。因此，我们只需检查log n个修改（≈13），而不是测试所有 9000 次提交。
Git 附带了git bisect为您实现二分法查找逻辑的命令。你所要做的就是给它一些起点，然后对于每次提交它跳转过去，告诉它是好还是坏。如果你做了足够多次，它会告诉你哪个提交有问题。
这一切都很好，但有两个问题。
问题❶：跳过 让我们想象一下2 + 2用来返回的情况4（正确！），但现在返回42（&amp;hellip;&amp;hellip;也正确，但不完全对）。
所以你启动了 bisection 过程，git 在修改之间跳转，你测试它们。如果它是4那么good（或old），如果它是42那么它是bad（或new）。但后来你偶然发现了这种行为：
&amp;gt; 2 + 2 Merry Christmas!  … 怎么办？显然，那个具体修改有点特殊。我们无法判断我们的错误是否存在，我们根本无法知道。是的，它不会打印4，但我们正在寻找一个非常具体的错误，因此它也不会被归类为“新”行为。当然，我们可以抛硬币并随机标记为old或者new，并希望圣诞节奇迹&amp;hellip;&amp;hellip;但是有50％的概率（如果我们只看到其中一个）将二分法查找转移到错误的方向。
对于这些情况，git 提供了一个特殊skip命令。
如果你是手动测试，那么处理这些修改就有点简单（只要你记得你应该跳过(skip)他们）。但是，由于问题❷，很多人都倾向于使用git bisect run脚本自动化过程。也可以使用脚本跳过修改（使用退出代码125），但是如何确定应该跳过哪些修改并不是那么明显。
问题❷：构建时间 让我们用乐观的数字13来估计我们要测试的修改量。请记住，它不包括我们必须跳过的提交，以及可能需要测试的其他额外构建。
构建rakudo所需的时间因硬件而异，但我们乐观地说，在特定的提交中构建rakudo需要2分钟时间并对其进行测试。
13 × 2 = 26 (minutes)  那不是很方便，对吧？如果在此过程中出现问题&amp;hellip;&amp;hellip;你重新开始，然后等待。
Bisectable 在2016年，在看到那些必须手动运行 git bisect 的人（实际上，大部分是我自己）的痛苦之后，我想知道：
 有没有人想过为每一次提交构建rakudo，以便你可以快速运行git bisect？
 该想法的成本效益分析受到了迅速质疑：
 AlexDaniel：你认为未来二分法将会很普遍吗？</description>
    </item>
    
    <item>
      <title>第二十二天 - 测试 Cro HTTP API</title>
      <link>https://ohmysummer.github.io/post/2018-12-22-testing-cro-http-apis/</link>
      <pubDate>Sat, 22 Dec 2018 10:28:35 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-22-testing-cro-http-apis/</guid>
      <description>测试Cro HTTP API 今年我花了大量的工作时间用于构建一些 Perl 6 应用程序。经过为 Perl 6 编译器和运行时开发贡献代码十年之后，最终使用它来提供解决实际问题的生产解决方案感觉很棒。我还不确定在我创建的IDE中编写代码，使用我设计的HTTP库，由我实现大部分的编译器编译，并在我扮演架构师的VM上运行，是否会使我成为世界上最差的“尚未发明”的案例，或者只是真正的全栈。
无论我在做什么，我都非常重视自动化测试。每一次通过测试我都知道有东西能工作了 - 当我改进有问题的软件时，我不会破坏这些测试。即使使用自动化测试，也会发生错误，但是添加测试来弥补错误至少意味着我将来会犯下*不同的*错误，这可能有点可以原谅。
我目前正在处理的系统中的大多数代码和复杂性都在其域对象中。这些是通过使用Cro实现的HTTP API实现的 - 与系统的其他部分一样，此 HTTP API 具有自动化测试。他们使用我的一个旧模块Test::Mock- 以及今年发布的新模块，Cro::HTTP::Test。在今天的 Advent 文章中，我将讨论我如何一起使用它们，结果我觉得非常讨人喜欢。
一个示例问题 这是 advent 日历，所以当然我需要一个足够节日化的例子问题。对我而言，中欧圣诞时间的亮点之一是圣诞市场，有许多都坐落在美丽的历史城市广场上。除了香肠和热葡萄酒之外，我们还需要在广场上吗？当然，这是一棵高大帅气的圣诞树！但如何找到最好的树？好吧，我们通过建立一个系统来提供互联网帮助，他们可以提交他们认为可能适合的圣诞树的建议。什么可能出错？
可以 PUT 到路由 /trees/{latitude}/{longitude} 以在该位置提交候选圣诞树。预期的有效负载是带有树的高度( height) 的 JSON blob，以及 10-200 个文本字符的描述(description)，解释为什么这棵圣诞树太棒了。如果同一位置已经提交了圣诞树，则应返回 409 Conflict 响应。如果圣诞树被接受，那么将生成一个简单的 200 OK 响应，并带有一个 JSON 格式的主体描述该圣诞树。
同一 URI 的 GET 将返回相关树的描述，而 GET /trees 将返回已提交的树，最高的圣诞树排第一个。
可测性 回到高中，科学课肯定是我最喜欢的。我们不时地做实验。当然，每个实验都需要编写 - 包括之前的计划，结果和对它们的分析。规划中最重要的部分之一是关于如何确保“公平测试”：我们如何试图控制我们还未尝试测试的所有事情，以便我们可以信任我们的观察并从中得出结论？
软件测试涉及大致相同的思考过程：我们如何运用我们感兴趣的组件，同时控制它们运行的上下文？有时，我们很幸运，我们正在测试纯粹的逻辑：它不依赖于我们提供给它的东西以外的任何东西。事实上，我们可以在这方面*创造自己的运气*，发现我们系统中可以是纯函数或不可变对象的部分。从我正在研究的当前系统中获取示例：
 我们有一个由一堆规范文件构建的对象模型。 构建它的过程非常复杂，包括一系列健全性 检查，一些图形算法等等。但结果是 一堆*不可变的对象*。一旦建成，它们永远不会改变。 测试很简单：丢出一堆测试输入，并检查它是否 构建了预期的对象。 我们有一个计算器的小语言。 语言中表达式使用的数据作为参数传递给计算器， 然后我们可以检查结果是否符合预期。因此，计算器 是一个*纯函数*。  因此，为可测试性做的第一件事就是找到可以像这样的系统部分并以这种方式构建它们。唉，并非所有事情都如此简单。HTTP API 通常是可变状态的网关，数据库操作等。此外，良好的 HTTP API 会将域级别的错误条件映射到适当的 HTTP 状态代码。我们希望能够在我们的测试中创建这样的情况，以便覆盖它们。这是一个类似 Test::Mock工具入场的地方, 但要使用它，我们需要以一种对测试友好的方式考虑我们的Cro服务。</description>
    </item>
    
    <item>
      <title>第二十一天 - 一个红色的圣诞老人</title>
      <link>https://ohmysummer.github.io/post/2018-12-21-a-red-secret-santa/</link>
      <pubDate>Fri, 21 Dec 2018 18:25:21 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-21-a-red-secret-santa/</guid>
      <description>这一年即将结束，我们有很多值得庆祝的事情！与家人和朋友相比，庆祝今年年底更好的方式是什么？为了帮助实现这一目标，在我家，我们决定开办秘密圣诞老人游戏！所以，我的目标是写一个秘密圣诞老人计划！这就是我可以使用这个名为Red的精彩项目的地方。
Red是一个仍在开发中的perl6的ORM （对象关系模型），尚未作为模块发布。但它正在增长，而且接近发布。
因此，让我们创建我们的第一张桌子：一张桌子，用于存储参与我们的秘密圣诞老人的人。代码：
use Red; model Person { has UInt $.id is serial; has Str $.name is column; has Str $.email is column{ :nullable }; } my $*RED-DB = database &amp;quot;SQLite&amp;quot;; Person.^create-table; Person.^create: :name&amp;lt;Fernando&amp;gt;, :email&amp;lt;fco@aco.com&amp;gt;; Person.^create: :name&amp;lt;Aline&amp;gt;, :email&amp;lt;aja@aco.com&amp;gt;; Person.^create: :name&amp;lt;Fernanda&amp;gt;; Person.^create: :name&amp;lt;Sophia&amp;gt;; .say for Person.^all.grep(*.email.defined).map: *.name;  Red将关系数据库映射 到OOP。每个表都映射到一个 Red类（*模型*），每个表的 *对象*代表*一行*。
我们创建*模型的方式*是使用模型特殊单词。一个*模型*仅仅是延伸的正常类红::型号 ，具有MetamodelX ::红::型号的对象作为它的 *元类*。 Red不会向您的模型添加任何未明确创建的方法。因此，要与*数据库*进行交互，您应该使用*元类*。
但是让我们继续吧。
代码创建一个名为 *Person*的新*模型*。此*模型*表示的*表*的名称将与模型名称相同：“Person”。如有必要，您可以使用特征更改表的名称 （例如 *:)*。is table&amp;lt;...&amp;gt; model Person is table&amp;lt;another_name&amp;gt; {...}
该*模型*有3个*属性*：
 $ .</description>
    </item>
    
    <item>
      <title>第二十天 - Perl 6 中的命题组合</title>
      <link>https://ohmysummer.github.io/post/2018-12-20-perl6%E4%B8%AD%E7%9A%84%E5%91%BD%E9%A2%98%E7%BB%84%E5%90%88/</link>
      <pubDate>Thu, 20 Dec 2018 09:38:07 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-20-perl6%E4%B8%AD%E7%9A%84%E5%91%BD%E9%A2%98%E7%BB%84%E5%90%88/</guid>
      <description>来临是一个激动人心的时刻，是一个期待的时刻。不仅对我们人类而言 - 正是精灵变得最具创造力的时候。今天，我想在圣诞节压力下休闲一些时间来报道礼品包装领域正在开展的一些开创性工作。即使你没有预料到任何消息，这份报告仍然可以帮助你改进你的技术，因为 - 我不必提醒你 - 圣诞节快到了。
你知道哪个小孩子最喜欢吗？大礼物。因此，Northpole的现有扩大研究实验室的任务是寻找实用的方法来扩大礼物。现在，“大”可能意味着多种事物。我承认，第6单元弯曲的意思了一点，但他们的工作是迄今为止最有趣的：他们增加了音量的礼物，通过增加的礼品盒的尺寸。
“你如何包装6维礼物？”是管理层提出的有效问题。就好像天才击中了UX精灵的回应：«只需将它包裹起来，从每个三维视角看起来都像是一个正常的礼物»（他们实际上从高斯中学到了一个技巧，但谁也不想被视为天才偶尔？）。管理层感到满意，资金安全，数学精灵喜欢UX精灵提出的复杂性降低 - 只是制造技术还没有到那里生产那些高维盒子。因此他们决定在Perl 6中进行编程，因为在等待技术赶上100年语言时，最好使用什么？
“让我们开始工作，”他们说，并且他们得到了工作。
你如何以数学方式包装礼物？ 我在实验室逗留期间真正带回家的是，只有很多社会可接受或物理上可能的方式来包装礼物。首先，你需要一个礼物，然后一个盒子。你必须把礼品包装在盒子周围。这些步骤非常自然，精灵认为这是理所当然的。对于他们来说，“礼物”是礼品包装盒内的礼物。“包装”的挑战，以及将包装工与艺术大师分开的关键点，就是丝带和蝴蝶结发挥作用。你认为这应该够容易吗？好吧，再想一想！
一个立方体卡罗尔 此设置中的礼物由n维立方体建模，或简称为“n立方体”。n-cube是一个非常好的东西，因为它的所有面都是较小尺寸的立方体。计算机科学家喜欢它，因为它的顶点实际上只是长度为n 的0s和1s的串。在这里，我们关心n立方体的二维面或“正方形”。通常的三维立方体有六个正方形，正如你从骰子中所知道的那样。
精灵采取的方法将这些方块视为变量并分配给它们
 没有如果的礼品盒，这部分上有唯一的礼品包装，因为我们同意需要， 色带，如果有两端礼品丝带运行，或 弓如果在立方体的这一侧弓或循环。  是时候看一些代码了：
#|« A square on the n-cube with wrapping. In the n-cube there are 3*(n choose 2)*2**(n-2) WrapSquare variables, one for every square and every kind of value that can be assigned to it. » class WrapSquare is Cube::Face does Propositional::Variable { has $.kind is required; method WHICH { ValueObjAt.</description>
    </item>
    
    <item>
      <title>第十九天 - 交互式桌面应用</title>
      <link>https://ohmysummer.github.io/post/2018-12-19-interactive-desktop-apps/</link>
      <pubDate>Wed, 19 Dec 2018 10:37:00 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-19-interactive-desktop-apps/</guid>
      <description>我是地下城与龙等角色扮演游戏的忠实粉丝。这些游戏中的大多数都有屏幕来帮助你隐藏你在运行游戏时所做的事情，并为你提供游戏中使用的一些图表，以减少书中的内容。
我的游戏收藏很广泛而且我宁愿使用我的笔记本电脑不仅隐藏在后面并跟踪信息，而且我还可以自动化骰子和图表使用。虽然我可以用文本编辑器和命令行魔法拼凑一些东西，但我宁愿拥有一些时髦的桌面应用程序，我可以向人们展示。
输入GTK::Simple是Linux Gnome桌面使用的gtk3 UI库的包装器，但也可以在Windows和Mac上使用。该库通过Native Call 的强大功能为你提供了一个简单易用的界面，让你可以创建简单的桌面应用程序。
骰子滚动 由于历史原因，角色扮演游戏大多数倾向于选择使用基于柏拉图固体的骰子。骰子的标准组合是4,6,8,10,12,20，并且通过组合2个10面骰子100的骰子。骰子可以多次滚动，用于写入的标准符号是“ xdy ”，其中 “*x*“ 是掷骰子的数量，”*y*“ 是掷骰子的大小。单个骰子在开始时跳过1，例如“roll a d6”意味着掷出六面骰子。
有趣的是，在 Perl 6 中制作 “d” 运算符非常简单：
sub infix: ( UInt $count, UInt $size ) { (1..$size).roll($count) } sub prefix: ( UInt $size ) { 1 d $size }  请注意，你需要将数字与空格分开，并且 “d” 运算符或编译器会混淆。
我想要的是一个骰子滚轮应用程序，它提供了选择滚动标准骰子组的选项。现在我不会看到一些游戏使用的不同骰子，或者修改滚动，很多游戏都使用这些骰子。我想看看每个掷骰子，因为这可能很重要，具体取决于系统。如果可能的话，我也想要总数。
简单的 GTK::Simple GTK::Simple 的基本用法很简单。创建一个应用程序，添加内容，放入一些事件处理程序，然后离开。
首先，我们创建我们的应用程序，如下所示：
#!/usr/bin/env perl6 # Get the GTK::Simple libraries use GTK::Simple; use GTK::Simple::App; # Create the main app my $app = GTK::Simple::App.</description>
    </item>
    
    <item>
      <title>第十八天 - 一棵 AVG 格式的圣诞树</title>
      <link>https://ohmysummer.github.io/post/2018-12-18-an-avg-christmas-tree/</link>
      <pubDate>Tue, 18 Dec 2018 12:14:48 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-18-an-avg-christmas-tree/</guid>
      <description>圣诞树是一种传统的象征，可以追溯到欧洲四百多年前，所以对于一篇关于创造圣诞树图像的出现文章来说，这可能更好。
树的典型，简化的表示是几个尺寸逐渐减小的三角形，彼此叠加并且具有小的重叠，因此使用计算机程序很容易创建。
在这里，我将使用可缩放矢量图形（SVG）绘制图像，如上所述，它似乎非常适合任务。
关于SVG并创建它 SVG是一种XML文档格式，它将图像描述为点之间的一组矢量，它具有线条和形状的基元，并提供所描述对象的样式。
也许最简单的SVG文档是这样的：
&amp;lt;svg xmlns=&amp;quot;http://www.w3.org/2000/svg&amp;quot; xmlns:svg=&amp;quot;http://www.w3.org/2000/svg&amp;quot; xmlns:xlink=&amp;quot;http://www.w3.org/1999/xlink&amp;quot; width=&amp;quot;100&amp;quot; height=&amp;quot;100&amp;quot;&amp;gt; &amp;lt;g&amp;gt; &amp;lt;rect x=&amp;quot;5&amp;quot; y=&amp;quot;5&amp;quot; width=&amp;quot;90&amp;quot; height=&amp;quot;90&amp;quot; stroke=&amp;quot;black&amp;quot; fill=&amp;quot;green&amp;quot; /&amp;gt; &amp;lt;/g&amp;gt; &amp;lt;/svg&amp;gt;  这描述了侧面90的绿色填充正方形（单元基本上是抽象的并且相对于显示器的尺寸，因为图像的可缩放特性意味着它们可能不等同于例如像素。）
现在我们可以在程序中使用一些变量插值打印出XML，但是对于比上面的例子更复杂的事情，这可能会非常繁琐且容易出错。幸运的是Perl 6有一个方便的SVG模块，它负责从描述它的数据结构中实际创建格式良好的XML文档。因此，我们的示例矩形可以使用以下内容创建：
use SVG; say SVG.serialize( svg =&amp;gt; [ width =&amp;gt; 100, height =&amp;gt; 100, :g[:rect[:x&amp;lt;5&amp;gt;, :y&amp;lt;5&amp;gt;, :width&amp;lt;90&amp;gt;, :height&amp;lt;90&amp;gt;, :stroke&amp;lt;black&amp;gt;, :file&amp;lt;green&amp;gt;]], ], );  本质上，参数serialize是一组嵌套的Pairs：其中value是标量类型，键和值用于形成XML属性，其中值是List of Pairs，这将创建一个以键命名的XML元素，列表中的每个对都被解释为如上所述，从而允许以简单的声明方式构建复杂文档。
所以我们可以通过构造适当的数据结构来生成我们的示例圣诞树，但是因为我们的图像中可能至少有四个对象（三个三角形和一个用于树干的矩形）及其相关属性，这可能会非常不合适如果我们想改变某些东西，很难改变。
所以…
我们抽象吧！ 为了使我们的SVG生成更加灵活并为未来的代码重用开辟了机会，创建一组代表我们可能想要使用的SVG原语的类并抽象出将要生成的数据结构可能是有意义的。序列化为XML。
所以让我们从可以生成原始矩形示例的东西开始：
use SVG; class SVG::Drawing { role Element { method serialize() { ... } } has Element @.</description>
    </item>
    
    <item>
      <title>第十七天 - 通往幸福的编译之路</title>
      <link>https://ohmysummer.github.io/post/2018-12-17-compiling-our-way-to-happiness/</link>
      <pubDate>Mon, 17 Dec 2018 10:35:05 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-17-compiling-our-way-to-happiness/</guid>
      <description>第17天 - 通往幸福的编译道路 如果我们选择接受它，我们的任务就是解决SEND + MORE = MONEY代码中的问题。不，请等一下，让我这样说吧：
 S E N D + M O R E ----------- M O N E Y  它意味着相同，但是这样放置它更具视觉冲击力，特别是因为我们很多人在学校这样做了。
基本规则很简单。
 每个字母代表0到9之间的数字。 字母代表*不同的*数字; 两个字母可能不共享相同的数字。 前导数字（在我们的拼图中，S 和 M）不能为零。如果为零他们就不会是前导数字！  鉴于这些限制因素，上述难题有一个独特的解决方案。
我鼓励你找到解决方案。写一点代码，坚持一下！在这篇文章中，我们会这样做，但后来（关键）*不满足*于此，并最终陷入嵌套玩偶的情况，其中代码编写代码直到出现真正整洁的东西。结论将拼出最终目标-坚持不住了，我被实时地通过多个委员会获悉，正确的说法是“ *一个*终极愿景” -为了 Perl 6。
我们开工吧。
Marcus Junius Brute Force（The Younger） 我们当天的第一语言及其相应的解决方案是 Perl 6 本身。这里没有技巧; 我们只是像愤怒的公牛一样向问题域冲去，尝试一切。事实上，我们确保不要在这个问题上耍小聪明，只是尝试尽可能直接地表达解决方案。
for 0..9 -&amp;gt; int $d { for 0..9 -&amp;gt; int $e { next if $e == $d; my int $y = ($d + $e) % 10; my int $_c1 = ($d + $e) div 10; for 0.</description>
    </item>
    
    <item>
      <title>第十六天 - 检查你的列表俩次</title>
      <link>https://ohmysummer.github.io/post/2018-12-16-checking-your-list-twice/</link>
      <pubDate>Sun, 16 Dec 2018 18:08:05 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-16-checking-your-list-twice/</guid>
      <description>从命令行了解 Perl 6 这是 Sniffles the Elf 的大好机会！在丝带矿山经过多年的苦差事后，他们终于被提升到了清单管理部门。作为一名闪亮的新助理尼斯名单审核员，Sniffles 正在走向重要时刻。
在 Sniffles 到达的第一天，他们的新老板格伦布尔先生正等着他。“好人清单管理很麻烦，当有人在服务器上洒了牛奶和饼干时，我们的数据被意外删除了。我们一直在忙着检查列表，我们忘了检查备份！现在我们必须从头开始重建一切！裁员后，我们有点人手不足，所以由你来挽救这一天。“
Sniffles，特别勤劳，津津乐道于这个问题。经过一些研究，他们意识到他们需要的所有数据都可用，他们只需要收集它。
他们的朋友在丝带矿山中，一位名叫 Hermie 的自称口述历史学家一直在谈论 Perl 6 有多么伟大。Sniffles 决定尝试一下。
就像拔牙? Sniffles 首先用一种新语言抛出标准的第一个脚本：
use v6.d; say &amp;quot;Nice List restored!!!&amp;quot;;  该脚本运行并尽职尽责地打印出消息。距离圣诞节还有几天了，是时候认真对待 Perl 6文档了。
稍微浏览一下 Sniffles 的 Perl 6 命令行界面实用程序 页面。他们喜欢它描述的 MAIN 这个特殊子程序的外观。
say &#39;Started initializing nice lister.&#39;; sub MAIN() { say &amp;quot;Nice List restored!!!&amp;quot; } say &#39;Finished initializing nice lister.&#39;;  产生：
Started initializing nice lister. Finished initializing nice lister.</description>
    </item>
    
    <item>
      <title>第十五天 - 使用Perl 6构建(小型)航天器</title>
      <link>https://ohmysummer.github.io/post/2018-12-15-building-a-little-spacecraft-with-perl6/</link>
      <pubDate>Sat, 15 Dec 2018 14:41:59 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-15-building-a-little-spacecraft-with-perl6/</guid>
      <description>炫耀长耳朵 在上一篇文章中，我们遇到了某种特殊精灵的魔力：
enum Fuel &amp;lt;Solid Liquid Gas&amp;gt;; class SpeedChoice does ASNChoice { method ASN-choice { { mph =&amp;gt; (1 =&amp;gt; Int), kmph =&amp;gt; (0 =&amp;gt; Int) } } } class Rocket does ASNSequence { has Str $.name is UTF8String; has Str $.message is default-value(&amp;quot;Hello World&amp;quot;) is UTF8String; has Fuel $.fuel; has SpeedChoice $.speed is optional; has Str @.payload is UTF8String; method ASN-order { &amp;lt;$!name $!message $!fuel $!speed @!payload&amp;gt; } } my $rocket = Rocket.</description>
    </item>
    
    <item>
      <title>第十四天 - 使用 Perl 6 设计(小)航天器</title>
      <link>https://ohmysummer.github.io/post/2018-12-14-%E4%BD%BF%E7%94%A8perl6%E8%AE%BE%E8%AE%A1%E5%B0%8F%E8%88%AA%E5%A4%A9%E5%99%A8/</link>
      <pubDate>Fri, 14 Dec 2018 10:13:30 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-14-%E4%BD%BF%E7%94%A8perl6%E8%AE%BE%E8%AE%A1%E5%B0%8F%E8%88%AA%E5%A4%A9%E5%99%A8/</guid>
      <description>寻找共同点 大家好！
那些日子我花了一些时间在基础部件上工作，揭示了可能的惊喜，Perl 6 的 LDAP（轻量级目录访问协议）实现。
然而，现在谈论这个还为时尚早，所以我现在将有一些神秘的封面覆盖这个话题，因为我们有另一个 - 宇宙飞船！
航天器和LDAP之间的共同点是：LDAP规范使用一种称为符号的符号 ASN.1，它允许使用特定的文本语法定义抽象类型，并在 ASN.1编译器的帮助下，为特定的编程语言创建类型定义，以及什么是更多：此类型值的编码器和解码器，可以将您的值序列化为某些数据，例如，可以通过网络发送并在另一台计算机上很好地解析。
通过这种方式，您可以轻松地在应用程序中获得跨平台类型。编码器和解码器可以自动生成，不仅针对某些指定的编码格式，而且针对整个范围的二进制（例如 BER，PER和其他）和文本（例如SOAP）编码格式。
因此，为了完成工作，我必须至少实现 ASN.1Perl 6中的一些子集- 不是完整的规范，这很大，只关注LDAP规范中使用的功能。
“这听起来很有趣，但我们的宇宙飞船在哪里！？”，你可能会问。事实证明，这种 Rocket 类型是您在 ASN.1 Playground 网站上看到的第一件事，它让您可以免费访问 ASN.1编译器，它可以作为参考！
ASN.1 和限制 这是花哨的代码：
World-Schema DEFINITIONS AUTOMATIC TAGS ::= BEGIN Rocket ::= SEQUENCE { name UTF8String (SIZE(1..16)), message UTF8String DEFAULT &amp;quot;Hello World&amp;quot; , fuel ENUMERATED {solid, liquid, gas}, speed CHOICE { mph INTEGER, kmph INTEGER } OPTIONAL, payload SEQUENCE OF UTF8String } END  让我们快速浏览一下这个定义：</description>
    </item>
    
    <item>
      <title>第十三天 - 使用 Cro 和 Debian 从头构建 Web 服务</title>
      <link>https://ohmysummer.github.io/post/2018-12-13-web-server-from-scratch-with-cro-and-debian/</link>
      <pubDate>Thu, 13 Dec 2018 10:43:05 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-13-web-server-from-scratch-with-cro-and-debian/</guid>
      <description>我和圣诞老人​​谈过，他说他不知道如何在 Debian 上安装 Cro，所以我对自己说：我要帮助他。
如果您对 Apache 等 Web 服务器有一些经验，并且您已经听说过 Perl6 强大的并发/响应方面，那么您肯定有兴趣了解 Cro 服务。这篇文章的受众是具有 Debian 基本经验的人，或者在 Perl6 新手&amp;hellip;就像圣诞老人一样。
Cro 是一个 Perl6 模块，它提供了轻松构建反应式和并发服务所需的一切，例如：Web 服务器。
在这篇文章中，我们将看到如何在 Debian 中安装 Cro，这是最受欢迎的 Linux 发行版之一。然后，我将解释 Cro 的演示示例。
我们将使用 Debian 9,64 位（Stretch），我们将在安装后启动它。
安装 Rakudo Perl6 编译器 Rakudo 是 Cro 模块运行的当前 Perl6 编译器。安装 Rakudo 的常规方法是安装 Rakudo Star，但我更喜欢快速的方式：rakudo-pkg &amp;hellip;&amp;hellip;怎么样？只需从此 repo 下载并安装相应的 Debian 软件包。在我们的例子中，是来自 Debian 9, 64位的 .deb 文件。
使用 Debian 中的 root 用户，我们可以在 root home 中为 Rakudo 创建一个包文件夹，进入这个目录，下载 Debian 9, 64 位的当前 Rakudo 包，并安装它。就我而言：</description>
    </item>
    
    <item>
      <title>第十二天 - 构建灵活的 grammar</title>
      <link>https://ohmysummer.github.io/post/2018-12-12-building-a-flexible-grammar/</link>
      <pubDate>Wed, 12 Dec 2018 09:54:05 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-12-building-a-flexible-grammar/</guid>
      <description>圣诞老人夫人写了一个基础的 Grammar，以配合 GDPR 无知精灵从世界各地收集的有关今年 naughty 或 nice 的人的简单列表。
每个记录都是一个名称，后跟一个标签，后跟一个地址，然后是一个标签，然后是 naughty 或 nice 的评估，然后用换行符结束。
Batman 1 Batman Street, Gotham Nice Joker 5 Joker Street, Arkham Naughty Riddler 12 Riddler Street, Arkham Naughty Robin 2 Robin Street, Gotham Nice  她希望将 naughty 的人排除在一个列表中，将 nice 的人过滤到另一个列表中，因为 Krampus 将在今年处理所有 naughty 的人。
S.夫人用这样的 grammar 开头：
grammar naughty-nice-list { token TOP { &amp;lt;details&amp;gt;+ } # Find one or more records made up of name, address, assessment (defined below) token details { &amp;lt;name&amp;gt; &amp;lt;address&amp;gt; &amp;lt;assessment&amp;gt; } # Find the elements from below, in this order token name { .</description>
    </item>
    
    <item>
      <title>第十一天 - 使用 Perl 6 测试你的时刻表</title>
      <link>https://ohmysummer.github.io/post/2018-12-11-testing-your-times-tables-with-perl-6/</link>
      <pubDate>Tue, 11 Dec 2018 13:27:58 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-11-testing-your-times-tables-with-perl-6/</guid>
      <description>这几乎是在北极附近的精灵小学冬季学期结束之时。对于精灵而言，敏锐的人物头脑非常重要，而小精灵的数学老师 Hopper 女士希望确保他们在任期的倒数第二天保持他们的算术技能。（学期的最后一天保留用于观看电影和玩耍 - 很嗨皮）。
小精灵刚刚学会了他们的时间表（乘法表），最多12个，但他们并不像他们所想的那样擅长，其中一些人在圣诞节前将在玩具工作坊帮忙，那时候他们可能需要快速告诉大精灵有多少特定类型的玩具。
幸运的是，Elf Hopper 是一个非常聪明的精灵，拥有出色的数学和编码能力 - 自己。所以她起了一个快速的控制台应用程序来运行小精灵的学校颁发的 Perlix 6.0 boxen。
该程序允许小精灵通过运行它们在2至12次表中测试自己，或者如果它们提供单个数字参数，他们可以尝试任何他们喜欢的乘法表。
#!/usr/bin/env perl6 use v6; my $fixednum; my %score; my @exits = &amp;lt;exit quit&amp;gt;; $fixednum = @*ARGS[0] || 0; put &amp;quot;Type the answer, or quit or exit to end the test.&amp;quot;; loop { my $coefficient = (2..12).pick; my $number = $fixednum || (2..12).pick; my $answer = prompt ( &amp;quot;$coefficient × $number = &amp;quot; ); my $rightanswer = $coefficient × $number; last if $answer.</description>
    </item>
    
    <item>
      <title>第十天 - 跳转, 开启你的工作流</title>
      <link>https://ohmysummer.github.io/post/2018-12-10-jmp-starting-your-work-flow/</link>
      <pubDate>Mon, 10 Dec 2018 10:19:53 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-10-jmp-starting-your-work-flow/</guid>
      <description>这是另一个版本的 jmp 供你在圣诞节前解开。
jmp 是一个命令行工具，用于搜索成堆的代码，然后快速跳转到 $EDITOR。这有助于保持流动。
然而，计算机编程具有许多潜在的流阻塞器。要在编码时保持流状态，通常需要在其他情况下快速跳转(jmp)到一行代码：修复错误，运行测试，检查日志文件，检查git状态等. jmp 也可以帮助加速这些任务吗？
幸运的是，重构 jmp 以容纳这些额外的使用场景相对容易。最新版本的 jmp 现在的工作原理如下：
在命令前加上 jmp 将导致命令再次执行，并且其输出会被吞噬并被分页。
#| find matching lines method find-files-in-command-output ($command) { # execute the command my $shell-cmd = shell $command, :out, :err; # join STDOUT and STDERR my $result = join(&amp;quot;\n&amp;quot;, $shell-cmd.out.slurp, $shell-cmd.err.slurp); # don&#39;t actually look for filenames just yet # do that lazily on demand by the user return $result.lines.map({ JMP::File::HitLater.new(context =&amp;gt; $_) }); }  jmp 为每一行创建结果提示，并对结果进行分页。然后，如果需要，您可以快速浏览输出并将 jmp 导入文本编辑器（请参阅 jmp config 以将其更改为您最喜欢的编辑器）。</description>
    </item>
    
    <item>
      <title>第九天 - Perl 6 中的常量</title>
      <link>https://ohmysummer.github.io/post/2018-12-09-constants-in-perl6/</link>
      <pubDate>Sun, 09 Dec 2018 10:19:12 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-09-constants-in-perl6/</guid>
      <description>我自豪地告诉人们在伦敦 Perl 工作室前一天我写了我的第一个 Perl 6 程序（也就是一个能工作的程序）。 所以，JJ 说：“为什么不为 Perl 6 写一个 Advent 日历帖？”
我名下只有区区一个程序，我该写些什么呢？ 嗯&amp;hellip;&amp;hellip;我在 Perl 5 中创作了 Astro::Constants，那么将它迁移到 Perl 6 有多难？
话匣子打开就关不上了，我给你讲一个 Perl 5 模块作者在 Perl 6 的领地中徘徊的故事。
如果在第5天你被“诊断”为常数，那么你正好需要今天的帖子。
我们习惯使用变量来计算东西和持有东西。 随着我们获得更多“东西”，总量会发生变化。 常量是那些永远不会改变的值。 像一天中的秒数或光速。 当然，我们在计算中使用它们就像使用变量一样，但是你不想通过赋值意外地改变常量
$SPEED_LIGHT = 30;  甚至意外地当你打算测试它是否等于某个值时，就像这样
if ( $SECONDS_IN_A_DAY = $seconds_waited) {  当你真正想的是
if ( $SECONDS_IN_A_DAY == $seconds_waited) {  在这些情况下，你希望编译器说“对不起，戴夫。 恐怕我不能这样做。“ Perl 编译器关闭了。 如果你尝试运行第一行，你会得到
Cannot modify an immutable Num (299792458) in block at im_sorry_dave.</description>
    </item>
    
    <item>
      <title>第八天 — 让你的 Perl 6 grammar 紧凑一点</title>
      <link>https://ohmysummer.github.io/post/2018-12-08-make-your-perl6-grammar-compact/</link>
      <pubDate>Sat, 08 Dec 2018 12:44:15 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-08-make-your-perl6-grammar-compact/</guid>
      <description>欢迎来到今年的 Perl 6 Advent Calendar 的第8天！
Grammars 是使 Perl 6 成为一种优秀编程语言的众多因素之一。 我甚至不会尝试预测轮询的结果，以便在 grammars，Unicode 支持，并发功能，超运算符或集合语法之间进行选择，或者选择 Whatever star。 谷歌发现了自己在互联网上发布的最好的 Perl 6 功能列表。
无论如何，今天我们将讨论 Perl 6 grammars，我将分享一些技巧，用于使 grammars 更紧凑。
1.拆分 actions 假设您正在编写 grammar 来解析 Perl 的变量声明。 您希望它与以下语句匹配：
my $s; my @a;  它们都声明了一个变量，因此我们可以制定一个通用规则来解析这两种情况。 下面是完整的程序：
grammar G { rule TOP { &amp;lt;variable-declaration&amp;gt;* %% &#39;;&#39; } rule variable-declaration { | &amp;lt;scalar-declaration&amp;gt; | &amp;lt;array-declaration&amp;gt; } rule scalar-declaration { &#39;my&#39; &#39;$&#39; &amp;lt;variable-name&amp;gt; } rule array-declaration { &#39;my&#39; &#39;@&#39; &amp;lt;variable-name&amp;gt; } token variable-name { \w+ } } class A { has %!</description>
    </item>
    
    <item>
      <title>第七天 – 细胞自动机</title>
      <link>https://ohmysummer.github.io/post/2018-12-07-automatic-on-a-cellular-level/</link>
      <pubDate>Fri, 07 Dec 2018 13:11:51 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-07-automatic-on-a-cellular-level/</guid>
      <description>今天的降临日历帖子涉及Cellular Automata。
什么是细胞自动机？我很高兴你问！它们是由几个部分组成的系统：由细胞组成的一种场或“世界”，每个细胞可以在任何点处的一组状态，描述每个细胞可见的细胞的“邻域” ，以及一套规则，用于管理一个单元将其状态改变为什么状态以及其邻域中所有单元的状态。
当然，这是一个非常抽象的描述，所以让我举一些个别部分的例子，希望能让你了解你在细胞自动机中看到的内容：
在典型的世界中，你可能会发现细胞像串珠一样排列，或者像国际象棋或中国跳棋板上的字段。您还可以组成更多奇特的配置：任何二维场都可以映射到任何表面，例如斯坦福兔子
你可以在野外找到的状态集是“从0到n的数字”，“这里有细菌”，“黑白颜色”（或更多）。由于您基本上可以将任何信息表示为“数字”，并且允许任意数量的状态，因此还可以存在表示“此时此单元格中有多少粒子在上升，下降，向左或向右移动的状态？ “作为整数或甚至浮点数。
邻域可以被认为是细胞“连接在一起”的模式。典型的社区将是“前面的一个，后面的一个”的“串珠”字段，以及“北，东，南，西”或“北，东北，东，东南，南，西南，西，西北“对于棋盘场 - 这两个分别是冯诺依曼附近和摩尔附近。
管理每个单元的邻域中的状态的一组规则将导致哪个状态转到其他状态可被视为特定元胞自动机的核心。
在今天的降临日历中，我们将探索您可能称之为最简单的自动机。我们将字段串起来像字符串上的珠子，我们将尝试一个或两个和一些不同的状态集。
为了让家里的人感兴趣，我将为您提供链接，让您在浏览器中运行示例代码，或在家中使用您的本地perl6编译器！
为学习而做 让我们开始，然后：
首先，我们需要什么？世界上必须有存储空间，需要一些代码来获得一个符合条件的邻居，以及一些代码来计算一个单元的下一个状态，给定它自己的状态和邻居的状态。最重要的是，我们想看看发生了什么，所以我们也有一些代码。
在确定每个单元可以具有哪些状态之后，我们将知道什么存储适合于我们的世界。使用8位整数数组将允许我们从任何不超过255个单独状态的状态集中进行选择。不过，让我们现在共计3个州。我们可以随心所欲地初始化世界，但是将每个字段设置为随机有效状态是一个很好的起点。另一个是将一个状态的单个单元放在中间，并使每个其他单元具有不同的状态。
constant number-of-states = 3; constant field-width = 60; my int8 @field; sub init-field { @field = (^number-of-states).roll(field-width); }  显示字段非常简单，具体取决于我们使用的输出。 这是一段可以在任何控制台中运行的代码，下面是一个6pad的链接，它在pad的HTML部分输出很少的彩色方块。
sub output-a-row { for @field { # Using the unicode characters &amp;quot;Light shade&amp;quot;, &amp;quot;Medium shade&amp;quot;, and &amp;quot;Dark shade&amp;quot; # and printing each field twice so they look square rather than slim and tall.</description>
    </item>
    
    <item>
      <title>第六天 - 懒惰精灵与勤劳精灵</title>
      <link>https://ohmysummer.github.io/post/2018-12-06-lazy-and-industrious-elves/</link>
      <pubDate>Thu, 06 Dec 2018 09:33:12 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-06-lazy-and-industrious-elves/</guid>
      <description>对圣诞老人来说，圣诞节总是一年中最忙碌的时刻。 幸运的是，圣诞老人有很多帮手。 他们总是做一些小工作和家务，只是为了创造最好的假日季节体验！
Object::Delayed 模块为圣诞老人的快乐精灵添加了两个非常有趣的精灵！ 他们的名字是 slack 和 catchup!
Lazy slack 那个懒散的(slack)精灵确实非常懒惰。 懒散(slack)精灵不会做任何事情，直到你真的需要他去做。 虽然人们可以认为这是精灵中非常糟糕的性格特征，但它也是一种非常生态的特征。 人们可以认为这个懒散的(slack)精灵是他们所有人中最环保的精灵！ 你有多少次要求精灵为你做点事情，然后却没用过那个精灵辛苦工作的结果？ 即使它只是到处移动的被回收的电子，但仍然需要能量来移动它们！ 特别是, 如果那些电子被用来告诉其他精灵做一些遥远的事情，就像在外部数据库中一样！
use Object::Delayed; my $dbh = slack { DBIish.connect(...) }  这就是你需要的 $dbh 变量，它只在实际需要时才与数据库建立连接。 当然，如果你想对该数据库进行查询，那么也可以使其懒惰！
use Object::Delayed; my $dbh = slack { DBIish.connect(...) } my $sth = slack { $dbh.prepare(...) }  由于语句句柄也是懒惰的，因此在实际需要之前它实际上不会进行查询准备。
use Object::Delayed; my $dbh = slack { DBIish.connect(...) } my $sth = slack { $dbh.prepare(...) } # lotsa program if $needed { $sth.</description>
    </item>
    
    <item>
      <title>第五天 - 变量</title>
      <link>https://ohmysummer.github.io/post/2018-12-05-variables/</link>
      <pubDate>Wed, 05 Dec 2018 12:17:44 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-05-variables/</guid>
      <description>这么简单的事，不是吗？ 变量是一个保存着值的名字。
有时候，它持有的值可能会被另一个值所取代 - 因此就是名字。 （根据外科医生的说法，没有经常变化的变量应该看医生，并要求被诊断为常数。）
虽然它们很容易掌握，而且基本上每种语言都有它们，但我今天的目标是让你相信变量实际上非常棘手。 好的方式！ 我的目的是让你被这篇博文绊倒，茫然，喃喃自语“我以为我知道变量，但我真的不知道&amp;hellip;&amp;hellip;”。
接近最后，实验语言007也将会出现，我考虑变量这么多完全是这种语言的过错。
左还是右？ 变量奇怪的第一种方式是它们以两种完全不同的方式使用。
my $x = &amp;quot;Christmas&amp;quot;; say(&amp;quot;Merry &amp;quot; ~ $x); # reading $x = &amp;quot;Easter&amp;quot;; # writing  有时我们使用变量来读取值，有时我们使用它们来写一个值。但在这两种情况下，语法看起来完全一样！一些较旧的语言（例如Forth）实际上对这两种用法有不同的语法，我喜欢它们。但是这样的惯例似乎并没有幸存到现代。
相反，我们通过语法位置来区分这两种用法。如果你在赋值的左侧，那么你就被写了。否则，你正在被读取。
在文献中，这两种用途分别称为 lvalues 和 *rvalues*。分别为“左”和“右”。
Rvalues 非常正常，与我们对变量的一般考虑方式相对应;他们只是计算它们包含的值。然而，Lvalues 很奇怪。它们更像是盒子，你可以把东西放入（或内存位置？引用？），或者如果不是盒子本身，那么分离的能力放入其中。如果 lvalues 有一个类型，它看起来像 (T) -&amp;gt; void，接受 T 但不返回任何东西的东西。
参数 变量对现代编程至关重要。 还有一个原则表明它们完全没有必要。
那就对了！ Tennent 的通信原则！ （我知道你在想什么。不，我说的不是那个 Tennant。
这个原则主要指向一种在程序中重写所有变量声明的方法，因此它们是参数声明。 一个例子应该足以展示一般原则：
# Before my $veggie = &amp;quot;potato&amp;quot;; say &amp;quot;$veggie, and that&#39;s all I have to say about that!</description>
    </item>
    
    <item>
      <title>第四天 - 献给新年的 Perl 6 Pod 新功能</title>
      <link>https://ohmysummer.github.io/post/2018-12-04-new-perl6-pod-features-for-the-new-year/</link>
      <pubDate>Tue, 04 Dec 2018 22:37:48 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-04-new-perl6-pod-features-for-the-new-year/</guid>
      <description>介绍 Rakudo NQP 文件包含解析 Perl 6 输入文件并将其转换为正在运行的 Perl 6 程序的代码。 本文将重点介绍最近使用 Rakudo NQP 文件时的经验所学到的一些细节。 这项工作涉及实现一些尚未实现的（NYI）Perl 6 POD 功能，我希望尽快合并这些更改。
准备 使用的 NQP 文件保存在 https://github.com/rakudo/rakudo/src/Perl6 的git存储库中。 有关我的开发设置和工作流的更多背景信息，请参阅 https://perl6advent.wordpress.com/2017/12/08/ 上的 2017 年 Perl 6 Advent 条目。
背景 在我实现 NYI POD 功能的过程中，我已经给我添加到 Rakudo 仓库中的文档添加了注释: rakudo/docs/rakudo-nqp-and-pod-notes.md。我更新它，因为我发现了可能没有记录的新内容或者可能不容易找到其文档。该文件还包含一份完整的清单，通过我的计算，NYI POD 功能。以下是我已经工作了几个月的 NYI POD 功能列表，我希望在今年或新年初完成（以及每个功能的 roast 测试）:
 NYI: %config :numbered 对于段落或分隔的POD块，使用&amp;rsquo;#&amp;lsquo;别名 NYI: POD 数据块 NYI: 以defn块术语格式化代码  缺少的项目描述在由 Damian Conway 博士撰写的精美制作的概要S26中，Larry Wall 是多产的得力男人 - 世界知名的 Perl 专家和著名的 Perl 作者。（请注意，现在很少有人在积极研究 POD，我的 NYI 功能列表可能不完整.</description>
    </item>
    
    <item>
      <title>第三天 – Perl 6 – 跳转到那儿</title>
      <link>https://ohmysummer.github.io/post/2018-12-03-jmp2it/</link>
      <pubDate>Mon, 03 Dec 2018 09:54:10 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-03-jmp2it/</guid>
      <description>jmp是一个Perl 6驱动的命令行程序，我每天都使用它来浏览成堆的Perl并快速跳转到我的$EDITOR。 我尝试在编码时保持流状态，并且能够快速搜索文件然后直接跳转到编辑器中。
jmp 是一个简单的基于终端的前端到您最喜欢的代码搜索工具（例如，rgrep，ag，ack，git grep等）。 它会显示一个搜索结果列表，您可以在跳转到编辑文件之前快速浏览（例如，vim，nano，comma等）。
它的工作原理如下：
最近我重构了 jmp，以便在 Terminal::Print 模块的帮助下改进用户界面。 Terminal::Print 提供了一个方便的二维网格，用于在终端屏幕上绘图。 还有一个用于异步处理用户输入的模块。
这是 jmp 代码，只要用户按下某个键，它就会响应：
my $in-supply = decoded-input-supply; my $timer = Supply.interval(1).map: { Tick }; my $supplies = Supply.merge($in-supply, $timer); react { whenever $supplies -&amp;gt; $_ { when Tick {} when &#39;CursorUp&#39; { self.pager.cursor-up; } when &#39;CursorDown&#39; { self.pager.cursor-down; } when &#39;CursorRight&#39; | &#39;PageDown&#39; { self.pager.next; } when &#39;CursorLeft&#39; | &#39;PageUp&#39; { self.pager.previous; } when &#39;x&#39; | &#39;X&#39; { self.</description>
    </item>
    
    <item>
      <title>第二天 – 写文档</title>
      <link>https://ohmysummer.github.io/post/2018-12-02-document-every-thing/</link>
      <pubDate>Sun, 02 Dec 2018 11:01:52 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-02-document-every-thing/</guid>
      <description>Like 6 Perls in a Pod: document everything 圣诞节即将到来，圣诞老人很沮丧。 他的收件箱被来自全国各地的男孩和女孩的来信塞爆了。
但，
这些信是写给圣诞老人的吗？ 是否通过签名正确识别了孩子，以便将礼物送给对的人而不是给其他可能不值得的人？ 他们是针对圣诞老人的，而不是那些冒名顶替者，复活节兔子，或者更糟糕的是，三个所谓的 - 我不知道为什么 - 来自东方的智者？ 最糟糕的是，他个人是否必须通过他的王室和神圣的自我来检查所有这些东西？
没有。
Perl 6 以下面的方式来救援：
grammar
unit grammar Santa-Letter; token TOP { &amp;lt;dear&amp;gt; \v+ &amp;lt;paragraph&amp;gt; [\v+ &amp;lt;paragraph&amp;gt;]* \v+ &amp;lt;signature&amp;gt;\v*} token paragraph { &amp;lt;superword&amp;gt;[ \h+ &amp;lt;superword&amp;gt;]+ } token superword { &amp;lt;word&amp;gt; | &amp;lt;enhanced-word&amp;gt; } token word { \w+ } token enhanced-word { &amp;lt;word&amp;gt; [\,|\.|\:] } token dear { Dear \h+ [S|s]anta [\,|\:]? } token signature { \h+ \w+ \h* \w* }  该单位向圣诞老人宣布一封致敬的信，其后是一个或多个段落，最后是一个签名，其前面应有一个水平的空格，如 \h 所示。</description>
    </item>
    
    <item>
      <title>第一天 - 移植 Vigilance, 将 Perl 6 与标准工具集成在一起</title>
      <link>https://ohmysummer.github.io/post/2018-12-01-porting-vigilance/</link>
      <pubDate>Sat, 01 Dec 2018 21:49:03 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-12-01-porting-vigilance/</guid>
      <description>移植 Vigilance，将Perl 6与标准工具集成在一起 大家好，今天我们将采用基础设施脚本并将其从Perl 5移植到Perl 6.本文基于James Clark的一对帖子，你可以在这里找到：
 第1部分 第2部分  此脚本用于创建和验证MD5总和。 这些是128位值，可用于验证数据完整性。 虽然MD5已经被证明在防范恶意行为者方面不安全，但它对于检测磁盘损坏仍然很有用。
Perl 6生态系统正在发展，其中包含多种工具，这些工具可以从Perl 5 CPAN移植，也可以替代。 我将介绍原始脚本和移植的几个方面，并说明我为什么要进行一些特定的更改。 希望这会鼓励你出去移植你自己的小脚本。
Shebang 和导入 Perl 5版本使用一些基础设施和一些实用程序来处理Unicode并使命令行输出更好：
#!/usr/bin/perl -CSDA use strict; use warnings; use utf8; use Encode qw/encode_utf8 decode_utf8/; use Getopt::Long; use Digest::MD5; use Term::ANSIColor; use Term::ProgressBar; use File::Find; use File::Basename; use Data::Dumper;  Perl 6默认启用了警告和限制，并且内置了Unicode支持，因此我们可以将其保留。 Data::Dumper也已经实现，它具有非常有用的IO功能。 将所有这些加在一起我们可以得到一个非常精益的标头：
#!/usr/bin/env perl6 use v6; use Digest::MD5; use Terminal::ANSIColor; use Terminal::Spinners;  命令行选项 Perl 5有许多用于处理命令行参数的很棒的模块，在我们使用 Getopt::Long 的原始脚本中：</description>
    </item>
    
    <item>
      <title>Send-Data-to-Socket</title>
      <link>https://ohmysummer.github.io/post/2018-11-23-send-data-to-socket/</link>
      <pubDate>Fri, 23 Nov 2018 16:18:07 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-11-23-send-data-to-socket/</guid>
      <description>发送数据到 Socket 的 3333 端口，并把所发送的数据保存到文件中。
my $vin = &#39;LSJA0000000000091&#39;; my $last_meter = 0; react { whenever IO::Socket::Async.listen(&#39;0.0.0.0&#39;, 3333) -&amp;gt; $conn { my $fh = open &#39;events.txt&#39;, :w; react { my Bool:D $ignore = True; whenever Supply.interval(5).rotor(1, 1 =&amp;gt; 1) { $ignore = !$ignore; } whenever Supply.interval(1) { next if $ignore; $fh.print: sprintf(&amp;quot;\{&#39;vin&#39;:&#39;%s&#39;,&#39;createTime&#39;:%s,&#39;mileage&#39;:%s}\n&amp;quot;, $vin, DateTime.now.posix, $last_meter); $conn.print: sprintf(&amp;quot;\{&#39;vin&#39;:&#39;%s&#39;,&#39;createTime&#39;:%s,&#39;mileage&#39;:%s}\n&amp;quot;, $vin, DateTime.now.posix, $last_meter++); } whenever signal(SIGINT) { say &amp;quot;Done.&amp;quot;; $fh.close; done; } } } CATCH { default { say .</description>
    </item>
    
    <item>
      <title>Make Empty</title>
      <link>https://ohmysummer.github.io/post/2018-11-15-make-empty/</link>
      <pubDate>Thu, 15 Nov 2018 23:46:35 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-11-15-make-empty/</guid>
      <description>my $str = q :to/EOF/; Perl6,Rust -- this is a comment Rakudo,Raku -- this is another comment Camelia,Camel EOF grammar MakeEmpty { token TOP { ^ &amp;lt;sentence&amp;gt;+ % &amp;lt;comment&amp;gt; $} token sentence { &amp;lt;words&amp;gt;+ % &#39;,&#39; \n } token comment { &#39;-- &#39; &amp;lt;words&amp;gt;+ % &#39; &#39; \n } token words { \w+ } } class Action { method TOP($/) { make $/.values».ast } method sentence($/) { make ~$/.trim } method comment($/) { make Empty } method words($/) { make ~$/ } } my $parsed = MakeEmpty.</description>
    </item>
    
    <item>
      <title>原生调用接口</title>
      <link>https://ohmysummer.github.io/post/2018-11-12-perl6-native-call-interface/</link>
      <pubDate>Mon, 12 Nov 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-11-12-perl6-native-call-interface/</guid>
      <description>原生调用接口 入门指南 能想象出的最简单的 NativeCall 用法应该类似于这样的东西：
use NativeCall; sub some_argless_function() is native(&#39;something&#39;) { * } some_argless_function();  第一行导入了各种 traits 和类型，接下来的一行看起来很像相对普通的 Perl 6 子例程声明 - 稍微有点变化。我们使用native这个 trait 是为了指定这个 sub 子例程实际上被定义在原生库中。Perl 6 会给你添加特定平台的扩展名（比如 .so 或者 .dll）还有任何惯常的前缀(例如: &amp;lsquo;lib&amp;rsquo;)。
当你第一次调用 “some_argless_function” 时，“libsomething” 将会被加载，然后会在 libsomething 库中定位到 “some_argless_function” 函数，接下来将会进行一次调用。之后的调用将会更快，因为符号句柄会被保留。
当然，大部分的函数都会接受参数或者返回值 - 但是你可以做的其他事情只是增加了这个声明Perl 6 sub的简单模式
但是一切你需要做的就是增加这个简单的模式，通过声明一个 Perl 6 的过程、在符号后面指出你想要调用的名字，并且使用 “native” trait。
改变名字 有时你想要 Perl 6 子例程的名字和加载库中使用的名字不同，可能这个名字很长, 或者有不同的大小写或者在你想要创建的模块的上下文中, 这个名字很繁琐。
NativeCall 为你提供了一个 symbol trait 以指定库中原生子例程的名字, 这个名字和你的 Perl 6 子例程名字不同。</description>
    </item>
    
    <item>
      <title>Traps to Avoid</title>
      <link>https://ohmysummer.github.io/post/2018-10-07-traps-to-avoid/</link>
      <pubDate>Sun, 07 Oct 2018 21:10:29 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-10-07-traps-to-avoid/</guid>
      <description>在学习一门编程语言时，可能有熟悉另一门编程语言的背景，总有一些事情会让您感到惊讶，并且可能会耗费宝贵的调试和发现时间。
本文件旨在展示常见的误解，以避免它们。
在编写 Perl 6 的过程中，我们付出了巨大的努力来消除语法中的瑕疵。然而，当你消灭一个瑕疵的时候，有时另一个会突然冒出来。所以我们花了很多时间去寻找最小数量的瑕疵或者试图把它们放在它们很少被看到的地方。正因为如此，Perl 6 的瑕疵出现在了不同的地方，而不是来自另一种语言时所期望的那样。
变量和常量 常量在编译时计算 常量是在编译时计算的，所以如果在模块中使用它们，请记住，由于模块本身的预编译，它们的值将被冻结:
# WRONG (most likely): unit module Something::Or::Other; constant $config-file = &amp;quot;config.txt&amp;quot;.IO.slurp;  $config-file 将在预编译时一次性被读入。config.txt 文件的更改不会在你再次启动脚本时重新加载;只有当模块被重新编译时才会重新加载。
避免使用容器，而倾向于将值绑定到提供类似于常量行为的变量上，但允许更新值:
# Good; file gets updated from &#39;config.txt&#39; file on each script run: unit module Something::Or::Other; my $config-file := &amp;quot;config.txt&amp;quot;.IO.slurp;  赋值为 Nil 产生不同的值, 通常是 Any 实际上，赋给 Nil 会将变量还原为其默认值。所以:
my @a = 4, 8, 15, 16; @a[2] = Nil; say @a; # OUTPUT: «[4 8 (Any) 16]␤»  在本例中，Any 是 Array 元素的默认值。</description>
    </item>
    
    <item>
      <title>Perl 6 中的命令行参数</title>
      <link>https://ohmysummer.github.io/post/2018-10-05-command-line-arguments-in-perl-6/</link>
      <pubDate>Fri, 05 Oct 2018 21:33:03 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-10-05-command-line-arguments-in-perl-6/</guid>
      <description>Sub MAIN 在 Perl 6 中，命令行参数的解析是通过 MAIN 子例程完成的，MAIN 子例程是一种特殊的子例程，它根据 MAIN 子例程的签名解析命令行参数。与其他子例程一样，MAIN 子例程可以具有命名参数和位置参数、可选(和必需)参数、多重分派等等。
有了 MAIN 子例程的定义，USAGE 子例程将由编译器自动生成。可以修改此子例程以返回定制的使用消息。所有命令行参数也可以在特殊变量 @*ARGS 中使用，它可以在 MAIN 处理之前发生转变。
命名参数和位置参数 命名参数 让我们从一个简单的程序开始(保存为 prog.p6):
use v6; sub MAIN( Str :$name = &#39;John&#39;, Str :$last-name = &#39;Doe&#39;, ) { my $formatted-name = &amp;quot;$name.tc() $last-name.tc()&amp;quot;; say $formatted-name; }  在这个 MAIN 子句中，我们通过前置 : 到子例程签名中的每个变量上，创建了两个带有类型约束(Str)的命名参数，$name 和 $last-name。这些参数也有默认值，这是通过给参数赋值来实现的。在本例中，我们将 $name 设置为默认值 “John”，将 $last-name 设置为 “Doe”。如果执行 prog.p6 时命令行参数与 MAIN 签名匹配，则会打印出一个格式化的全名:
$ perl6 prog.p6 John Doe $ perl6 prog.</description>
    </item>
    
    <item>
      <title>Rmarkdown 中的 Perl 6 代码</title>
      <link>https://ohmysummer.github.io/post/2018-10-04-perl-6-code-in-rmarkdown/</link>
      <pubDate>Thu, 04 Oct 2018 21:32:27 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-10-04-perl-6-code-in-rmarkdown/</guid>
      <description>安装 首先，首先安装 R 编程语言。在此之后，运行 R 并执行以下命令来安装 rmarkdown: install.packages(&amp;quot;rmarkdown&amp;quot;)。在安装 rmarkdown 时，我收到以下错误消息:
Error: .onLoad failed in loadNamespace() for &#39;tcltk&#39;, details: call: dyn.load(file, DLLpath = DLLpath, ...) error: unable to load shared object &#39;/usr/lib/R/library/tcltk/libs/tcltk.so&#39;: libtk8.6.so: cannot open shared object file: No such file or directory  这可以通过安装包 tk 来解决，然后继续安装 rmarkdown。
Rmarkdown 的代码块 你可以用 rmarkdown 做的几乎所有都可以用“常规” markdown 来做的事情。然而，rmarkdown 的一个突出特性是它能够执行代码块并返回结果。为此，rmarkdown 使用了 knitr 包，这是一个使用 R 生成动态报告的引擎，除了 R 之外，它还支持其他语言引擎，您可以使用这些引擎来计算来自其他语言的代码。要列出可用引擎的名称，请在 R REPL 中执行 names(knitr::knit_engines$get()) 命令。就像“常规” markdown 一样，代码块可以用三个反勾号创建，然后是代码，最后是另外三个反勾号。如果希望计算代码块，请在花括号 {} 中指定语言，该语言位于前三个反勾号之后。例如，要执行 Perl 5 代码，可以在 {} 中指定 perl:</description>
    </item>
    
    <item>
      <title>Perl 6 面向对象简单入门</title>
      <link>https://ohmysummer.github.io/post/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/</link>
      <pubDate>Wed, 03 Oct 2018 21:13:31 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/</guid>
      <description>序言 介绍 本教程最多只关注 Perl 6 中的面向对象编程(OOP)的基本知识。因此，对语句/表达式、变量、条件、循环、子例程(函数)等有一个基本的了解是很重要的，如果不在 Perl 6 中，至少在另一种编程语言中是这样的。此外，您至少应该对类、属性和方法有一般的了解。作为对 Perl 6 的介绍，我强烈推荐 Perl 6 introduction。下一步是 Perl 6 文档。
确保你已经设置好了 Perl 6 编译器。如果你还没有设置好，请看这里。 从这里开始，你可能会厌倦代词“我们”，但它的使用是经过深思熟虑的。这是一个教程，希望你能跟上。所以，是的，我们在一起工作，你应该做好准备。顺便说一下，本教程是冗长的，这是故意的，但也是手把手教程的副产品。
问题陈述 我们将从现实生活中的问题开始，并尝试以面向对象的方式对其进行建模。问题陈述如下: 在她的数学101课程中，一位教授记录了三个作业(2个作业和1个考试)的分数，按照学生交作业的顺序:
Bill Jones:1:35 Sara Tims:2:45 Sara Tims:1:39 Bill Jones:1:42 Bill Jones:E1:72  在一个名为 MATH-101 的简单文本文件中。您可以假设有更多的学生，而这只是数据文件的一个代表性块。在这个文件中，每行记录学生的姓名、作业编号(作业编号为1,2，第一次考试为E1)和学生获得的原始分数。 教授使用另一个扩展名为 .std 的文件存储她课程的学生名单:
Bill Jones Ana Smith Sara Tims Frank Horza  除了 MATH-101，这位教授还教其他课程，并设计了一个扩展名为 .cfg 的配置文件来存储给定课程的配置格式。她这样做的目的是在她的其他课程中也使用它。配置文件格式指定了作业的类型、作业编号、作业的总分以及作业对最终课程成绩的贡献。她的数学101课程的 .cfg 文件如下:
Homework:1:50:25 Homework:2:50:25 Exam:1:75:50  您的任务是创建一个名为 report.p6 的程序。该程序生成一个报告，其中列出了班级中每个学生的姓名、每次作业的分数和最终成绩。该程序应该假设具有扩展名 .cgf 和 .std 的文件在执行该程序的目录中可用。另一方面，包含学生成绩的文件必须通过命令行传递给程序。为了简单起见，您可以假设每个文件都是根据课程命名的。对于她的数学101课程，教授会有以下的文件: MATH-101, MATH-101.</description>
    </item>
    
    <item>
      <title>How Naming of Variables Works in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-09-28-how-naming-of-variables-works-in-perl-6/</link>
      <pubDate>Fri, 28 Sep 2018 20:18:30 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-28-how-naming-of-variables-works-in-perl-6/</guid>
      <description>在本系列的第 5 篇文章中，比较 Perl 5 和 Perl 6，了解在 Perl 6 中使用 sigils。
在本系列的前 4 篇文章中，我们比较了 Perl 5 和 Perl 6，讨论了迁移代码时可能遇到的一些问题，垃圾收集是如何工作的，为什么容器替换了引用，以及在 Perl 6 中使用(子例程)签名，以及这些与 Perl 5 的区别。
在第 5 篇文章中，我们将查看 Perl 5 和 Perl 6 之间 sigils(变量名开头的符号)的细微差别。
概览 让我们从 Perl 5 和 Perl 6 中的 sigils 的概述开始:
   Sigil Perl 5 Perl 6     @ Array Positional   % Hash Associative   &amp;amp; Subroutine Callable   $ Scalar Item   * Typeglob n/a    @ (Array vs.</description>
    </item>
    
    <item>
      <title>第二十一章. 结论</title>
      <link>https://ohmysummer.github.io/post/2018-09-21-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0.-%E7%BB%93%E8%AE%BA/</link>
      <pubDate>Fri, 21 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-21-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0.-%E7%BB%93%E8%AE%BA/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第二十一章. 结论 Congratulations. You’ve made it to the end of the book. Some people estimate that only one-third of the readers of a technical book accomplish that feat. This book was only supposed to be 300 pages long, but I couldn’t decide how to leave out anything still included. Sorry about that. The 80 pages of exercise answers really sent me over the limit.</description>
    </item>
    
    <item>
      <title>第二十章. 高级话题</title>
      <link>https://ohmysummer.github.io/post/2018-09-20-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0.-%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/</link>
      <pubDate>Thu, 20 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-20-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0.-%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第二十章. 高级话题 In such a short book I don’t have enough pages to show you everything that you can do. This chapter is a brief survey of some of the features I would have liked to explain in more detail. You now know these exist and you can investigate them further on your own.
在这么短的书中，我没有足够的页面向你展示你可以做的一切。本章简要介绍了一些我希望更详细解释的功能。你现在知道这些存在，你可以自己进一步研究它们。
单行 You can run perl6 one-liners. These are programs that you compose completely on the command line.</description>
    </item>
    
    <item>
      <title>第十九章. 控制其他程序</title>
      <link>https://ohmysummer.github.io/post/2018-09-19-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0.-%E6%8E%A7%E5%88%B6%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Wed, 19 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-19-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0.-%E6%8E%A7%E5%88%B6%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第十九章. 控制其它程序 有时你需要让其他程序为你做一些工作。 Perl 系列语言被称为“互联网的胶水”。开始一个著名的，稳定的，现有的程序比自己重新实现它更容易，更快。本章介绍了许多启动和控制外部程序的方法，以便根据你的意愿对其进行控制。
快速和容易 shell 例程是运行外部命令或程序的快捷方式。它接受参数并在 shell 中运行它，就像你自己输入它一样。此示例使用类 Unix 的 shell 命令列出所有文件：
shell( &#39;ls -l&#39; );  If you were on Windows you’d use a different command. There’s an implicit cmd /c in front of your command:
如果你在 Windows 上，你会使用不同的命令。命令前面有一个隐式的 cmd /c：
shell( &#39;dir&#39; ); # actually cmd /c dir  此命令的输出将转到程序输出所在的位置（只要你没有将标准输出或错误重定向到其他内容）。
你可以通过检查 $*DISTRO 变量来选择命令。 Distro 对象有一个 .is-win 方法，如果它认为你的程序在该平台上运行，则返回 True：
my $command = $*DISTRO.</description>
    </item>
    
    <item>
      <title>第十八章.  Supplies, Channels 和 Promises</title>
      <link>https://ohmysummer.github.io/post/2018-09-18-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0.-supplies-channels-%E5%92%8C-promises/</link>
      <pubDate>Tue, 18 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-18-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0.-supplies-channels-%E5%92%8C-promises/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第十八章. Supplies, Channels 和 Promises Supplies and channels provide ways to send data from one part of a program to another. A Supply is a direct line of communication from a source of data to possibly many consumers. A Channel allows any part of your program to add data to a queue that any part of your program can read.
Supplies 和 channels 提供了将数据从程序的一部分发送到另一个程序的方法。 Supply 是从数据源到可能许多消费者的直接通信线。 Channel 允许程序的任何部分将数据添加到程序的任何部分都可以读取的队列中。</description>
    </item>
    
    <item>
      <title>第十七章. Grammars</title>
      <link>https://ohmysummer.github.io/post/2018-09-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0.-grammars/</link>
      <pubDate>Mon, 17 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0.-grammars/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第十七章. Grammars Grammars are patterns on a higher plane of existence. They integrate and reuse pattern fragments to parse and react to complicated formats. This feature is at the core of Perl 6 in a very literal sense; the language itself is implemented as a grammar. Once you start using it you’ll probably prefer it to regexes for all but the most simple problems.</description>
    </item>
    
    <item>
      <title>第十六章. 更漂亮的正则表达式</title>
      <link>https://ohmysummer.github.io/post/2018-09-16-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0.-%E6%9B%B4%E6%BC%82%E4%BA%AE%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 16 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-16-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0.-%E6%9B%B4%E6%BC%82%E4%BA%AE%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第十六章. 更漂亮的正则表达式 You won’t see all the rest of the regular expression syntax in this chapter, but you’ll see the syntax you’ll use the most. There’s much more to patterns, but this should get you most of the way through common problems. With grammars (Chapter 17), the power of even simple patterns will become apparent.
在本章中，你不会看到所有其他正则表达式语法，但你将看到最常用的语法。模式有很多，但这应该可以解决常见问题。使用 grammars（第17章），即使是简单模式的威力也会变得明显。
量词 Quantifiers allow you to repeat a part of a pattern.</description>
    </item>
    
    <item>
      <title>第十五章. 正则表达式</title>
      <link>https://ohmysummer.github.io/post/2018-09-15-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sat, 15 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-15-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第十五章. 正则表达式 Regular expressions (or regexes) are patterns that describe a possible set of matching texts. They are a little language of their own, and many characters have a special meaning inside patterns. They may look cryptic at first, but after you learn them you have quite a bit of power.
Forget what you’ve seen about patterns in other languages. The Perl 6 pattern syntax started over.</description>
    </item>
    
    <item>
      <title>Toptic Variable</title>
      <link>https://ohmysummer.github.io/post/2018-09-13-toptic-variable/</link>
      <pubDate>Fri, 14 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-13-toptic-variable/</guid>
      <description>$_ 变量 $_ 是主题变量。它是没有显式签名的块的默认参数，因此 for @array {...} 和 given $var {...} 这样的构造通过调用块绑定到 $_。
for for &amp;lt;a b c&amp;gt; { say $_ } # sets $_ to &#39;a&#39;, &#39;b&#39; and &#39;c&#39; in turn say $_ for &amp;lt;a b c&amp;gt;; # same, even though it&#39;s not a block  given given &#39;a&#39; { say $_ } # sets $_ to &#39;a&#39; say $_ given &#39;a&#39;; # same, even though it&#39;s not a block  设置默认的主题变量可以省去很多打字：</description>
    </item>
    
    <item>
      <title>第十四章. Junctions 和集合</title>
      <link>https://ohmysummer.github.io/post/2018-09-14-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0.-junctions-%E4%B8%8E%E9%9B%86%E5%90%88/</link>
      <pubDate>Fri, 14 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-14-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0.-junctions-%E4%B8%8E%E9%9B%86%E5%90%88/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第十四章. Junctions 和集合 Junctions A Junction is a combination of values that is mostly indistinguishable from a single value. They have their roots in the math of quantum mechanics. You may have heard of Schrödinger’s cat, who is both dead and alive at the same time—an analogy that physicist used to show how ridiculous this all is. Well, the joke was on him.</description>
    </item>
    
    <item>
      <title>第十三章. 角色</title>
      <link>https://ohmysummer.github.io/post/2018-09-13-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0.-%E8%A7%92%E8%89%B2/</link>
      <pubDate>Thu, 13 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-13-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0.-%E8%A7%92%E8%89%B2/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第十三章. 角色 角色是 mixins，可以增强你的类，就像它们的内容被定义在类里一样。一旦定义，它们的源实际上会被遗忘（与父类不同）。你可以使用角色来更改类，从现有类创建新类，以及增强单个对象。它们比继承更灵活，通常是更好的解决方案。角色用于代码重用，而类用于管理对象。
给类添加行为 构造一个空的 Butterfly 类。即使没有属性接收参数的值，你也可以为 .new 提供参数：
class Butterfly {} my $butterfly = Butterfly.new: :common-name(&#39;Perly Cracker&#39;);  现在给你的蝴蝶命名。名字应该是 Butterfly 类的一部分吗？名字不是对象. Hamadryas guatemalena 是蝴蝶的名字。 Guatemalan Cracker，Calicó 和 Soñadoracomún 也是蝴蝶的名字。这些都是同一只蝴蝶的名字。
注意 最终，你编写的代码必须在该语言框架内运行。语法有时会让你在认知上将事物分开。
A name is not a more specific version of something the class already does and it’s not limited to butterflies or butterfly-like things. Many dissimilar things can have a common name—animals, cars, food.</description>
    </item>
    
    <item>
      <title>第十二章. 类</title>
      <link>https://ohmysummer.github.io/post/2018-09-12-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0.-%E7%B1%BB/</link>
      <pubDate>Wed, 12 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-12-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0.-%E7%B1%BB/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第十二章. 类 A class is the blueprint for an object and manages an object and its behavior. It declares attributes to define what an object will store and methods to define how an object can behave. Classes model the world in a way that makes it easier for your program to do its job.
类是对象的蓝图，用于管理对象及其行为。它声明属性以定义对象将存储的内容以及定义对象行为方式的方法。类以一种使程序更容易完成其工作的方式对世界建模。
I’m mostly going to ignore object-oriented analysis and design.</description>
    </item>
    
    <item>
      <title>第十一章. 子例程</title>
      <link>https://ohmysummer.github.io/post/2018-09-11-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0.-%E5%AD%90%E4%BE%8B%E7%A8%8B/</link>
      <pubDate>Tue, 11 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-11-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0.-%E5%AD%90%E4%BE%8B%E7%A8%8B/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第十一章. 子例程 Now it’s time for more sophisticated subroutines. You were introduced to them in Chapter 5 but you only saw enough to support the upcoming chapters. Now that you’ve seen Arrays and Hashes, there’s much more you can do with subroutine signatures.
现在是更复杂的子例程的时候了。你在第五章见过它们了，但你只看到足以支持即将到来的章节。现在你已经看过数组 和 哈希，你可以用子例程签名做更多的事情。
A Basic Subroutine When you run a subroutine you get some sort of result: the last evaluated expression.</description>
    </item>
    
    <item>
      <title>第十章. 使用模块</title>
      <link>https://ohmysummer.github.io/post/2018-09-10-%E7%AC%AC%E5%8D%81%E7%AB%A0.-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 10 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-10-%E7%AC%AC%E5%8D%81%E7%AB%A0.-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第十章. 使用模块 Modules allow you to compartmentalize, distribute, and reuse code. Someone creates a general solution to something, then packages it so you can reuse it in your programs. Sometimes people make these modules available to everyone. You can find some Perl 6 modules at https://modules.perl6.org
You don’t have to understand the code inside a module to benefit from its features. You can usually follow the examples in its documentation even if it uses syntax that you haven’t already seen.</description>
    </item>
    
    <item>
      <title>第九章. Associatives</title>
      <link>https://ohmysummer.github.io/post/2018-09-09-%E7%AC%AC%E4%B9%9D%E7%AB%A0.-associatives/</link>
      <pubDate>Sun, 09 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-09-%E7%AC%AC%E4%B9%9D%E7%AB%A0.-associatives/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第九章. Associatives Associative 使用被称为键的任何名字索引到值。Associative是无序的，因为键没有相对顺序。其他语言具有类似的数据类型，它们称为关联数组，字典，散列，映射或类似的东西。有几种类型的专用关联数据结构，你已经使用了其中的一些。
Pairs A Pair has a single key and a value. You’ve already used these in their adverbial form, although you didn’t know they were Pairs. Create a Pair through general object construction with the name and value as arguments:
Pair 具有单个键和值。你已经以他们的副词形式使用了这些，虽然你不知道他们是 Pair。通过一般对象构造创建一个 Pair，名称和值作为参数：
my $pair = Pair.new: &#39;Genus&#39;, &#39;Hamadryas&#39;;  The =&amp;gt; is the Pair constructor. You don’t have to quote the lefthand side because the =&amp;gt; does that for you as long as it looks like a term:</description>
    </item>
    
    <item>
      <title>第八章. 文件和目录,输入和输出</title>
      <link>https://ohmysummer.github.io/post/2018-09-08-%E7%AC%AC%E5%85%AB%E7%AB%A0.-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/</link>
      <pubDate>Sat, 08 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-08-%E7%AC%AC%E5%85%AB%E7%AB%A0.-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第八章. 文件和目录, 输入和输出 读写文本是许多你想要编写的程序的基础。你将数据存储在文件中并稍后检索该数据。本章是关于你需要执行此操作的所有功能。在此过程中，你将看到如何处理文件路径，移动文件以及使用目录。大多数情况都是使用你已经看过的相同语法完成的，但现在使用不同对象的类型。
本章中的许多任务可能由于程序之外的原因而失败。如果你希望在不同的目录中工作或希望某个文件存在，那么如果这些条件不为真，你可能不希望继续。这只是一个处理外部资源的程序的事实。
文件路径 IO::Path 对象表示文件路径。它知道如何根据文件系统的规则组合和拆分路径。只要路径的形式符合这些规则，该路径与实际存在的文件无关。你马上会看到如何处理丢失的文件。现在，在任何字符串上调用 .IO 将其转换为 IO::Path 对象：
my $unix-path = &#39;/home&#39;.IO; my $windows-path = &#39;C:/Users&#39;.IO;  要构建更深的路径，请使用 .add。你一次可以有多个层级。 .add 不会改变原始对象;它为你提供了一个新对象：
my $home-directory = $unix-path.add: &#39;hamadryas&#39;; my $file = $unix-path.add: &#39;hamadryas/file.txt&#39;;  如果要在那里构建路径，请赋值回原始对象：
$unix-path = $unix-path.add: &#39;hamadryas/file.txt&#39;;  二元赋值形式可能更有用：
$unix-path .= add: &#39;hamadryas/file.txt&#39;;  .basename 和 .parent 方法拆分路径：
my $home = &#39;/home&#39;.IO; my $user = &#39;hamadryas&#39;; # Str or IO::File will work my $file = &#39;file.</description>
    </item>
    
    <item>
      <title>第七章. 当出错的时候</title>
      <link>https://ohmysummer.github.io/post/2018-09-07-%E7%AC%AC%E4%B8%83%E7%AB%A0.-%E5%BD%93%E5%87%BA%E9%94%99%E7%9A%84%E6%97%B6%E5%80%99/</link>
      <pubDate>Fri, 07 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-07-%E7%AC%AC%E4%B8%83%E7%AB%A0.-%E5%BD%93%E5%87%BA%E9%94%99%E7%9A%84%E6%97%B6%E5%80%99/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第七章. 当出错的时候 Perl 6 doesn’t always immediately give up when something goes wrong. It can fail softly. If the result of that problem doesn’t affect anything else in the program there’s no need to complain about it. However, the moment it becomes a problem that passive failure demands your attention.
This chapter shows you the error mechanisms and how to deal with them. You’ll see how to handle the problems that your program notices on your behalf as well as detect and report problems on your own.</description>
    </item>
    
    <item>
      <title>第六章. Positionals</title>
      <link>https://ohmysummer.github.io/post/2018-09-06-%E7%AC%AC%E5%85%AD%E7%AB%A0.-positionals/</link>
      <pubDate>Thu, 06 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-06-%E7%AC%AC%E5%85%AD%E7%AB%A0.-positionals/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第六章. Positionals Your programming career is likely to be, at its heart, about moving and transforming ordered lists of some kind. Those might be to-do lists, shopping lists, lists of web pages, or just about anything else.
The broad term for such as list is Positional. Not everything in this chapter is strictly one of those; it’s okay to pretend that they are, though.</description>
    </item>
    
    <item>
      <title>第五章. 创建块</title>
      <link>https://ohmysummer.github.io/post/2018-09-05-%E7%AC%AC%E4%BA%94%E7%AB%A0.-%E5%88%9B%E5%BB%BA%E5%9D%97/</link>
      <pubDate>Wed, 05 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-05-%E7%AC%AC%E4%BA%94%E7%AB%A0.-%E5%88%9B%E5%BB%BA%E5%9D%97/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第五章. 创建块 存储 Blocks 你可以把 Block 存储在一个变量中而不立即执行它。now 是一个内置项, 它能够给你一个 Instant。使用 := 进行绑定让右侧和左侧一样。这意味着 $block 和 Block 相同:
my $block := { now };  你不能对 $block 赋值, 因为没有涉及到容器。
你本没必要绑定到 Block 的。赋值也是可以的, 并且你可以在后面更改值:
my $block = { now }; $block = &#39;Hamadryas&#39;;  这不是那么有趣, 因为你可以在你能使用 now 的任何地方使用它。但是计算一个 1 分钟之后的时间的 Block 怎么样？给 now 加上 60 秒：
my $minute-later := { now + 60 };  当你执行 Block 的时候, 它的结果是最后一个被求值的表达式的值。使用 () 操作符执行 Block：</description>
    </item>
    
    <item>
      <title>第四章. 字符串</title>
      <link>https://ohmysummer.github.io/post/2018-09-04-%E7%AC%AC%E5%9B%9B%E7%AB%A0.-%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 04 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-04-%E7%AC%AC%E5%9B%9B%E7%AB%A0.-%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第四章 字符串 Strings represent the text data in your program as Str objects. Perl 6’s facility with text data and its manipulation is one of its major attractions. This chapter focuses on the many ways that you can create Strs; for any job you have there’s likely a feature that makes that easy for you. Along with that you’ll see a bit about inspecting, extracting, and comparing text in preparation for loftier goals coming up.</description>
    </item>
    
    <item>
      <title>第三章. 数字</title>
      <link>https://ohmysummer.github.io/post/2018-09-03-%E7%AC%AC%E4%B8%89%E7%AB%A0.-%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 03 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-03-%E7%AC%AC%E4%B8%89%E7%AB%A0.-%E6%95%B0%E5%AD%97/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第三章. 数字 This chapter steps back from the breadth of the previous chapter to focus on the idea of numbers and their representation in your programs. Perl 6 supports several types of numbers and works hard to keep them exact as long as it can.
本章从前一章的广度开始，重点介绍数字的概念及其在程序中的表示。 Perl 6 支持多种类型的数字，并且尽可能地努力保持它们的准确性。
Number Types Not all numbers are created alike. You’ve seen whole numbers, how to do basic mathematical operations on them, and how to compare them.</description>
    </item>
    
    <item>
      <title>第二章. 猜数字</title>
      <link>https://ohmysummer.github.io/post/2018-09-02-%E7%AC%AC%E4%BA%8C%E7%AB%A0.-%E7%8C%9C%E6%95%B0%E5%AD%97/</link>
      <pubDate>Sun, 02 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-02-%E7%AC%AC%E4%BA%8C%E7%AB%A0.-%E7%8C%9C%E6%95%B0%E5%AD%97/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第二章. 猜数字 You’re about to be thrown in the deep end. There are some basic things you need to know to write useful programs, and you’ll meet a lot of them in this chapter so you can write a number-guessing program by the end. It’s quite a bit to take in all at once but it should make the rest of the chapters more interesting.</description>
    </item>
    
    <item>
      <title>第一章. 介绍</title>
      <link>https://ohmysummer.github.io/post/2018-09-01-%E7%AC%AC%E4%B8%80%E7%AB%A0.-%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sat, 01 Sep 2018 00:10:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-01-%E7%AC%AC%E4%B8%80%E7%AB%A0.-%E4%BB%8B%E7%BB%8D/</guid>
      <description>声明 本章翻译仅用于 Perl 6 学习和研究, 请支持电子版或纸质版。
第一章. 介绍 本章是该语言的全貌图; 如果你还不了解正在发生的一切，请不要担心。担心如果你到了本书的最后，你仍然没有了解全部！有讲很多东西，所以将围绕一些话题，重新审视其他话题，并通过一些练习看看它们是如何融合在一起的 - 这真的都是关于实践的。
为什么是 Perl 6? 对于初学者，你要学习 Perl 6。你也可能通过使用这种语言来使得物有所值！
但是什么使这种语言变得有吸引力？ Perl 家族一直喜欢 DWIM-Do What I Mean。你经常做的事情应该很容易做，而最困难的事情应该是可能的。任何编程语言的用处都可以通过它解决问题的程度来衡量。
Perl 6 是一种出色的文本处理语言 - 甚至可能比 Perl 5 更好。正则表达式（第15章）有许多令人兴奋的新功能，可以更容易地匹配和提取文本。内置 grammar（第17章）功能允许你轻松编写复杂的规则来处理和响应文本。
渐进类型（第3章）允许你注释变量，并限制你可以存储的内容。例如，你可以指定数字必须是整数，正数或两个其他数字之间的数。你不必必须使用它（这是渐进的部分）。你将能够注释子例程接受什么以及它应该返回什么。这可以快速揭示数据边界的错误。
内置并发（第18章）功能允许你将问题分解为单独运行并可能同时运行的部分。该语言为你处理大部分内容。
惰性列表和无限列表允许你处理序列而无需过多复制或甚至一次拥有整个列表（第6章）。你可以轻松创建自己的无限惰性列表。
我可以继续前进，但是当你按照本书的方式工作时，你会遇到更多令人惊叹的功能。
有时你不想使用 Perl 6。没有语言能适用所有的工作。如果你更喜欢其他更好的东西，或者可以使用不同的工具更快地完成任务，那么对你来说更强大！但是，我希望本书可以帮助你在 Perl 6 中快速有效地完成你需要做的事情。
First Steps with the REPL REPL 是一个 Read-Evaluate-Print-Loop 的工具，提供交互式提示。 REPL 计算你键入的代码，显示结果，然后再次提示你。这是尝试代码片段的快速方法。当你运行不带参数的 perl6 时，它会启动它的 REPL：
% perl6 To exit type &#39;exit&#39; or &#39;^D&#39; &amp;gt;  &amp;gt; 是等待你输入内容的提示。当你键入 Return 时，REPL 开始工作。通过使两个数字相加来尝试 REPL：</description>
    </item>
    
    <item>
      <title>Perl 6 中的容器</title>
      <link>https://ohmysummer.github.io/post/2018-08-29-perl6%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Wed, 29 Aug 2018 19:55:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-08-29-perl6%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description>在本系列的第一篇文章中，将 Perl 5 与 Perl 6 进行了比较，我们研究了将代码迁移到 Perl 6 时可能遇到的一些问题。在第二篇文章中，我们研究了垃圾收集在 Perl 6 中的工作原理。第三篇文章，我们将重点介绍 Perl 5 的引用以及如何在 Perl 6 中处理它们，并介绍绑定和容器的概念。
引用 Perl 6 中没有引用，这对许多习惯于 Perl 5 语义的人来说都是令人惊讶的。但不要担心：因为没有引用，所以您不必担心是否应该解引用某些内容。
# Perl 5 my $foo = \@bar; # must add reference \ to make $foo a reference to @bar say @bar[1]; # no dereference needed say $foo-&amp;gt;[1]; # must add dereference -&amp;gt;  # Perl 6 my $foo = @bar; # $foo now contains @bar say @bar[1]; # no dereference needed, note: sigil does not change say $foo[1]; # no dereference needed either  有人可能会说 Perl 6 中的所有东西都是引用。来自 Perl 5（其中一个对象是一个受祝福的引用），这将是关于 Perl 6 的逻辑结论，其中所有的东西都是对象（或者可以被认为是一个对象）。但这并不能完全符合 Perl 6 中的情况，并且会妨碍你理解 Perl 6 的工作原理。谨防虚假的朋友！</description>
    </item>
    
    <item>
      <title>Command Line Arguments in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-08-07-command-line-arguments-in-perl-6/</link>
      <pubDate>Tue, 07 Aug 2018 19:54:26 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-08-07-command-line-arguments-in-perl-6/</guid>
      <description>MAIN 子例程 命名参数和位置参数  命名参数 位置参数 Multi dispatch 组合命名参数和位置参数  可选参数和必选参数 别名或备用命名参数 USAGE 子例程  Sub MAIN 在 Perl 6 中，命令行参数的解析是使用 MAIN 子例程完成的，MAIN 子例程是一个特殊的子例程，它根据签名解析命令行参数。与其他子程序一样，您可以使用命名参数和位置参数，可选（和必需）参数，multiple dispatch 等。 通过定义 MAIN 子例程，编译器会自动生成 USAGE 子例程。可以修改此子例程以返回自定义的 usage 信息。所有的命令行参数也可以在特殊变量 @*ARGS 中使用，它可以在 MAIN 处理之前进行更改。
命名参数和位置参数 命名参数
我们从一个简单的程序开始（保存为 prog.p6）:
use v6; sub MAIN( Str :$name = &#39;John&#39;, Str :$last-name = &#39;Doe&#39;, ) { my $formatted-name = &amp;quot;$name.tc() $last-name.tc()&amp;quot;; say $formatted-name; }  在这个 MAIN 子程序中，我们创建了两个命名参数，$name 和 $last-name，带有类型约束（Str），方法是在子例程的签名给每个变量添加 :。这些参数还具有默认值，这是通过为参数赋值来实现的。在这种情况下，我们将 $name 设置为默认值 &amp;lsquo;John&amp;rsquo;，将 $last-name 设置为 &amp;lsquo;Doe&amp;rsquo;。如果执行 prog.</description>
    </item>
    
    <item>
      <title>Intro Into Perl 6 Regexes and Grammars</title>
      <link>https://ohmysummer.github.io/post/2018-08-04-intro-into-perl-6-regexes-and-grammars/</link>
      <pubDate>Sat, 04 Aug 2018 20:33:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-08-04-intro-into-perl-6-regexes-and-grammars/</guid>
      <description>tpm-regex.perl6.party
STATUS QUO: PCRE “Perl 兼容的正则表达式”非常神秘，但许多语言只是盲目地遵循现状。
它们是 &amp;lt;?!, &amp;lt;=?!, or &amp;lt;!#?@$%^( 吗？
/(?&amp;lt;!foo)bar(?=baz)/  更好的正则表达式语法 Perl 6 并不害怕拒绝现状。
/&amp;lt;!after foo&amp;gt; bar &amp;lt;before baz&amp;gt;/  空格可以自由使用 文字字符串：字母数字字符可以按原样使用。 其他的字符，只需使用引号或反斜杠：
say so &amp;quot;I ♥ Perl 6&amp;quot; ~~ /I \♥ Perl 6/; # False say so &amp;quot;I ♥ Perl 6&amp;quot; ~~ / &#39;I ♥ Perl 6&#39; /; # True say so &amp;quot;I ♥ Perl 6&amp;quot; ~~ / I #`(BTW, you can use inline,) &amp;quot; ♥ &amp;quot; &amp;quot;Perl 6&amp;quot; # as well as end-of-line comments /; # True  文本内容的变量 默认设置是将内容与纯文本匹配。将变量放入尖括号中以将其解释为正则表达式。</description>
    </item>
    
    <item>
      <title>Ping Pang in Perl6</title>
      <link>https://ohmysummer.github.io/post/2018-08-03-ping-pang-in-perl6/</link>
      <pubDate>Fri, 03 Aug 2018 21:08:25 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-08-03-ping-pang-in-perl6/</guid>
      <description>Ping Pang in Perl 6 使用 channels 在线程之间传递消息是一种管理并发的简单方法。
一位朋友最近向我展示了一个很酷的程序，用 elixir 来演示消息传递 - 两个线程通过来回传递递增的数字来计数。快速搜索出现了一些例子。
我决定在 Perl 6 中实现这个。这就是我想出来的→
my ($ping, $pong) = Channel.new xx 2; sub ping { while $ping.receive -&amp;gt; $n { say &amp;quot;ping $n (thread #{$*THREAD.id})&amp;quot;; $pong.send: $n + 1; } } sub pong { while $pong.receive -&amp;gt; $n { last if $n &amp;gt;= 5; say &amp;quot;pong $n (thread #{$*THREAD.id})&amp;quot;; $ping.send: $n + 1; } } $ping.send: 1; await Promise.</description>
    </item>
    
    <item>
      <title>使用 Cro 创建单页应用程序</title>
      <link>https://ohmysummer.github.io/post/2018-08-02-%E4%BD%BF%E7%94%A8cro%E5%88%9B%E5%BB%BA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Thu, 02 Aug 2018 22:54:18 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-08-02-%E4%BD%BF%E7%94%A8cro%E5%88%9B%E5%BB%BA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>使用 Cro 创建单页应用 本教程将介绍如何使用 Cro 作为后端构建简单的单页应用程序。对于前端，我们将使用 webpack，ES6，React 和 Redux。你不需要事先了解这些信息，但如果您想在自己的应用程序中很好地使用它们，则需要进一步阅读。
代码可以在这里获取。在教程的各个阶段，提交了当前的状态。仓库历史记录与教程完全匹配，因此你可以使用它来获取各步骤变更的概述，或者如果你试图通过从头开始构建这些东西，可以知道你错过了什么。
你需要什么  要安装 Cro (请参阅本指南获取相关帮助)
 要安装 npm (即 Node.js 的包管理器, 我们要用它来获取需要的包来构建前端); 在基于 Debian 的 Linux 发行版上，只需 sudo apt install npm。
  我们要构建什么 所以我们正在举办美食节或者啤酒节。或者任何带有一堆我们可以尝试的东西的活动。但是&amp;hellip;尝试什么？如果有这样一些应用程序就好了，人们可以留下他们关于什么火和什么不火的提示，我们可以实时看到他们。如果在去过的上一届啤酒节上有过这样的东西，我可能会幸免于那杯绿茶啤酒&amp;hellip;&amp;hellip;
所以, 我们会制作一个单页应用程序以支持:
 提交新的提示 (POST 到后端)
 现场发布最新提示 (通过网络套接字提供)
 能够同意或不同意某提示 (也是 POST) 能够看到按照最愉快到最不愉快 (通过 GE T获取) 排序的提示列表  Stubbing 后端 给应用程序想一个有创意的名称。我叫它 &amp;ldquo;tipsy&amp;rdquo;。然后使用 cro stub 来存根 HTTP 应用程序。为了简单起见，我们将跳过 HTTPS（也就是HTTP/2.0），但会包含 Web 套接字支持。
$ cro stub http tipsy tipsy Stubbing a HTTP Service &#39;tipsy&#39; in &#39;tipsy&#39;.</description>
    </item>
    
    <item>
      <title>使用 Perl 6 连接 Kafka</title>
      <link>https://ohmysummer.github.io/post/2018-07-20-%E4%BD%BF%E7%94%A8perl6%E8%BF%9E%E6%8E%A5kafka/</link>
      <pubDate>Fri, 20 Jul 2018 20:14:28 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-20-%E4%BD%BF%E7%94%A8perl6%E8%BF%9E%E6%8E%A5kafka/</guid>
      <description>有这样一个场景, 数据发送方将压缩文件读成字节数组后发往 Kafka, 然后第三方的 Kafka Client 从中读取字节数组解压缩, 每条 message 对应一个压缩文件, 每个压缩文件中包含 _log.txt 和 _result.txt。
Perl 6 可以从 Kafka 中读取消息并完成解析。
首先安装相关模块: Pkafka 用于和 Kafka 交互； Archive::Libarchive 用于解压缩字节数组。 Cro 用于 HTTP 请求，DBiish 用于数据库读写。
zef install Pkafka zef install Archive::Libarchive zef install Cro zef install DBIish  代码片段如下:
use PKafka::Consumer; use PKafka::Message; use PKafka::Producer; use Archive::Libarchive; use Archive::Libarchive::Constants; use Cro::HTTP::Client; use JSON::Fast; use JSON::Path; use DBIish; sub MAIN () { my $brokers = &amp;quot;127.</description>
    </item>
    
    <item>
      <title>Io Guide</title>
      <link>https://ohmysummer.github.io/post/2018-07-14-io-guide/</link>
      <pubDate>Sat, 14 Jul 2018 22:35:26 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-14-io-guide/</guid>
      <description>基础知识 绝大多数常见的 IO 工作都是由 IO::Path 类型完成的。如果你想以某种形式或形状读取或写入文件，这就是你想要的类。它抽象出文件句柄（或“文件描述符”）的细节，因此你甚至不必考虑它们。
在幕后， IO::Path 与 IO::Handle 一起使用 ; 如果你需要比 IO::Path 提供的更多控制，你可以直接使用的类。当与其他进程，例如通过工作 Proc 或 Proc::Async 类型，你还可以处理一个子类的 IO::Handle 在 IO::Pipe。
最后，你有 IO::CatHandle ，以及 IO::Spec 及其子类，你很少直接使用它们。这些类为你提供了高级功能，例如将多个文件作为一个句柄进行操作，或者进行低级路径操作。
除了所有这些类之外，Perl 6还提供了几个子程序，可以让你间接使用这些类。如果你喜欢函数式编程风格或Perl 6 单行程序，这些就派上用场了。
虽然 IO::Socket 及其子类也与输入和输出有关，但本指南并未涵盖它们。
路径导航 什么是 IO::Path？ 要将路径表示为文件或目录，请使用 IO::Path 类型。获取该类型对象的最简单方法是通过在 Str 上调用 .IO 方法将字符串强制为 IO 类型：
say &#39;my-file.txt&#39;.IO; # OUTPUT: «&amp;quot;my-file.txt&amp;quot;.IO␤»  看起来这里似乎缺少某些东西 - 没有涉及卷或绝对路径 - 但该信息实际上存在于该 IO 对象中。你可以通过使用 .perl 方法看到它：
say &#39;my-file.txt&#39;.IO.perl; # OUTPUT: «IO::Path.new(&amp;quot;my-file.txt&amp;quot;, :SPEC(IO::Spec::Unix), :CWD(&amp;quot;/home/camelia&amp;quot;))␤»  这两个额外的属性 - SPEC 和 - CWD 指定路径应该使用的操作系统语义类型以及路径的“当前工作目录”，即如果它是相对路径，则它相对于该目录。</description>
    </item>
    
    <item>
      <title>Cro Http Test</title>
      <link>https://ohmysummer.github.io/post/2018-07-14-cro-http-test/</link>
      <pubDate>Sat, 14 Jul 2018 17:14:59 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-14-cro-http-test/</guid>
      <description>Cro::HTTP::Test 原则上可以通过使用 Cro::HTTP::Server托管应用程序, 使用 Cro::HTTP::Client向其发出请求, 并使用标准 Test 库检查结果来编写 Cro HTTP 服务的测试。该库使编写此类测试更容易, 并通过以下方式更快地执行它们：
 为发出测试请求和检查结果提供更方便的 API 跳过网络并将 Cro::TCP 对象从客户端管道传递到服务器管道, 反之亦然  基本示例 给定模块 MyService::Routes, 如下所示：
sub routes() is export { route { get -&amp;gt; { content &#39;text/plain&#39;, &#39;Nothing to see here&#39;; } post -&amp;gt; &#39;add&#39; { request-body &#39;application-json&#39; =&amp;gt; -&amp;gt; (:$x!, :$y!) { content &#39;application/json&#39;, { :result($x + $y) }; } } } }  我们可以像这样编写测试：
use Cro::HTTP::Test; use MyService::Routes; test-service routes(), { test get(&#39;/&#39;), status =&amp;gt; 200, content-type =&amp;gt; &#39;text/plain&#39;, body =&amp;gt; /nothing/; test-given &#39;/add&#39;, { test post(json =&amp;gt; { :x(37), :y(5) }), status =&amp;gt; 200, json =&amp;gt; { :result(42) }; test post(json =&amp;gt; { :x(37) }), status =&amp;gt; 400; test get(json =&amp;gt; { :x(37) }), status =&amp;gt; 405; } } done-testing;  设置要测试的服务 test-service 函数有两个候选者。</description>
    </item>
    
    <item>
      <title>Class Channel</title>
      <link>https://ohmysummer.github.io/post/2018-07-08-class-channel/</link>
      <pubDate>Sun, 08 Jul 2018 16:11:52 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-08-class-channel/</guid>
      <description>class Channel {}  Channel 是一个线程安全的队列，可帮助你将一个或多个生产者的一系列对象发送给一个或多个消费者。每个对象将仅到达由调度程序选择的一个这样的消费者。如果只有一个消费者和一个生产者，则保证保留对象的顺序。在 Channel 上发送是非阻塞的。
my $c = Channel.new; await (^10).map: { start { my $r = rand; sleep $r; $c.send($r); } } $c.close; say $c.list;  可以在并发页面中找到更多示例。
方法 send 方法 定义为：
method send(Channel:D: \item)  将项目排入频道。如果通道已经关闭，则抛出类型X :: Channel :: SendOnClosed的异常。此调用不会阻止等待使用者获取该对象。对可排队的项目数量没有设定限制，因此应注意防止失控排队。
my $c = Channel.new; $c.send(1); $c.send([2, 3, 4, 5]); $c.close; say $c.list; # OUTPUT: «(1 [2 3 4 5])␤»  receive 方法 定义为：
method receive(Channel:D:)  从频道接收和删除项目。如果没有项目存在，它会阻塞，等待来自另一个线程的发送。</description>
    </item>
    
    <item>
      <title>class Supply</title>
      <link>https://ohmysummer.github.io/post/2018-07-07-class-supply/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:07 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-07-class-supply/</guid>
      <description>class Supply {}  supply 是一种线程安全的异步数据流，如 Channel，但它可以有多个订阅者（taps: 水龙头），所有订阅者都可以获得流经 supply 的相同值。
它是 观察者模式 的线程安全实现，是支持 Perl 6 中的反应式编程的核心。
有两种类型的 Supplies：实时(live)和按需(on demand)。当水龙头接入到实时(live)供应时，水龙头将仅在创建水龙头之后看到流经 supply 的值。这种供应(supplies)通常是无限的，例如鼠标移动。关闭这样的水龙头(tap)不会阻止鼠标事件的发生，它只是意味着值将看不见了。所有的开孔器(tappers )都看到了相同的值流(flow of values)。
在按需供应上轻敲(tap)将发起值的产生，再次轻敲(tap)供应可能会产生一组新的值。例如，每次轻敲时，Supply.interval 都会生成一个具有适当间隔的新计时器。如果水龙头(tap)关闭，计时器只会停止向该水龙头发射值。
从 Supplier 的工厂方法 Supply 获得 live Supply（实时供应）。通过在 Supplier 对象上调用 emit 来发出新值。
my $supplier = Supplier.new; my $supply = $supplier.Supply; $supplier.tap( -&amp;gt; $v { say &amp;quot;$v&amp;quot; }); $supplier.emit(42); # Will cause the tap to output &amp;quot;42&amp;quot;  实时方法在实时供应上返回 True。工厂方法如 interval，from-list 会返回按需供应(on demand supplies)。
可以使用 Supplier::Preserving创建一个直到第一次轻敲的保存值的实时供应（Supply）。</description>
    </item>
    
    <item>
      <title>Perl 6 Pod</title>
      <link>https://ohmysummer.github.io/post/2018-07-07-perl6-pod/</link>
      <pubDate>Sat, 07 Jul 2018 18:16:19 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-07-perl6-pod/</guid>
      <description>Perl 6 Pod 是一种易于使用的标记语言。 Pod 可用于编写语言文档，用于文档化程序和模块，以及其他类型的文档组合。
每个 Pod 文档必须以 =begin pod 开头，以 =end pod 结束。这两个分隔符之间的所有内容都将被处理并用于生成文档。
=begin pod A very simple Perl 6 Pod document =end pod  块结构 Pod 文档可能包含多个 Pod 块。有四种方法可以定义块（分隔符，段落，缩写和声明符）; 前三个产生相同的结果，但第四个不同。你可以使用最方便你的特定文档任务的任何形式。
分割符块 分隔块由 =begin 和 =end 标记限定，两者都后跟有效的 Perl 6 标识符，后者是块的 typename。完全小写的类型名称（例如 =begin head1）或完全大写（例如：=begin SYNOPSIS）保留。
=begin head1 Top Level Heading =end head1  配置信息 在 typename 之后， =begin 标记行的其余部分被视为块的配置信息。此信息由不同类型的块以不同方式使用，但始终使用 Perl6-ish 选项对指定。也就是说，任何：
   alue is&amp;hellip; Specify with&amp;hellip; Or with&amp;hellip; Or with&amp;hellip;     List :key[$e1, $e2, &amp;hellip;] :key($e1, $e2, &amp;hellip;)    Hash :key{$k1=&amp;gt;$v1, $k2=&amp;gt;$v2}     Boolean (true) :key :key(True) :key[True]   Boolean (false) :!</description>
    </item>
    
    <item>
      <title>Doing Math With Perl6</title>
      <link>https://ohmysummer.github.io/post/2018-07-07-doing-math-with-perl6/</link>
      <pubDate>Sat, 07 Jul 2018 15:08:06 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-07-doing-math-with-perl6/</guid>
      <description>Sets Perl 6 包括 Set 数据类型，以及对大多数 set 操作的支持。并集和交集不仅是原生操作，它们使用自然符号 ∩ 和 ∪。例如，此代码将检查有限数量集的集算术的基本定律：
my @arbitrary-numbers = ^100; my \U = @arbitrary-numbers.Set; my @sets; @sets.push: Set.new( @arbitrary-numbers.pick( @arbitrary-numbers.elems.rand)) for @arbitrary-numbers; my (@union, @intersection); for @sets -&amp;gt; $set { @union.push: $set ∩ $set === $set; @intersection.push: $set ∪ $set === $set; } say &amp;quot;Idempotent union is &amp;quot;, so @union.all; # OUTPUT: «Idempotent union is True» say &amp;quot;Idempotent intersection is &amp;quot;, so @intersection.all; # OUTPUT: «Idempotent intersection is True» my (@universe, @empty-set, @id-universe, @id-empty); for @sets -&amp;gt; \A { @universe.</description>
    </item>
    
    <item>
      <title>Date and Time Functions</title>
      <link>https://ohmysummer.github.io/post/2018-07-07-date-and-time-functions/</link>
      <pubDate>Sat, 07 Jul 2018 13:33:35 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-07-date-and-time-functions/</guid>
      <description>Perl 6 包括几个处理时态信息的类：Date，DateTime，Instant 和 Duration。前三个是 dateish，所以它们混合了 Dateish 角色，它定义了处理日期的类应该采用的所有方法和属性。它还包括以 X::Temporal 为根的异常的类层次结构。
我们将尝试在下一个（稍微扩展）的示例中说明这些类，这个示例可用于处理目录中的所有文件（默认情况下）。在目录中使用特定扩展名（默认为 .p6），根据他们的年龄对其进行排序，并计算每月创建的文件数量，以及在几个月的范围内表示的特定时期内修改的文件数量：
use v6; sub MAIN( $path = &amp;quot;.&amp;quot;, $extension = &amp;quot;p6&amp;quot; ) { my DateTime $right = DateTime.now; my %metadata; my %files-month; my %files-period; for dir($path).grep( / \.$extension $/ ) -&amp;gt; $file { CATCH { when X::Temporal { say &amp;quot;Date-related problem&amp;quot;, .payload } when X::IO { say &amp;quot;File-related problem&amp;quot;, .payload } default { .payload.say } } my Instant $modified = $file.</description>
    </item>
    
    <item>
      <title>Hashes and Maps</title>
      <link>https://ohmysummer.github.io/post/2018-07-07-hashes-and-maps/</link>
      <pubDate>Sat, 07 Jul 2018 10:56:38 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-07-hashes-and-maps/</guid>
      <description>关联角色和关联类 关联角色是 Hash 和 Map 以及 MixHash 等其他类的基础。它定义了将在关联类中使用的两种类型; 默认情况下，您可以使用任何内容（字面意思，因为任何 Any 子类的类都可以使用）作为键和 keyof 方法。
默认情况下，使用 % sigil 声明的任何对象都将获得 Associative 角色，默认情况下将表现为散列，但此角色仅提供上述两种方法，以及默认的 Hash 行为。
say (%).^name ; # 输出 Hash  相反，如果未混入 Associative 角色，则不能使用 % sigil，但由于此角色没有任何关联属性，因此你必须重新定义散列下标操作符的行为。为此，你必须重写几个函数：
class Logger does Associative[Cool,DateTime] { has %.store; method log( Cool $event ) { %.store{ DateTime.new( now ) } = $event; } multi method AT-KEY ( ::?CLASS:D: $key) { my @keys = %.store.keys.grep( /$key/ ); %.store{ @keys }; } multi method EXISTS-KEY (::?</description>
    </item>
    
    <item>
      <title>Proc Async</title>
      <link>https://ohmysummer.github.io/post/2018-07-06-proc-async/</link>
      <pubDate>Fri, 06 Jul 2018 21:14:56 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-06-proc-async/</guid>
      <description>class Proc::Async {}  注意: 目前只有 Rakudo 的 MoarVM 后端实现了 [Proc::Async](https://docs.perl6.org/type/Proc::Async)。
Proc::Async 允许你异步地运行外部命令, 捕获标准输出和错误句柄，并可选择地写入到它的标准输入中。
my $file = &#39;foo&#39;.IO; spurt $file, &amp;quot;and\nCamelia\n♡\nme\n&amp;quot;; my $proc = Proc::Async.new: :w, &#39;tac&#39;, &#39;--&#39;, $file, &#39;-&#39;; # my $proc = Proc::Async.new: :w, &#39;sleep&#39;, 15; # uncomment to try timeouts react { whenever $proc.stdout.lines { # split input on \r\n, \n, and \r say &#39;lines: &#39;, $_ } whenever $proc.stderr { say &#39;stderr: &#39;, $_ } whenever $proc.</description>
    </item>
    
    <item>
      <title>我为什么学习Perl6</title>
      <link>https://ohmysummer.github.io/post/2018-07-07-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0perl6/</link>
      <pubDate>Fri, 06 Jul 2018 00:27:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-07-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0perl6/</guid>
      <description>http://www.evanmiller.org/why-im-learning-perl-6.html
想听一个编程笑话吗？
Perl 6。
想知道我最喜欢的编程语言吗？
Perl 6。
嘘，克隆 master 分支并运行这个：
use v6.d.PREVIEW; my $channel = Channel.new; my @ten_tasks = (^10).map: { start { my $thread = $*THREAD.id; await $channel; say &amp;quot;HOLY MOLEY SOMEONE STOLE MY THREAD&amp;quot; if $thread != $*THREAD.id; } } $channel.send(&amp;quot;Ring ring&amp;quot;) for ^10; $channel.close; await @ten_tasks;  猜猜它输出了什么？
没有！开个玩笑，你会看到很多来自任务的烦恼消息，等待电话响起，然后穿着别人的操作系统线程醒来。
为什么这很重要？并发很难，如果你想要M：N线程多路复用（即WEB SCALE CODE，其中应用程序线程没有固定到pthread）你今天的选择正是Erlang，Go，.NET和Perl 6。
如果你对Erlang感到困惑，被Go推迟，对.NET无动于衷，请看看Perl 6.认真的。当然，它的发展时间比男孩时期要长 - 从2000年开始，比电影早两年，并在2015年发布，两年之后 - 但也许如果有人在某事上工作了15年，他们实际上可能会做出一些好事。我不是说这种情况是真的（可能不是少年时代），但至少它是可能的，对吗？
有趣的是，十五年前，每个人都在说Perl是如何通过大规模的语言重新设计而自拔的，因为世界显然将转向Python和Ruby。好吧每个人都切换到Python和Ruby，但现在每个人都有了再次切换的痒，因为事实证明Python和Ruby并不是为并发代码执行而设计的。如果你需要的是仿生robo-feet，也许拍摄自己的脚并不是一个糟糕的策略。
我不会在这里回顾 Perl 6 作为一种语言，因为它是一个包含大量黑暗角落和奇怪边缘情况的大规模规范，但我确实希望分享一些关于语言运行时发现的事情。 Perl 6虚拟机MoarVM是一项出色的技术。</description>
    </item>
    
    <item>
      <title>Perl 6 概览</title>
      <link>https://ohmysummer.github.io/post/2018-07-06-perl6%E6%A6%82%E8%A7%88/</link>
      <pubDate>Fri, 06 Jul 2018 00:23:57 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-06-perl6%E6%A6%82%E8%A7%88/</guid>
      <description>http://www.evanmiller.org/a-review-of-perl-6.html
Perl 6 让我想起了我叔叔的博士学位论文。在前五年, 我们会问（圣诞节前）他什么时候完成; 时间久了我们就越来越不相信他的答案了, 并且没有任何证据表明论文确实存在过, 我们使完成日期成为一种流行的笑话, 就像波士顿 Big Dig 或纽约的第二大道地铁线。但是, 经过多次自我强加的最后期限后, 我们已经不再拿它开玩笑了。过了那么多年, 我们不再问了。
如果你错过了, 我认为每个人都错过了, Perl 6 在一年半前 - 在 2015 年的圣诞节 - 碰巧发布了 - 在名义上跨越了近 16 年之后被发布了。 （我想, 但我不确定, 我的叔叔的论文也在某个时候完成了。）我在 2017 年写这篇文章的新编程语言市场虽然具有竞争力, 但并不是难以理解的 - 但就像一位新博士生, 似乎没有人确定 Perl 6 的市场前景, 就像一篇刚刚开始的论文, 似乎没有人知道多年的劳动成果是否真的值得一试。
除了你想要的任何简单答案之外, Perl 6 的提供者几乎没有提供关于你应该用这个语言做什么的一些提示。 Perl 6 是多范式的, 也许是全范式的; 它声称支持面向对象的编程, 函数式编程, 面向标记的编程, 数组编程和（旧的）过程式编程。这是一种新语言, 而不仅仅是 Perl 5 的清理版本, 只不过英语是德语减去变音符号。了解以前的版本, 唉, 不会让你走得太远。出于同样的原因, 对前面化身的偏见并不一定适用于今天的水。
接下来是我试图向世界提供一个对编程世界中最白的大象Perl 6的一个诚实的, 如果不完整的评估。我受到以下思想的激励：每个系统管理员至少知道一点 Perl, 但我不认识任何人我知道任何 Perl 6, 也不认识任何知道 Perl 6 的人。我从来没有读过任何关于 Perl 6 的信息。我同样可以想象一个 Perl 6 是一堆垃圾的世界, 还有一个语言设计的 Hope Diamond。似乎没有人知道;没有人会知道。 Perl 6 是一个已写入的寄存器, 仍在等待读取。</description>
    </item>
    
    <item>
      <title>散列的散列</title>
      <link>https://ohmysummer.github.io/post/2018-07-05-%E6%95%A3%E5%88%97%E7%9A%84%E6%95%A3%E5%88%97/</link>
      <pubDate>Thu, 05 Jul 2018 00:29:18 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-05-%E6%95%A3%E5%88%97%E7%9A%84%E6%95%A3%E5%88%97/</guid>
      <description>如何在 Perl 6 中声明散列的数字散列？ 默认情况下，散列将所有键转换为字符串。当你的键是可能接近的数字时，会导致问题：
&amp;gt; my %h; %h{1/3} = 1; %h{0.333333} = 2; dd %h; Hash %h = {&amp;quot;0.333333&amp;quot; =&amp;gt; 2}  当然，这可以修复如下：
&amp;gt; my %h{Real}; %h{1/3} = 1; %h{0.333333} = 2; dd %h; Hash[Any,Real] %h = (my Any %{Real} = 0.333333 =&amp;gt; 2, &amp;lt;1/3&amp;gt; =&amp;gt; 1)  但现在我需要散列的数字散列时，例如 { 1/3 =&amp;gt; { 2/3 =&amp;gt; 1, 0.666667 =&amp;gt; 2 } }。
&amp;gt; my %h{Real}; %h{1/3}{2/3} = 1; %h{1/3}{0.666667} = 2; dd %h; Hash[Any,Real] %h = (my Any %{Real} = &amp;lt;1/3&amp;gt; =&amp;gt; ${&amp;quot;0.</description>
    </item>
    
    <item>
      <title>Perl 6 Colon Pair</title>
      <link>https://ohmysummer.github.io/post/2018-06-19-perl-6-colon-pair/</link>
      <pubDate>Tue, 19 Jun 2018 19:38:05 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-06-19-perl-6-colon-pair/</guid>
      <description>原文
如果我选择 Perl 6 编程语言中最普遍的构造，那肯定是 colonpair。哈希构造函数，命名参数和参数，副词和正则表达式修饰符 - 都涉及到 colonpair。毫不奇怪，在这样广阔的空间里，构建 colonpair 时会有很多捷径。
今天，我们将了解所有这些！这样做会让我们看到最简单的以及一些更高级的语言结构，所以如果本文的某些部分让你头脑发热，不要担心 - 你不必一次就知道所有的东西！
第一部分: 创建 Colonwhaaaa? Colonpair 的名字（通常）来自于 Pair 对象构造函数，并且（通常）里面有一个冒号。以下是一些 colonpairs 的例子：
:foo, :$bar, :meow&amp;lt;moo&amp;gt;, heh =&amp;gt; hah  最后一个没有冒号，但由于它和其他 colonpairs 基本上是一样的，我个人认为它也是一个 colonpair。
我们可以通过查看它们的 0 来看到这些 colonpairs 构成 Pair 对象：
say :foo.^name; # OUTPUT: «Pair␤»  但是，在参数列表中使用时，这些 colonpairs 被特殊处理了以表示命名参数。我们将在后面的文章中介绍这一部分。
简写 这里有一个完整的可用的 colonpair 列表，你可以在深入之前浏览一下。我知道，它看起来像一个巨大的列表，但这就是我们阅读这篇文章的原因 - 要了解构成这些排列的一般模式。
# 标准的, take-any-type, 非便捷形式 :nd(2).say; # OUTPUT: «nd =&amp;gt; 2␤» :foo(&#39;foo&#39;, &#39;bar&#39;).say; # OUTPUT: «foo =&amp;gt; (foo bar)␤» :foo( %(:42a, :foo&amp;lt;a b c&amp;gt;) ).</description>
    </item>
    
    <item>
      <title>饭否机器人教程</title>
      <link>https://ohmysummer.github.io/post/2018-06-03-a-guide-to-fanfou-robot/</link>
      <pubDate>Sun, 03 Jun 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-06-03-a-guide-to-fanfou-robot/</guid>
      <description>使用 Perl 6 轻松活泼地写饭否机器人 安装 Perl 6 Perl 6 是一门很有趣的语言。
目前支持 Windows, macOS, Linux 主流操作系统, 首先去官网下载对应的安装包, 然后安装。安装完成后在终端/命令行提示符中输入
perl6 -v  它会打印出 Perl 6 的版本信息：
This is Rakudo Star version 2018.04.1 built on MoarVM version 2018.04.1 implementing Perl 6.c.  Rakudo Star 自带了模块管理工具 Zef, 你可以使用 zef --help 查看 zef 的帮助。如果提示 command not found 请检查是否设置好了 PATH 路径。我们会用 Zef 来安装饭否客户端模块。
Perl 6 入门 在开始写机器人之前, 需要先了解一点 Perl 6 的基础语法。
Perl 6 入门是 Perl 6 入门的简明教程, 涵盖了写机器人所需要的基础知识。</description>
    </item>
    
    <item>
      <title>饭否客户端</title>
      <link>https://ohmysummer.github.io/post/2018-05-10-%E9%A5%AD%E5%90%A6%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>Thu, 10 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-10-%E9%A5%AD%E5%90%A6%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid>
      <description>Inspired by fanfou-py
use Digest::HMAC; use Digest; use Digest::SHA; use MIME::Base64; use URI::Encode; use URI; use Cro::HTTP::Client; # URL 编码 sub oauth_escape($s){ return uri_encode_component($s.Str); } # 返回当前时间戳 sub oauth_timestamp() { return time; } # 单次值, 返回一个8位的随机字符串, 防止重复请求 sub oauth_nonce($size=8) { return ((1..9).pick for 1..$size).join(&amp;quot;&amp;quot;); } # 返回按一定顺序拼接好的字符串 sub oauth_query(%args) { return (sprintf &amp;quot;%s=%s&amp;quot;, $_, oauth_escape(~%args{$_}) for %args.keys.sort).join(&#39;&amp;amp;&#39;); } # URL 正规化 sub oauth_normalized_url($url){ my URI $u .= new($url); return sprintf(&#39;%s://%s%s&#39;, $u.</description>
    </item>
    
    <item>
      <title>Perl 6 CookBook</title>
      <link>https://ohmysummer.github.io/post/2018-05-08-perl6cookbook/</link>
      <pubDate>Tue, 08 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-08-perl6cookbook/</guid>
      <description>Perl 6 CookBook(inspired by Python cookbook)
数据结构和算法 解压序列赋值给多个变量 问题 现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值 给 N 个变量？
解决方案 任何的序列 (或者是可迭代对象) 可以通过一个简单的赋值语句解压并赋值给多个 变量。唯一的前提就是变量的数量必须跟序列元素的数量是一样的。
代码示例：
&amp;gt; my @p = (4,5); [4 5] &amp;gt; my ($x, $y) = @p; (4 5) &amp;gt; $x 4 &amp;gt; $y 5 &amp;gt; my @data = (&#39;ACME&#39;, 50, 91.1, (2012, 12, 21) ); [ACME 50 91.1 (2012 12 21)] &amp;gt; my ($name, $shares, $price, ($year, $mon, $day)) = (&#39;ACME&#39;, 50, 91.</description>
    </item>
    
    <item>
      <title>Dateish</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-dateish/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-dateish/</guid>
      <description>role Dateish { ... }  Date 和 DateTime 都支持访问 year, month 和 day-of-month 以及相关的函数，例如计算星期几。
方法 year 方法 定义为：
method year(Date:D: --&amp;gt; Int:D)  返回日期的月份(1..12)。
say Date.new(&#39;2015-12-31&#39;).month; # OUTPUT: «12» say DateTime.new(date =&amp;gt; Date.new(&#39;2015-12-24&#39;), hour =&amp;gt; 1).month; # OUTPUT: «12»  day 方法 定义为：
method day(Date:D: --&amp;gt; Int:D)  返回日期中月份的天(1..31)。
say Date.new(&#39;2015-12-31&#39;).day; # OUTPUT: «31» say DateTime.new(date =&amp;gt; Date.new(&#39;2015-12-24&#39;), hour =&amp;gt; 1).day; # OUTPUT: «24»  formatter 方法 定义为：</description>
    </item>
    
    <item>
      <title>Make</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-make/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-make/</guid>
      <description>方法 make 的文档由以下类型组装而成：
Match 类 来自于 Match
make 方法 method make(Match:D: Mu $payload) sub make(Mu $payload)  将任意有效载荷(payload)存储到 Match 对象中，稍后可通过 .made / .ast 方法重新取回它。
这通常用于 grammar 的 action 类方法中，其中一个方法存储一段数据，然后由另一个方法取回。这取决于你存储什么数据。它可以是树节点，计算结果或值的列表。
sub 形式的 make 操作当前的 $/，这可能是一个简写：
method my-action ($/) { make &amp;quot;foo: $/&amp;quot;; }  make 会把数据结构附加到各自的 Match 对象上, 随后通过 .made 方法取回。使用 Match.perl 方法可以看到, Match 里面有一个 made 属性：
&amp;gt; if &#39;abc&#39; ~~ /\w+/ { $/.make: {&#39;a&#39; =&amp;gt; &#39;bc&#39;, &#39;d&#39; =&amp;gt; &#39;wsl&#39;}; say $/.</description>
    </item>
    
    <item>
      <title>Slip</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-slip/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-slip/</guid>
      <description>有时您想要将列表的元素插入到另一个列表中。这可以通过称为 Slip 的特殊类型的列表完成。
say (1, (2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «False␤» say (1, Slip.new(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, slip(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤»  另一种方法是使用 | 前缀运算符。请注意，这比逗号的优先级更高，因此它只影响单个值，但与上述选项不同，它会打破标量。
say (1, |(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, |$(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, slip($(2, 3)), 4) eqv (1, 2, 3, 4); # OUTPUT: «False␤»  Slip class Slip is List {}  Slip 是一个 List，自动展平到一个外部列表（或其他类似列表的容器或 iterable）中。</description>
    </item>
    
    <item>
      <title>类和对象</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</guid>
      <description>Perl 6 有一个丰富的内置语法来定义和使用类。
默认构造函数允许为创建的对象设置属性：
class Point { has Int $.x; has Int $.y; } class Rectangle { has Point $.lower; has Point $.upper; method area() returns Int { ($!upper.x - $!lower.x) * ( $!upper.y - $!lower.y); } } # Create a new Rectangle from two Points my $r = Rectangle.new(lower =&amp;gt; Point.new(x =&amp;gt; 0, y =&amp;gt; 0), upper =&amp;gt; Point.new(x =&amp;gt; 10, y =&amp;gt; 10)); say $r.area(); # OUTPUT: «100␤»  您也可以提供自己的构建和构建实现。下面更详细的例子展示了 Perl 6 中依赖处理器的外观。它展示了自定义构造函数，私有属性和公共属性，方法以及签名的各个方面。它代码不多，但结果是有趣和有用的。</description>
    </item>
    
    <item>
      <title>DateTime</title>
      <link>https://ohmysummer.github.io/post/2018-05-05-datetime/</link>
      <pubDate>Sat, 05 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-05-datetime/</guid>
      <description>DateTime class DateTime does Dateish {}  对于在国内处理点数，DateTime 对象存储年，月，日，小时，分钟（全部为 Int），秒（可能为小数）和时区。
它提供了用日期和时间计算的方法。
DateTime 方法是不可变的;如果你试图修改它，请改为创建修改后的副本。
时区的处理时间为以 UTC 为单位的整数，而不是时区名称。
use v6.c; my $dt = DateTime.new( year =&amp;gt; 2015, month =&amp;gt; 11, day =&amp;gt; 21, hour =&amp;gt; 16, minute =&amp;gt; 1, ); say $dt; # OUTPUT: «2015-11-21T16:01:00Z␤» say $dt.later(days =&amp;gt; 20); # OUTPUT: «2015-12-11T16:01:00Z␤» say $dt.truncated-to(&#39;hour&#39;); # OUTPUT: «2015-11-21T16:00:00Z␤» say $dt.in-timezone(-8 * 3600); # OUTPUT: «2015-11-21T08:01:00-0800␤» my $now = DateTime.now(formatter =&amp;gt; { sprintf &amp;quot;%02d:%02d&amp;quot;, .</description>
    </item>
    
    <item>
      <title>Awesome Async Interfaces with Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-04-27-perl-6%E4%B8%AD%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 26 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-27-perl-6%E4%B8%AD%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3/</guid>
      <description>IRC::Client: Perl 6 Multi-Server IRC (or Awesome Async Interfaces with Perl 6) 我在 2015 年圣诞节编写了我的第一个 Perl 6 程序 - 一个新年 IRC 派对机器人工具。这项工作包括发布 IRC::Client 模块. 我从这个语言中找到了童年的乐趣并且在假期喝了不少酒, 结果就是这个模块差强人意。
最近，我需要一个用于某些 Perl 6 bug 队列工作的工具，因此我决定花费一个周末，从头开始重新设计并重写这个模块。在过去的几个月中，有好几个人请求我这么做，所以我想我还会写一篇关于如何使用该模块的教程 - 作为一名主拖延者的道歉。如果你对 IRC 不感兴趣，我希望本教程将作为 Perl 6 中异步，非阻塞接口的一个通用示例。
基础 要创建一个 IRC 机器人，实例化一个 IRC::Client 对象，给它一些基本信息，并调用 .run 方法。实现所需的所有功能，并将它们作为方法名称匹配要收听的事件的类，并通过 .plugins 属性传递。当发生 IRC 事件时，它会按照您指定的顺序传递给所有插件，如果某个插件要求它处理事件，则停止。
这里有一个简单的 IRC 机器人，它可以响应在频道中发送的消息，通知和发送给它的私人消息。响应是 bot 收到的大写原始消息：
use IRC::Client; .run with IRC::Client.new: :nick&amp;lt;MahBot&amp;gt; :host&amp;lt;irc.freenode.net&amp;gt; :channels&amp;lt;#perl6&amp;gt; :debug :plugins(class { method irc-to-me ($_) { .</description>
    </item>
    
    <item>
      <title>Cro::HTTP::Client</title>
      <link>https://ohmysummer.github.io/post/2018-04-16-cro-http-client/</link>
      <pubDate>Mon, 16 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-16-cro-http-client/</guid>
      <description>Cro::HTTP::Client Cro::HTTP::Client 类提供了一个灵活的 HTTP 和 HTTPS 客户端实现，可以从简单到更复杂的情况进行扩展。它可以通过两种方式消费：
通过对类型对象（ Cro::HTTP::Client.get($url) ）进行调用。这对于一次性请求很有用，但在向同一服务器发出多个请求时（例如使用 keep-alive）不提供连接重用。
通过创建一个 Cro::HTTP::Client 实例。默认情况下，这可以重用连接池。它还可以配置默认的 base URL，传递的默认授权数据，甚至是插入到请求/响应处理管道中的中间件。 Cro::HTTP::Client 实例可以并发地使用。
一般来说，如果您打算发起一次性请求，请使用类型对象。如果您要向同一台服务器或一组服务器发出很多请求，请创建一个实例。
默认情况下，HTTPS 请求将使用 ALPN 来协商是否执行 HTTP/2 或 HTTP/1.1，并且 HTTP 请求将始终使用 HTTP/1.1。
发起基本请求 可以在类型对象或 Cro::HTTP::Client 的实例上调用 get，post，put，delete，patch 和 head 方法。他们都会返回一个 Promise，如果请求成功则会被保留(kept), 如果失败则被毁掉(broken)。
my $resp = await Cro::HTTP::Client.get(&#39;https://www.perl6.org/&#39;);  响应($resp) 是一个 Cro::HTTP::Response 对象。它将在请求头可用时立即生成;请求体可能尚未收到。默认情况下，错误（4xx和5xx状态码）将导致遵守 X::Cro::HTTP::Error 角色的异常，该角色具有包含 Cro::HTTP::Response 对象的 response 属性。
my $resp = await Cro::HTTP::Client.delete($product-url); CATCH { when X::Cro::HTTP::Error { if .response.status == 404 { say &amp;quot;Product not found!</description>
    </item>
    
    <item>
      <title>使用 flip-flop 和 gather-take 提取文本块儿</title>
      <link>https://ohmysummer.github.io/post/2018-04-15-flip-flop/</link>
      <pubDate>Sun, 15 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-15-flip-flop/</guid>
      <description>使用 flip-flop 和 gather-take 提取文本块儿 my $excerpt = q:to/END/; Here&#39;s some unimportant text. =begin code This code block is what we&#39;re after. We&#39;ll use &#39;ff&#39; to get it. =end code More unimportant text. =begin code Today rains heavy. Long live AI . HaHa =end code More unimport text. =begin code Like to go home. =end code END my @lines = gather { my @current; for $excerpt.lines { if &amp;quot;=begin code&amp;quot; ^ff^ &amp;quot;=end code&amp;quot; { # collect the values between matches push @current, .</description>
    </item>
    
    <item>
      <title>Perl 6 中散列的键和值</title>
      <link>https://ohmysummer.github.io/post/2018-04-14-keys-values-of-hashes-in-perl-6/</link>
      <pubDate>Sat, 14 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-14-keys-values-of-hashes-in-perl-6/</guid>
      <description>Perl 6 中散列的键和值 今天，我们将看看 Hash 类的几个返回散列所有键或值或同时返回键和值的方法:
&amp;gt; my %h = H =&amp;gt; &#39;Hydrogen&#39;, He =&amp;gt; &#39;Helium&#39;, Li =&amp;gt; &#39;Lithium&#39;; {H =&amp;gt; Hydrogen, He =&amp;gt; Helium, Li =&amp;gt; Lithium} &amp;gt; %h.keys; (H Li He) &amp;gt; %h.values; (Hydrogen Lithium Helium) &amp;gt; %h.kv; (H Hydrogen Li Lithium He Helium)  虽然你可能想直接进入 src/core/Hash.pm6 文件来查看方法的定义，但你会一无所获。 Hash 类是 Map 的子类，所有这些方法都定义在 src/core/Map.pm6 文件中。获取键和值很简单:
multi method keys(Map:D:) { Seq.new(Rakudo::Iterator.Mappy-keys(self)) } multi method values(Map:D:) { Seq.new(Rakudo::Iterator.Mappy-values(self)) }  对于 kv 方法, 需要多做点工作:</description>
    </item>
    
    <item>
      <title>Perl 6 中的列表解析</title>
      <link>https://ohmysummer.github.io/post/2018-04-13-perl-6-%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 13 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-13-perl-6-%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>Perl 6 中的列表解析 看一看 Python 中关于列表推导的页面。
S = {x² : x in {0 ... 9}} V = (1, 2, 4, 8, ..., 2¹²) M = {x | x in S and x even}  Python 列表解析:
S = [x**2 for x in range(10)] V = [2**i for i in range(13)] M = [x for x in S if x % 2 == 0]  在原始定义中我没有看到 10 或 13 , Perl 6 与原始语言最接近的语法是:</description>
    </item>
    
    <item>
      <title>在 Perl 6 中设置超时</title>
      <link>https://ohmysummer.github.io/post/2018-04-12-setting-timeouts-in-perl-6/</link>
      <pubDate>Thu, 12 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-12-setting-timeouts-in-perl-6/</guid>
      <description>在 Perl 6 中设置超时 在 Perl 5 中，我曾经使用信号设置超时（至少，这是一种简单且可预测的方式）。在 Perl 6 中，您可以使用 promise。让我们看看如何做到这一点。
要模仿长时间运行的任务，请创建一个无限循环，然后打印其状态。开始吧:
for 1 .. * { .say if $_ %% 100_000; }  只要循环得到控制，它将永远不会退出。我们的任务是在几秒钟内停止程序，因此计时器应在循环之前设置:
Promise.in(2).then({ exit; }); for 1 .. * { .say if $_ %% 100_000; }  在这里，Promise.in 方法创建一个 promise，在给定秒数后自动 kept。在 promise 的基础上，使用 then，我们添加了另一个 promise，其代码将在超时后运行。这里唯一的语句就是退出，停止主程序。
运行该程序以查看它的工作原理：
$ time perl6 timeout.pl 100000 200000 300000 . . . 3700000 3800000 3900000 real 0m2.196s user 0m2.120s sys 0m0.068s  该程序在我的计算机上计数达四百万，并在两秒内退出。这正是我们需要的行为。</description>
    </item>
    
    <item>
      <title>Typed hashes in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-04-11-typed-hashes-in-perl-6/</link>
      <pubDate>Wed, 11 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-11-typed-hashes-in-perl-6/</guid>
      <description>Typed hashes in Perl 6 在 Perl 6 中, 你可以通过指定变量的类型来限制变量容器的内容, 例如：
my Int $i;  标量变量中只有一个值。你可以将该概念扩展到数组, 并让其元素仅保存整数, 如下例所示：
&amp;gt; my Int @i; [] &amp;gt; @i.push(42); [42] &amp;gt; @i.push(&#39;Hello&#39;); Type check failed in assignment to @i; expected Int but got Str (&amp;quot;Hello&amp;quot;) in block &amp;lt;unit&amp;gt; at &amp;lt;unknown file&amp;gt; line 1  哈希中保存的是 pairs, 所以你可以同时指定键和值的类型。语法和上面的例子并无不同。
首先, 让我们声明值的类型：
my Str %s;  现在, 可以将字符串作为哈希的值：
&amp;gt; %s&amp;lt;Hello&amp;gt; = &#39;World&#39; World &amp;gt; %s&amp;lt;42&amp;gt; = &#39;Fourty-two&#39; Fourty-two  但这个哈希不能保存整数:</description>
    </item>
    
    <item>
      <title>Perl 6 中的 gist 方法</title>
      <link>https://ohmysummer.github.io/post/2018-04-10-what-does-gist-do-in-perl-6/</link>
      <pubDate>Tue, 10 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-10-what-does-gist-do-in-perl-6/</guid>
      <description>当你打印对象的时候, 例如 say $x, Perl 6 调用 gist 方法. 这个方法是为所有内建类型定义的：对于其中一些类型，它调用 Str 方法，对于某些类型它调用 perl 方法，对于某些类型，它使字符串表示有所不同。
让我们看看如何使用该方法来创建您自己的变体：
class X { has $.value; method gist { &#39;[&#39; ~ $!value ~ &#39;]&#39; } } my $x = X.new(value =&amp;gt; 42); say $x; # [42] $x.say; # [42]  当你调用 say 时，该程序在方括号中打印一个数字：[42]。
请注意，双引号字符串中的插值使用 Str，而不是 gist。你可以在这里看到它：
say $x.Str; # X&amp;lt;140586830040512&amp;gt; say &amp;quot;$x&amp;quot;; # X&amp;lt;140586830040512&amp;gt;  如果您需要自定义插值，请重新定义 Str 方法:
class X { has $.value; method gist { &#39;[&#39; ~ $!</description>
    </item>
    
    <item>
      <title>Perl 6 中的 Superscripts</title>
      <link>https://ohmysummer.github.io/post/2018-04-09-perl-6-%E4%B8%AD%E7%9A%84%E4%B8%8A%E6%A0%87/</link>
      <pubDate>Mon, 09 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-09-perl-6-%E4%B8%AD%E7%9A%84%E4%B8%8A%E6%A0%87/</guid>
      <description>Perl 6 中的 Superscripts 在 Perl 6 中，可以使用上标索引来计算数字的幂数，例如:
&amp;gt; 2⁵ 32 &amp;gt; 7³ 343  也可以在上标中使用多个数字：
&amp;gt; 10¹² 1000000000000  你可以猜到，上面的代码等同于这样：
&amp;gt; 2**5 32 &amp;gt; 7**3 343 &amp;gt; 10**12 1000000000000  但问题是：上标到底是如何工作的？让我们找出答案。
对于 Numeric 角色，定义了以下操作：
proto sub postfix:&amp;lt;ⁿ&amp;gt;(Mu $, Mu $) is pure {*} multi sub postfix:&amp;lt;ⁿ&amp;gt;(\a, \b) { a ** b }  啊哈，这就是我们需要的，上标符号在这里转换为简单的 ** 运算符。
您可以通过打印操作数来可视化传递给操作的确切内容：
multi sub postfix:&amp;lt;ⁿ&amp;gt;(\a, \b) { nqp::say(&#39;# a = &#39; ~ a); nqp::say(&#39;# b = &#39; ~ b); a ** b }  这个时候，你会看到上面的测试示例输出如下：</description>
    </item>
    
    <item>
      <title> More on the proto keyword in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-21-more-on-the-proto-keyword-in-perl-6/</link>
      <pubDate>Wed, 21 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-21-more-on-the-proto-keyword-in-perl-6/</guid>
      <description>在深入研究 EVAL 子例程的细节之前，我们必须揭示一些关于 protos 原型和多重分派的更多信息。检查以下程序：
proto sub f($x) { say &amp;quot;proto f($x)&amp;quot;; } multi sub f($x) { say &amp;quot;f($x)&amp;quot; } multi sub f(Int $x) { say &amp;quot;f(Int $x)&amp;quot; } multi sub f(Str $x) { say &amp;quot;f(Str $x)&amp;quot; } f(2); f(&#39;2&#39;); f(3); f(&#39;3&#39;);  这里有三个 multi 函数和一个用 proto 关键字声明的函数。早些时候，我们只看到了函数体为空的原型函数，如:
proto sub f($x) {*}  但这不是必需的。正如我们在示例中所看到的，该函数可以承载正常的函数体：
proto sub f($x) { say &amp;quot;proto f($x)&amp;quot;; }  运行这个程序：
proto f(2) proto f(2) proto f(3) proto f(3)  所有的调用都被 proto-候选者抓住了。现在，更新它并返回一些专用值的 {*} 块;</description>
    </item>
    
    <item>
      <title>Examining the Real role of Perl 6, part 2</title>
      <link>https://ohmysummer.github.io/post/2018-02-18-examining-the-real-role-of-perl-6-part-2/</link>
      <pubDate>Sun, 18 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-18-examining-the-real-role-of-perl-6-part-2/</guid>
      <description>今天，我们继续对几天前开始的 Real 角色进行初步探索。
与其方法一起，角色包含许多子例程（放置在角色之外），它们使用 Real 类型的对象定义中缀运算符。名单不长，所以让我把它复制在这里：
multi sub infix:&amp;lt;+&amp;gt;(Real \a, Real \b) { a.Bridge + b.Bridge } multi sub infix:&amp;lt;-&amp;gt;(Real \a, Real \b) { a.Bridge - b.Bridge } multi sub infix:&amp;lt;*&amp;gt;(Real \a, Real \b) { a.Bridge * b.Bridge } multi sub infix:&amp;lt;/&amp;gt;(Real \a, Real \b) { a.Bridge / b.Bridge } multi sub infix:&amp;lt;%&amp;gt;(Real \a, Real \b) { a.Bridge % b.Bridge } multi sub infix:&amp;lt;**&amp;gt;(Real \a, Real \b) { a.Bridge ** b.</description>
    </item>
    
    <item>
      <title>Everyone Loves Porgs</title>
      <link>https://ohmysummer.github.io/post/2018-02-17-everyone-loves-porgs/</link>
      <pubDate>Sat, 17 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-17-everyone-loves-porgs/</guid>
      <description>这个想法有一阵子了。我在完成的各个阶段都有几个发文的想法，有时候很难优先考虑这个问题。所以我想我要开始发布我一直在玩的更短的想法和事情，以免这个博客变成那些永不更新的博客之一。所以，我们开始吧。
类在 Perl 6 中很容易定义。它们非常容易，我发现自己使用它们来封装小型的 Hash-like 那样的东西，其中我也可能会使用一两种方法。
class Contact { has $.name; has $.phone; has $.bday; method age { (Date.new($.bday), *.later(:1year) ...^ * &amp;gt; Date.today).end } }  是的，这是一种低效率的计算年龄的方法&amp;hellip;&amp;hellip;就像生活中的很多事情一样，你越老，这种方法变得越慢。
无论如何，现在我已经定义了一个简单的小类来保存一些数据，但要实际实例化一个我不得不 bust out 一些命名参数。
my @contacts; @contacts.push: Contact.new(:name&amp;lt;John&amp;gt;, :phone&amp;lt;555-1111&amp;gt;, :bday&amp;lt;1940-10-09&amp;gt;);  谁有时间为所有这些角色？有时候我只是想用位置参数来构建它们，但这意味着要编写一个新的自定义 multi method new 来处理这些情况&amp;hellip;&amp;hellip;但我只是将一个快速肮脏的类放在一起，真的值得我花时间来构建自定义构造函数吗？
于是我开始四处游玩，并创建了一个让我用 Positional 参数的角色&amp;hellip;&amp;hellip;或一个 Array ..或 List &amp;hellip;构建我的类，嘿，I threw in a Hash for free!！
@contacts.push: Contact.new(&#39;James&#39;, &#39;555-1112&#39;, &#39;1942-06-18&#39;); @contacts.push: Contact.new(&amp;lt; George 555-1113 1943-02-25 &amp;gt;) my %hash = name =&amp;gt; &#39;Richard&#39;, phone =&amp;gt; &#39;555-1114&#39;, bday =&amp;gt; &#39;1940-07-07&#39;; @contacts.</description>
    </item>
    
    <item>
      <title>A word on polymod in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-16-a-word-on-polymod-in-perl-6/</link>
      <pubDate>Fri, 16 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-16-a-word-on-polymod-in-perl-6/</guid>
      <description>在转到 Real 角色的第二部分之前，让我们停下来研究一下 Int 类的中的 polymod 方法。
该方法接收一个数字和任意数字（单位）的列表并返回相应的乘数。所以，你可以很容易地说，例如 550 秒，是 9分 10 秒：
&amp;gt; 550.polymod(60) (10 9)  在方法调用中，60 的值是一分钟内的秒数。结果中，9 是分钟数，10 是余数，其为秒数。所以，550 秒= 10 秒 + 9 分钟。
如果你想了解更多细节，请添加更多单位。例如，什么是 32768 秒？
&amp;gt; 32768.polymod(60, 60, 24) (8 6 9 0)  这是 8 秒，6 分钟，9 小时和 0 天。
类似地，132768 秒是 1 天，12 小时，52 分钟和 48 秒：
&amp;gt; 132768.polymod(60, 60, 24) (48 52 12 1)  老实说，我很难理解它是如何工作的，以及如何读取结果。
文档中的另一个例子更加难以理解：
&amp;gt; 120.polymod(1, 10, 100) (0 0 12 0)  12 是什么意思？这显然是12倍10.</description>
    </item>
    
    <item>
      <title>如何在 Perl 6 中对散列进行排序</title>
      <link>https://ohmysummer.github.io/post/2018-02-16-%E5%A6%82%E4%BD%95%E5%9C%A8perl-6%E4%B8%AD%E5%AF%B9%E6%95%A3%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 16 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-16-%E5%A6%82%E4%BD%95%E5%9C%A8perl-6%E4%B8%AD%E5%AF%B9%E6%95%A3%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</guid>
      <description>要在 Perl 6 中对散列进行排序，首先你要知道什么是占位符变量。一旦这个概念变得清晰，对散列排序就变得非常简单。
例如，创建一个不同城市距离莫斯科远近的散列：
my %distance = Владимир =&amp;gt; 185, Волгоград =&amp;gt; 1000, Калининград =&amp;gt; 1227, Мурманск =&amp;gt; 1895, Новосибирск =&amp;gt; 3550;  现在的任务是通过比较距离来对散列进行排序。
say %distance.sort({$^a.value &amp;lt;=&amp;gt; $^b.value});  一般来说，它已经准备好了。该程序打印你需要的东西：
(Владимир =&amp;gt; 185 Волгоград =&amp;gt; 1000 Калининград =&amp;gt; 1227 Архангельск =&amp;gt; 1261 Астрахань =&amp;gt; 1411 Мурманск =&amp;gt; 1895 Новосибирск =&amp;gt; 3550)  让我们看看传递给排序方法的块内发生了什么。
首先，变量 $^a 和 $^b 是占位符，它是匿名块的参数并按字母顺序排序。也就是说，以相同的方式，他们可以被称为 $^x 和 $^y 或 $^var1 和 $^var2。
其次，这些占位符变量内部是 Pair 类型的对象，它包含键和值：
say %distance.</description>
    </item>
    
    <item>
      <title>Examining the Real role of Perl 6, part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-15-examining-the-real-role-of-perl-6-part-1/</link>
      <pubDate>Thu, 15 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-15-examining-the-real-role-of-perl-6-part-1/</guid>
      <description>在过去的几天里，我们谈了很多关于 Real 这个角色。让我们更仔细地看看它。该代码位于 src/core/Real.pm 文件中。
它包含角色本身和一些实现不同中缀的子例程。Real 角色又实现了 Numeric 角色：
my role Real does Numeric { . . . }  有趣的是，类定义还需要关于 Complex 类的一些知识，这就是为什么在文件的第一行有一个前向类声明：
my class Complex { ... }  Real 角色将许多三角函数定义为方法，正如我们已经看到的，他们正在使用 Bridge 方法：
method sqrt() { self.Bridge.sqrt } method rand() { self.Bridge.rand } method sin() { self.Bridge.sin } method asin() { self.Bridge.asin } method cos() { self.Bridge.cos } method acos() { self.Bridge.acos } method tan() { self.Bridge.tan } method atan() { self.</description>
    </item>
    
    <item>
      <title>FatRat vs Rat in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-15-fatrat-vs-rat-in-perl-6/</link>
      <pubDate>Thu, 15 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-15-fatrat-vs-rat-in-perl-6/</guid>
      <description>昨天，Solomon Foster 在 Facebook 的 Perl 6 小组上发布了一个例子:
my @x = FatRat.new(1, 1), -&amp;gt; $x { $x - ($x ** 2 - $N) / (2 * $x) } ... *  这段代码实现了牛顿找到 $N 平方根近似值的方法。重要的是它使用 FatRat 值来获得更高的准确性。
让我们运行 9 的平方根：
my $N = 9; my @x = Rat.new(1, 1), -&amp;gt; $x { $x - ($x ** 2 - $N) / (2 * $x) } ... *; .say for @x[0..7];  很快，它收敛到正确的值：</description>
    </item>
    
    <item>
      <title>A bit more on Rat vs FatRat in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-14-a-bit-more-on-rat-vs-fatrat-in-perl-6/</link>
      <pubDate>Wed, 14 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-14-a-bit-more-on-rat-vs-fatrat-in-perl-6/</guid>
      <description>昨天，我们正在深入研究 Rakudo Perl 6，以了解Rat值成为Num值的时间。事实证明，如果该值变得太小，这意味着它的分母变得越来越大，Rakudo开始使用Num值而不是Rat。
我们找到了它发生的地方。今天，让我们进行一个练习，看看Perl 6的行为是否可能不同，即扩展数据类型而不是将其切换为浮点数并且失去准确性。
改变很简单。所有你需要的是更新DIVIDE_N例程中的ifs：
--- a/src/core/Rat.pm +++ b/src/core/Rat.pm @@ -48,16 +48,14 @@ sub DIVIDE_NUMBERS(Int:D \nu, Int:D \de, \t1, \t2) { ($numerator := -$numerator), ($denominator := -$denominator))), nqp::if( - nqp::istype(t1, FatRat) || nqp::istype(t2, FatRat), + nqp::istype(t1, FatRat) || nqp::istype(t2, FatRat) || $denominator &amp;gt;= UINT64_UPPER, nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(FatRat),FatRat,&#39;$!numerator&#39;,$numerator), FatRat,&#39;$!denominator&#39;,$denominator), - nqp::if( - $denominator &amp;lt; UINT64_UPPER, nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(Rat),Rat,&#39;$!numerator&#39;,$numerator), - Rat,&#39;$!denominator&#39;,$denominator), - nqp::p6box_n(nqp::div_In($numerator, $denominator))))) + Rat,&#39;$!denominator&#39;,$denominator) + )) }  现在有两种结果：例程产生一个Rat值或一个FatRat。当子参数已经是FatRats或当前Rat太接近于零时，后者发生。</description>
    </item>
    
    <item>
      <title>Going over the Bridge, part 2. Let’s get rid of it</title>
      <link>https://ohmysummer.github.io/post/2018-02-12-going-over-the-bridge-part-2/</link>
      <pubDate>Mon, 12 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-12-going-over-the-bridge-part-2/</guid>
      <description>今天，我们继续在 Rakudo Perl 6 中使用 Bridge 方法。昨天，我们在几个预定义的数据类型中看到了方法的定义。现在是时候看看如何使用该方法。
里面有什么? 该方法的主要用途在 Real 角色中，该角色包含以下一组方法：
method sqrt() { self.Bridge.sqrt } method rand() { self.Bridge.rand } method sin() { self.Bridge.sin } method asin() { self.Bridge.asin } method cos() { self.Bridge.cos } method acos() { self.Bridge.acos } method tan() { self.Bridge.tan } method atan() { self.Bridge.atan } . . . method sec() { self.Bridge.sec } method asec() { self.Bridge.asec } method cosec() { self.Bridge.cosec } method acosec() { self.</description>
    </item>
    
    <item>
      <title>Going over the Bridge, part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-11-going-over-the-bridge-part-1/</link>
      <pubDate>Sun, 11 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-11-going-over-the-bridge-part-1/</guid>
      <description>在处理 Perl 6 中的数字的类中，我们看到了 Bridge 方法，该方法以多态方式使用。让我们花一些时间，并试图了解 1）它是如何工作的，2）是否有必要。
类和角色 我们的第一步是查看方法定义在哪里。以下是我们需要的类和角色列表：
 Duration Instant Int Num Rational Real  为了预测下一步，让我们添加一些关于他们关系的更多细节：
 class Duration is Cool does Real class Instant is Cool does Real class Int is Cool does Real class Num is Cool does Real role Rational does Real role Real does Numeric  在斜体字体中，我添加了伪声明，这些伪声明没有在 src/core 的相应文件中明确拼写，而是通过 src/Perl6/Metamodel/BOOTSTRAP.nqp 设置:
Int.HOW.add_parent(Int, Cool); . . . Num.HOW.add_parent(Num, Cool);  对于完整的图片，我们可以查看其他类的位置，例如 Rat 或 Complex，但让我们先关注上面的列表。</description>
    </item>
    
    <item>
      <title>Perl 6 中的命名参数</title>
      <link>https://ohmysummer.github.io/post/2018-02-10-perl-6%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 10 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-10-perl-6%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</guid>
      <description> Perl 6 中的函数（和类方法）能够接受命名参数。最简单的方法是用箭头分隔名称和值：
sub f(:$a, :$b) { $a ** $b } say f(a =&amp;gt; 2, b =&amp;gt; 3); # 8  但另一种语法是可能的，在冒号的帮助下。有几个主要品种。
:key(value) 所有内容都以冒号开头，数值在括号内：
say f(:a(2), :b(3));  例如，不用圆括号，尖角括号也是允许的：
say f(:a&amp;lt;2&amp;gt;, :b&amp;lt;3&amp;gt;);  ：Nkey 对于整数值，仍然有这样一个奇怪的语法：
say f(:2a, :3b);  :key 和 :!key 如果命名参数用作标记，则不需要指定值。在这种情况下，您可以传递 True 和 False，如下所示：
sub g(:$key) { $key } say g(:key); # True say g(:!key); # False  实际上，所有冒号对儿都会创建键值对，因此您可以在创建散列时执行相同的操作
my %data = :alpha(10), :beta(20), :gamma(30); say %data&amp;lt;beta&amp;gt;; # 20  </description>
    </item>
    
    <item>
      <title>Perl 6 Grammar 中的冒号对儿</title>
      <link>https://ohmysummer.github.io/post/2018-02-08-perl-6-grammar%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7%E5%AF%B9%E5%84%BF/</link>
      <pubDate>Thu, 08 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-08-perl-6-grammar%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7%E5%AF%B9%E5%84%BF/</guid>
      <description>欢迎来到这个系列的第 50 篇文章!
今天, 我们将讨论一个小的语法结构, 然而就 Grammar 来说这是非常复杂的。首先让我们看看整个 colonpair token:
token colonpair { :my $*key; :my $*value; &#39;:&#39; :dba(&#39;colon pair&#39;) [ | &#39;!&#39; [ &amp;lt;identifier&amp;gt; || &amp;lt;.panic: &amp;quot;Malformed False pair; expected identifier&amp;quot;&amp;gt; ] [ &amp;lt;[ \[ \( \&amp;lt; \{ ]&amp;gt; { $/.typed_panic(&#39;X::Syntax::NegatedPair&#39;, key =&amp;gt; ~$&amp;lt;identifier&amp;gt;) } ]? { $*key := $&amp;lt;identifier&amp;gt;.Str; $*value := 0 } | $&amp;lt;num&amp;gt; = [\d+] &amp;lt;identifier&amp;gt; [ &amp;lt;?before &amp;lt;.[ \[ \( \&amp;lt; \{ ]&amp;gt;&amp;gt; {} &amp;lt;.</description>
    </item>
    
    <item>
      <title>Perl 6 中的数据类型 Bag</title>
      <link>https://ohmysummer.github.io/post/2018-02-07-perl-6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/</link>
      <pubDate>Wed, 07 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-07-perl-6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/</guid>
      <description>数据类型 Bag 是一种 Perl 5 中没有的新的数据类型。
它可以被认为是一个容器，它一方面知道它里面有多少个单独的元素，另一方面可以说有多少种不同类型的商品。您可以用不同的方式描述此类型：Bag 是一个哈希，默认情况下，您添加的键的值为1。我们来看看例子。
把一个 1 放进 bag 里，看看 perl 的输出：
my $b1 = bag(1); say $b1.perl;  该程序打印以下输出：
(1=&amp;gt;1).Bag  也就是说，我们有一个 1。
如果你把另一个数字也放进 bag 里面：
my $b2 = bag(1, 2); say $b2.perl;  现在有一个 1 和一个 2：
(1=&amp;gt;1,2=&amp;gt;1).Bag  好的，如果你添加另一个 1 呢?
my $b3 = bag(1, 2, 1); say $b3.perl;  现在有两个 1：
(1=&amp;gt;2,2=&amp;gt;1).Bag  让我们稍微离题一下：所有显示的例子都可以把括号去掉：
my $b1 = bag 1; my $b2 = bag 1, 2; my $b3 = bag 1, 2, 1;  比较典型的是，bag 不止能存储数字，还可以存储字符串，例如：</description>
    </item>
    
    <item>
      <title>Perl 6 Rakudo 和 NQP 内部研讨(二)</title>
      <link>https://ohmysummer.github.io/post/2018-01-29-perl-6-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/</link>
      <pubDate>Mon, 29 Jan 2018 23:01:01 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-01-29-perl-6-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/</guid>
      <description>title: Rakudo and NQP Internals subtitle: The guts tormented implementers made author: Jonathan Worthington
课程概览 - 第二天 欢迎回来. 今天我们会涉及到如下话题:
 6model Bounded Serialization and Module Loading The regex and grammar engine The JVM backend The MoarVM backend  6model 对象系统的组成成分
什么是 6model? 6model 提供了一组用于构建类型和对象系统的原语.
Rakudo 的类, roles, 枚举和 subset 类型都由这些原语组装在一起. NQP 也是, 尽管 NQP 的对象系统更简单, 它仅仅提供了类和 roles.
这些原语已经在 Parrot 和 JVM 虚拟机上实现了. MoarVM 也提供了那些原语, 但是它走的更远, 它让 6model 成为 MoarVM 的对象系统.</description>
    </item>
    
    <item>
      <title>Perl 6 Core Hacking: QASTalicious</title>
      <link>https://ohmysummer.github.io/post/2018-01-28-perl-6-core-hacking-qastalicious/</link>
      <pubDate>Sun, 28 Jan 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-01-28-perl-6-core-hacking-qastalicious/</guid>
      <description>在过去的一个月中，我在 Rakudo 的 QAST 地区花了一些时间写了一些优化，修复了包含警告的错误，并且用一个单一的提交压缩了一个10个thunk范围的bug的怪物蜂巢。 在今天的文章中，我们将详细介绍最后一个专长，以及了解QAST是什么以及如何使用它。
第一部分: QAST &amp;ldquo;QAST&amp;rdquo; 代表 &amp;ldquo;Q&amp;rdquo; Abstract Syntax Tree.(&amp;ldquo;Q&amp;rdquo; 抽象语法树.) 为什么会有个字母 &amp;ldquo;Q&amp;rdquo; 在那里呢, 因为 Q 是 P 的下一个字母, 而 &amp;ldquo;P&amp;rdquo; 过去是在 &amp;ldquo;PAST&amp;rdquo; 里面的, 代表 &amp;ldquo;Parrot&amp;rdquo;(鹦鹉), 是很早之前的一个实验性的 Perl 6 实现(或者说, 它的虚拟机). 我们来看看什么是 QAST!
Dumping QAST 每个 Rakudo Perl 6 程序都编译到 QAST 节点树上，如果在编译程序或模块时给 perl6 指定 --target=ast 或 --target=optimize 命令行选项，则可以转储该树:
$ perl6 --target=ast -e &#39;say &amp;quot;Hello, World!&amp;quot;&#39; [...] - QAST::Op(call &amp;amp;say) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;?&amp;gt; say \&amp;quot;Hello, World!\&amp;quot; - QAST::Want &amp;lt;wanted&amp;gt; Hello, World!</description>
    </item>
    
    <item>
      <title>Perl 6 logo</title>
      <link>https://ohmysummer.github.io/post/2018-01-28-perl-6-logo/</link>
      <pubDate>Sun, 28 Jan 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-01-28-perl-6-logo/</guid>
      <description></description>
    </item>
    
    <item>
      <title>第二十五天-圣诞奖金 - 并发HTTP服务器实施和scripter的方法</title>
      <link>https://ohmysummer.github.io/post/2017-12-25-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E5%A4%A9-%E5%B9%B6%E5%8F%91http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 25 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-25-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E5%A4%A9-%E5%B9%B6%E5%8F%91http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0/</guid>
      <description>Bonus Xmas – Concurrent HTTP Server implementation and the scripter’s approach 首先，我想强调 Jonathan Worthington 在 Rakudo Perl6 和 IO::Socket::Async 中的工作。谢谢 Jon！
我喜欢制作脚本;编写组织良好的动作序列，获得结果并对它们进行处理。
当我从 Perl6 开始时，我发现了一个壮观的生态系统，我可以按照自己喜欢的方式实践我的想法：脚本方式。其中一个想法是实现一个小型的 HTTP 服务器来玩玩。查看与 Perl6，HTTP 和套接字相关的其他项目和模块，我发现背后的作者是具有面向对象编程经验的程序员。
Perl6 范式 Perl6 支持三种最流行的编程范式:
 面向对象 函数式 过程式  我认为，当你设计一个将会增长的应用程序或服务时，面向对象的范式是很好的，它会做许多不同的事情并且会有很多变化。但我不喜欢那些变化太大，会有很多变化的东西;这就是为什么我喜欢使用原生过程式方法的脚本，因为它能够快速提升简单性和有效性。我喜欢小（一步一步）但能快速完成伟大东西的事物。
函数式范式在我看来非常棒;你可以使用一个函数，并像 var 一样使用它，以及其他令人惊讶的事情。
Perl6 Supplies 就像一个 V12 引擎 在我开始将 perl6intro.com 翻译成西班牙语后不久，我开始使用 Perl6。看看 Perl6 的文档，我发现了 Perl6 巨大的并发潜力。 Perl6在并发方面比我想象的更加强大。
我使用 Perl6 的 HTTP 服务器的思想始于 Perl6 Supplies（具有多个订阅者的异步数据流），具体来说就是 IO::Socket::Async类。所有的套接字管理，数据传输和并发性实际上都是自动且易于理解的。制作并玩一玩小并发但强大的服务是极好的。
基于 IO::Socket::Async 文档的示例，我开始在 mini-http-cgi-server 项目中实现一个支持 pseudoCGI 的小型 HTTP 服务器，并且按照我的预期工作。当我得到我想要的东西时，我很满意，我离开了这个项目一段时间。我不喜欢事情发展太多。</description>
    </item>
    
    <item>
      <title>第二十四天-解魔方</title>
      <link>https://ohmysummer.github.io/post/2017-12-24-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%A4%A9-%E8%A7%A3%E9%AD%94%E6%96%B9/</link>
      <pubDate>Sun, 24 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-24-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%A4%A9-%E8%A7%A3%E9%AD%94%E6%96%B9/</guid>
      <description>Day 24 – Solving a Rubik’s Cube 介绍 我在圣诞节的愿望清单上有一个速度魔方，我真的很兴奋。 :)我想分享一些Perl 6代码的热情。
我在89年从高中毕业，所以我恰好是在青少年时期拥有魔方的合适年龄。我记得试图在巴士上炫耀，让我的时间缩短到不到一分钟。我在80年代从当地的一家玩具店拿到了一本小册子，其中展示了一个关于如何解决我记忆的立方体的算法。我再也没有这本小册子了。多年来我一直坚持，但从来没有达到竞争水平。
在过去的几个月里，YouTube根据我对立体声频道的兴趣，向我推荐了一些立方体视频;看到世界纪录在5秒以内，使我一分钟的旧时间看起来很慢。
我所讲过的每个人都可以解决魔方问题，他们使用的算法与我所学的算法不同，而在立体魔法中讨论的方法却与众不同。不过，这种先进的版本似乎被定期制定世界记录的人们普遍使用。
拾取这个算法并不难，我找到了几个视频，尤其是描述如何解决最后一层的视频。这样做了几天之后，我将步骤转录为几个笔记，其中列出了步骤列表，以及每个步骤的关键部分：所需的方向，然后是该步骤的各个转弯。然后，我可以参考我的笔记本的一个页面，而不是一个30分钟的视频，并且在几天后，记住了以下步骤：能够从记谱法移动到仅仅做这些移动是一个很大的加速。
一周后，我能够在两分钟内使用新方法可靠地解决问题;退后一步，但在休息时间里一周的努力并不坏。从那以后（几个星期后），我一直下到1:20以下。再次，这是初学者的方法，没有任何先进的技术，而且我可以在不查看立方体的情况下完成各个算法步骤。 （尽管如此，我仍然有很长的路要走。）
符号 关于移动符号的快速注释 - 考虑到您将立方体的一边保持在顶部，一边朝向您，相对边是：
L (Left) R (Right) U (Up) D (Down) F (Front) B (Back)  如果在步骤中看到一个单独的字母，如B，则表示顺时针转动该面（相对于立方体的中心，而不是您）。如果你在信里加了一个&amp;rdquo;，那就意味着逆时针方向，所以R&amp;rsquo;会让最上面的部分下来，而R会让底部的部分出现。
此外，您可能必须翻转两次，写成U2; （顺时针或逆时针无关紧要，因为它从起点开始为180º。）
算法 我正在使用的初学者算法有以下基本步骤：
1.白色十字架2.白色拐角3.第二层4.黄色十字架5.黄色边缘6.黄色拐角7.定位黄色拐角
如果您对每个步骤的具体内容感到好奇，您可以浏览Rubik的wiki或上面链接的YouTube视频。该算法的更高级版本（由Jessica Fridrich提供的CFOP）允许您合并步骤，具有处理特定立方体状态的特定“快捷方式”，或者解决任何颜色作为第一面，而不仅仅是白色。
设计一个模块 当我开始研究这个模块时，我知道我希望能够以某种熟悉算法的人熟悉的方式展示每一步所需的位置，并且让各个步骤也是自然的，就像是：
F.R.U.Rʼ.Uʼ.Fʼ  我也希望能够转储立方体的现有状态;现在作为文本，但最终也能够将其与视觉表示相结合，
我们需要能够判断立方体是否已解决;我们需要能够检查相对于当前方向的棋子，并且能够改变我们的方向。
由于我要开始渲染立方体状态的能力，然后快速添加转向两侧的能力，我选择了一个内部结构，使其变得相当容易。
代码 github上提供了该模块的最新版本。这里介绍的代码来自最初的版本。
Perl 6允许您创建Enumerations，因此您可以在代码中使用实际的单词而不是查找值，所以让我们从一些我们需要的内容开始：
enum Side «:Up(&#39;U&#39;) :Down(&#39;D&#39;) :Front(&#39;F&#39;) :Back(&#39;B&#39;) :Left(&#39;L&#39;) :Right(&#39;R&#39;)»; enum Colors «:Red(&#39;R&#39;) :Green(&#39;G&#39;) :Blue(&#39;B&#39;) :Yellow(&#39;Y&#39;) :White(&#39;W&#39;) :Orange(&#39;O&#39;)»;  有了这个语法，我们可以直接在我们的代码中使用Up，并且它的关联值是U.</description>
    </item>
    
    <item>
      <title>Playing with the code of Rakudo Perl 6</title>
      <link>https://ohmysummer.github.io/post/2017-12-23-playing-with-the-code-of-rakudo-perl-6/</link>
      <pubDate>Sat, 23 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-23-playing-with-the-code-of-rakudo-perl-6/</guid>
      <description>昨天，我们查看了返回字符串的 Bool 类的两个方法。函数产生的字符串表示在源代码中被硬编码。
让我们使用这个观察并尝试改变文本。
所以，这里是我们要修改的片段：
Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) { self ?? &#39;True&#39; !! &#39;False&#39; });  该 gist 方法用于对已定义的变量进行字符串化。
要做到这一点，你需要在计算机上安装 Rakudo 的源代码，以便编译它们。首先从 GitHub 克隆项目：
$ git clone https://github.com/rakudo/rakudo.git  编译 MoarVM：
$ cd rakudo $ perl Configure.pl --gen-moar --gen-nqp --backends=moar $ make  完成之后，你会在 rakudo 目录下获得 perl6 可执行文件。
现在，打开 src/core/Bool.pm 文件，并将 gist 方法的字符串更改为使用 Unicode 大拇指代替纯文本：
Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) { self ?? &#39;👍&#39; !! &#39;👎&#39; });  保存文件后，您需要重新编译 Rakudo。 Bool.</description>
    </item>
    
    <item>
      <title>第二十三天-Perl 6 高尔夫</title>
      <link>https://ohmysummer.github.io/post/2017-12-23-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E5%A4%A9-perl-6%E9%AB%98%E5%B0%94%E5%A4%AB/</link>
      <pubDate>Sat, 23 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-23-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E5%A4%A9-perl-6%E9%AB%98%E5%B0%94%E5%A4%AB/</guid>
      <description>Day 23 – The Wonders of Perl 6 Golf 啊，圣诞节！还有什么比和你的朋友与家人一起坐在桌子旁边玩高尔夫球代码还好呢！ &amp;hellip;等等，什么？
哦，对，这还不是圣诞节。但是你可能想要为它做好准备！
如果你还没有注意到，有一个不错的网站可以玩高尔夫球代码：https://code-golf.io/。这个网站很酷的地方是，它不仅仅只支持 perl 6！在撰写本文时，它还支持其他 6 种语言。嗯&amp;hellip;
无论如何，因为我在那个网站的成绩还不错，我会分享一些我觉得最好的解决方案。所有的 trickety-hackety，unicode-cheatery 和 mind-blowety。在我们看来，也许我们甚至会看到即使在代码高尔夫中，perl 6 也非常简洁易读。也就是说，如果你很难将你的圣诞愿望放在一张卡片上，那么可能会放得下一行 perl 6 代码。
我不会提供完整的解决方案，不会破坏你的圣诞乐趣，但我会给你足够的提示，以提出有竞争力的解决方案。
这个圣诞节我就是想让你得到一些乐趣。所以你先下载一份 rakudo，以确保你可以跟随。稍后我们会有一些南瓜派，我们会做一些颂歌。如果您在运行 perl 6 时遇到任何问题，可以在 freenode 上加入 ＃perl6 频道以获得一些帮助。这就是说，https://code-golf.io/ 本身为你提供了一个很好的编辑器来编写和评估你的代码，所以应该没有问题。
一些基本的例子 让我们以帕斯卡三角形任务为例。我听到了，我听到了！圣诞节前的数学，这太残酷了。残忍，但很有必要。
只有一个你必须知道的基本技巧。如果从 Pascal 三角形中取出任何一行，将它移动一个元素，然后用原始行对结果进行 zip-sum，就会得到下一行！
所以如果你有一行数字：
1 3 3 1  你所做的只是把它移到右边：
0 1 3 3 1  并将其与原始行相加：
1 3 3 1 + + + + 0 1 3 3 1 = 1 4 6 4 1  就是如此容易！所以我们还是写代码吧：</description>
    </item>
    
    <item>
      <title>Exploring the Bool type in Perl 6, part 1</title>
      <link>https://ohmysummer.github.io/post/2017-12-22-exploring-the-bool-type-in-perl-6-part-1/</link>
      <pubDate>Fri, 22 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-22-exploring-the-bool-type-in-perl-6-part-1/</guid>
      <description>今天，我们将使用 GitHub 上提供的 Rakudo 源代码挖掘 Bool 类型的内部。
Perl 6 是用 Perl 6 和 NQP（Not Quite Perl 6）语言编写的，这使得阅读源代码变得相对容易。当然，有很多东西不容易理解，或者没有反映在 Perl 6 语言的公开文档中。到目前为止，您都无法在 Perl 6 书籍中找到深入的细节。无论如何，对 Perl 6 有一些中级的理解，这仍然是可能的。
好的，回到 src/core/Bool.pm 文件。它以一些 BEGIN phasers 开始，它为 Bool 类添加了一些方法和 multi 方法。下一次我们将讨论元模型和类构造的细节。今天，对我们来说更有趣的是 Bool 类的方法在做什么。
gist 和 perl gist 和 perl 方法返回对象的字符串表示形式：当变量被字符串化时隐式调用 gist，perl 应该直接调用。它适用于 Perl 6 中的任何对象，但这种行为当然应该定义在某处。他们在这里：
Bool.^add_method(&#39;gist&#39;, my proto method gist(|) {*}); Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) { self ?? &#39;True&#39; !! &#39;False&#39; }); Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:U:) { &#39;(Bool)&#39; }); Bool.</description>
    </item>
    
    <item>
      <title>第二十二天-Perl 6.d 的特性</title>
      <link>https://ohmysummer.github.io/post/2017-12-22-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%A4%A9-perl-6.d%E7%9A%84%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 22 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-22-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%A4%A9-perl-6.d%E7%9A%84%E7%89%B9%E6%80%A7/</guid>
      <description>Day 22 – Features of Perl 6.d 所以我们就是这样。 Rakudo Perl 6第一次正式发布两年后，或者更准确的说是6.c。自从马特奥茨从那时起就开始关注性能的提升之后，圣诞老人认为要对此进行对比，描述自那时起实施的6.d的新功能。因为有很多，圣诞老人不得不做出选择。
在创建时调整对象 您创建的任何课程现在都可以使用TWEAK方法。在新的类的新实例的所有其他初始化完成之前，这个方法将被调用。一个简单的，有点人为的例子，其中一个类A有一个属性，默认值是42，但如果在创建对象时指定了默认值，它应该更改该值：
class A { has $.value = 42; method TWEAK(:$value = 0) { # default prevents warning # change the attribute if the default value is specified $!value = 666 if $value == $!value; } } # no value specified, it gets the default attribute value dd A.new; # A.new(value =&amp;gt; 42) # value specified, but it is not the default dd A.</description>
    </item>
    
    <item>
      <title>Perl 6 中的 proto 关键字</title>
      <link>https://ohmysummer.github.io/post/2017-12-21-perl-6-%E4%B8%AD%E7%9A%84-proto-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Thu, 21 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-21-perl-6-%E4%B8%AD%E7%9A%84-proto-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>今天，我们正在关注 proto 关键字。它向编译器提供了关于你打算创建 multi-subs 的提示。
例子 1 考虑一个翻转字符串或使整数变成负数的函数示例。
multi sub f(Int $x) { return -$x; } multi sub f(Str $x) { return $x.flip; } say f(42); # -42 say f(&#39;Hello&#39;); # olleH  如果我们创建另一个接收两个参数的函数的变体，会怎么样？
multi sub f($a, $b) { return $a + $b; } say f(1, 2); # 3  这个代码完美的工作，但它看起来像它的和谐是破碎的。即使函数的名称没有提及它的作用，我们也打算设置一个函数，以某种方式返回它的参数的“反射”版本。将两个数字相加的函数不适合这个想法。
所以，现在是在 proto 关键字的帮助下清楚地宣布意图的时候了。
proto sub f($x) {*}  现在，尝试调用双参数函数将无法编译：
===SORRY!=== Error while compiling proto.pl Calling f(Int, Int) will never work with proto signature ($x) at proto.</description>
    </item>
    
    <item>
      <title>第二十一天-数独与Junctions和集合</title>
      <link>https://ohmysummer.github.io/post/2017-12-21-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E5%A4%A9-%E6%95%B0%E7%8B%AC%E4%B8%8Ejunctions%E5%92%8C%E9%9B%86%E5%90%88/</link>
      <pubDate>Thu, 21 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-21-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E5%A4%A9-%E6%95%B0%E7%8B%AC%E4%B8%8Ejunctions%E5%92%8C%E9%9B%86%E5%90%88/</guid>
      <description>Day 21 – Sudoku with Junctions and Sets Perl6 中有许多核心元素为您提供强大的工具，以简洁而强大的方式完成任务。其中两个是具有许多特征的联结和集合，但也是截然不同的。为了演示这些功能，我将介绍如何将它们用于一个简单的问题，Sudoku拼图。
数独：进修 所以对于那些不知道数独谜题的人来说，它是一个9乘9的网格，它提供了一些填充了数字1-9的单元格。目标是填充数字在1和9之间的所有单元格，所以没有任何行，列或子广场具有多于一个的数字。
有几种方法来表示一个数独谜题，我个人最喜欢的是 9×9 嵌套数组，例如：
my @game = [ [4,0,0,0,0,0,0,0,0], [0,9,0,3,4,6,0,5,0], [5,8,0,0,9,0,0,0,6], [0,4,0,8,1,3,0,0,9], [0,0,0,5,0,4,0,0,0], [8,0,0,6,2,9,0,4,0], [3,0,0,0,5,0,0,6,2], [0,5,0,9,3,2,0,8,0], [0,0,0,0,0,0,0,0,1] ];  在这种情况下，没有赋值的单元格被赋值为0，这样所有的单元格都有一个赋值给它们的整数值。使用这种格式要记住的主要事情是你需要使用@game [$ y] [$ x]而不是@game [$ x] [$ y]来引用单元格，
Junctions：量子逻辑测试 在 Perl6 中使用 Junction 的最简单方法之一是逻辑测试。 Junction可以表示您想要测试的值的选择。例如 ：
if ( 5 &amp;lt; 1|10 &amp;lt; 2 ) { say &amp;quot;Spooky&amp;quot; } else { say &amp;quot;Boo&amp;quot; } Spooky  因此，这不仅证明了操作符链（经验丰富的程序员可能已经看起来很困惑），而且对于5 &amp;lt;10和1 &amp;lt;2，任何连接点（1 | 10）的计算结果都为True。这样，连接点可以非常已经很强大了，当你为它们分配一个变量容器时，它变得非常有趣。</description>
    </item>
    
    <item>
      <title>第二十天-宏的进阶</title>
      <link>https://ohmysummer.github.io/post/2017-12-20-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%A4%A9-%E5%AE%8F%E7%9A%84%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Wed, 20 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-20-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%A4%A9-%E5%AE%8F%E7%9A%84%E8%BF%9B%E9%98%B6/</guid>
      <description>Day 20: Advancements in Macrotechnologies 你好！
请允许我，在出现日历的这一天，一个小切线。我不会直接谈论一个很酷的熟练的Perl 6特性。相反，我会打开一个小窗口，讨论可能会发生什么 - 希望在某些时候！
如果你像我一样，在Rakudo上继续了几年的进步，你在版本中经常看到这一点：&amp;gt;一些不太有效的功能包括：&amp;gt; - 高级宏
那么，这究竟意味着什么？ Perl 6确实有宏，但它们目前的限制超出了人们通常想要做的。这并不是说它们目前是无用的，它们仍然是有用的，从前几年出现的其他帖子到OO :: Monitor使用宏来提前报告拼写错误。
输入007. 007是“具有宏观许可的小型实验语言”。这是什么意思？！这是一种用于对宏进行调试和实验的语言，因此当他们被集成到Perl 6中时，他们的设计就已经准备好并经过战斗测试。
那么，它有什么？ 007试图模仿Perl 6的“强大”部分，因此我们不会为完全不同的语言设计宏。这意味着阶段，中缀操作员，（MOP和正则表达式的要点）。
它是什么样子的？ 007的核心就是喜欢Perl 6.然而，它的确存在一些问题。让我们来看看你想写的最重要的片段：FizzBu​​zz。注意：此博客帖子中的所有代码片段都是可执行的007代码，而不是Perl 6代码。
my n = 1; while n &amp;lt;= 100 { if n %% 15 { say(&amp;quot;FizzBuzz&amp;quot;); } else if n %% 3 { say(&amp;quot;Fizz&amp;quot;); } else if n %% 5 { say(&amp;quot;Buzz&amp;quot;); } else { say(n); } n = n + 1; }  什么？你不在乎吗？很明显，我确实答应过你的宏。我们将看看一个简单的宏“name”，它返回最后一个索引对象的名称。</description>
    </item>
    
    <item>
      <title>第十九天-Language Independent Validation Rules (LIVR) for Perl6</title>
      <link>https://ohmysummer.github.io/post/2017-12-19-%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%A4%A9-language-independent-validation-rules-livr-for-perl6/</link>
      <pubDate>Tue, 19 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-19-%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%A4%A9-language-independent-validation-rules-livr-for-perl6/</guid>
      <description>Language Independent Validation Rules (LIVR) for Perl6 我刚刚将 LIVR 移植到了 Perl6。在 Perl6 中编写代码非常有趣。而且，LIVR 的测试套件让我能够在 Perl6 的 Email::Valid 模块中发现 bug，而在 Rakudo 中则发现另一个 bug。更有趣的是，不仅仅实现了一个模块，而且还帮助其他开发人员进行了一些测试:)
什么是 LIVR？ LIVR 代表“语言独立验证规则”。所以，它就像 “Mustache” ，但在验证的世界。所以，LIVR 由以下几部分组成：
 LIVR规范 针对不同语言的实现 通用测试套件，用于检查实现是否正常工作。  LIVR 有如下语言的实现：
 Perl 5 (LIVR 2.0) available at CPAN, 维护者 @koorchik Perl 6 (LIVR 2.0) available at CPAN, 维护者 @koorchik JavaScript (LIVR 2.0) available at npm, 维护者 @koorchik PHP (LIVR 2.0) available at packagist, 维护者 @WebbyLab Python (LIVR 2.</description>
    </item>
    
    <item>
      <title>第十八天-Perl 6 支持的工作流</title>
      <link>https://ohmysummer.github.io/post/2017-12-18-%E7%AC%AC%E5%8D%81%E5%85%AB%E5%A4%A9-perl-6%E6%94%AF%E6%8C%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81/</link>
      <pubDate>Mon, 18 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-18-%E7%AC%AC%E5%8D%81%E5%85%AB%E5%A4%A9-perl-6%E6%94%AF%E6%8C%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81/</guid>
      <description> Day 18: Perl 6 powered work flow 保持流畅的编码可能是一个挑战。分心和讨厌的句法错误是潜在的流量瓶颈。
然后是7 +/- 2短期内存限制，我们都必须耍弄。与计算机不同，我们不能仅仅增加更多的硬件来增加大脑工作内存缓冲区的大小 - 至少目前还没有。保持流量需要管理这个缓冲区以避免井喷。幸运的是，我们有电脑帮助。
自计算开始以来，使用计算机扩展记忆的想法一直存在。早在1945年，Vannevar Bush就设想了一种Memex（MEMory EXtender），这是一种“扩大了对个人记忆的贴心补充”。
在2017年，卑微的文本文件可以像一个穷人的memex。该文本文件包含三个部分的时间轴：过去，现在和下一个。这有点像改变日志，但也有未来。过去的部分会随着时间的推移填满，包含完成的任务和信息供以后召回。现在部分可帮助您专注于手头的任务，而下一部分将排队完成将来要完成的任务。
任务通过三种状态：do（+ next），done（！now）和done（-past）。
为了保持畅通，你有时需要快速回忆一些事情，记下将来要做的事情，并专注于现在的进步。保留一个123.do文件可以帮助您减轻编码时的认知负担。
123.do文件的格式很简单，因此您可以直接使用文本编辑器对其进行破解，并使用此Perl 6语法进行描述。
这是驱动它的Perl 6命令行模块。
安装它只需:
shell&amp;gt; zef install Do123 shell&amp;gt; 123 +7 Merry Christmas shell&amp;gt; 123 +13 Happy New Year  </description>
    </item>
    
    <item>
      <title>第十七天-关于消息传递</title>
      <link>https://ohmysummer.github.io/post/2017-12-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E5%A4%A9-%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/</link>
      <pubDate>Sun, 17 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E5%A4%A9-%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/</guid>
      <description>Day 17: Something about messaging (but I couldn’t think of a snappier title.) 为什么要传递消息 当我第一次开始考虑写今年的 Advent 文章时，我反思我在过去的十二个月里并没有真正写过大量的 Perl 6，与往年相比，我似乎写了大量的模块。我一直在做的事情（至少在我的日常工作中）正在考虑和实施大量使用某些消息传递系统的应用程序。所以我认为将这些想法引入 Perl 6 会很有趣。
作为一种“胶水语言”，Perl一直享有盛誉，Perl 6 具有与之竞争的功能，最显着的是响应式和并发功能，因此非常适合创建基于消息的集成服务。
传递什么信息 现在我的脚下就是优秀的企业集成模式，尽管它现在已经有近15年的历史了，但我仍然建议任何有兴趣（或工作于）该领域的人。然而，它是一个重量级的书（字面上，它在硬书中的重量接近一点五公斤），所以我用它来提醒自己不要试图在这个主题上详尽无遗，以免这会变成一本书本身。
有相当多的自由和商业管理消息系统，使用一系列开放和专有的协议，但我将限制自己到我熟悉的 RabbitMQ，并且在 Perl 6 中由 Net::AMQP 支持。
如果你想亲自尝试一下这些例子，你将需要访问一个 RabbitMQ 代理（它可以作为大多数操作系统发行版的包），但是你可以使用 Docker Image，它看起来工作得很好。
您还需要安装 Net::AMQP，这可以通过以下方式完成：
zef install Net::AMQP  在示例中，我将使用 RabbitMQ 服务器的默认连接详细信息（即代理正在本地主机上运行，​​并且默认 guest 处于活动状态），如果您需要提供不同的详细信息，则可以更改 Net::AMQP 的构造函数以反映适当的值：
my $n = Net::AMQP.new( host =&amp;gt; &#39;localhost&#39;, port =&amp;gt; 5672, login =&amp;gt; &#39;guest&#39;, password =&amp;gt; &#39;guest&#39;, vhost =&amp;gt; &#39;/&#39; );  一些示例可能需要其他模块，但我会在介绍时介绍它们。</description>
    </item>
    
    <item>
      <title>第十六天-Perl 6 性能改进</title>
      <link>https://ohmysummer.github.io/post/2017-12-16-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%A4%A9-perl-6%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B/</link>
      <pubDate>Sat, 16 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-16-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%A4%A9-perl-6%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B/</guid>
      <description>Day 16 – 🎶 Deck The Halls With Perf Improvements 🎶 在英国，我们缺乏感恩节给圣诞节带来了新的一年，感谢和反思。为此，我想围绕Perl 6性能的状态放置一些我已经坐了一段时间的零碎片断，这些片断强调了这个过程需要付出多少努力。我不确定更广泛的编程社区对正在发生的努力的速度和数量表示赞赏。
我不是核心开发人员，但自2010年推出Rakudo *之后，我一直是Perl 6的低级用户。通常情况下，已经进入Rakudo的努力被未知的努力所掩盖。人们重新审视Rakudo Perl 6时尤其如此，他可能会想象下一个圣诞节将会如何。但是Perl 6在历史上证明，在下一个圣诞节之前，事情总会有所改善，无论您选择哪个圣诞节，
回到2014年的圣诞节，我写了一篇关于为什么我认为Perl 6能够完成生物信息学工作的出色文章。那篇文章中没有提到的是，为什么在Rakudo上实现Perl 6根本没有准备好去做任何严肃的生物信息学。表演真的没有！我在Perl 6中的第一次尝试（当Parrot虚拟机完全使用时）让我执行了几十分钟的简单操作，我期望它是毫秒级的性能。这很遗憾，因为我没有跟踪时间。但这当然不是一个好起点。
然而，快速转发到2014年和MoarVM，我觉得自己写这篇来临邮件感觉很舒服，因为我知道在作为用户的4年中有多少改进。而且，所有的发展都是在完成语言定义和正确的实施。然而，我是一直在等待perf到达那里的用户。我认为大部分时间到了。为此，我要感谢所有核心开发者所付出的巨大的日常努力。观看它展现出令人难以置信的动力。对我来说，这个圣诞节是圣诞节的目标，它已经到来。 👏🏻🎊
我一直在为我的BioInfo模块运行和计时测试，这些模块对生物序列数据进行了多年的基本操作。它以非常糟糕的方式做到了这一点。在紧密循环中分配和丢弃哈希时出现了很多错误等等。但是我已经将这些代码留给了现在 - 在五年多的时间里。悄悄地进行私人基准测试，偶尔鼓励在IRC频道看到大幅飞跃的努力。 Sub 10s是一个很大的！它从30/40秒突然发生。在我暗示IRC一个地方，我的代码在分析时特别慢，这是一次跳跃！
这是一个长期观点，如果我放大去年的这一年，可以看到，如果时间不是很长，整个系数的性能仍然在提高。
请记住，所有这些配置文件都不是来自Rakudo编译器的发布版本，而是来自当天的HEAD。所以偶尔会有一些奇怪的表现回归，正如你上面看到的，通常不会留下来发布。
发生什么了？情况如何变好？有几个原因。 Perl 6中的许多算法选择和核心功能都已经在源代码级别（更晚些时候）逐步和积极地进行了优化。但支持Rakudo的MoarVM虚拟机的优化能力也得到了提高，并且可以降低到原生代码和内联专用版本的代码。这部分得益于2014年以来Rakudo Perl 6提供的-profile选项，它提供了所有这些信息。
在上面关于MoarVM如何处理我编译过的Perl 6测试的代码框的情节中，应该很清楚的是，自从今年夏天以来，有相当多的框架被JIT编译，解释较少，并且几乎所有专用框架（橙色）结束原生JIT（绿色）。如果您想了解更多有关“spesh”MoarVM代码专门工具的最新工作，您可以在他的博客上阅读Jonathan Worthington的4篇文章。 Baart Weigmans还有一篇博客概述了他在JIT编译器方面的工作，最近还谈到了许多尚未登陆的新功能，希望能让许多新开发人员加入并帮助改进JIT。所以如果这对你来说是一件有趣的事情，我建议你查看一下上面的链接。
所以这是我的基准和我的目标，其中大部分是围绕数据结构创建和解析。但是，数字作品等其他内容呢？那也保持了吗？没有任何人推动，就像我推动我对事情可以改进的地方的看法。答案是肯定的！
曾几何时，早在2013年，一位名叫Tim King的绅士就开始对Perl 6中的素数感兴趣.Tim对他发现的性能颇为不满。正确如此。他从以下漂亮的代码开始：
通过定义一个素数的交叉点找到任何素数，真是一个不错的优雅解决方案！但是蒂姆惊讶地发现联赛很慢，上面的代码让他看到了前1000个素数。今天，超级高级代码需要0.96s。
对于基于联结的代码的缓慢程度，蒂姆继续做更标准的迭代方法感到不满。 Tim在这些帖子后不久就从网上消失。但他留下了我继续留下的遗产。他的主要基准测试代码和我对时间结果的适应性可以在这个要点中找到。以下是另一张图表，其中显示了每个超过100次试验找到前1000个素数所需的平均时间。 2015年的垂直线是较高的标准偏差。
再次以最近的放大视图（最新的数据点让我担心一点，我以某种方式搞砸了&amp;hellip;&amp;hellip;）
上面的收敛到一个点，是启动和停止Rakudo运行时和MoarVM的开销。发现素数并不是它曾经的努力，它比Rakudo的开始稍微慢一些。无论您选择的代码解决方案的级别和优雅程度如何，至少要快一个数量级。
好吧，我们已经看到MoarVM获得了一些闪亮的新运动部件。但是像Liz，jnthn，Zoffix以及最近在字符串Samcv世界中开发人员已经付出了巨大的努力，以改进MoarVM和Rakudo在算法上实际上正在做的事情。
旁注：我相信我根本不会做大多数其他开发人员的正义，特别是在这篇文章中忽略了JVM的努力。我建议每个人都去，并检查提交日志，看看有多少人现在参与使Rakudo更快，更好，更强大。我确定他们想在本文的底部看到您的感谢！  因此，节省你一份查看提交日志的工作我已经做了一些挖掘，看看自上个圣诞节以来与提高性能有关的提交。 N％或Nx更快的东西。如下所示：
3c6277c77 Have .codes use nqp::codes op. 350% faster for short strings ee4593601 Make Baggy (^) Baggy about 150x faster  这两项承诺将以一年的核心发展时间表推动编程项目的发展。但是，今年，它们仅仅是数百次提交中的两次。</description>
    </item>
    
    <item>
      <title>第十五天-带有 Promise 的简单网络爬虫</title>
      <link>https://ohmysummer.github.io/post/2017-12-15-%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9-%E5%B8%A6%E6%9C%89promise%E7%9A%84%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</link>
      <pubDate>Fri, 15 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-15-%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9-%E5%B8%A6%E6%9C%89promise%E7%9A%84%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</guid>
      <description>Day 15 – A Simple Web Spider With Promises 承诺，承诺 去年夏天，我申请了一项编程工作，面试官要求我编写一个程序来抓取给定的域，只在该域中的链接之后，找到它引用的所有页面。我被允许以任何语言编写程序，但我选择使用Go语言执行任务，因为这是该公司使用的主要语言。这对于并发编程来说是一个理想的任务，并且Go具有非常好的现代化功能，即使有些低级别的并发支持。网络蜘蛛中的主要工作是执行与在域中发现的唯一锚链接相同的次数，即在每个页面上执行HTTP GET并解析页面文本以获取新链接。这个任务可以并行安全地完成，因为没有可能（除非你做得很糟糕），任何调用爬取代码都会干扰其他任何调用。
Go和Perl 6的创造者受到安东尼霍尔爵士1978年的开创性工作“沟通顺序过程”的启发，但值得注意的是，Perl 6代码更加简洁，因此更容易隐藏到博客文章中。事实上，Go设计者总是将他们的结构称为“并发原语”。 Go为我的作业应用程序编写的并发spider代码大约有200行，而在Perl 6中大小不到这个大小的一半。
下面我们来看看如何在Perl 6中实现一个简单的Web爬虫。内置的Promise类允许您启动，调度和检查异步计算的结果。所有你需要做的就是给Promise.start方法一个代码引用，然后调用await方法，这会阻塞，直到promise完成执行。然后您可以测试结果方法以确定承诺是否已被保留或中断。
您可以通过将其保存到本地文件中来运行本文中的代码，例如网络spider.p6。如果您希望抓取https网站，请使用zef安装HTML :: Parser :: XML和HTTP :: UserAgent以及IO :: Socket :: SSL。我会提醒你，SSL支持目前看起来有点狼狈，所以最好坚持http站点。 Perl 6程序中的MAIN子程序存在时表示一个独立程序，这就是执行开始的地方。 MAIN的参数表示命令行参数。我编写了这个程序，以便默认情况下它会抓取Perlmonks站点，但是您可以覆盖它，如下所示：
$ perl6 web-spider.p6 [–domain=http://example.com]  简单的Perl 6域蜘蛛
use HTML::Parser::XML; use XML::Document; use HTTP::UserAgent; sub MAIN(:$domain=&amp;quot;http://www.perlmonks.org&amp;quot;) { my $ua = HTTP::UserAgent.new; my %url_seen; my @urls=($domain); loop { my @promises; while ( @urls ) { my $url = @urls.</description>
    </item>
    
    <item>
      <title>第十四天-在 Perl 6 中构建和测试 Big Grammars</title>
      <link>https://ohmysummer.github.io/post/2017-12-14-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9-%E5%9C%A8perl-6%E4%B8%AD%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95%E5%A4%A7grammars/</link>
      <pubDate>Thu, 14 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-14-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9-%E5%9C%A8perl-6%E4%B8%AD%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95%E5%A4%A7grammars/</guid>
      <description>The Little Match Girl: Building and Testing Big Grammars in Perl 6 Perl 6 Grammars 很棒，但在项目中使用它们会是什么样呢？在圣诞节前和圣诞节后，我的经历是一个令人心酸的故事。你可以在这里找到版本库。我不是来自计算机科学背景，所以也许它看起来很简陋，但是当我学习 Perl 6 Grammars 时，这是我的困难和胜利。
第一根火柴 就像卖火柴的小女孩一样，我们的故事发生在圣诞节前。卖火柴的小女孩的任务是在圣诞节前夕销售一捆火柴棍（实际上是新年，我确实回去读了那个故事。圣诞节更适合 Perl 6），而我的任务是从 Modelica 模型中提取注释渲染为矢量图形。现在，Modelica 是一个非常棒的面向对象的建模语言，除了提及其附录中包含一个具体语法部分的非常好的规范文档（pdf）之外，我将完全理解它。仔细阅读本节，我意识到“语法元符号”和“词法单位”看起来像我最近读过的一篇博客文章中的 Perl 6 Grammars，并且急于尝试。
来自 Modelica 的示例具体语法：
class-definition : [ encapsulated ] class-prefixes class-specifier  Perl 6 rule 的示例:
rule class_definition { [&amp;lt;|w&amp;gt;&#39;encapsulated&#39;&amp;lt;|w&amp;gt;]? &amp;lt;class_prefixes&amp;gt; &amp;lt;class_specifier&amp;gt; }  这就像卖火柴的小女孩划第一颗火柴一样，第一次看到了一个超越她现实的奇妙世界。一个温暖的小炉子。然后它熄灭了。
它非常接近，我把它放到了一个文本编辑器中，并且用一些 Perl 6 的东西替换了不是 Perl 6 的部分，以查看它是否会运行。它没有运行。我砍掉了它，我指出了不同的位来解决更小的块。无处不在的空白符号，正则表达式，标记，规则。我能够解析某些部分，其他部分神秘地没有起效。回顾过去，这一定很糟糕。与此同时，我们一起破解传统的正则表达式来提取注释，并将我的 Grammar 放在架子上。
第二根火柴 不久之后，发布了 Grammar::Profiler 和 Grammar::Debugger，并且我受到启发，决定再试一试。我被授予了对我的规则出乎意料表现的很好的见解。我能够比以前更深入地理解 grammar。第二支火柴一直亮着，我有一场盛宴。然后它熄灭了。</description>
    </item>
    
    <item>
      <title>第十三天 - 使用 Perl 6 挖掘维基百科</title>
      <link>https://ohmysummer.github.io/post/2017-12-13-%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9-%E4%BD%BF%E7%94%A8-perl-6-%E6%8C%96%E6%8E%98%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91/</link>
      <pubDate>Wed, 13 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-13-%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9-%E4%BD%BF%E7%94%A8-perl-6-%E6%8C%96%E6%8E%98%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91/</guid>
      <description>介绍 大家好!
今天，让我介绍一下如何用 Perl 6 挖掘维基百科的 Infobox。
维基百科信息框在自然语言处理中扮演着非常重要的角色，并且有许多应用程序可以利用维基百科信息框：
 构建知识库（例如 DBpedia[0]） 排名属性的重要性[1] 问答[2]  其中，我将重点讨论信息框提取问题，并演示如何使用 Grammars 和 Actions 解析信息框的复杂结构。
Grammar 和 Actions 难学吗? 不，他们不是！
你只需要知道五件事情：
 Grammar
 token 是最基础的一个。你通常使用它。 rule 让空白符有意义。 regex 让匹配引擎回溯。  Actions
 make 准备一个对象用于返回当 made calls on it。 made 在它的调用者身上调用并返回准备好的对象。   欲了解更多信息, 请查看: https://docs.perl6.org/language/grammars
什么是 Infobox? 你有没有听过 &amp;ldquo;Infobox&amp;rdquo; 这个词?
对于那些没听说过的人，我会简单地解释一下。
理解信息框的一个简单方法是使用一个真实的例子：
你可以看到，信息框会在页面的右上方显示页面主题的属性-值对儿。例如, 在这个例子中, 它说 Perl 6 的设计者 (ja: 設計者)是 Larry Wall(ja: ラリー・ウォール)。
欲了解更多信息, 请查看: https://en.</description>
    </item>
    
    <item>
      <title>第十二天 – The Year of Perl 6 Books</title>
      <link>https://ohmysummer.github.io/post/2017-12-12-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9the-year-of-perl-6-books/</link>
      <pubDate>Tue, 12 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-12-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9the-year-of-perl-6-books/</guid>
      <description>https://perl6advent.wordpress.com/2017/12/12/day-12-the-year-of-perl-6-books/</description>
    </item>
    
    <item>
      <title>第十一天-Perl 6 中所有的星号</title>
      <link>https://ohmysummer.github.io/post/2017-12-11-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9perl6%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E6%98%9F%E5%8F%B7/</link>
      <pubDate>Mon, 11 Dec 2017 12:50:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-11-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9perl6%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9A%84%E6%98%9F%E5%8F%B7/</guid>
      <description>在今年的 Perl 6 Advent Calendar 中, 雪花被今天的博客文章承包了。 我们将检阅使用了 * 字符的结构。 在 Perl 6 中，根据上下文的不同，您可以叫它星星（或者，如果你愿意的话，可以叫它星号）或者 *whatever*。
Perl 6 不是一个隐秘的编程语言， 在许多方面它的语法比 Perl 5 更加一致。另一方面，有些地方需要花时间来开启对语法的信心。
让我们看看 * 的不同用法，从最简单的开始，旨在了解最烧脑的例如 * ** *。
前两种用法很简单，不需要太多的讨论：
1. 乘法 单个星号用于乘法。严格来讲, 这是一个中缀操作符 infix:&amp;lt;*&amp;gt;, 它的返回值为 Numeric。
say 20 * 18; # 360  2. 幂 两个星号 ** 是幂操作符。再次, 这是一个中缀操作符 infix:&amp;lt;**&amp;gt;, 它返回 Numeric 结果, 计算两个给定值点幂。
say pi ** e; # 22.4591577183611  正则表达式中同样也使用了两个标记（* 或 **），它们表示不同的东西。 Perl 6 的一个特点是它可以很容易地在不同的语言之间切换。 正则表达式和 grammar 都是这样的内部语言的例子，其中同样的符号在 Perl 6 中可能意味着不同的含义。</description>
    </item>
    
    <item>
      <title>第十天 – Wrapping Rats</title>
      <link>https://ohmysummer.github.io/post/2017-12-10-%E7%AC%AC%E5%8D%81%E5%A4%A9wrapping-rats/</link>
      <pubDate>Sun, 10 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-10-%E7%AC%AC%E5%8D%81%E5%A4%A9wrapping-rats/</guid>
      <description>Day 10 – Wrapping Rats 沿着烟囱向下是一件危险的事情。
烟囱可能很窄，很高，有时候建造得不够好。
今年，圣诞老人想要做好准备。因此，他正在将烟囱检查与交付礼物结合起来。
烟囱检查涉及确保每层砖都处于正确的高度; 即砂浆层的高度是一致的，并且砖的高度也是一致的。
例如，对于 2¼” 高的砖和厚度为 ⅜” 的砂浆，测量序列应该如下所示：
 🎅 ─██─ || layer total ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░ 2¼ ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░ ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░ ⅜ ‾‾??? ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░ 2¼ ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░ ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░ ⅜ ‾‾5⅝ ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ 2¼ ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ⅜ ‾‾3 ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░ 2¼ ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░ ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░ ⅜ _____________________________________‾‾⅜  这个计划是让精灵们下降到烟囱的底部，手中拿着卷尺，然后回来，确保每个砖块的顶部恰好位于卷尺上的正确位置。</description>
    </item>
    
    <item>
      <title>第九天 – HTTP and Web Sockets with Cro</title>
      <link>https://ohmysummer.github.io/post/2017-12-09-%E7%AC%AC%E4%B9%9D%E5%A4%A9http-and-web-sockets-with-cro/</link>
      <pubDate>Sat, 09 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-09-%E7%AC%AC%E4%B9%9D%E5%A4%A9http-and-web-sockets-with-cro/</guid>
      <description>Day 9 – HTTP and Web Sockets with Cro 礼物不仅仅是圣诞节的时候才有。今年夏天，在瑞士 Perl 工作室 - 精美地坐落在阿尔卑斯山 - 我有幸透露了 Cro。 Cro 是一组用于在 Perl 6 中构建服务的库，以及一些用于 stub，run 和跟踪服务的开发工具。 Cro 主要关注使用 HTTP（包括HTTP/2.0）和 Web 套接字构建服务，但可以提供对 ZeroMQ 的早期支持，并计划在未来推出一系列其他选项。
响应式管道 Cro 遵循 Perl 的设计原则，使简单的事情变得简单，并且让困难的事情变得可能。就像 Git 一样，Cro 可以被认为是具有瓷器（使简单的事情变得简单）和管道（使困难的事情成为可能）。管道水平由组成管道的组件组成。这些组件具有不同的形状，例如源，传输和下沉。这是一个将 HTTP 请求转换为 HTTP 响应的转换：
use Cro; use Cro::HTTP::Request; use Cro::HTTP::Response; class MuskoxApp does Cro::Transform { method consumes() { Cro::HTTP::Request } method produces() { Cro::HTTP::Response } method transformer(Supply $pipeline --&amp;gt; Supply) { supply whenever $pipeline -&amp;gt; $request { given Cro::HTTP::Response.</description>
    </item>
    
    <item>
      <title>第八天 – Adventures in NQP Land: Hacking the Rakudo Compiler</title>
      <link>https://ohmysummer.github.io/post/2017-12-08-%E7%AC%AC%E5%85%AB%E5%A4%A9adventures-in-nqp-land-hacking-the-rakudo-compiler/</link>
      <pubDate>Fri, 08 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-08-%E7%AC%AC%E5%85%AB%E5%A4%A9adventures-in-nqp-land-hacking-the-rakudo-compiler/</guid>
      <description>Day 8 – Adventures in NQP Land: Hacking the Rakudo Compiler/ 对旧圣诞节经典“圣诞节十二天”的道歉，我给你一个 Perl 6 版本的第一行：
在圣诞节的第一天，我真正的爱给了 pod 树上的 Perl 表格&amp;hellip;&amp;hellip;
但是我得到的表格不是很漂亮！
背景 我与 Perl 6 的第一次真正联系是在 2015 年春天，当时我决定检查它的状态，发现它已经准备好迎接黄金时段。在获得了该语言的一些经验之后，我开始在我可以提供帮助的地方贡献文档。我对文档的第一个贡献是清理其中没有很好呈现的表格。在我对本地主机上的 pod 表进行实验期间，我尝试了下表格：
=begin table -r0c0 r0c1 =end table  这导致 Perl 6 抛出一个丑陋的, LTA（非常搓）的异常消息：
&amp;quot;===SORRY!=== Cannot iterate object with P6opaque representation&amp;quot;  我解决了这个问题，但它让我感觉不爽，所以我开始调查 pod 和 tables 的内部。这导致我在 github.com/rakudo/src/Perl6/Pod.nqp 中发现了问题的根源。
事实上，许多 pod 表格问题的真正问题最终都出现在该文件中。
Not Quite Perl (NQP) nqp 是用于构建 Rakudo Perl 6 编译器的中间语言。它的 git 仓库在这里。本文的其余部分是关于修改 rakudo 编译器中的 nqp 代码，其仓库地址在这里。 Rakudo 在这里也有一个网站。</description>
    </item>
    
    <item>
      <title>第七天 – Test All The Things</title>
      <link>https://ohmysummer.github.io/post/2017-12-07-%E7%AC%AC%E4%B8%83%E5%A4%A9test-all-the-things/</link>
      <pubDate>Thu, 07 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-07-%E7%AC%AC%E4%B8%83%E5%A4%A9test-all-the-things/</guid>
      <description>https://perl6advent.wordpress.com/2017/12/07/day-7-test-all-the-things/
Perl 6 与其大姐姐 Perl 5一样，具有很悠久的测试传统。当您安装任何 Perl 模块时，安装程​​序通常会运行该模块的测试套件。当然，作为新兴的 Perl 6 模块作者，您需要创建自己的测试套件。或者，也许你会在创建模块之前勇于创建测试套件。这实际上有几个好处，其中最主要的是你的第一个用户，甚至在它被写之前。
但在实际代码之前，我想提一下我经常使用的两个 shell 别名 -
alias 6=&#39;perl6 -Ilib&#39; alias 6p=&amp;quot;prove -e&#39;perl6 -Ilib&#39;&amp;quot;  这些别名使我可以快速运行测试文件，而不必去安装我的代码。如果我在项目目录中，我可以运行
$ 6 t/01-core.t ok 1 - call with number ok 2 - call with text ok 3 - call with formatted string 1..3  它会告诉我我运行了哪些测试以及它们是否全部通过。就像它的大姐姐Perl 5一样，Perl 6使用&amp;rsquo;t /&amp;lsquo;目录作为测试文件，并按照惯例使用后缀&amp;rsquo;.t&amp;rsquo;来区分测试文件和软件包或脚本。它还有一个内置的单元测试模块，我们在上面使用。如果我们正在测试sprintf（）内部，它可能看起来像
use Test; ok sprintf(1), &#39;call with number&#39;; ok sprintf(&amp;quot;text&amp;quot;), &#39;call with text&#39;; ok sprintf(&amp;quot;%d&amp;quot;,1), &#39;call with formatted string&#39;; done-testing;  ok和done-testing功能会自动导出给我们。我在这里使用规范的Perl 6风格，而不是太依赖括号。在这种情况下，我确实需要使用圆括号来确保sprintf（）不会“认为”“空调用”是它的参数。</description>
    </item>
    
    <item>
      <title>第六天-Perl 6 书评</title>
      <link>https://ohmysummer.github.io/post/2017-12-06-%E7%AC%AC%E5%85%AD%E5%A4%A9-perl-6-%E4%B9%A6%E8%AF%84/</link>
      <pubDate>Wed, 06 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-06-%E7%AC%AC%E5%85%AD%E5%A4%A9-perl-6-%E4%B9%A6%E8%AF%84/</guid>
      <description>https://perl6advent.wordpress.com/2017/12/06/</description>
    </item>
    
    <item>
      <title>第五天 - 使用 Perl 6 签名解构参数</title>
      <link>https://ohmysummer.github.io/post/2017-12-05-%E7%AC%AC%E4%BA%94%E5%A4%A9-%E4%BD%BF%E7%94%A8perl6%E7%AD%BE%E5%90%8D%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0/</link>
      <pubDate>Tue, 05 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-05-%E7%AC%AC%E4%BA%94%E5%A4%A9-%E4%BD%BF%E7%94%A8perl6%E7%AD%BE%E5%90%8D%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0/</guid>
      <description>第五天 - 使用 Perl 6 签名解构参数 在许多其他关键的 Perl 6 特性中，我认为 Signatures 是众多&amp;rdquo;杀手级&amp;rdquo;特性之一。 它们的功能如此丰富而强大，我怀疑关于如何使用它们可以写一整本书。 我想探索一下我原来忽略但是非常珍惜的一些特定功能。
您可能已经看到了基本的子程序签名：
sub myfunc($x, $y, $z) {...}  它给函数声明了 3 个标量参数, 并在函数体里面给了它们 $x, $y, $z 的名字。
太简单了。
你可以更有爱心, 给它们加上指定的类型:
sub myfunc(Str $x, Int $y, Rat $z) {...}  你可以使用笑脸符号 :D 让参数值是有定义的:
sub myfunc(Str:D $x, Int:D $y, Rat:D $z) {...}  还有很多其它花哨的说明符你可以使用，在这里我不深入了。
但是如果你的参数更复杂呢？ （不是 Complex - 虽然它也起作用..）
For example, you might want to restrict a specific parameter to a Positional argument like an Array, or an Associative one like a Hash using the respective sigils, @ or %.</description>
    </item>
    
    <item>
      <title>第四天-使用 Grammars 进行解析</title>
      <link>https://ohmysummer.github.io/post/2017-12-04-%E7%AC%AC%E5%9B%9B%E5%A4%A9-%E4%BD%BF%E7%94%A8grammars%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 04 Dec 2017 10:08:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-04-%E7%AC%AC%E5%9B%9B%E5%A4%A9-%E4%BD%BF%E7%94%A8grammars%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90/</guid>
      <description>第四天-使用 Grammars 进行解析 下面是从 Parsing with Perl 6 Regexes and Grammars: A Recursive Descent into Parsing 这本书里面提取出来的一章, 作者是 Moritz Lenz, 由 Apress Media 出版社出版。版权经过允许。
这本书马上就要出版了。至少该书的电子版这个月应该可以购买, 纸质版的可以在 亚马逊 预定了。原本最迟会在 2018 年元月发出, 但是幸运的是, 圣诞节你就可以看到了。
下面你会看到第九章, 使用 Grammars 进行解析。前面的章节详细探讨了创建正则表达式块儿、正则表达式怎么和 Perl 6 代码进行交互、匹配对象、正则力学、常用正则技术，还有重用和组合正则。你可以通过阅读正则表达式官方文档来获取更多关于正则的背景。
后面的章节涵盖了 action 类和对象, 怎么报告高质量的解析错误, Unicode 支持, 最后还有三个案例研究。
现在, 尽情享受吧！
Grammar 是众人皆知的用于解析的瑞士军刀。
在本章中，我们将更详细地探讨它们。 最重要的是，我们将讨论如何利用他们的威力。
理解 Grammars Grammars 实现了自顶向下的解析方法。 入口点，通常是 TOP regex 正则表达式，它知道粗粒度的结构，并调用下降到繁复细节的更深一步的正则表达式。 也会涉及到递归。 例如，如果解析算术表达式，则操作符可以是一对括号内的任意表达式。
这是一个自顶向下的结构，或者更确切地说是一个递归下降分析方法。 如果不涉及回溯，我们称之为*预测分析法*，因为在字符串中的每个位置，我们确切地知道我们在寻找什么 - 我们可以预测下一个 token 将会是什么（即使我们只能预测它可能是一组可选分支的其中之一）。
结果匹配树在结构上完全对应于 grammar 中正则表达式的调用结构。 让我们考虑解析一个只包含运算符 *，+和用于分组的括号的算术表达式：</description>
    </item>
    
    <item>
      <title>第三天 – LetterOps with Perl6</title>
      <link>https://ohmysummer.github.io/post/2017-12-03-%E7%AC%AC%E4%B8%89%E5%A4%A9letterops-with-perl6/</link>
      <pubDate>Sun, 03 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-03-%E7%AC%AC%E4%B8%89%E5%A4%A9letterops-with-perl6/</guid>
      <description>Day 3 – LetterOps with Perl6 规模 “规模！规模就是一切！“。
当圣诞老人的声音传到他们身上时，精灵散落在四面八方。
“这个 operation 是为三十四个孩子准备的？现在我们有无数的！大人也送信！“
小精灵 Buzzius 站了出来，喷出“但现在我们有电脑！”，又回到他精灵的追求。
“他们有什么好处？请告诉我，如果我仍然需要阅读每一封信，我该怎么办？“。
小精灵 Diodius 短暂地从藏身处抬起头，说：“告诉孩子们发一封文字信”。
圣诞老人停止了叫喊，并抓住了他有胡子的下巴。 “我可以做到这一点”。早期的儿童采用者就像这样发了一封信。
Dear Santa: I have been a good boy so I want you to bring me a collection of scythes and an ocean liner with a captain and a purser and a time travel machine and instructions to operate it and I know I haven&#39;t been so good at times but that is why I&#39;m asking the time machine so that I can make it good and well and also find out what happened on July 13th which I completely forgot.</description>
    </item>
    
    <item>
      <title>第二天-Perl 6: 符号, 变量和容器</title>
      <link>https://ohmysummer.github.io/post/2017-12-02-%E7%AC%AC%E4%BA%8C%E5%A4%A9-perl6%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sat, 02 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-02-%E7%AC%AC%E4%BA%8C%E5%A4%A9-perl6%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%B9%E5%99%A8/</guid>
      <description>第二天-Perl 6: 符号, 变量和容器 对容器的基本理解对于在 Perl 6 中进行愉快的编程是至关重要的。它们无处不在，不仅影响你获得的变量类型，还决定了 List 和 Map 在迭代时的行为方式。
今天，我们将学习什么是容器，以及如何使用它们，但是首先，我希望你暂时忘记你对 Perl 6 的符号和变量的所有知识或怀疑，特别是如果你来自 Perl 5 的背景。 忘记一切。
把钱拿出来 在 Perl 6 中，变量以 $ 符号为前缀，用绑定运算符（:=）赋值。 像这样：
my $foo := 42; say &amp;quot;The value is $foo&amp;quot;; # OUTPUT: «The value is 42␤»  如果你已经按照我的建议来忘记你所知道的一切，那么学习 List 和 Hash 类型也是一样：
my $ordered-things := &amp;lt;foo bar ber&amp;gt;; my $named-things := %(:42foo, :bar&amp;lt;ber&amp;gt;); say &amp;quot;$named-things&amp;lt;foo&amp;gt; bottles of $ordered-things[2] on the wall&amp;quot;; # OUTPUT: «42 bottles of ber on the wall␤» .</description>
    </item>
    
    <item>
      <title>第一天 – Perl 6 鬼精灵: 圣诞节实用指南</title>
      <link>https://ohmysummer.github.io/post/2017-12-01-%E7%AC%AC%E4%B8%80%E5%A4%A9-perl6%E9%AC%BC%E7%B2%BE%E7%81%B5-%E5%9C%A3%E8%AF%9E%E8%8A%82%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 01 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-01-%E7%AC%AC%E4%B8%80%E5%A4%A9-perl6%E9%AC%BC%E7%B2%BE%E7%81%B5-%E5%9C%A3%E8%AF%9E%E8%8A%82%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>第一天 – Perl 6 鬼精灵: 圣诞节实用指南 看看他们！同事、朋友和亲近的家人都在开心地笑着。他们都在享受着使用 Perl 6 的 6.c “圣诞”版编程的乐趣。给力的并发原语, 核心文法, 还有非常棒的对象模型。它让我印象深刻！
但是等一下&amp;hellip; 就一秒。我有个想法。一个可怕的想法。我想到了一个鬼主意! 我们可以在他们的&amp;rdquo;圣诞&amp;rdquo;上捣乱。需要的只有一点花招。哈哈哈哈哈哈！！
欢迎来到 2017 年的 Perl 6 圣诞日历！每天，从今天直到圣诞节，我们都会有一篇很赞的关于 Perl6 的博客推送到你面前。
今天，我们会展示我们淘气的一面并且故意地做些淘气的事情。确实，这有点用，但是淘气点更快乐。我们开始吧！
But True does False 你听过 but 操作符吗？一个好玩的东西：
say True but False ?? &#39;Tis true&#39; !! &#39;Tis false&#39;; # OUTPUT: «Tis false␤» my $n = 42 but &#39;forty two&#39;; say $n; # OUTPUT: «forty two␤» say $n + 7; # OUTPUT: «49␤»  它是一个中缀操作符，它首先拷贝它左边的对象，然后把它右边提供的 role 混进这个拷贝中：</description>
    </item>
    
    <item>
      <title>根据select结果生成insert语句</title>
      <link>https://ohmysummer.github.io/post/2017-09-16-%E6%A0%B9%E6%8D%AEselect%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90insert%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sat, 16 Sep 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-09-16-%E6%A0%B9%E6%8D%AEselect%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90insert%E8%AF%AD%E5%8F%A5/</guid>
      <description>想根据 MySQL select 语句的结果生成 insert 语句。
use v6; for $=finish.lines -&amp;gt; $line { next if $++ &amp;lt; 3 || $line ~~ / &#39;-&#39; /; say &#39;insert into convert_path (id, path_name, events, app_key, create_at, update_at) values (&#39; ~ ($line.split: /&amp;lt;[\s+ |]&amp;gt;/, :skip-empty)&amp;gt;&amp;gt;.&amp;amp;quote.join(&amp;quot;,&amp;quot;) ~ &amp;quot;);&amp;quot;; } sub quote(Str $ele) { return &#39;&amp;quot;&#39; ~ $ele ~ &#39;&amp;quot;&#39;; } =finish +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+ | id | path_name | events | app_key | create_at | update_at | +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+ | 308 | 新增打听流程1 | 新增打听,提交打听 | 10c29cf8bd6e61f9ae4a0212eed803c8 | 1505098067 | 1505098067 | | 309 | 用户购买流程 | 浏览商品,加入购物车,结算购物车中的商品,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505283224 | 1505283224 | | 311 | 用户购买流程2 | 浏览商品,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505284039 | 1505284039 | | 312 | 朗读模板付费转化流程 | 访问朗读首页,访问朗读模板,输入或导入文本,开始朗读,进入下载支付页,微信支付 | 54117664fad164a634c57571ba7c5aa7 | 1505284047 | 1505284047 | | 313 | 用户购买流程3 | 浏览商品,填写配送地址,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505284110 | 1505284110 | | 315 | 用户购买流程4 | 浏览商品,填写配送地址,完成配送地址,点击立即购买,付款,付款完成 | c10606f35c85bac58625c95006fba769 | 1505284303 | 1505284303 | | 316 | 新建朗读付费转化流程 | 访问朗读首页,访问新建朗读,输入或导入文本,开始朗读,进入下载支付页,微信支付 | 54117664fad164a634c57571ba7c5aa7 | 1505284351 | 1505284351 | | 321 | goodsDetail | onLoad,onShow | c10606f35c85bac58625c95006fba769 | 1505451421 | 1505451421 | +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+  最后生成的结果如下：</description>
    </item>
    
    <item>
      <title>开启 Disqus 评论</title>
      <link>https://ohmysummer.github.io/post/2017-09-15-%E5%BC%80%E5%90%AFdisqus%E8%AF%84%E8%AE%BA/</link>
      <pubDate>Fri, 15 Sep 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-09-15-%E5%BC%80%E5%90%AFdisqus%E8%AF%84%E8%AE%BA/</guid>
      <description>要开启 Disqus 评论, 需要先在 Disqus 官网注册账号, 获得 disqusShortname。
#use Grammar::Tracer; #use Grammar::Debugger; my $scene = q:to/END/; ★ 二维码 1011 扫描二维码 1047 扫描小程序码 1012 长按图片识别二维码 1013 手机相册选取二维码 1031 长按图片识别一维码 1032 手机相册选取一维码 1048 长按图片识别小程序码 1049 手机相册选取小程序码 1025 扫描一维码 1072 二维码收款页面 ★ 搜索 1005 顶部搜索框的搜索结果页 1006 发现栏小程序主入口搜索框的搜索结果页 1042 添加好友搜索框的搜索结果页 1053 搜一搜的结果页 1027 顶部搜索框搜索结果页“使用过的小程序”列表 ★ 公众号 1043 公众号模板消息 1020 公众号 profile 页相关小程序列表 1035 公众号自定义菜单 1058 公众号文章 1074 公众号会话下发的小程序消息卡片 ★ 分享 1036 App 分享消息卡片 1007 单人聊天会话中的小程序消息卡片 1008 群聊会话中的小程序消息卡片 1044 带 shareTicket 的小程序消息卡片 ★ 模板消息 1014 小程序模版消息 1034 微信支付完成页 ★ 测试 1059 体验版小程序绑定邀请页 1017 前往体验版的入口页 ★ 卡券 1028 我的卡包 1029 卡券详情页 1052 卡券的适用门店列表 ★ 小程序之间跳转 1037 小程序打开小程序 1038 从另一个小程序返回 ★ 快捷入口 1001 发现栏小程序主入口 1022 聊天顶部置顶小程序入口 1023 安卓系统桌面图标 1024 小程序 profile 页 ★ 广告投放 1068 附近小程序列表广告 1067 公众号文章广告 ★ 其他 1039 摇电视 1056 音乐播放器菜单 1019 微信钱包 1026 附近小程序列表 1064 微信连Wifi状态栏 1073 客服消息列表下发的小程序消息卡片 END grammar Scene { token TOP { ^ &amp;lt;entry&amp;gt;+ $ } # 一个或多个块 token entry { &amp;lt;head&amp;gt; \s* # 每个块都有一个标题 &amp;lt;line&amp;gt;+ \s* # 每个标题下面有很多非标题行 } token head { &#39;★&#39; \s+ &amp;lt;title&amp;gt; } token line { [ &amp;lt;!</description>
    </item>
    
    <item>
      <title>Seq 和摇滚</title>
      <link>https://ohmysummer.github.io/post/2017-07-31-seq%E5%92%8C%E6%91%87%E6%BB%9A/</link>
      <pubDate>Mon, 31 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-07-31-seq%E5%92%8C%E6%91%87%E6%BB%9A/</guid>
      <description>这是这个系列的第二部分！请确保你已经阅读过第一部分, 在那里我们讨论了什么是 Seq, 并且怎么来缓存它们。
今天, 我们把 Seq 单独拎出来, 看看里面到底有什么; 是什么驱动的它; 并且怎样让它实现我们的想法。
第二部分: 快速迭代 使 Seq 做事情的主要部分是遵循 Iterator 角色的对象。 这个对象知道如何生成下一个值，什么时候从 Seq 中提取一个值，或者将其所有值推送到某个地方，或者简单地丢弃所有剩余的值。
请记住，当使用 Seq 作为值的来源时，您不需要直接使用 Iterator 的方法。 它们被间接称为各种 Perl 6 结构。 自己调用这些方法的场景通常是我们制作一个由另一个 Iterator 提供的迭代器的时候，就像我们会看到的那样。
Pull my finger 在最基本的形式中, 一个 Iterator 对象需要提供的只有一个方法: .pull-one
my $seq := Seq.new: class :: does Iterator { method pull-one { return $++ if $++ &amp;lt; 4; IterationEnd } }.new; .say for $seq;  输出:
# OUTPUT: # 0 # 1 # 2 # 3  上面的例子中, 我们使用 Seq 的 .</description>
    </item>
    
    <item>
      <title>Perl 6 Sheet</title>
      <link>https://ohmysummer.github.io/post/2017-05-19-sheet/</link>
      <pubDate>Fri, 19 May 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-05-19-sheet/</guid>
      <description>正则表达式 Perl 6 的正则表达式允许你为你自定义的字符类混进 Unicode 属性！
constant string = &#39;The Quick 🐼 Jumped Over 57 Dogs&#39;; say string ~~ m:g/ &amp;lt;:upper-[TQ]&amp;gt; /; # (「J」 「O」 「P」) say string ~~ m:g/ &amp;lt;-[\x0..\x255]+[\x35..\x37]&amp;gt; /; # (「🐼」 「5」 「7」) say string ~~ m:g/ &amp;lt;-:digit -:Ll -:Zs&amp;gt; /; # (「T」 「Q」 「🐼」 「J」 「O」 「D」) say string ~~ m:g/ &amp;lt;[\w]-[TQJ\d]-:lower+[5]&amp;gt; /; # (「O」 「5」 「D」)  Wow! #Perl6 #Regex is so awesome, you can just shove an array into it and it&amp;rsquo;ll know to treat it as alternatives to match!</description>
    </item>
    
    <item>
      <title>Perl 6 Dispatch 解密</title>
      <link>https://ohmysummer.github.io/post/2017-04-02-dispath%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Sun, 02 Apr 2017 14:24:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-04-02-dispath%E8%A7%A3%E5%AF%86/</guid>
      <description>Perl 6 的一个很好的特性是 multi-dispatch, 即多重分派。它允许你在函数, 方法或 Grammar token 中使用相同的名字并让它们所处理的数据的类型来决定执行哪一个。下面是一个 factorial postfix 操作符, 用两个 multies 来实现:
multi postfix:&amp;lt;!&amp;gt; (0) { 1 } multi postfix:&amp;lt;!&amp;gt; (UInt \n) { n × samewith n − 1 } say 5! # OUTPUT: 120  虽然 multi-dispatch 的主题很明显并且它还有一些说明文档, 我今天想讲的是 7 个特殊的子例程, 让你能够行走在 dispatch 迷宫中。它们是 nextwith, nextsame, samewith, callwith, callsame, nextcallee 和 lastcall.
设立实验室 Multies 从最窄到最广的候选者进行排序，并且当一个 multi 被调用时，绑定器尝试找到一个匹配并调用第一个匹配的候选者。 有时，您可能希望调用或简单地移动到链中的下一个匹配候选者，可选地使用不同的参数。 为了观察这些操作的效果，我们将使用以下设置：
class Wide { } class Middle is Wide { } class Narrow is Middle { } multi foo (Narrow $v) { say &#39;Narrow &#39;, $v; &#39;from Narrow&#39; } multi foo (Middle $v) { say &#39;Middle &#39;, $v; &#39;from Middle&#39; } multi foo (Wide $v) { say &#39;Wide &#39;, $v; &#39;from Wide&#39; } foo Narrow; # OUTPUT: Narrow (Narrow) foo Middle; # OUTPUT: Middle (Middle) foo Wide; # OUTPUT: Wide (Wide)  我们有三个类，每个类都继承自前一个类，所以我们的 Narrow 类 可以适应 Middle 和 Wide multi 候选者; Middle 也可以适应 Wide，但不能适应 Narrow; 而 Narrow 既不适用于 Middle，也不适用于 Narrow。请记住，Perl 6 中的所有类也都是 Any 类型，因此也适用于任何接受 Any 的候选者。</description>
    </item>
    
    <item>
      <title>Regexes</title>
      <link>https://ohmysummer.github.io/post/2017-03-18-regexes/</link>
      <pubDate>Sat, 18 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-18-regexes/</guid>
      <description>正则表达式, 简称 regexes, 是描述文本模式的字符序列。模式匹配就是将这些模式和实际的文本进行匹配的过程。
词法约定 Perl 6 正则表达式有特殊的写法:
m/abc/; # a regex that is immediately matched against $_ rx/abc/; # a Regex object /abc/; # a Regex object  对于前两个例子, 分隔符还能用除了斜线之外的其它字符:
m{abc}; rx{abc};  注意, 冒号和圆括号都不能用作分隔符; 禁止使用冒号作为正则表达式分割符是因为它和副词冲突, 例如 rx:i/abc/(忽略大小写的正则表达式), 而圆括号表明函数调用。
空白符在正则表达式中通常被忽略(带有 :s 或 :sigspace 副词的正则表达式除外)。
通常, 对于 Perl 6 来说, 正则表达式中的注释以 # 号开头, 直至行尾。
字面值 正则表达式最简单的情况是匹配字符串字面值。
if &#39;properly&#39; ~~ m/ perl / { say &amp;quot;&#39;properly&#39; contains &#39;perl&#39;&amp;quot;; }  字母数字和下划线 _ 按字面值匹配。所有其它字符要么使用反斜线转义(例如, \: 匹配一个冒号), 要么用引号引起来:</description>
    </item>
    
    <item>
      <title>Perl 6 中的笑脸</title>
      <link>https://ohmysummer.github.io/post/2017-03-11-perl6%E4%B8%AD%E7%9A%84%E7%AC%91%E8%84%B8/</link>
      <pubDate>Sat, 11 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-11-perl6%E4%B8%AD%E7%9A%84%E7%AC%91%E8%84%B8/</guid>
      <description>在 Perl 6 中在调用者的类型身上使用 :D 或 :U 类型笑脸来制造 type/instance 方法:
class Foo { multi method foo (Foo:D:) { say &amp;quot;instance&amp;quot; } multi method foo (Foo:U:) { say &amp;quot;type object&amp;quot; } } Foo .foo; # 输出 type object Foo.new.foo; # 输出 instance # Can use compile time vars to aovid re-typing the actual name everywhere: class Bar { multi method foo (::?CLASS:D:) { say &amp;quot;instance&amp;quot; } multi method foo (::?CLASS:U:) { say &amp;quot;type object&amp;quot; } } Bar .</description>
    </item>
    
    <item>
      <title>Perl 6 Gramamr 指南</title>
      <link>https://ohmysummer.github.io/post/2017-03-05-perl-6-grammar-%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sun, 05 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-05-perl-6-grammar-%E6%8C%87%E5%8D%97/</guid>
      <description>开始之前 为什么是 grammars? Grammars 解析字符串并从这些字符串返回数据结构。Grammars 可用于编写执行程序以确定程序是否可以运行（如果它是一个有效的程序），将网页分解成组成部分，或在其它的东西中识别句子的不同部分。
我什么时候该使用 grammars? 如果你有驯服或解释的字符串，grammar 提供工具来完成这项工作。
该字符串可能是一个文件, 您想把它拆分成多个章节; 也许是一个协议，比如 SMTP，你需要指定哪些“命令”来自用户提供的数据;也许你正在设计自己的领域特定语言。Grammars 可以提供帮助。
grammars 的广义概念 正则表达式（Regexes）适用于查找字符串中的模式。然而，对于一些任务来说，如同时查找多个模式，或者组合模式，或者单独测试可能围绕字符串正则表达式的模式是不够的。
在使用 HTML 时，您可以定义一个 grammar 来识别 HTML 标记，包括开始和结束元素以及它们之间的文本。然后，您可以将这些元素组织到数据结构中，例如数组或散列。
Grammar 指南 你总是会遇到令人头疼的字符串解析。举个例子, 据说 HTML 不能被有效地分解和解析，只需使用正则表达式来排序元素。另一个例子是定义单词和符号可能构成语言并提供含义的顺序。这正 和 Perl 的 Gramamr 系统完美契合。
Grammar 非常适合接受字符串，试图理解它们，然后将它们保存到一个你实际可以使用的数据结构中。如果你有某种带顺序或解释类型的字符串，Grammar 给你一些很强大的工具，使解析字符串更容易。
你的字符串可能是整个文件，你需要分成几个部分。也或许是一行一行的。也许你有一个正在使用的 SMTP 那样的协议，想要一个方便有条理的方式来定义哪些“命令”需要在用户数据的后面，使协议工作。也许你想创建自己的基于字符串的协议。也许你正在设计自己的语言。
正则表达式（regex）很好地在字符串中查找模式并操作它们。然而，当你需要同时找到多个模式，或者需要组合模式，或者测试可能围绕字符串的模式或其他模式 - 单单用正则表达式是不够的。
Grammar 提供了一种方式来定义如何使用正则表达式来检查字符串，并且可以将这些正则表达式组合在一起以提供更多的意义。
例如，在HTML的情况下，您可以定义一个语法，它可以识别HTML标记（开始和结束元素以及它们之间的文本），并通过将这些元素填充到数据结构中来对这些元素进行操作，例如数组或散列，然后可以轻松使用。实质上，Grammar 提供了一种定义可用于解析任意大小和复杂度的字符串的完整语言或规范的手段。
更多 Grammar 技术 概念描述 Gramamr 被定义为对象, 就像 Perl 中的其它东西。从技术上讲, Gramamr 是普通的类加上一点额外的魔法, 我们稍后就说到它 &amp;ndash; 还有一点限制。你像类那样命名和定义一个 Grammar, 除了使用「grammar」关键字代替「class」。
grammar My::Gram { ..methods &#39;n stuff.</description>
    </item>
    
    <item>
      <title>通过模块学习 Grammar</title>
      <link>https://ohmysummer.github.io/post/2017-03-05-%E4%BD%BF%E7%94%A8grammar%E7%9A%84%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 05 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-05-%E4%BD%BF%E7%94%A8grammar%E7%9A%84%E6%A8%A1%E5%9D%97/</guid>
      <description>学习 Perl 6 Grammar 的一个很好的地方是 GitHub 上的模块仓库, 里面有不少模块使用了 Grammar 来编写。下面我们列举出哪些模块值得我们学习。
 Perl 6 STD 使用 Grammar 解析 YAML 使用 Grammar 解析 TAP 测试文件 使用 Grammar 解析 CSS 解析和操纵 CSS 解析 CSS 属性定义 使用 Perl 6 Gramamr 解析 fortran 源代码 用 Perl 6 写的 Grammar 引擎 解析 BNF 和 ABNF grammars 并从中生成 Perl 6 grammars Perl 6 Gramamr 调试 使用 Perl 6 Grammars 解析 HTTP 头, 消息体, 和 URIs Perl 6 PDF Grammars 解析 URI 解析 ini 文件 解析 .</description>
    </item>
    
    <item>
      <title>4 种风格的模板引擎</title>
      <link>https://ohmysummer.github.io/post/2017-03-04-4%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</link>
      <pubDate>Sat, 04 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-04-4%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</guid>
      <description>4 种风格的模板引擎. 带基准测试！ 这一次在博客上，我将告诉你如何编写自己的模板引擎 - 根据需要为你量身定制语法和行为。 我们将以四种不同的方式来分析每种方法的优缺点，以及代码速度和复杂性。 我们今天的示例任务是为用户撰写密码提醒文本，然后可以通过电子邮件发送。
use v6; my $template = q{ Hi [VARIABLE person]! You can change your password by visiting [VARIABLE link] . Best regards. }; my %fields = ( &#39;person&#39; =&amp;gt; &#39;John&#39;, &#39;link&#39; =&amp;gt; &#39;http://example.com&#39; );  所以由我们决定我们的模板语法应该是什么样子的，对于初学者，我们会有一些小的变量（虽然这不是很精确的名称，因为模板中的变量几乎总是不变的）。 我们还有用于填充模板字段的数据。 让我们开始吧！
Substitutions sub substitutions ( $template is copy, %fields ) { for %fields.kv -&amp;gt; $key, $value { $template ~~ s:g/&#39;[VARIABLE &#39; $key &#39;]&#39;/$value/; } return $template; } say substitutions($template, %fields);  输出:</description>
    </item>
    
    <item>
      <title>Perl 6 中的 *, $_ 和 $</title>
      <link>https://ohmysummer.github.io/post/2017-02-04-whatever-star-vs.-_-vs-/</link>
      <pubDate>Sat, 04 Feb 2017 22:55:48 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-02-04-whatever-star-vs.-_-vs-/</guid>
      <description>cale2 问了一个很难的问题 今天卡尔2拒绝问简单的问题。我们来看它今天问了什么难题：
  我需要一份关于 * vs $_ vs $ 的指南。
 这个问题问得多么好。那三种东西都是语法糖, 因为上下文转换, 它们能很好地避免折行和更少的 bugs。
我们从我们的老朋友主题变量 $_ 开始。在 Perl 5 中它刚好出现在每个 sub 的外面。在 Perl 6 中它出现在块的默认值之外。
my &amp;amp;block = { &#39;oi?&#39; }; &amp;amp;block.signature.say; # OUTPUT?(;; $_? is raw)??  块的默认签名是一个名为 $_ 的位置参数。因此每个块都有一个主题变量 $_。还有其他设置 $_ 主题变量的语句，而不引入一个新的块，像 with 和 given （given 的确引入了一个块，但它是特殊的，我在这里不说明细节）。
say $_ with 42; # OUTPUT ?42??  因为它是默认的, Perl 6 会在很多地方期待它的出现。最突出的是当没有对象方法调用时。
$_ = 42; say &#39;oi?&#39; when 42; .</description>
    </item>
    
    <item>
      <title>2017 StackOverFlow-sort,deepmap,flat</title>
      <link>https://ohmysummer.github.io/post/2017-01-02-stackoverflow/</link>
      <pubDate>Mon, 02 Jan 2017 22:56:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-01-02-stackoverflow/</guid>
      <description>perl6 What is the best way to match any of a group of words?  我想匹配任意一组单词，但是失败了，请问怎样才能正确地匹配到？
my @a=&amp;lt;a b c d e f&amp;gt;; my $x=&amp;quot;a1234567&amp;quot;; say $x ~~ m/ @a.any /;  Answer
my @a = &amp;lt;a b c d e f&amp;gt;; my $x = &amp;quot;a1234567&amp;quot;; say $x ~~ /@a/  /@a/ 和 /| @a/ 相同，它是最长的备选分支。对于备选分支，你可以使用 /|| @a/。
 How to build lazy lists with defined generators and is there a “takeWhile” alternative?</description>
    </item>
    
    <item>
      <title>Perl 6 Rakudo 和 NQP 内部研讨(一)</title>
      <link>https://ohmysummer.github.io/post/2017-01-01-perl-6-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/</link>
      <pubDate>Sun, 01 Jan 2017 23:01:01 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-01-01-perl-6-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/</guid>
      <description>标题: Rakudo and NQP Internals 子标题: The guts tormented implementers made 作者: Jonathan Worthington
关于这个课程 Perl 6 是一种大型语言, 包含许多要求正确实现的功能。
这样的软件项目很容易被难以控制的复杂性淹没。 Rakudo 和 NQP 项目的早期阶段已经遭受了这样的困难, 因为我们学到了 - 艰难的方式 - 关于复杂性, 出现并可能在实现过程中不受限制地扩散。
本课程将教您如何使用 Rakudo 和 NQP 内部。 在他们的设计中编码是一个大量学习的过程, 关于如何(以及如何不)写一个 Perl 6 实现, 这个过程持续了多年。 因此, 本课程还将教你事情的来龙去脉。
关于讲师  计算机科学背景 选择旅行世界,并帮助实现 Perl 6, 而不是做博士 有不止一种方法来获得&amp;rdquo;永久头部损伤&amp;rdquo; :-) 不知何故在 Edument AB 被聘用, 作为讲师/顾问 从 2008 年开始成为 Rakudo Perl 6 核心开发者 6model, MoarVM, NQP 和 Rakudo 各个方面的缔造者  课程大纲 - 第一天  鹰的视角: 编译器和 NQP/Rakudo 架构 NQP 语言 编译管道 QAST 探索 nqp::ops  课程大纲 - 第二天  6model 有界序列化和模块加载 正则表达式和 grammar 引擎 JVM 后端 MoarVM 后端  鹰的视角 编译器和 NQP/Rakudo 架构</description>
    </item>
    
    <item>
      <title>Perl 6 Tips - 创建可重用的数据类型</title>
      <link>https://ohmysummer.github.io/post/2016-12-31-perl-6-tips-%E5%88%9B%E5%BB%BA%E5%8F%AF%E9%87%8D%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 31 Dec 2016 23:14:12 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-31-perl-6-tips-%E5%88%9B%E5%BB%BA%E5%8F%AF%E9%87%8D%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Quick Tip #19: 创建可重用的数据类型 Perl 6 允许你使用类型来约束变量值，但是你不必拘泥于内置类型。一旦你定义了自己的类型，它们就表现得像内置类型一样。
下面是我从布拉德的 Subsets::Common模块偷得的一些子集(subsets):
my package EXPORT::DEFAULT { ... subset Pos of Numeric where * &amp;gt; 0; subset Neg of Numeric where * &amp;lt; 0; subset Zero of Numeric where * == 0; subset UNumeric of Numeric where * &amp;gt;= 0; subset Even of Int where * % 2 == 0; subset Odd of Int where * % 2; subset Time::Hour12 of PosInt where * ~~ 1 .</description>
    </item>
    
    <item>
      <title>Perl 6 时间戳转换器命令行版</title>
      <link>https://ohmysummer.github.io/post/2016-12-31-perl-6-%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88/</link>
      <pubDate>Sat, 31 Dec 2016 23:14:12 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-31-perl-6-%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88/</guid>
      <description>Perl 6 By Example: Datetime Conversion for the Command Line 我偶尔会在数据库中存储 UNIX 时间戳, 即从 1970-01-01 开始的秒数。我在按照日期查询数据库中的数据时, 需要将 UNIX 时间戳转换为人类可读的时间, 所以我写了个很小的工具来帮助我在 UNIX 时间戳和日期/时间之间来回转换:
$ autotime 2015-12-24 1450915200 $ autotime 2015-12-24 11:23:00 1450956180 $ autotime 1450915200 2015-12-24 $ autotime 1450956180 2015-12-24 11:23:00  使用库 Perl 6 的 DateTime 和 Date 模块会做实际的转换。 DateTime.new 构造函数有一个接收单个整数作为 UNIX 时间戳的变体:
$ perl6 -e &amp;quot;say DateTime.new(1480915200)&amp;quot; 2016-12-05T05:20:00Z  看起来我们已经完成了一个方向的转换,对吗?
#!/usr/bin/env perl6 sub MAIN (Int $timestamp) { say DateTime.</description>
    </item>
    
    <item>
      <title>2016 年末总结</title>
      <link>https://ohmysummer.github.io/post/2016-12-31-2016-%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 31 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-31-2016-%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/</guid>
      <description> 不想总结。 总结个大西瓜。 有什么好总结的。 说多了都是泪。 还是不要总结了。  </description>
    </item>
    
    <item>
      <title>Perl 6 Tips - 排列组合</title>
      <link>https://ohmysummer.github.io/post/2016-12-30-perl-6-tips-%E6%8E%A2%E7%B4%A2%E7%BB%84%E5%90%88/</link>
      <pubDate>Fri, 30 Dec 2016 23:14:12 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-30-perl-6-tips-%E6%8E%A2%E7%B4%A2%E7%BB%84%E5%90%88/</guid>
      <description>Quick Tip #16: 探索组合
xx 是列表重复操作符, 用于将一个列表重复指定的次数。xx 不会展平列表中的元素。
$ perl6 &amp;gt; my @n = &amp;lt;1 2 3&amp;gt;; [1 2 3] &amp;gt; my $n = 4; 4 &amp;gt; my @c = @n xx $n  输出：
[[1 2 3] [1 2 3] [1 2 3] [1 2 3]]  现在我想要长度为 $n 的一堆列表的所有排列（combinations）:
&amp;gt; ( [X] ( @n xx $n ) ) ((1 1 1 1) (1 1 1 2) (1 1 1 3) (1 1 2 1) (1 1 2 2) (1 1 2 3) (1 1 3 1) (1 1 3 2) (1 1 3 3) (1 2 1 1) (1 2 1 2) (1 2 1 3) (1 2 2 1) (1 2 2 2) (1 2 2 3) (1 2 3 1) (1 2 3 2) (1 2 3 3) (1 3 1 1) (1 3 1 2) (1 3 1 3) (1 3 2 1) (1 3 2 2) (1 3 2 3) (1 3 3 1) (1 3 3 2) (1 3 3 3) (2 1 1 1) (2 1 1 2) (2 1 1 3) (2 1 2 1) (2 1 2 2) (2 1 2 3) (2 1 3 1) (2 1 3 2) (2 1 3 3) (2 2 1 1) (2 2 1 2) (2 2 1 3) (2 2 2 1) (2 2 2 2) (2 2 2 3) (2 2 3 1) (2 2 3 2) (2 2 3 3) (2 3 1 1) (2 3 1 2) (2 3 1 3) (2 3 2 1) (2 3 2 2) (2 3 2 3) (2 3 3 1) (2 3 3 2) (2 3 3 3) (3 1 1 1) (3 1 1 2) (3 1 1 3) (3 1 2 1) (3 1 2 2) (3 1 2 3) (3 1 3 1) (3 1 3 2) (3 1 3 3) (3 2 1 1) (3 2 1 2) (3 2 1 3) (3 2 2 1) (3 2 2 2) (3 2 2 3) (3 2 3 1) (3 2 3 2) (3 2 3 3) (3 3 1 1) (3 3 1 2) (3 3 1 3) (3 3 2 1) (3 3 2 2) (3 3 2 3) (3 3 3 1) (3 3 3 2) (3 3 3 3))  注意，排列是不一样的，它更简单，因为有一个方法来生成排列：</description>
    </item>
    
    <item>
      <title>Perl 6 中的 Setty 和 Baggy 类型</title>
      <link>https://ohmysummer.github.io/post/2016-12-11-perl-6-%E7%9A%84-setty-%E5%92%8C-baggy-%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 11 Dec 2016 23:50:12 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-11-perl-6-%E7%9A%84-setty-%E5%92%8C-baggy-%E7%B1%BB%E5%9E%8B/</guid>
      <description>有一个很常见的计数场景。比如说计算 DNA 中各个碱基的个数:
my %counts; %counts{$_}++ for &#39;AGTCAGTCAGTCTTTCCCAAAAT&#39;.comb; say %counts&amp;lt;A T G C&amp;gt;; # (7 7 3 6)  创建一个哈希。对于每一个你想计数的东西, 每遇到一次就在那个哈希中加 1。所以有什么问题？
Perl 6 通常有特定的更合适的类型来做这种操作; 例如,Bag 类型：
&#39;AGTCAGTCAGTCTTTCCCAAAAT&#39;.comb.Bag&amp;lt;A T G C&amp;gt;.say; # (7 7 3 6)  我们来说说这些类型还有那些时髦的运算符！
注意 Unicode 我将在这篇文章中使用花哨的 Unicode 版本的运算符和符号,因为它们看起来很纯。 然而, 他们都有我们称之为Texas的等同物, 你可以改用它们。
准备. Set. 走起 这些类型中最简单的就是 Set。 它将仅保存每个项目之一, 因此如果您有多个相同的对象, 那么重复项将被丢弃:
say set 1, 2, 2, &amp;quot;foo&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;; # OUTPUT: set(a, foo, b, 1, 2)  集合运算符是强制的, 因此我们不需要显式地创建集合; 他们会为我们做：</description>
    </item>
    
    <item>
      <title>Perl 6 Grammar 之分割结构化文本</title>
      <link>https://ohmysummer.github.io/post/2016-11-01-perl6-grammar%E4%B9%8B%E5%88%86%E5%89%B2%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%87%E6%9C%AC/</link>
      <pubDate>Tue, 01 Nov 2016 02:05:48 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-11-01-perl6-grammar%E4%B9%8B%E5%88%86%E5%89%B2%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%87%E6%9C%AC/</guid>
      <description>如何使用 Grammar 分割一个有规律的文本文件? 首先这个文本有规律, 但是却是多行的。 我想将这样的文档分为独立的. 比如下面这个例子, 我想将他们分成3个独立的文本, 每个文本包含: [时间] Title 以及下面的 content lines. 实际的文件会有上千个, 最终输出的文本的名字是按照括号里面的时间来。
sample.txt
[28/04/2015 12:32] Title1 content line 1 content line 2 content line 3 content line 4 content line 5 balabala balabala [28/04/2015 12:16] Title2 content line 6 balabala content line 7 [27/04/2015 17:30] ​Title3 content line 8 content line 9 content line 10  下面是解析：
use Grammar::Tracer; # 开启 Grammar 调试有助于排错 grammar StructedText { token TOP { ^ &amp;lt;entry&amp;gt;+ $ } token entry { &amp;lt;head&amp;gt; \s* # 每一项有一个标题 &amp;lt;line&amp;gt;+ \s* # 每个标题下面有很多行 } token head { &#39;[&#39; &amp;lt;datetime&amp;gt; &#39;]&#39; \s+ &amp;lt;title&amp;gt; } token datetime { &amp;lt;filedate&amp;gt; \s+ &amp;lt;filetime&amp;gt; } token filedate { [\d+]+ % &#39;/&#39; } token filetime { [\d+]+ % &#39;:&#39; } token title { \N+ } token line { [ &amp;lt;!</description>
    </item>
    
    <item>
      <title>Perl 6 中的包</title>
      <link>https://ohmysummer.github.io/post/2016-10-28-perl6%E4%B8%AD%E7%9A%84%E5%8C%85/</link>
      <pubDate>Fri, 28 Oct 2016 23:17:11 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-28-perl6%E4%B8%AD%E7%9A%84%E5%8C%85/</guid>
      <description>Packages - Organizing and referencing namespaced program elements
 包是指定程序元素的嵌套命名空间。 模块，类，Grammar是包类型。 像目录中的文件一样，通常可以使用其短名称（如果它们是本地的）或使用较长的名称来消除歧义的引用具名元素。
Names 名称是作为变量名称的合法部分的任何东西（不包括sigil符号）。 这包括：
$foo # 简单标识符 $Foo::Bar::baz # 通过 :: 分割的组合标识符 $Foo::($bar)::baz # 执行插值的组合标识符 $42 # numeric names $! # 某些标点符号变量  :: 用于分割嵌套的包名。
包限定名 普通的包限定名像这样:
$Foo::Bar::baz # 包 Foo::Bar 中的 $baz 变量  有时保持sigil与变量名很清晰，所以来写这个的一个替代方式是：
Foo::Bar::&amp;lt;$baz&amp;gt;  这在编译时解决，因为变量名是一个常量。
如果 :: 之前的名称部分为 null，则意味着包未指定并且必须搜索。 一般来说，这意味着跟在主sigil后面的初始 :: 是对编译时已知的名字的无操作(no-op)，但 ::() 也可以用来引入插值。 另外，在没有另一个sigil的情况下，:: 可以作为它自己的sigil，表明有意使用一个尚未声明的包名。
伪包 在名称前面保留以下伪包名称：
MY # 当前词法作用域中的符号 (aka $?SCOPE) OUR # 当前包中的符号 (aka $?</description>
    </item>
    
    <item>
      <title>Perl 6 中列表、序列和数组</title>
      <link>https://ohmysummer.github.io/post/2016-10-27-perl6%E4%B8%AD%E5%88%97%E8%A1%A8%E5%BA%8F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 27 Oct 2016 22:33:17 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-27-perl6%E4%B8%AD%E5%88%97%E8%A1%A8%E5%BA%8F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</guid>
      <description>列表一直是计算机的核心部分，因为之前有计算机，在这段时间里，许多恶魔占据了他们的细节。 它们实际上是 Perl 6 设计中最难的部分之一，但是通过坚持和耐心，Perl 6 已经使用了一个优雅的系统来处理它们。
Literal Lists 字面上的列表用逗号和分号不是用圆括号创建，因此：
1, 2 # This is two-element list (1, 2) # This is also a List, in parentheses (1; 2) # same List (1) # This is not a List, just a 1 in parentheses (1,) # This is a one-element List  括号可用于标记列表的开头和结尾，因此：
(1, 2), (1, 2) # This is a list of two lists.  多维字面上的列表是通过逗号和分号组合而成的。 它们可以在常规参数列表和下标中使用。
say so (1,2; 3,4) eqv ((1,2), (3,4)); # OUTPUT«True␤» say(&#39;foo&#39;;); # a list with one element and the empty list # OUTPUT«(foo)()␤»  单个元素可以使用下标从列表中拉出。 列表的第一个元素的索引号为零：</description>
    </item>
    
    <item>
      <title>第 10000 个素数</title>
      <link>https://ohmysummer.github.io/post/2016-10-26-%E7%AC%AC10000%E4%B8%AA%E7%B4%A0%E6%95%B0/</link>
      <pubDate>Wed, 26 Oct 2016 16:41:13 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-26-%E7%AC%AC10000%E4%B8%AA%E7%B4%A0%E6%95%B0/</guid>
      <description>到目前为止(2016.10.26), Perl 6 的速度相比 Perl 5/Python 的差距还是很大的。以打印从 1 开始计数的第 10000 个素数为例, 使用如下版本的 Rakudo:
 This is Rakudo version 2016.07.1 built on MoarVM version 2016.07 implementing Perl 6.c.
 从程序执行耗费的时间来看, Perl 6 实在慢的如蜗牛。
并发打印第10000个素数 sub find-prime($count) { my $channel = Channel.new; my $promise = start { for ^$count { $channel.send($_) if .is-prime; } LEAVE $channel.close unless $channel.closed; } return $channel.list but role :: { method channel { $channel } };; } my @primes = find-prime(110000); #for @primes { # @primes.</description>
    </item>
    
    <item>
      <title>Perl 6 中的 require</title>
      <link>https://ohmysummer.github.io/post/2016-10-26-perl6%E4%B8%AD%E7%9A%84require/</link>
      <pubDate>Wed, 26 Oct 2016 16:37:31 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-26-perl6%E4%B8%AD%E7%9A%84require/</guid>
      <description>有时你必须不择手段地得到一个东西。 如果它是一个文件，你可以使用 Jonathan Stowes 的 URI::FetchFile。 所述模块检查四个模块中的任何一个是否可用，并且采用第一个将 URI 保存为磁盘上的文件。 在他的代码中有一个有趣的触发了 ENODOC 的行。
$type = try require :: ($class-name);  这里 require 返回一个类型对象，该类型对象由模块声明，并且具有与该模块相同的名字。
检查 roast 这个巧妙的花招并把玩整个动态模块的魔法让我意识到，我们没有真正地在文档中覆盖这一点。 当我尝试处理一个 ENODOC 时我喜欢从一个可编译的例子开始。 这一次，我们需要两个文件。
# M.pm6 unit module M; class C is export { method m { &#39;method C::m&#39; } }; class D is export { method m { &#39;method D::m&#39; } }; # dynamic-modules.p6 use v6; use lib &#39;.&#39;; subset C where ::(&#39;M::C&#39;); my C $context = try { CATCH { default { .</description>
    </item>
    
    <item>
      <title>关于 Perl 6 你要知道的 10 件事</title>
      <link>https://ohmysummer.github.io/post/2016-10-22-%E5%85%B3%E4%BA%8Eperl6%E4%BD%A0%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8410%E4%BB%B6%E4%BA%8B/</link>
      <pubDate>Sat, 22 Oct 2016 00:52:52 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-22-%E5%85%B3%E4%BA%8Eperl6%E4%BD%A0%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8410%E4%BB%B6%E4%BA%8B/</guid>
      <description>Ten Things You Need To Know about Perl 6 Jeffrey Goff, Evozon Systems LLC OSCON London 2016 https://github.com/drforr http://theperlfisher.blogspot.ro  资源  perl6.org (obviously) docs.perl6.org - Online documentation modules.perl6.org - CPAN Lite
 rakudo.org - Where to get the latest
 https://github.com/tadzik/rakudobrew - Perlbrew for Perl 6
 https://github.com/tadzik/panda/ - Module installer
 irc://irc.freenode.org/perl6 - #perl6 on IRC.freenode.org
 http://rosettacode.org/wiki/Category:Perl_6 - Sample source
  要闻  干净, 一次性的可解析的文法 对用户友好的错误信息 友好的 Unicode 对初学者有帮助的符号 Math that works 函数签名 用正则表达式引导 OO with a type lattice built on a Metaprogramming model 自定义运算符 内置并发  一次性文法 my @doctor = { :first(&#39;Christopher&#39;), :last(&#39;Eccleston&#39;), years =&amp;gt; 1 }, { :first(&#39;David&#39;), :last(&#39;Tennant&#39;), years =&amp;gt; 4 }, { :first(&#39;Matt&#39;), :last(&#39;Smith&#39;), years =&amp;gt; 4 }, { :first(&#39;Peter&#39;), :last(&#39;Capaldi&#39;), years =&amp;gt; 3 }; say &#39;First New Who Doctor: &#39;, @doctor[0]{&#39;first&#39;}, &#39; &#39;, @doctor[0]&amp;lt;last&amp;gt;; say &amp;quot;Average run: &amp;quot; ~ @doctor.</description>
    </item>
    
    <item>
      <title>我在查找文件时所学到的</title>
      <link>https://ohmysummer.github.io/post/2016-10-20-%E6%88%91%E5%9C%A8%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E6%97%B6%E6%89%80%E5%AD%A6%E5%88%B0%E7%9A%84/</link>
      <pubDate>Thu, 20 Oct 2016 14:19:52 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-20-%E6%88%91%E5%9C%A8%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E6%97%B6%E6%89%80%E5%AD%A6%E5%88%B0%E7%9A%84/</guid>
      <description>Things I found out while finding
Concurrent::File::Find 现在已经在生态系统中了。我在这里分享几点我学到的东西。
在子签名(sub-signature)上使用 where 从句将不会在子签名中提供变量。 如果 where 从句必须对所有参数进行操作，为了检查排他性或其他相互依赖性，那么它必须应用于最后一个参数上。 这个限制设计时就是这样的，所以我告诉了文档。 where 从句对捕获没有效果，但原意不是那样设计的并且第二天 jnthn 就修复了它。 我知道抱怨会得到你的关注，但我没想到它是这么快。
我还发现一个叫 .close 的方法, 它几乎总是需要一个 LEAVE。 让我们看一些代码。
sub find-simple ( IO(Str) $dir, :$keep-going = True, :$no-thread = False ) is export { my $channel = Channel.new; my &amp;amp;start = -&amp;gt; ( &amp;amp;c ) { c } if $no-thread; my $promise = start { for dir($dir) { CATCH { default { if $keep-going { note .</description>
    </item>
    
    <item>
      <title>Perl 6 中的 with</title>
      <link>https://ohmysummer.github.io/post/2016-10-19-perl6%E4%B8%AD%E7%9A%84with/</link>
      <pubDate>Wed, 19 Oct 2016 19:17:03 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-19-perl6%E4%B8%AD%E7%9A%84with/</guid>
      <description>with orwith without with 语句就像 if 但是是为了测试是否定义而非真假。此外, 它主题化了条件, 这很像 given:
with &amp;quot;abc&amp;quot;.index(&amp;quot;a&amp;quot;) { .say } # print 0  代替 elsif, orwith 用于把是否定义的测试链接起来:
# The below code says &amp;quot;Found a at 0&amp;quot; my $s = &amp;quot;abc&amp;quot;; with $s.index(&amp;quot;a&amp;quot;) { say &amp;quot;Found a at $_&amp;quot; } orwith $s.index(&amp;quot;b&amp;quot;) { say &amp;quot;Found b at $_&amp;quot; } orwith $s.index(&amp;quot;c&amp;quot;) { say &amp;quot;Found c at $_&amp;quot; } else { say &amp;quot;Didn&#39;t find a, b or c&amp;quot; }  你可以混合基于 if 的从句和基于 with 的从句：</description>
    </item>
    
    <item>
      <title>Perl6 模块分析 - 并行查找文件</title>
      <link>https://ohmysummer.github.io/post/2016-10-19-perl6%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90-%E5%B9%B6%E8%A1%8C%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 19 Oct 2016 19:12:22 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-19-perl6%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90-%E5%B9%B6%E8%A1%8C%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</guid>
      <description>并行查找文件 如果你没有使用 panda 或 zef 安装该模块, 你可以下载到本地：
use v6; use lib &amp;quot;C:\\Users\\Administrator\\perl6-concurrent-file-find\\lib&amp;quot;; use Concurrent::File::Find;  下面来看具体代码：
class X::IO::NotADirectory does X::IO is export { has $.path; method message { &amp;quot;«$.path» is not a directory&amp;quot; } } class X::IO::CanNotAccess does X::IO is export { has $.path; method message { &amp;quot;Cannot access «$.path»: permission denied&amp;quot; } } class X::IO::StaleSymlink does X::IO is export { has $.path; method message { &amp;quot;Stale symlink «$.path»&amp;quot; } }  上面的代码自定义了 3 个与 IO 错误相关的类并导出, 每个类中有一个 $.</description>
    </item>
    
    <item>
      <title>Perl 6 中的 Block</title>
      <link>https://ohmysummer.github.io/post/2016-10-19-perl6%E4%B8%AD%E7%9A%84block/</link>
      <pubDate>Wed, 19 Oct 2016 00:22:27 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-19-perl6%E4%B8%AD%E7%9A%84block/</guid>
      <description>Perl 6 中的 Block class Block is Code { }  Block 是用于小规模代码复用的代码对象。 Block 由花括号括起来的一组语句创建。
如果没有显式的签名或占位符参数，那么 Block 会把 $_ 作为位置参数：
my $block = { uc $_; }; say $block.WHAT; # (Block) say $block(&#39;hello&#39;); # HELLO  Block 和 -&amp;gt; 或 &amp;lt;-&amp;gt; 之间还可以拥有签名:
my $add = -&amp;gt; $a, $b { $a + $b }; say $add(38, 4); # 42  如果用 &amp;lt;-&amp;gt; 引入签名, 那么参数默认标记为 rw:
my $swap = &amp;lt;-&amp;gt; $a, $b { ($a, $b) = ($b, $a) }; my ($a, $b) = (2, 4); $swap($a, $b); say $a; # 4  类型不是 Routine（它是 Block 的子类）的 Blocks 对于 return是透明的。</description>
    </item>
    
    <item>
      <title>Perl 6 中的函数</title>
      <link>https://ohmysummer.github.io/post/2016-10-17-perl6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 17 Oct 2016 21:13:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-17-perl6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</guid>
      <description>Perl 6 中的函数 例程（Routines）是 Perl 6 中代码重用的最小手段。它们有几种形式，最明显的是属于类和角色并与对象相关联的方法，还有函数, 也叫做子例程或短子程序，它们独立于对象而存在。
子例程默认是词法（my）作用域的，对它们的调用通常在编译时解析。
子例程可以具有签名，也称为*参数列表*，其指定签名期望的参数（如果有的话）。 它可以指定（或保持打开）参数的数量和类型，以及返回值。
子例程的内省通过例程提供。
定义/创建/使用 函数 子例程 创建子例程的基本方法是使用 sub 声明符，后跟可选标识符
sub my-func { say &amp;quot;Look ma, no args!&amp;quot; } my-func;  sub 声明符返回可以存储在任何容器中的 Sub 类型的值:
my &amp;amp;c = sub { say &amp;quot;Look ma, no name!&amp;quot; } c; # OUTPUT: «Look ma, no name!␤» my Any:D $f = sub { say &#39;Still nameless...&#39; } $f(); # OUTPUT: «Still nameless...␤» my Code \a = sub { say ‚raw containers don&#39;t implement postcircumfix:&amp;lt;( )&amp;gt;‘ }; a.</description>
    </item>
    
    <item>
      <title>Perl 6 From Ruby - Nutshell</title>
      <link>https://ohmysummer.github.io/post/2016-10-17-perl6fromruby/</link>
      <pubDate>Mon, 17 Oct 2016 17:55:34 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-17-perl6fromruby/</guid>
      <description>Perl 6 from Ruby - Nutshell
基本语法 语句结束分号 Ruby 使用换行(有几个例外)来探测大部分语句的结束, 只要表达式已经完成。通过把运算符挂在行的末尾以保证解析会继续而打断一个长的表达式的做法很常见:
foo + # 在 Ruby 中结尾的运算符意味着解析会继续 bar + baz  在 Perl 6 中你必须显式地使用 ; 来结束语句, 这允许更好的反馈和更灵活的断行。有两个例外不需要显式的 ;, 块儿中的最后一条语句, 在块自身的闭合花括号之后(如果那一行上没有任何其它东西):
if 5 &amp;lt; $x &amp;lt; 10 { say &amp;quot;Yep!&amp;quot;; $x = 17 # 在闭合花括号 } 之前不需要分号 ; } # 因为换行, 在闭合花括号 } 之后不需要分号 ; say &amp;quot;Done!&amp;quot;; # 如果后面什么也没有, 那么这儿的分号也不需要  空白 Ruby 中允许使用大量令人吃惊的灵活的空白, 即使在开启了严格模式和警告的情况下:
# 不符合习惯但是在 Ruby 中是合法的 puts&amp;quot;Hello &amp;quot;+ (people [ i] .</description>
    </item>
    
    <item>
      <title>stackoverflowWeekly1014</title>
      <link>https://ohmysummer.github.io/post/2016-10-14-stackoverflowweekly1014/</link>
      <pubDate>Fri, 14 Oct 2016 15:09:54 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-14-stackoverflowweekly1014/</guid>
      <description>Perl 6 List Concatenation without Slip Perl 6 List Concatenation without Slip 在 Perl 5 中 , 操作符用来连接列表; 然而在 Perl 6 中需要使用 | 操作符, 即 slip 操作符。
my @a = &amp;lt;a b c&amp;gt;; my @b = &amp;lt;d e f&amp;gt;; my @ab = |@a, |@b;  有比这短点的写法吗？
 答案  你可以使用 「flat」sub:
my @a = &amp;lt;a b c&amp;gt;; my @b = &amp;lt;d e f&amp;gt;; my @ab = flat @a, @b; say @ab.</description>
    </item>
    
    <item>
      <title>在手机中运行 Perl 6</title>
      <link>https://ohmysummer.github.io/post/2016-10-14-%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%AD%E8%BF%90%E8%A1%8Cperl6/</link>
      <pubDate>Fri, 14 Oct 2016 11:15:24 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-14-%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%AD%E8%BF%90%E8%A1%8Cperl6/</guid>
      <description>准备工作  一只 Root 过的安卓智能手机(例如 Smartisan T1) 下载并安装 busybox.apk 、 Linux Deploy.apk 和 JuiceSSH.apk  安装 Linux 下面以在我的锤子手机上安装 Debian 为例, 说明如何在手机上运行 Linux:
设置 Linux Deploy 打开手机上的 Linux Deploy.apk：
在下面工具栏「启动」-&amp;gt;「停止」-&amp;gt; 「下载」 tab 中找到那个类似下载图标的按钮点击, 进入属性设置, 其中属性设置如下所示:
其中,
   选项 值 说 明     发行版 Debian 根据自己需要的系统选择   发行版本 jsssie 选择稳定版   架构 armhf 软件会自省判断 CPU 架构类型   镜像地址 http://debian.bjtu.edu.cn/debian/ http://ftp.cn.debian.org/debian/   镜像大小 不用填写 默认就行   选择组件 只保留 SSH 服务器 手机上用什么桌面环境   图形界面 取消勾选 手机上不需要 GUI   自定义挂载 勾选 在挂载点那里选择 sdcard0    设置完成后回到最上面的 Intall(安装 GNU/Linux), 就会开始下载镜像文件了:</description>
    </item>
    
    <item>
      <title>Perl 6 中的 subst</title>
      <link>https://ohmysummer.github.io/post/2016-10-05-perl6%E4%B8%AD%E7%9A%84subst/</link>
      <pubDate>Wed, 05 Oct 2016 23:32:51 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-05-perl6%E4%B8%AD%E7%9A%84subst/</guid>
      <description>(Str) 方法 subst subst 取的是单词 substitution(替换)的前5个字符, 意为替换之意。
multi method subst(Str:D: $matcher, $replacement, *%opts)  返回被调用的那个字符串, 其中 $matcher 被 $replacement 给替换掉了(或者返回原来的字符串, 如果没有找到匹配的话)。
subst 有一个「就地」替换的句法变体, 它被拼写为 s/matcher/replacement/。
$matcher 可以是一个正则表达式, 或者一个字符串字面值。 Cool 类型的非字符串 matcher 会被强转为字符串以用于字面上的匹配。
my $some-string = &amp;quot;Some foo&amp;quot;; my $another-string = $some-string.subst(/foo/, &amp;quot;string&amp;quot;); # gives &#39;Some string&#39; $some-string.=subst(/foo/, &amp;quot;string&amp;quot;); # in-place substitution. $some-string is now &#39;Some string&#39;  replacement 可以是一个闭包:
my $i = 41; my $str = &amp;quot;The answer is secret.</description>
    </item>
    
    <item>
      <title>Perl 6 中的并发</title>
      <link>https://ohmysummer.github.io/post/2016-10-03-perl6%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Mon, 03 Oct 2016 20:43:15 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-03-perl6%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91/</guid>
      <description>Concurrency
与大多数现代编程语言一样，Perl 6 被设计为支持并发（允许多个事件同时发生）和异步编程（有时称为事件驱动或反应式编程 - 即程序某些部分的事件或变化可能会导致程序流异步地改变程序的其它部分）。
Perl 的并发设计的目的是提供一个高层级的，可组合的，一致的接口，而不管如下所述的虚拟机通过工具层怎样为特定操作的系统来实现它。
此外，某些 Perl 的特性可以隐式地以异步的方式操作，所以为了确保这些特性可预测的互通，用户代码应在可能情况下，避免较低层级的并发的 API（即线程和调度器），并使用高层级接口。
High-level APIs Promises Promise（在其他编程环境中也被称为 *future*）封装了在获得 promise 时可能尚未完成或甚至未开始的计算结果。Promise 从 Planned 状态开始, 结果要么是 Kept 状态, 这意味着该 promise 已成功完成, 要么是 Broken 状态, 意味着该 promise 已失败。 通常这就是用户代码需要以并行或异步方式操作的使用最多的功能。
my $p1 = Promise.new; say $p1.status; # OUTPUT: «Planned␤» $p1.keep(&#39;Result&#39;); say $p1.status; # OUTPUT: «Kept␤» say $p1.result; # OUTPUT: «Result␤» # (since it has been kept, a result is available!) my $p2 = Promise.new; $p2.</description>
    </item>
    
    <item>
      <title>gather-take</title>
      <link>https://ohmysummer.github.io/post/2016-09-28-gather-take/</link>
      <pubDate>Wed, 28 Sep 2016 17:48:14 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-28-gather-take/</guid>
      <description>控制流 gather/take gather 是一个语句或者能返回一序列值的 block 前缀。该值来自于 gather 块中的动态作用域的 take 调用。
my $a = gather { take 1; take 5; take 42; } say join &#39;, &#39;, @$a; # 1, 5, 42  gather/take 能根据上下文按需(惰性地)生成值。如果你想强制惰性求值则使用 lazy 子例程或方法。绑定到一个标量或无符号的容器上也会强制惰性求值。 举个例子:
my @vals = lazy gather { take 1; say &amp;quot;Produced a value&amp;quot;; take 2; } say @vals[0]; say &#39;between consumption of two values&#39;; say @vals[1]; # OUTPUT: # 1 # between consumption of two values # Produced a value # 2  gather/take 是动态作用域的, 所以你可以从 gather 内部所调用的 subs 或方法中调用 take:</description>
    </item>
    
    <item>
      <title>解析命令行输出</title>
      <link>https://ohmysummer.github.io/post/2016-09-27-%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA/</link>
      <pubDate>Tue, 27 Sep 2016 07:51:05 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-27-%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA/</guid>
      <description>哦, 列, 你在哪里? 当 ramiroencinas 给 Perl 6 的生态系统增加 FileSystem::Capacity::VolumesInfo模块的时候, 我说他没有添加 macOS 支持。而当我尝试为这个模块贡献源代码时我才发现知道一丢丢 Perl 6 的特性就能节省很多时间。 FileSystem::Capacity::VolumesInfo 这个模块所做的就是解析 df 命令的输出, 它看起来长这样:
$ df -k -P Filesystem 1024-blocks Used Available Capacity Mounted on /dev/disk3 1219749248 341555644 877937604 29% / devfs 343 343 0 100% /dev /dev/disk1s4 133638140 101950628 31687512 77% /Volumes/Untitled map -hosts 0 0 0 100% /net map auto_home 0 0 0 100% /home map -fstab 0 0 0 100% /Network/Servers //Pawel%20Pabian@biala-skrzynka.</description>
    </item>
    
    <item>
      <title>I left my keys in a side-channel</title>
      <link>https://ohmysummer.github.io/post/2016-09-26-i-left-my-keys-in-a-side-channel/</link>
      <pubDate>Mon, 26 Sep 2016 12:17:59 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-26-i-left-my-keys-in-a-side-channel/</guid>
      <description>当我尝试把选项聚合到一个模块中时我无意中发现了一个常见问题的简洁解决办法。我想拥有一个子例程作为吞噬具名参数、做一些检查、并且要么返回 True 以满足那个 where 从句, 要么死掉并抛出一个合适的错误信息的 where 从句。 那很简单但是不彻底。那个 where 从句没有提供它所检查的参数的名字, 这需要拥有一个合适的错误信息。我们来简化下代码。
sub checker(*%colon-keys){ sub ($value-from-where-clause) { True } } sub f( *%h where checker(:a, :b, :c) ) {}  子例程 checker 在 where 从句真正检测任何东西之前被调用。在 Perl 6 中 where 从句是一种句法。如果提供一个表达式，它会调用该表达式，并保持它的返回值然后针对 %h 的值做实际检查。这并不在编译时发生，且返回值不进行缓存。在我们的例子中返回一个接受一个参数(where需要的)的匿名子例程，并且必须返回 True 以让 where 从句的检查通过。
如你所见 checker 接收一组冒号对(colon-pairs)。剩下的问题我们能提供给我们可能要输出的异常，特别的附加信息。如果我们希望该参数是可选的，避免奇怪的语法。我们可以有一个可选的位置，但我们就不能在checker中混合位置和具名参数。存储该值将是微不足道，因为返回的匿名子例程可以具有闭包变量。我们只需要填充它。幸运的是，子返回作为引用返回，然后由那个 where 从句调用。我们可以偷偷加进另一个呼叫，只要我们大家别忘了把代码引用返回给匿名子例程(sub)。
返回引用给同一个对象是通过链式方法调用完成的。通常情况下，当事情在 Perl 6 的领地上变得复杂时，我们就混入一个 role 好了。然后，我们有了一个可以返回自身的方法。
use v6; sub g($i){ my $closure-variable; sub ($value-from-where-clause) { say [$closure-variable, $value-from-where-clause]; $value-from-where-clause == $i or die &amp;quot;bad value $value-from-where-clause for $closure-variable&amp;quot; } but role :: { method side-channel($second-value){ $closure-variable = $second-value; self } } } sub f($a where g(42).</description>
    </item>
    
    <item>
      <title>These keys are LTA</title>
      <link>https://ohmysummer.github.io/post/2016-09-26-these-keys-are-lta/</link>
      <pubDate>Mon, 26 Sep 2016 12:15:14 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-26-these-keys-are-lta/</guid>
      <description>在折腾枚举作为子例程布尔选项的时候, 我发现默认的错误信息不够酷。
 Constraint type check failed for parameter &#39;@options&#39;  让错误信息变得更具体有点困难。我们来创建几个 exceptions 来告诉我们当东西出错时究竟发生了什么。
class X::Paramenter::Exclusive is Exception { has $.type; method message { &amp;quot;Parameters of {$.type.perl} are mutual exclusive&amp;quot; } }  现在我们能检查 Find::Type 的选项是否是独占的从而抛出异常。
&amp;amp;&amp;amp; ( exclusive-argument(@options, Find::Type) or fail X::Paramenter::Exclusive.new(type =&amp;gt; Find::Type) ) class X::Parameter::UnrecognisedOption is Exception { has $.type; has $.unrecognised; method message { &amp;quot;Option { $.unrecognised } not any of { $.type.map({ (.^name ~ &#39;::&#39;) xx * Z~ .</description>
    </item>
    
    <item>
      <title>键是可选的</title>
      <link>https://ohmysummer.github.io/post/2016-09-26-%E9%94%AE%E6%98%AF%E5%8F%AF%E9%80%89%E7%9A%84/</link>
      <pubDate>Mon, 26 Sep 2016 12:04:56 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-26-%E9%94%AE%E6%98%AF%E5%8F%AF%E9%80%89%E7%9A%84/</guid>
      <description>Keys are optional Keys are optional
在我探索一个并发的 File::Find 模块时我发现我需要一组排序用的参数(例如 Bool)和互相排斥的参数。枚举相当易于组合, 把好用的名字引入到作用域中(直接地或通过 export)并且应该让相互排斥变得容易。容易的那部分有点幼稚因为类型化的吞噬参数尚未支持(还没有)。如果没有容易的方式, 肯定会有一个可行的困难的方式。
首先, 我们定义两个枚举用作要查找的选项。
package Find { enum Type (&amp;lt;File Dir Symlink&amp;gt;); enum Options (&amp;lt;Recursive Keep-going&amp;gt;); }  现在我们可以让一个 where 从句首先检查吞噬数组的所有成员要么是 Find::Type 类型要么是 Find::Options 类型。然后我们可以检查 Find::Options 拥有多少个元素。因为如果有太多的话只有一个我们可以抱怨独占。
+@options where { @options.all (elem) (Find::Type::.values (|) Find::Options::.values) &amp;amp;&amp;amp; (+(@options.grep: * ~~ Find::Type) &amp;lt;= 1 or die &amp;quot;can only check for one type at a time&amp;quot;) }  在主体中我们可以使用 junctions 和智能匹配来检查选项是否出现。</description>
    </item>
    
    <item>
      <title>这些是你的键吗</title>
      <link>https://ohmysummer.github.io/post/2016-09-26-%E8%BF%99%E4%BA%9B%E6%98%AF%E4%BD%A0%E7%9A%84%E9%94%AE%E5%90%97/</link>
      <pubDate>Mon, 26 Sep 2016 12:01:22 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-26-%E8%BF%99%E4%BA%9B%E6%98%AF%E4%BD%A0%E7%9A%84%E9%94%AE%E5%90%97/</guid>
      <description>Are these your keys? are these your keys
在键是常量的散列中我经常打错键的名字。通过混合一个重载方法 AT-KEY 的 role 让键限制在一个给定的字符串列表中并不困难。但是那会是一个运行时错误并且用一个运行时错误代替另一个运行时错误。
枚举确实拥有一组常量值的键并提供散列能使用的同一性。Perl 6 的确允许枚举作为键的约束并且如果我们查询了一个没有定义为枚举的键的话会在编译时抛出异常。 然而, 如果我们把散列限制为一组给定的键, 我们可能想要输出所有可能的键, 而不仅仅是有关联值的那些键。我们可以通过混进一个 role 来解决它。
enum Noms(&amp;lt;Greenstuff Walkingstuff Syntetics&amp;gt;); (my %eaten{Noms} is default(0)) does role :: { method keys { Noms::.values } method kv { gather for self.keys -&amp;gt; \k { take k, self.{k} } } }; %eaten{Greenstuff}++; dd %eaten; # Hash[Any,Noms]+{&amp;lt;anon|75781152&amp;gt;} %eaten = (my Any %{Noms} = Noms::Greenstuff =&amp;gt; 1) dd %eaten.</description>
    </item>
    
    <item>
      <title>Whatever Star</title>
      <link>https://ohmysummer.github.io/post/2016-09-25-whatever-star/</link>
      <pubDate>Sun, 25 Sep 2016 16:14:05 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-25-whatever-star/</guid>
      <description>Whatever 是什么?  Placeholder for unspecified value/parameter - 未指定的值/参数的占位符。
 * 字面量在 「term」 位置上创建 「Whatever」 对象。 * 的大部分魔法来自于 「Whatever 柯里化」. 当 * 作为 item 与很多操作符组合使用时, 编译器会把表达式转换为 「WhateverCode」 类型的闭包.
my $c = * + 2; # same as -&amp;gt; $x { $x + 2 }; say $c(4); # 6  如果一个表达式中有 N 个 *, 则会产生一个含有 N 个参数的闭包:
my $c = * + *; # same as -&amp;gt; $x, $y { $x + $y }  在复杂的表达式中使用 * 也会产生闭包:</description>
    </item>
    
    <item>
      <title>Perl 6 中的冒号</title>
      <link>https://ohmysummer.github.io/post/2016-09-24-perl6%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</link>
      <pubDate>Sat, 24 Sep 2016 20:55:11 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-24-perl6%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</guid>
      <description>Perl 6 Colons 在 Perl 6 中到处都是冒号, 我搜集了你在 Perl 6 中使用冒号的所有方式。
Larry 语言再设计第一定律: 每个人都想要冒号 Larry 语言再设计第二定律: Larry 成为冒号
这些都是主题的变体，尤其是“冒号对”语法主题。如果冒号的两种用法看起来不同，或者在不同的用法上下文中不同，即使它们在技术上是相同的，我更愿意说明这两种用法。
命名空间 # namespace package A::B { ... } class A::B { ... } # Namespace separator my $x = A::B.new; # Dynamic namespace my $x = ::(&amp;quot;A::B&amp;quot;).new; # Pseudopackage representing null namespace say ::; # Anonymous class class :: is Int {...} # Current class in a compile-tiem var class Who { method myname { say ::?</description>
    </item>
    
    <item>
      <title>Learning Perl 6 - sets</title>
      <link>https://ohmysummer.github.io/post/2016-09-19-learning-perl-6-sets/</link>
      <pubDate>Mon, 19 Sep 2016 22:56:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-19-learning-perl-6-sets/</guid>
      <description>Quick Tip #8: Perl 6 sets Set – a collection of unique thingys Bag - a collection of unique thingys,but weighted for the count of the number of times something is put the bag Mix - a bag that allows fractional weights
这些是不可变类型。一旦生成就不可变了。每一个都有一个 Hash 版本以允许你更改成员, 但是我会忽略这些。
$ perl6 &amp;gt; my $set = set( 1, 2, 3, 4 ) set(4, 3, 1, 2) &amp;gt; 4 ∈ $set # member of True &amp;gt; 5 ∈ $set # member of False &amp;gt; 5 ∉ $set # not member of True &amp;gt; set( 2, 3 ) ⊆ $set # subset of True &amp;gt; set( 2, 6 ) ⊆ $set # subset of False  集合是一种更自然的查看一个值是否存在于一个值的列表中的方式。你可能每一个哈希和使用 :exists 来检查键，但集合会这样做（尽管那就是 Perl 6 集合现在在幕后为你所做的）：</description>
    </item>
    
    <item>
      <title>Python Vs Perl 6</title>
      <link>https://ohmysummer.github.io/post/2016-09-19-python-vs-perl6/</link>
      <pubDate>Mon, 19 Sep 2016 09:15:54 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-19-python-vs-perl6/</guid>
      <description>Python Vs Perl 6, 比较哪个写法更优雅简洁。
zip() # OUTPUT What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue.  Python
questions = [&#39;name&#39;, &#39;quest&#39;, &#39;favorite color&#39;] answers = [&#39;lancelot&#39;, &#39;the holy grail&#39;, &#39;blue&#39;] for q, a in zip(questions, answers): print &#39;What is your {0}? It is {1}.&#39;.format(q, a)  Perl6
my @questions = (&#39;name&#39;, &#39; quest&#39;, &#39;favorite color&#39;); my @answers = (&amp;quot;lancelot&amp;quot;, &amp;quot;the holy grail&amp;quot;, &amp;quot;blue&amp;quot;); for zip(@questions, @answers) -&amp;gt; ($question, $answer) { say &amp;quot;What is you $question?</description>
    </item>
    
    <item>
      <title>feed 操作符</title>
      <link>https://ohmysummer.github.io/post/2016-09-18-feed%E6%93%8D%E4%BD%9C%E7%AC%A6/</link>
      <pubDate>Sun, 18 Sep 2016 22:56:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-18-feed%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid>
      <description>Sequencer Precedence
infix ==&amp;gt; 这个流操作符(feed operator)从它的左侧接收结果并把结果作为最后一个参数传递给下一个(右侧的)例程(routine)。
这个操作符的优先级很松散所以你需要使用圆括号把结果赋值给其它变量, 或者你甚至可以使用另外一个流操作符! 在接收单个参数或第一个参数为 block 的程序/方法的例子中, 你必须经常使用圆括号来调用(尽管这对于最后一个例程/方法不是必须的)。
# Traditional structure, read bottom-to-top my @result = sort # (4) Sort, result is &amp;lt;Earth People&amp;gt; grep { /&amp;lt;[PE]&amp;gt;/ }, # (3) Look for P or E map { .tc }, # (2) Capitalize the words &amp;lt;people of earth&amp;gt;; # (1) Start with the input # Feed (left-to-right) with parentheses, read top-to-bottom @result = ( &amp;lt;people of earth&amp;gt; # (1) Start with the input ==&amp;gt; map({ .</description>
    </item>
    
    <item>
      <title>对象哈希</title>
      <link>https://ohmysummer.github.io/post/2016-09-18-perl-6-calendar-2016-%E7%AC%AC%E4%B8%89%E5%A4%A9%E5%AF%B9%E8%B1%A1%E5%93%88%E5%B8%8C/</link>
      <pubDate>Sun, 18 Sep 2016 22:56:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-18-perl-6-calendar-2016-%E7%AC%AC%E4%B8%89%E5%A4%A9%E5%AF%B9%E8%B1%A1%E5%93%88%E5%B8%8C/</guid>
      <description>第三天　－　对象哈希
Perl 6 添加对象散列, 其键并不仅仅是字符串。这些键是值和类型的结合。这意味着对象可以被字符串化为同样的东西但是它们可以是不同的键。
普通的哈希构造：
use v6; my Int $int = 4; my Str $str = &amp;quot;4&amp;quot;; my IntStr $int_str = &amp;lt;4&amp;gt;; # Allomorph my %hash; %hash{$int} = &#39;Plain old number&#39;; %hash{$str} = &#39;String of digits&#39;; %hash{$int_str} = &#39;Dualvar&#39;; say &amp;quot;There are &amp;quot;, %hash.elems, &amp;quot; elements in the hash&amp;quot;; # this calls the .gist method, sorta like a dumper routine %hash.say;  结果显示该哈希中只有一个元素并且这个元素是我最后添加的那个：
There are 1 elements in the hash {4 =&amp;gt; Dualvar}  但是我也可以通过告诉哈希我想要它接受的对象来声明一个对象哈希（Object hash）。我可以使用　Any 对象来允许哈希接受任何东西：</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://ohmysummer.github.io/page/about/</link>
      <pubDate>Wed, 14 Sep 2016 09:05:31 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/page/about/</guid>
      <description> About Me class Ohmycloud { has $.location; has $.email; has $.qq; has $.title; has @.books; method gist() { qq{ Location：$!location, Email： $!email, QQ： $!qq, Title： $!title, } ~ &amp;quot; Books： &amp;quot; ~ @!books.join(&#39;,&#39;) } } my $cloudy = Ohmycloud.new( location =&amp;gt; &#39;北京&#39;, email =&amp;gt; &#39;ohmycloudy@gmail.com&#39;, qq =&amp;gt; &#39;740011611&#39;, title =&amp;gt; &#39;如果我的勇气是鱼&#39;, books =&amp;gt; [&#39;暗夜独行客&#39;, &#39;一首朋克救地球&#39;, &#39;亲爱的阿道夫&#39;, &#39;殡葬人的秘密&#39;] ); say $cloudy;  关于本站  本博客使用 Hugo, 主题采用 Beautifulhugo 本博客主要是关于 「Perl 6」, Perl 6 QQ 群: 378106403 搭建开始于 2015 年某个无聊的晚上  其它说明  以上文字都是使用「小狼毫」输入法编码的 中秋不吃月饼, 也不会写脚本抢月饼  友情链接  ☀️哲の小窝☀️  </description>
    </item>
    
    <item>
      <title>Data Dump</title>
      <link>https://ohmysummer.github.io/post/2016-09-10-data-dump/</link>
      <pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-10-data-dump/</guid>
      <description>for Perl 6 你们选对了, 这就是满足你们快速打印数据需要的. 如果你已经安装了 Term::ANSIColor的话,输出就会亮瞎你的狗眼!
选项 indent 默认缩进为 2
&amp;lt;...&amp;gt; say Dump({ some =&amp;gt; object }, :indent(4)); &amp;lt;...&amp;gt;  max-recursion 默认为 50
&amp;lt;...&amp;gt; say Dump({ some =&amp;gt; object }, :max-recursion(3)); &amp;lt;...&amp;gt;  :color( ) 默认为 :color(true), 安装了 Term::ANSIColor的情况下输出会带颜色. 当为 :color(False) 时关闭彩色.
用法 use Data::Dump; say Dump(%( key1 =&amp;gt; &#39;value1&#39;, key256 =&amp;gt; 1, ));  输出:
{ key1 =&amp;gt; &amp;quot;value1&amp;quot;.Str, key256 =&amp;gt; 1.Int, }  注意: 如果你已经安装了 Term::ANSIColor, 那么接下来就会让你吃惊了.</description>
    </item>
    
    <item>
      <title>Perl 6 Shortcuts(第一部分)</title>
      <link>https://ohmysummer.github.io/post/2016-08-31-perl-6-shortcuts%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</link>
      <pubDate>Wed, 31 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-31-perl-6-shortcuts%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</guid>
      <description>查看原文
快捷(Shortcuts)是一个具有争议性的话题。有些人认为它让代码更快更易读。有些人认为它让代码变得更难度如果人们不熟悉那些快捷的话。这篇文章仅仅告诉你 Shortcuts 的东西, 用不用取决于你。让我们开始把。
类属性的公开 Getter/Setter &amp;ldquo;getter&amp;rdquo; 和 &amp;ldquo;setter&amp;rdquo; 的概念在很多语言中是共通的: 在你的类中有一个 &amp;ldquo;东西&amp;rdquo;, 并且你写了一个方法来设置或获取那个东西的值。以啰嗦的 Perl 6 方式来写, 这样的一个设置看起来像这样:
class Foo { has $!attr = 42; method attr is rw { $!attr } } my $obj = Foo.new; say $obj.attr; $obj.attr = 72; say $obj.attr; # 输出&amp;gt;&amp;gt; # 42 # 72  这就像它本来的那样简洁, 但公共属性通常足以使编写这点儿代码变得恼人。这就是为什么 $. twigil 存在的原因。单独使用它会创建一个 &amp;ldquo;getter&amp;rdquo;; 如果你还想要一个 &amp;ldquo;setter&amp;rdquo;, 需要使用 is rw 特性:
class Foo { has $.attr is rw = 42; } my $obj = Foo.</description>
    </item>
    
    <item>
      <title>哇, Perl 6!</title>
      <link>https://ohmysummer.github.io/post/2016-08-14-%E5%93%87perl6/</link>
      <pubDate>Sun, 14 Aug 2016 13:14:00 +0100</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-14-%E5%93%87perl6/</guid>
      <description>前言 Slides 地址 视频地址
答案地址
注意 Unicode  Perl 6 允许你使用 Unicode 的项和操作符。 这些 Unicode 都有对应的只使用 ASCII 字符的 Texas 变体, 如果你更喜欢使用它们, 到 http://docs.perl6.org/language/unicode_texas 找到它们。
惰性列表和它们的使用 ## 惰性列表
我们来做点儿疯狂的事情吧&amp;hellip;例如创建一个无限列表(INIFINITE LIST)!
my @to-infinity-and-beyond = 0, 2 ... ∞; say @to-infinity-and-beyond[1008]; # 2016  来点更有用的东西: 处理大文件
for &#39;/tmp/4GB-file.txt&#39;.IO.words { .say; last if ++$ == 3; } say &amp;quot;Code took {now - INIT now} seconds to run&amp;quot;; # OUTPUT: # foo # bar # ber # Code took 0.</description>
    </item>
    
    <item>
      <title>大列表重构</title>
      <link>https://ohmysummer.github.io/post/2016-08-12-%E5%A4%A7%E5%88%97%E8%A1%A8%E9%87%8D%E6%9E%84/</link>
      <pubDate>Fri, 12 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-12-%E5%A4%A7%E5%88%97%E8%A1%A8%E9%87%8D%E6%9E%84/</guid>
      <description>Perl 6 最近(2015.9)经历的最大的变化就是 Great List Refactor(GLR), 俗称大列表重构。
它还很难解释！但是幸好有某些历史背景能帮助我们。 在 2014 年澳大利亚 Perl Workshop 会议上讨论了很多 GLR 的东西, Patrick Michaud 在它的博客上写了很多关于 GLR 的内容。
GLE 意图强调性能和列表和相关类型操作的一致性问题。改变这样的基本数据类型将会很痛苦。
通常 Perl 5 这样展开列表:
% perl -dE 1 -MData::Dumper [...snip...] DB&amp;lt;1&amp;gt; @foos=((1,2),3) DB&amp;lt;2&amp;gt; say Dumper \@foos $VAR1 = [ 1, 2, 3 ];  开始, 很多的 Perl 6 行为都模仿这种展平行为但是在去年年底的时候, 使用 non-flatterning(非展平)行为以保留原始数据结构的用法越来越多。
这样做和很多边界情况不一致并且 Rakudo 内部大量使用了一种叫做 Parcel 的数据类型, 之后 Parcel 被认为是一个 Bad Idea(糟糕的设计) — 主要是因为性能问题。
2015 年 7 月, Patrick 导入了一个涵盖 &amp;ldquo;Synopsis 7&amp;rdquo; 的孪生设计草案, 随后的月份中它变成官方的 S07。</description>
    </item>
    
    <item>
      <title>Abundant and Deficient Numbers</title>
      <link>https://ohmysummer.github.io/post/2016-08-11-abundant-and-deficient-numbers/</link>
      <pubDate>Thu, 11 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-11-abundant-and-deficient-numbers/</guid>
      <description>问题描述 abundant 数是其所有因子的和大于该数，而deficient数是其因子的和小于该数。
例如, 考虑数字 21。它的因子是 1, 3, 7 和 21, 这些因子的和是32。 因为 32 小于 2 x 21, 所以 21 是 deficient。它的差额是 2 x 21 - 32 = 10。
12 是第一个 abundant 数。它的因子是 1, 2, 3, 4, 6 和 12, 并且它们的和是 28。 因为 28 大于 2 x 12, 所以 12 是 abundant。它们的差额是 28 - 2 x 12 = 4。
输入描述 你会给定一个整数, 每行一个。例如:
18 21 9  输出描述 你的程序应该打印信息, 如果数字是 deficient, abundant(和它的abundance), 或者都不。例如:</description>
    </item>
    
    <item>
      <title>引号结构</title>
      <link>https://ohmysummer.github.io/post/2016-08-09-%E5%BC%95%E5%8F%B7%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 09 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-09-%E5%BC%95%E5%8F%B7%E7%BB%93%E6%9E%84/</guid>
      <description>The Q Lang 在 Perl 6 中, 字符串通常使用一些引号结构来表示. 这些引号结构中,最简单的就是 Q, 通过便捷方式 ｢…｣ 或 Q 后跟着由任意一对儿分隔符包围着的文本. 大多数时候, 你需要的只是 &#39;…&#39; 或 &amp;quot;…&amp;quot;.
Literal strings: Q Q[A literal string] ｢More plainly.｣ Q ^Almost any non-word character can be a delimiter!^ Q ｢｢Delimiters can be repeated/nested if they are adjacent.｣｣  分隔符能够嵌套, 但是在普通的 Q 形式中, 反斜线转义是不允许的. 换种说法就是, Q 字符串尽可能被作为字面量.
在 Q、q 或 qq 之后不允许立即使用一些分隔符。标识符中允许的任何字符都不允许使用，因为在这种情况下，引号结构和这些字符一起被解释为标识符。此外，( ) 是不允许的，因为它被解释为函数调用。如果你仍然希望使用这些字符作为分隔符，请用空格将它们与 Q、q 或 qq 分隔开。请注意，一些自然语言在字符串的右侧使用左分隔引号。Q 不支持这些，因为它依赖unicode 属性来区分左分隔符和右分隔符。
Q&#39;this will not work!</description>
    </item>
    
    <item>
      <title>智能匹配</title>
      <link>https://ohmysummer.github.io/post/2016-08-03-%E6%99%BA%E8%83%BD%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-03-%E6%99%BA%E8%83%BD%E5%8C%B9%E9%85%8D/</guid>
      <description>智能匹配 智能匹配通常作用在当前”主题”(topic)上, 即作用在 $_ 变量上. 在下面的表格中, $_ 代表 ~~ 操作符的左侧, 或者作为 given 的参数, 或者作为其它主题化的参数. X 代表 ~~ 操作符右侧要匹配的模式, 或者在 when 后面的模式.(实际上, ~~ 操作符充当着一个小型的主题; 即, 为了右侧的计算, 它把 $_ 绑定到左侧的值上. 使用底层的 .ACCEPTS 形式来避免这种主题化.)
第一节包含了含有享有特权的语法; 如果匹配能通过那些条目之一完成, 那它就会那样做. 这些特别的语法是通过它们的形式而非它们的类型进行分派的. 否则就使用表格中的剩余部分,并且匹配会根据普通的方法分派规则进行分派. 允许优化器(optimizer)假定编译时之后没有定义额外的匹配操作符, 所以, 如果在编译时模式类型就显而易见的, 那么跳转表(jump table)可以被优化. 然而, 这部分表格的语法仍然有点特权的, 跟 ~~ 操作符一样, 是 Perl 中少有的几个不使用多重分派的操作符之一. 相反, 基于类型的智能匹配会被单个地分派给属于 X 模式对象的底层方法.
换句话说, 智能匹配首先根据模式(pattern)的形式或类型(下面的X)进行分派(dispatch), 然后那个模式自身决定是否和怎样注意主题($_)的类型. 所以, 下面表格中的第二列就是初始列. 第一列中的 Any 条目标示了模式要么不关心主题的类型, 要么把那个条目作为默认值, 因为上面列出的更具体的类型不匹配.
$_ X Type of Match Implied Match if (given $_) ====== ===== ===================== =================== Any True ~~ True (parsewarn on literal token) Any False ~~ False match (parsewarn on literal token) Any Match ~~ Successful match (parsewarn on literal token) Any Nil ~~ Benign failure (parsewarn on literal token) Any Failure Failure type check (okay, matches against type) Any * block signature match block successfully binds to |$_ Any Callable:($) item sub truth X($_) S03-smartmatch/any-callable.</description>
    </item>
    
    <item>
      <title>Perl 6 Types--成人之美</title>
      <link>https://ohmysummer.github.io/post/2016-08-02-perl-6-types-%E6%88%90%E4%BA%BA%E4%B9%8B%E7%BE%8E/</link>
      <pubDate>Tue, 02 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-02-perl-6-types-%E6%88%90%E4%BA%BA%E4%B9%8B%E7%BE%8E/</guid>
      <description>Perl 6 Types: 成人之美
在我的第一次大学编程语言课中， 我被告知 Pascal 语言在其它类型之外还拥有 Integer、Boolen 和 Stirng 类型。我知道了类型本来就该存在因为计算机很笨。当我在 C语言中涉猎的时候，我学到了更多有关 *int*、 char 和其它像在暖和的地方里地寄生虫， 还有我课桌底下嗡嗡的金属盒的声音。
Perl 5 没有类型，它给我的感觉就像骑着自行车无拘无束的追风少年，沿着斜坡而下。不久之后我一门心思钻到计算机硬件的缝隙中。我拥有数据并且我能用它做任何我想做的事， 只要我得到的不是错误的数据。当我搞定的时候，我从自行车上掉了下来并刮破了我的膝盖。
有了 Perl 6，鱼和熊掌可以兼得。你可以使用类型来避免它们。你可以拥有一个广域的类型来接收很多种类的值或窄类型。并且你可以享受代表机器智力的类型的速度， 或者你可以享受你自定义的代表你自己意志的类型的精度，类型为人类而生。
渐进类型 my $a = &amp;quot;whatever&amp;quot;; my Str $b = &amp;quot;strings only&amp;quot;; my Str:D $c = &amp;quot;defined strings only&amp;quot;; my int $d = 14; # native int sub foo ($x) { $x + 2 } sub bar (Int:D $x) returns Int { $x + 2 }  Perl 6 拥有渐进类型， 这意味着你要么可以使用它们，要么避免使用它们。所以究竟为什么要打扰它们呢？</description>
    </item>
    
    <item>
      <title>unspaces</title>
      <link>https://ohmysummer.github.io/post/2016-08-01-unspaces/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-01-unspaces/</guid>
      <description>有些语言例如 C 允许你转义一个换行符使行联合起来. 其它语言(例如正则表达式)因为各种各样的原因, 允许你使用反斜线转义一个空白符. Perl 6 把这种记法推广到任何种类的空白上. 通过在空白处前置一个 \, 任何相邻的空白(包括注释)都会在解析器面前隐身. 这就是鼎鼎大名的空白隐身( “unspace”).
在 Perl 中, 一个 unspace 能够抑制任意的几种空白附属物. 例如, 因为 Perl 要求名词和后缀操作符之间不能出现空白, 所以使用 unspace 让你可以把后缀操作符贴线对齐:
%hash\ {$key} @array\ [$ix] $subref\($arg)  上面的最后一种形式作为一种退化了的 unspace, 即反斜线后面直接跟着后缀. 注意, 反斜线前面不允许有空白, 所以:
$subref \($arg)  是语法错误(two terms in a row). 而
foo \($arg)  会被解析为带有 Capture 参数的列表操作:
foo(\($arg))  然而, 其它形式的 unspace 可能被有效地放在空白之前.
其它后缀操作符也可能使用 unspace:
$number\ ++; $number\ --; 1+3\ i; $object\ .say(); $object\#`{ your ad here }.</description>
    </item>
    
    <item>
      <title>学习Perl6的一些网站</title>
      <link>https://ohmysummer.github.io/post/2016-07-25-%E5%AD%A6%E4%B9%A0perl6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/</link>
      <pubDate>Mon, 25 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-25-%E5%AD%A6%E4%B9%A0perl6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/</guid>
      <description> Blog  perl6intro perl6.party Perl6 - Reddit Perl 6 Tablet Rosetta Rosetta GitBook mfollett perlgeek Perl 6 advent calendars Perl6Maven Strangely Consistent Death by Perl6 jnthn 道  官方网站  perl6.org Perl6 Documentation Perl 6 Design Documents modules.perl6.org pl6anet examples.perl6.org Perl 6 Features Perl 6 测试套件 Perl 6 IRC  国内  sunnavy songzan 扶凯  </description>
    </item>
    
    <item>
      <title>HOW 方法</title>
      <link>https://ohmysummer.github.io/post/2016-07-22-how%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 22 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-22-how%E6%96%B9%E6%B3%95/</guid>
      <description>Why can&amp;rsquo;t I call the methods method on a Perl 6&amp;rsquo;s ClassHOW object?
我可以在某个对象身上调用 ^methods 方法, 以列出我能调用的方法的名字列表:
my $object = &#39;Camelia&#39; my @object_methods = $object.^methods; @object_methods.map( {.gist} ).sort.join(&amp;quot;\n&amp;quot;).say;  ^methods 返回一个列表, 通过对列表中的每个元素调用 .gist 方法, 得到一个人类友好的形式。
但是 ^methods 中的 ^ 暗含了 .HOW 方法:
我想下面这段代码本该有效的, 但是没有:
my $object = &#39;Camelia&#39;; my @object_objects = $object.HOW.methods;  但是我得到了一个错误:
Too few positionals passed; expected 2 arguments but got 1 in any methods at gen/moar/m-Metamodel.nqp line 490 in block &amp;lt;unit&amp;gt; at.</description>
    </item>
    
    <item>
      <title>The Awesome Errors of Perl 6</title>
      <link>https://ohmysummer.github.io/post/2016-07-20-the-awesome-errors-of-perl-6/</link>
      <pubDate>Wed, 20 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-20-the-awesome-errors-of-perl-6/</guid>
      <description>The Awesome Errors of Perl 6 如果你一直在读技术相关的东西，你现在可能知道 Rust 里面的令人惊喜的错误报告能力。 既然 Perl 6 也因它的绝妙的错误处理而闻名, mst 查询了一些例子来炫耀 rust 的错误处理能力, 但是不幸的是我没有发现。
我尽力避免错误并且我很少完整地读完它。所以我会搜寻一些很酷的关于令人惊叹的错误方面的例子并写出来。虽然我能够用头撞击键盘并把输出粘贴出来, 但是那将会惨不忍读, 所以我会谈论一些对初学者来说没那么明显的棘手的错误, 还有怎样修复那些错误。
让我们开始用头部猛击吧!
基础 下面是一段有错误的代码;
say &amp;quot;Hello world!; say &amp;quot;Local time is {DateTime.now}&amp;quot;; # ===SORRY!=== Error while compiling /home/zoffix/test.p6 # Two terms in a row (runaway multi-line &amp;quot;&amp;quot; quote starting at line 1 maybe?) # at /home/zoffix/test.p6:2 # ------&amp;gt; say &amp;quot;Local time is {DateTime.now}&amp;quot;; # expecting any of: # infix # infix stopper # postfix # statement end # statement modifier # statement modifier loop  第一行丢失了字符串上的闭合引号, 所以直到第二行的开括号之间的所有东西都会被认为是字符串的一部分。一旦推测的闭合引号被找到, Perl 6 就看到单词 &amp;ldquo;Local&amp;rdquo;, 这个单词被定义为一个项(item)。因为在 Perl 6 中一行中同时存在两个项(item)是不允许的, 所以编译器抛出了错误, 并对它所期望的提供了一些建议, 并且它探测到了我们正处在一个字符串中, 并且建议我们检测, 我们忘记在行 1 中闭合引号了。</description>
    </item>
    
    <item>
      <title>roundrobin</title>
      <link>https://ohmysummer.github.io/post/2016-07-18-roundrobin/</link>
      <pubDate>Mon, 18 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-18-roundrobin/</guid>
      <description>定义为
multi roundrobin(List:D: --&amp;gt; Seq)  用法
roundrobin LISTS  Round-Robin Merge Two Lists of Different Length roundrobin很像 zip。不同之处是, roundrobin不会在用光元素的列表上停止而是仅仅跳过任何未定义的值：
my @a = 1; my @b = 1..2; my @c = 1..3; for flat roundrobin(@a, @b, @c) -&amp;gt; $x { $x.say } # 1,1,1,2,2,3  它只是跳过了未定的值, 直到最长的那个列表的元素用完。
my @list1 = &#39;a&#39; .. &#39;h&#39;; my @list2 = &amp;lt;x y&amp;gt;; say flat roundrobin @list1, @list2; # a x b y c d e f g h  roundrobin 返回的是一列 Seq, 所以使用 flat 进行展开。</description>
    </item>
    
    <item>
      <title>副词的Pair形式</title>
      <link>https://ohmysummer.github.io/post/2016-07-16-%E5%89%AF%E8%AF%8D%E7%9A%84pair%E5%BD%A2%E5%BC%8F/</link>
      <pubDate>Sat, 16 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-16-%E5%89%AF%E8%AF%8D%E7%9A%84pair%E5%BD%A2%E5%BC%8F/</guid>
      <description>副词的 Pair 形式 S02-literals/adverbs.t lines 6–69
现在有一个普通的副词形式的 Pair 记号，也是人们所熟知的 &amp;ldquo;colon pair&amp;rdquo;（冒号对）形式。下面的表格展示了和胖箭头记号相一致的记号：
Fat arrow Adverbial pair Paren form ========= ============== ========== a =&amp;gt; True :a a =&amp;gt; False :!a a =&amp;gt; 0 :a(0) a =&amp;gt; $x :a($x) a =&amp;gt; &#39;foo&#39; :a&amp;lt;foo&amp;gt; :a(&amp;lt;foo&amp;gt;) a =&amp;gt; &amp;lt;foo bar&amp;gt; :a&amp;lt;foo bar&amp;gt; :a(&amp;lt;foo bar&amp;gt;) a =&amp;gt; «$foo @bar» :a«$foo @bar» :a(«$foo @bar») a =&amp;gt; {...} :a{...} :a({...}) a =&amp;gt; [...] :a[...] :a([...]) a =&amp;gt; $a :$a a =&amp;gt; @a :@a a =&amp;gt; %a :%a a =&amp;gt; &amp;amp;a :&amp;amp;a a =&amp;gt; %foo&amp;lt;a&amp;gt; %foo&amp;lt;a&amp;gt;:p  胖箭头结构应只用于项(term)所在位置因为它被认为是一个独立的表达式，因为胖箭头自身被解析为一个普通的中缀操作符（即使自动引起它左侧的标识符时）。因为左侧是一个普通的表达式，胖箭头形式会使用任何值作为键来创建 Pair。另一方面，当用上面的形式来生成 Pair 对象时，副词形式被约束为使用标识符作为键。在键不是标识符的地方，你必须使用胖箭头形式来生成 Pair。</description>
    </item>
    
    <item>
      <title>given when</title>
      <link>https://ohmysummer.github.io/post/2016-07-09-given-when/</link>
      <pubDate>Sat, 09 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-09-given-when/</guid>
      <description>given-when 有两个小的改变, 并且这俩改变都是开启新行为的, 而不是限制已存在的行为。
第一个小的改变: when 的开关行为不仅仅是用于 given 块儿中的, 而是可以用在任何&amp;rdquo;主题化&amp;rdquo;的块儿中的, 例如 for 循环中或接收 $_作为参数的子例程中。
given $answer { when &amp;quot;Atlantis&amp;quot; { say &amp;quot;那是对的&amp;quot; } default { say &amp;quot;BZZZZZZZZZZZZZ!&amp;quot; } } for 1..100 { when * %% 15 { say &amp;quot;Fizzbuzz&amp;quot; } when * %% 3 { say &amp;quot;Fizz&amp;quot; } when * %% 5 { say &amp;quot;Buzz&amp;quot; } default { say $_ } } sub expand($_) { when &amp;quot;R&amp;quot; { say &amp;quot;红警&amp;quot; } when &amp;quot;G&amp;quot; { say &amp;quot;绿警&amp;quot; } when &amp;quot;B&amp;quot; { say &amp;quot;蓝警&amp;quot; } default { say $_ } }  但是甚至不接受 $_作为参数的子例程也得到了它们自己的词法变量 $_供修改。所以规则就是&amp;rdquo;现在, 在 $_ 中有某些我能启动的好东西吗&amp;rdquo;。如果我们想要, 我们甚至能自己设置 $_。</description>
    </item>
    
    <item>
      <title>It&#39;s blocks all the way down</title>
      <link>https://ohmysummer.github.io/post/2016-07-07-its-blocks-all-the-way-down/</link>
      <pubDate>Thu, 07 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-07-its-blocks-all-the-way-down/</guid>
      <description>It’s blocks all the way down
当我在 glot.io 上玩 Perl 6 的时候我知道它们真的很像带有简单程序的 docker：
dir(&#39;/&#39;)&amp;gt;&amp;gt;.Str.say;  我想知道递归到目录里面是否还有更好的方法。 IO::Path.dir 会返回一个 IO::Path 对象的 Seq 序列。那就是为什么 &amp;gt;&amp;gt;. 超运算符会有效。它当然不会递归因为没有用来进行递归的子例程, 经过一段时间的冥思苦想我找到了我找了很久的东西。
在 Perl 6 中带有一个位置参数的 block 块是可调用的(Callable)。那个参数被绑定给主题变量 $_。 那是我们为什么能做:
for 1,2,3 {.say}  递归到目录中会很容易如果我们把 Str &#39;/&#39; 变成 IO::Path 对象并且检测我们是否得到了一个目录并且使用那个元素调用那个 block 块。那个 block 块需要一个名字, 这个我们可以通过使用 my &amp;amp;block = {Nil} 做到, 或者我们使用编译时变量 &amp;amp;?BLOCK。
for &#39;.&#39; { .Str.say when !.IO.d; .IO.dir()&amp;gt;&amp;gt;.&amp;amp;?BLOCK.IO.d }  .&amp;amp;?BLOCK 形式会把调用看作像方法调用一样, 这意味着 . 号左侧的对象会成为调用的第一个参数, 在调用者所属的地方。</description>
    </item>
    
    <item>
      <title>Perl 6 中的梳子!</title>
      <link>https://ohmysummer.github.io/post/2016-07-07-perl6%E4%B8%AD%E7%9A%84%E6%A2%B3%E5%AD%90/</link>
      <pubDate>Thu, 07 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-07-perl6%E4%B8%AD%E7%9A%84%E6%A2%B3%E5%AD%90/</guid>
      <description>Perl 6 中的梳子! 在 Perl 5 中, 我很感激有这样两个便利的结构:
my @things = $text =~ /thing/g; my %things = $text =~ /(key)...(value)/g;  你拿出一小段可以预见的文本，并给它一个正则表达式，吼吼, 你得到了一个列表和散列，像变魔术一般！我们也可以在 Perl 6 中使用正则表达式，但是 comb 更适合做这个工作。
Plain &amp;lsquo;Ol Characters 你可以把 comb 用作子例程或方法。在它的最基本的形式中， comb 会把字符串分解为字符:
&#39;foobar moobar 駱駝道bar&#39;.comb.join(&#39;|&#39;).say; &#39;foobar moobar 駱駝道bar&#39;.comb(6).join(&#39;|&#39;).say; # OUTPUT: # f|o|o|b|a|r| |m|o|o|b|a|r| |駱|駝|道|b|a|r # foobar| mooba|r 駱駝道b|ar  不适用任何参数的 comb 你会得到各个单独的字符。给 comb 提供一个整数 $n, 那么你会得到长度至多为 $n 个字符的一个列表，并且如果没有剩下的字符不够的话，这个列表会接收较短的这个字符串。这个方法比使用正则表快了 30 倍。
Limits 你也可以为 comb 提供第二个整数参数，即 *limit*，来标示每个列表中最多含有 limit 个元素:</description>
    </item>
    
    <item>
      <title>Perl 6 中的正则表达式(二)</title>
      <link>https://ohmysummer.github.io/post/2016-06-29-perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%8C/</link>
      <pubDate>Wed, 29 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-29-perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%8C/</guid>
      <description>允许的修饰符 有些修饰符能在所有允许的地方出现, 但并非所有的都这样.
通常, 影响 regex 编译的修饰符( 像 :i ) 一定要在编译时被知道. 只影响行为而非 regex本身的修饰符(eg. :pos, :overlap, :x(4)) 可能只出现在引用某个调用的结构上(例如 m// 和s///), 并且不会出现在 rx// 上. 最后, 重叠在替换结构中是不被允许的, 而影响修改的副词只允许出现在替中.
这些准则导致了下面的 rules:
 :ignorecase, :ignoremark, :sigspace, :ratchet 和  :Perl5 修饰符和它们的便捷形式允许出现在 regex 中的任何地方, 还有 m//, rx// 和s/// 结构中. 一个 regex实现可能要求它们的值在编译时是被知晓的, 而如果不是这种情况则给出编译时错误信息.  rx:i/ hello / # OK rx:i(1) /hello/ # OK my $i = 1; rx:i($i) /hello/ # may error out at compile time   :samecase, :samespace 和 :same mark 修饰符(还有它们的便捷形式) 只允许出现在替换结构上 (s/// 和 s[] = .</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2011)</title>
      <link>https://ohmysummer.github.io/post/2016-06-28-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2011/</link>
      <pubDate>Tue, 28 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-28-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2011/</guid>
      <description>2011 The Flip-Flop operator Perl5有一个二元操作符叫做flip-flop,它为假直到它的第一个参数被计算为真，然后它保持真(反转)，直到第二个参数计算为真，然后在那里它又变成假(flop)。 这真是太有用了，以至于Perl6也有flip-flop,只是它拼写为ff,并有一些变异：
ff ff^ ^ff ^ff^  音调符号^意味着在那个结尾跳过结尾。 …或许一些例子更能说明问题…
for 1..20 { .say if $_ == 9 ff $_ == 13; } # 9 10 11 12 13 for 1..20 { .say if $_ == 9 ff^ $_ == 13; } # 9 10 11 12 for 1..20 { .say if $_ == 9 ^ff $_ == 13; } # 10 11 12 13 for 1.</description>
    </item>
    
    <item>
      <title>S06-Subroutines</title>
      <link>https://ohmysummer.github.io/post/2016-06-27-s06-subroutines/</link>
      <pubDate>Mon, 27 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-27-s06-subroutines/</guid>
      <description>原文Subroutines
标题 概要 6: 子例程
版本 创建于: 2003 年 5 月 21
上一次更新: 2015 年 10 月 16
版本: 169
该文档总结了概要 6, 其中涵盖了子例程和新的类型系统。
子例程和其它 code 对象 Routine 是所有以关键字声明的 code blocks 的父类型。所有的 routines(程序)生来就带有未定义的 $_、$!和$/ 值, 除非该 routine 显式地声明了它们。一个编译单元, 例如模块文件或 EVAL 字符串, 也被看作是 routine, 要不然你就不能引用它们里面的 $! 或 $/。
使用 -&amp;gt; 声明或使用裸花括号的非-routine 的 code Blocks, 生来只有 $_, 它被别名到它的 OUTER::&amp;lt;$_&amp;gt; 上, 除非被绑定为参数。 block 通常使用由最里面的闭合 routine 所定义的 $! 和 $/, 除非在 block 中显式地声明了 $! 或 $/。</description>
    </item>
    
    <item>
      <title>给标题添加换行</title>
      <link>https://ohmysummer.github.io/post/2016-06-19-%E7%BB%99%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%8D%A2%E8%A1%8C/</link>
      <pubDate>Sun, 19 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-19-%E7%BB%99%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%8D%A2%E8%A1%8C/</guid>
      <description>简书太扯了, 不管是什么空格都替换掉了。 开门见山, 废话不多说。如果非标题行在标题行上面, 那么这俩行之间会有一段空白, 但是你肯定遇到过:
这个标题会和下面的非标题行贴在一块 即使我在这一行换行也于事无补, 它们被简书吃掉啦。这不能忍! 看起来很丑有没有？下面我们就来解决这个问题, 手动在这一行的上面加上一个全角的空格, 就 okay 了。
问题似乎已经解决了, 但是我不能够。必须写个程序来帮我们解决这烦人的问题。方法就是在标题行后面添加一个换行符和一个全角空格（测试后行不通, 还是被吃, 换成 &amp;lt;br&amp;gt; 吧）。
use v6; for dir(test =&amp;gt; /\. md|markdown $/) -&amp;gt; $file { my $out = open $file ~ &#39;.txt&#39;, :w; my @lines = $file.lines; for @lines -&amp;gt; $line is rw { if $line ~~ /^\s*$/ { $out.say($line); next; } $line ~~ s/^ (&#39;#&#39; ** 1..7 .*?) $/$0\n &amp;lt;br&amp;gt;/ unless $line ~~ /^\s*&#39;```&#39;\s*(\w+)?</description>
    </item>
    
    <item>
      <title>Perl 6 FAQ</title>
      <link>https://ohmysummer.github.io/post/2016-06-06-perl-6-faq/</link>
      <pubDate>Mon, 06 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-06-perl-6-faq/</guid>
      <description>源文件可以在 github 或 perl6.org上找到.
General Rakudo 和 Perl 6 的区别是什么？ Rakudo 是 Perl 6 的一个实现。目前它是完成度最好的但是过去也有其它的实现, 将来也可能会有其它实现。Perl 6 是语言的定义。很多场合
这两个名字可以宽松地使用并互相替换。
会有 Perl 6 版本 6.0.0 吗? 第一个稳定语言版本的版本称为 v6.c，而不是 6.0.0。 不同的命名方案使得不太可能发布具有精确版本 6.0.0 的语言。
您可以使用下面的代码检查您的 Rakudo 编译器是当前至少是什么版本（注意这可能不是真正的供应商二进制文件）：
perl6 -e &#39;say q[too old] if $*PERL.version before Version.new(q[6.c])&#39;  它首先由 Rakudo Perl 6 编译器版本的 2015.12 实现，并且可能通过使用 &amp;lsquo;use 6.c&amp;rsquo; 指令在可预见的未来支持后续版本。 下一个语言版本（无发布日期）为 v6.d.
作为一个 Perl 6 初学者我应该安装什么？ 如果你是一个 Linux 或 Mac 用户, 你可能需要下载 Rakudo Star 并通过编译 MoarVM 版本安装（一个简单的处理）</description>
    </item>
    
    <item>
      <title>Perl 6 中的 Subscripts</title>
      <link>https://ohmysummer.github.io/post/2016-06-01-perl6%E4%B8%AD%E7%9A%84subscripts/</link>
      <pubDate>Wed, 01 Jun 2016 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-01-perl6%E4%B8%AD%E7%9A%84subscripts/</guid>
      <description>Subscripts 通过索引或键访问数据结构中的元素。
通常，人们需要引用集合或数据结构中的一个特定的元素（或特定的元素切片）。从数学标记法中偷学到的，向量 v 的组成部分用 v₁, v₂, v₃ 来引用，在 Perl 6 中这个概念叫做 “下标” （或“索引”）。
Basics Perl 6 提供了两个通用的下标接口：
elements are identified by interface name supported by [ ] zero-based indices Positional Array, List, Buf, Match, ... { } string or object keys Associative Hash, Bag, Mix, Match, ...   Positional 下标 (通过 postcircumfix [ ] 通过元素在有序集合中的位置来寻址元素。)索引 0 引用第一个元素， 索引 1 引用第二个元素， 以此类推：  my @chores = &amp;quot;buy groceries&amp;quot;, &amp;quot;feed dog&amp;quot;, &amp;quot;wash car&amp;quot;; say @chores[0]; #-&amp;gt; buy groceries say @chores[1]; #-&amp;gt; feed dog say @chores[2]; #-&amp;gt; wash car   Associative 下标 (通过 postcircumfix { }), 不要求集合以任何特定的顺序保存元素 - 相反，它使用一个唯一的键来寻址每个值。键的种类取决于使用的集合： 举个例子， 一个标准的散列 使用字符串作为键， 而一个 Mix 能使用任意的对象作为键， 等等:  my %grade = Zoe =&amp;gt; &amp;quot;C&amp;quot;, Ben =&amp;gt; &amp;quot;B+&amp;quot;; say %grade{&amp;quot;Zoe&amp;quot;}; #-&amp;gt; C say %grade{&amp;quot;Ben&amp;quot;}; #-&amp;gt; B+ my $stats = ( Date.</description>
    </item>
    
    <item>
      <title>如何在Perl6中创建Grammar</title>
      <link>https://ohmysummer.github.io/post/2016-05-14-%E5%A6%82%E4%BD%95%E5%9C%A8perl6%E4%B8%AD%E5%88%9B%E5%BB%BAgrammar/</link>
      <pubDate>Sat, 14 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-05-14-%E5%A6%82%E4%BD%95%E5%9C%A8perl6%E4%B8%AD%E5%88%9B%E5%BB%BAgrammar/</guid>
      <description>检查 module 的名字是否 遵循 Perl 6 的命名规范。模块的名字可以是使用 2 个冒号分割的标识符, 例如 File::Compare 。标识符必须以字母字符 (a-z) 或下划线开头， 后面跟着 0 个 或多个字母数字字符。但是并没有那么简单, 有些模块的名字只有一个标识符而没有冒号，例如 Bailador ， 而其它模块可能有多个标识符和 :: 组成。这看起来正符合 grammar 的胃口！
定义 grammar Perl 6 Grammars 是由 regexes 构建的。 我需要 2 个 regexes： 一个用于匹配标识符, 一个用于匹配双冒号分隔符。对于标识符 regex， 我使用：
&amp;lt;[A..Za..z_]&amp;gt; # begins with letter or underscore &amp;lt;[A..Za..z0..9]&amp;gt; ** 0..* # zero or more alpanumeric  Perl 6 中，字符类是使用 &amp;lt;[ ... ]&amp;gt; 来定义的， 范围是使用 范围操作符 .. 代替了短划线 -.</description>
    </item>
    
    <item>
      <title>Actions 和抽象语法树</title>
      <link>https://ohmysummer.github.io/post/2016-05-12-actions%E5%92%8C%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/</link>
      <pubDate>Thu, 12 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-05-12-actions%E5%92%8C%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/</guid>
      <description>有一段结构化的文本, 写一个 Grammar 来解析它：
name = Animal Facts author = jnthn [cat] desc = The smartest and cutest cuteness = 100000 [dugong] desc = The cow of the sea cuteness = -10 [magpie] desc = crow; raven; rook; jackdaw; chough; magpie; jay cuteness = 99  每一段都是一个章节, 有的章节没有[cat]这样的标题, 要求 grammar 生成一个散列, 散列的键是方括号中的单词, 如果没有就默认为 _ , 散列的值是一个散列的数组, 数组里面的每个散列的键为等号左边的单词, 键值为等号右边的字符。Grammar 如下:
use v6; #use Grammar::Debugger; grammar INIFile::Grammar { token TOP { ^ &amp;lt;entries&amp;gt; # 条目 &amp;lt;section&amp;gt;+ # 章节 $ } token section { &#39;[&#39; ~ &#39;]&#39; &amp;lt;key&amp;gt; \n &amp;lt;entries&amp;gt; # 每个章节含有多个条目 entry } token entries { [ | &amp;lt;entry&amp;gt; \n | \n # entry 可以为空 ]+ } token entry { &amp;lt;key&amp;gt; \h* &#39;=&#39; \h* &amp;lt;value&amp;gt; } token key { \w+ } token value { \N+ } } class INIFileActions { method entries($/) { my %entries; for $&amp;lt;entry&amp;gt; -&amp;gt; $e { %entries{$e&amp;lt;key&amp;gt;} := ~$e&amp;lt;value&amp;gt;; } make %entries; } method TOP($/) { my %result; %result&amp;lt;_&amp;gt; := $&amp;lt;entries&amp;gt;.</description>
    </item>
    
    <item>
      <title>列表解析</title>
      <link>https://ohmysummer.github.io/post/2016-05-11-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-05-11-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>列表解析 列表解析即 List Comprehensions。
生成 1x1, 2x2, 3x3, ..., 10x10 的列表：
($_**2 for 1..10);  for 语句前面还可以添加 if 修饰符，这样我们就可以仅筛选出偶数的平方：
($_**2 if !($_ % 2) for 1..10) ($_**2 if $_ % 2 == 1 for 1..10) # 同上  组合多个 if 条件:
my @list = ($_ if $_ %2 == 1 &amp;amp;&amp;amp; $_ &amp;gt; 2 for 1..6 ) # [3 5]  还可以生成全排列：
($_ for &amp;quot;ABC&amp;quot;.comb X~ &amp;quot;XYZ&amp;quot;.comb) # (&amp;quot;AX&amp;quot;, &amp;quot;AY&amp;quot;, &amp;quot;AZ&amp;quot;, &amp;quot;BX&amp;quot;, &amp;quot;BY&amp;quot;, &amp;quot;BZ&amp;quot;, &amp;quot;CX&amp;quot;, &amp;quot;CY&amp;quot;, &amp;quot;CZ&amp;quot;) my @a = (1,3,4) my @b = (2,4,6) my @list = (@a X @b) # 这儿也可以用圆括号, 也可以不用 # [(1 2) (1 4) (1 6) (3 2) (3 4) (3 6) (4 2) (4 4) (4 6)]  &amp;gt; ($_ when /7$/ for 1.</description>
    </item>
    
    <item>
      <title>输入Unicode字符</title>
      <link>https://ohmysummer.github.io/post/2016-05-11-%E8%BE%93%E5%85%A5unicode%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-05-11-%E8%BE%93%E5%85%A5unicode%E5%AD%97%E7%AC%A6/</guid>
      <description>输入 Unicode 字符 Perl 6 允许把 unicode 字符用作变量名. 很多操作符使用 unicode 符号(特别是在 set/bag 操作符中)还有一些引号结构. 因此, 知道如何把这些符号输入编辑器, Perl 6 shell 和 命令行中是极好的, 特别是现实键盘中不存在那个符号的时候.
在各种操作系统和环境下关于输入 unicode 字符的通用信息可以在 Wikipedia unicode input page 中找到.
编辑器和 shell Vim 在 Vim 中, unicode 字符是通过先按 Ctrl-V(也表示为 ^V), 然后按下 u 和 要输入的 unicode 字符的十六进制值来输入的(在插入模式). 例如, 希腊字母 λ (lambda) 是通过组合键来输入的:
^Vu03BB  更多关于在 Vim 中输入特殊字符的信息可以在 Vim Wikia 页 entering special characters 中找到.
Emacs 在 Emacs 中, unicode 字符的输入是首先输入和弦 Ctrl-x 8 Enter , 然后再输入 unicode 代码点的十六进制数字, 然后回车.</description>
    </item>
    
    <item>
      <title>Perl 6 中的操作符(二)</title>
      <link>https://ohmysummer.github.io/post/2016-05-02-perl6%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BA%8C/</link>
      <pubDate>Mon, 02 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-05-02-perl6%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BA%8C/</guid>
      <description>infix:&amp;lt;&amp;hellip;&amp;gt;, 序列操作符.  作为一个中缀操作符， ... 操作符的左右两侧都有一个列表，并且为了产生想要的值的序列，序列操作符 ... 会尽可能地对序列进行惰性求值。列表被展平后求值。就像所有的中缀操作符一样， &amp;hellip; 序列操作符比逗号的优先级要低，所以你没必要在逗号列表的两侧加上圆括号。
序列操作符 ... 以右侧列表的第一个值开始。这只在右侧的列表中， &amp;hellip; 序列操作符唯一感兴趣的值；any additional list elements are treasured up lazily to be returned after the &amp;hellip; is done.
&amp;hellip; 右侧的第一个值是序列的端点或界限，这是序列操作符 &amp;hellip; 从左侧生成的。
一旦我们知道了序列的边界，左侧的列表会一项一项地被求值，并且普通数字或字符串值被无差异地传递（在右侧边界允许的程度内）如果序列中的任何值匹配到边界值，序列会终止，包括那个最后的边界值在内。要排除边界值，使用 &amp;hellip;^ 代替。
在内部，这两种形式用于检测匿名的循环是否会终止，而循环返回序列中的值。假设下一个候选的值存储在 $x 中，并且右侧序列中的第一个值存储在 $limit 中，这两个操作符各自实现为：
... last($x) if $x ~~ $limit; ...^ last if $x ~~ $limit;  如果边界是 * ,序列就没有界限。如果边界是一个闭包，它会在当前候选对象中进行布尔真值求值，并且序列会一直继续只要闭包返回false。如果边界是一个含有一个或无限参数的闭包，
my $lim = 0; 1,2,3 ...^ * &amp;gt; $lim # returns (), since 1 &amp;gt; 0  这个操作符如果只能把左边的值原样返回就太乏味了。它的强大来自于能从旧值生成新值。你可以，例如，使用一个存在的生成器产生一个无穷列表：</description>
    </item>
    
    <item>
      <title>Perl 6 From Wikipedia</title>
      <link>https://ohmysummer.github.io/post/2016-04-26-perl-6-from-wikipedia/</link>
      <pubDate>Tue, 26 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-26-perl-6-from-wikipedia/</guid>
      <description>Perl 6 是 Perl 编程语言家族中的一员. 它仍旧在开发中, 几个解释器和编译器在同时进行. 它引入了很多现代和历史语言的元素. Perl 6 打算有很多实现. 和 Perl 5 兼容不是它的目标, 尽管兼容模式是它的计划书的一部分. Perl 6 的设计程序是从 2000 年开始的. 2015 年 9 月 预期会发布候选版, 并在 12 月 发布最终版.
Perl 6 第一个完成度最高的实现是 Pugs , 开始于 2005 年, 今天已经有多个 Perl 6 实现的工程了. Rakudo Perl 是基于 NQP (Not Quite Perl) 并使用 MoarVM 或 Java 虚拟机 作为运行时环境的一个 Perl 6 实现, 并且每个月会发布一个新版本; 在 2010 年 七月, 该项目发布了第一次 Rakudo Star 分发, 一个有用和可用的 Perl 6 实现和相关东西的集合.</description>
    </item>
    
    <item>
      <title>Meta Operator</title>
      <link>https://ohmysummer.github.io/post/2016-04-25-meta-operator/</link>
      <pubDate>Mon, 25 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-25-meta-operator/</guid>
      <description>快速构造散列 &amp;gt; my %hash = @lowers Z=&amp;gt; @nums a =&amp;gt; 1, b =&amp;gt; 2, c =&amp;gt; 3  未完待续</description>
    </item>
    
    <item>
      <title>Perl 6 中的特性(一)</title>
      <link>https://ohmysummer.github.io/post/2016-04-22-perl6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%80/</link>
      <pubDate>Fri, 22 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-22-perl6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%80/</guid>
      <description>基础 数组 切片, 索引, Zen
use v6; my @primes = (2,3,5,7,11,13,17,19,23); # an array gets filled like in Perl 5 # my @primes = 2,3,5,7,11,13,17,19,23 ; # same thing, since unlike P5 round braces just do group # my @primes = &amp;lt;2 3 5 7 11 13 17 19 23&amp;gt;; # dito, &amp;lt;&amp;gt; is the new qw() say @primes[]; # 2 3 5 7 11 13 17 19 23 my $arrayref = [2,3,5,7,11,13,17,19,23]; # in scalar context you get automatically a reference say @$arrayref; # 2 3 5 7 11 13 17 19 23 my $arrayref = item @primes; # same thing, more explicit say $arrayref; my $arrayref = [13,]; # comma is the new array generator say $arrayref; my @primes = 2; # array with one element my @primes = [2,3,5,7,11,13,17,19,23]; # array with one element (arrayref) say @primes; # 2 3 5 7 11 13 17 19 23 my @dev = {&#39;dan&#39; =&amp;gt; &#39;parrot&#39;}; # array with one element (hashref) say @dev; # (&amp;quot;dan&amp;quot; =&amp;gt; &amp;quot;parrot&amp;quot;).</description>
    </item>
    
    <item>
      <title>Perl 6 中的签名</title>
      <link>https://ohmysummer.github.io/post/2016-04-12-perl6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/</link>
      <pubDate>Tue, 12 Apr 2016 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-12-perl6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/</guid>
      <description>签名也是对象 class Signature {}  签名是代码对象参数列表的静态描述。即, 签名描述了你需要什么参数和多少参数传递给代码或函数以调用它们。
传递参数给签名把包含在 Capture 中的参数绑定到了签名上。
&amp;gt; sub a($a, $b) {}; &amp;gt; &amp;amp;a.signature.perl.say :($a, $b) &amp;gt; my $b = -&amp;gt; $a, $b {}; &amp;gt; $b.signature.perl.say :($a, $b)  签名是一个对象, 就像 Perl 6 中的任何其它东西一样。 任何 Callable 类型中都有签名, 并且它能使用 .signature方法获取到。
class Signature { ... }  签名字面量 签名出现在子例程和方法名后面的圆括号中, 对于 blocks 签名出现在 -&amp;gt;或 &amp;lt;-&amp;gt; 箭头后面, 或者作为变量声明符(例如 [my](https://docs.perl6.org/syntax/my) )的输入, 或者以冒号开头作为单独的项。
sub f($x) { } # ^^^^ sub f 的签名 method x() { } # ^^ 方法 x 的签名 my $s = sub (*@a) { } # ^^^^^ 匿名函数的签名 for &amp;lt;a b c&amp;gt; -&amp;gt; $x { } # ^^ Block 的签名 my ($a, @b) = 5, (6,7,8); # ^^^^^^^^ 变量声明符的签名 my $sig = :($a, $b); # ^^^^^^^^ 独立的签名对象  签名字面量可以用于定义回调或闭包的签名。</description>
    </item>
    
    <item>
      <title>reddit编程题-詹妮的水果篮</title>
      <link>https://ohmysummer.github.io/post/2016-04-12-reddit%E7%BC%96%E7%A8%8B%E9%A2%98-%E8%A9%B9%E5%A6%AE%E7%9A%84%E6%B0%B4%E6%9E%9C%E7%AF%AE/</link>
      <pubDate>Tue, 12 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-12-reddit%E7%BC%96%E7%A8%8B%E9%A2%98-%E8%A9%B9%E5%A6%AE%E7%9A%84%E6%B0%B4%E6%9E%9C%E7%AF%AE/</guid>
      <description>问题描述 小詹妮拿着 5 美元去超市买东西, 为新搬来的邻居买水果篮礼物。因为她是个勤奋并缺乏想象力的孩纸, 她打算正好花 5 美元, 不多也不少。
事实上超市里水果的价格并非整数, 正好花光 5 美元并不容易。 - 但是詹妮已经准备好了。她从背包里拿出上网本, 输入她看到过的水果的单价, 并且开启了一个程序为她收集 — 就是这样, 5 美元能买的水果的组合就出现在屏幕上。
挑战 : 用你选择的语言展示詹妮的程序是什么样子。
 目标就是 500 美分 (等于 5 美元) 解决方法可以包含多种同类型的水果 - 假设它们数量没有限制 解决方法没有必要包含所有水果类型 对给定的输入检测所有可能的方法  输入描述 每行一种水果 — 规定了水果的名字(不含空格的单词)和水果的单价(单位为美分, 整数)
输出描述 每个解决方法一行 — 用以逗号分割的数量+名字对儿, 描述了那种类型要买的水果数。
不要列出数量为 0 的水果。 如果为复数就给名字加 s。
输入样本 banana 32 kiwi 41 mango 97 papaya 254 pineapple 399  输出样本 6 kiwis, 1 papaya 7 bananas, 2 kiwis, 2 mangos  有挑战的输入 apple 59 banana 32 coconut 155 grapefruit 128 jackfruit 1100 kiwi 41 lemon 70 mango 97 orange 73 papaya 254 pear 37 pineapple 399 watermelon 500  注意, 这种输入有 180 种解决方法。</description>
    </item>
    
    <item>
      <title>正则替换</title>
      <link>https://ohmysummer.github.io/post/2016-04-07-%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2/</link>
      <pubDate>Thu, 07 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-07-%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2/</guid>
      <description>想把 Desgin Perl 6 中的 pod/html 转为 Markdown 格式, Perl 6 的 pod2markdown 不能用, 只能下载 html 格式的了, 然后用 pandoc test.html -o result.markdown 转换了, 但是也不理想, 里面还有很多 html 标签, 写个脚本批量替换下吧。 token 中的空白要显式地使用 \s、\h、\t 等表示, rule 中 :sigspace 是开启的。程序很丑, 仅仅是记录一下。
use v6; my rule r1 {&#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;line_\\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39; &#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;line_\\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;( &#39;&amp;lt;&#39;span)?$} my rule r2 {id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39; &#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;( &#39;&amp;lt;&#39;span)?$} my rule r3 {^id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;$} my rule r4 {&#39;&amp;lt;&#39;div class\=&#39;&amp;quot;&#39;smartlink&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;} my rule r5 {&#39;&amp;lt;&#39;&#39;/&#39;div&#39;&amp;gt;&#39;} my rule r6 {&#39;&amp;lt;&#39;div class\=&#39;&amp;quot;&#39;indexgroup&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;} my rule r7 {&#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;__top&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;} my token r8 {^ \s* &#39;&amp;lt;&#39;span$} my rule r9 {^id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39; &#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;$} my rule r10 {id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39; &#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;(\s&#39;&amp;lt;&#39;span)?</description>
    </item>
    
    <item>
      <title>Perl 6 中的术语</title>
      <link>https://ohmysummer.github.io/post/2016-03-26-perl6%E4%B8%AD%E7%9A%84%E6%9C%AF%E8%AF%AD/</link>
      <pubDate>Sat, 26 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-26-perl6%E4%B8%AD%E7%9A%84%E6%9C%AF%E8%AF%AD/</guid>
      <description>匿名 子例程、方法或子方法，当它们不能通过名字调用时，就被称为匿名的
# named subroutine sub double($x) { 2 * $x }; # 匿名子例程,存储在一个具名的标量里 my $double = sub ($x) { 2 * $x };  注意，匿名子例程仍然可以有名字
# 使用 anon 关键字使子例程匿名 my $s = anon sub triple($x) { 3 * $x } say $s.name; # triple  副词 通常, 副词是函数的命名参数. 也有一些其它特殊语法形式允许副词出现在某些合适的地方:
q:w&amp;quot;foo bar&amp;quot; # &amp;quot;:w&amp;quot; is a Quotelike form modifier adverb m:g/a|b|c/ # &amp;quot;:g&amp;quot; is also 4 +&amp;gt; 5 :rotate # &amp;quot;:rotate&amp;quot; is an operator adverb @h{3}:exists # &amp;quot;:exists&amp;quot; is also, but is known as a subscript adverb  副词通常使用冒号对儿标记来表示, 因为这个原因, 冒号对儿标记法也以副词对儿形式著称:</description>
    </item>
    
    <item>
      <title>Perl 6 中的操作符(三)</title>
      <link>https://ohmysummer.github.io/post/2016-03-23-perl6%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%89/</link>
      <pubDate>Wed, 23 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-23-perl6%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%89/</guid>
      <description>范围和范围迭代器语法 .. 范围操作符有各种在两端带有 ^符号的变体以表明把那个端点排除在范围之外。 它总会产生一个 Range 对象。 Range 对象是不可变的， 主要用于匹配间隔。
1..2 是从1到2包含端点的间隔， 而 1^..^2 不包含端点但是匹配任何在它俩之间的实数。
对于不同类型的数字参数， 范围会被强制为更宽的类型，所以：
1 .. 1.5  被看作为：
1.0 .. 1.5  这些强制由 multi 签名定义。（其它类型可能有不同的强制策略。）特别要说明的是， 使用 Range 作为末端是非法的：
0 ..^ 10 # 0 .. 9 0 .. ^10 # ERROR  如果范围右侧是非数字类型， 那么右侧的参数被强转为数字， 然后按上面那样使用。
因此，第二个参数中的 Array 类型会被假定用作数字， 如果左侧的参数是数字的话：
0 ..^ @x # okay 0 ..^ +@x # same thing  对于字符串也类似：
0 .. &#39;1.5&#39; # okay 0 .</description>
    </item>
    
    <item>
      <title>Perl 6 中的 Bailador Web 框架(简介)</title>
      <link>https://ohmysummer.github.io/post/2016-03-20-perl6%E4%B8%AD%E7%9A%84bailadorweb%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 20 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-20-perl6%E4%B8%AD%E7%9A%84bailadorweb%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</guid>
      <description>开始 Bailador Bailador 是对 Perl Dancer Web 开发框架的模仿。 安装方法：
panda install Bailador # or zef install Bailador  我们来创建一个脚本 first.pl，打印 &amp;ldquo;hello world&amp;rdquo;:
use v6; use Bailador; get &#39;/&#39; =&amp;gt; sub { &amp;quot;hello world&amp;quot; } baile;  运行：perl6 first.pl 它会启动一个小型的 Web 服务器，你可以在3000端口上访问它：
$ perl6 first.pl Entering the development dance floor: http://0.0.0.0:3000 [2016-05-05T12:57:31Z] Started HTTP server.  在 Bailador 中，我们需要把 HTTP 请求方法和服务器上的路径映射给一个匿名子例程, 这个子例程会返回它里面的内容。在这个例子中，我们把我们告诉它的网站根路径的 get HTTP 请求映射为返回字符串 hello world。如果你启动这个程序并用浏览器打开 http://0.0.0.0:3000/ 你就会看到这个文本。
我们还可以映射其它路径(path-es):</description>
    </item>
    
    <item>
      <title>用类来排序数组</title>
      <link>https://ohmysummer.github.io/post/2016-03-15-%E7%94%A8%E7%B1%BB%E6%9D%A5%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 15 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-15-%E7%94%A8%E7%B1%BB%E6%9D%A5%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>有多列数据, 序号, 学校, 课程 … 年份这几列。要如果学校和课程相同就根据年份倒序排列。
先按学校排序, 再按课程排序, 然后按年份倒序排序。
我定义一个类来进行多列数据的排序, 很方便：
class Course { has Int $.numb; has Str $.univ; has Str $.dis; has Int $.paper; has Int $.cited; has Int $.year; } my @headers = &amp;lt;numb univ dis paper cited year&amp;gt;; my @courses; for $=finish.lines -&amp;gt; $line { next if $line ~~ /^num/; my @words = $line.words; @words[0, 3,4,5] = @words[0,3,4,5]».Int; my %h = @headers Z=&amp;gt; @words; my $course = Course.</description>
    </item>
    
    <item>
      <title>Using Perl 6(二)</title>
      <link>https://ohmysummer.github.io/post/2016-03-14-using-perl-6%E4%BA%8C/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-14-using-perl-6%E4%BA%8C/</guid>
      <description>捕获 签名不仅仅是语法，它们是含有一列参数对象的 first-class 对象 。同样地，有一种含有参数集的数据结构,叫捕获。捕获有位置和命名两个部分，表现的就像列表和散列。像列表的那部分含有位置参数，而像散列的那部分含有命名参数。
创建和使用捕获 无论你什么时间写下一个子例程调用，你就隐式地创建了一个捕获。然而，它随即被调用消耗了。有时，你想做一个捕获，存储它，然后将一个或多个子例程应用到它包含的一系列参数上。为了这，使用 n(&amp;hellip;) 语法。
my @tasks = n(39, 3, action =&amp;gt; { say $^a + $^b }), n(6, 7, action =&amp;gt; { say $^a * $^b });  这里，@tasks数组最后会包含两个捕获，每个捕获各含有两个位置参数和一个命名参数。捕获中的命名参数出现在哪并没有关系，因为他们是按名字传递，而非按位置。就像数组和散列，使用 | ，捕获也能被展平到参数列表中去:
sub act($left, $right, :$action) { $action($left, $right); } for @tasks -&amp;gt; $task-args { act(|$task-args); }  However, in this case it is specifying the full set of arguments for the call, including both named and positional arguments.</description>
    </item>
    
    <item>
      <title>匿名状态变量的工作原理</title>
      <link>https://ohmysummer.github.io/post/2016-03-12-%E5%8C%BF%E5%90%8D%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 12 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-12-%E5%8C%BF%E5%90%8D%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</guid>
      <description>Anonymous State Variables And How They Work 当调试代码的时候, 我经常添加一个计数变量以用于循环, 所以我能跟踪发生了什么, 或我能在代码片段中处理正迭代的部分数据集:
my $event-no = 0; for get_events() -&amp;gt; $event { $event-no++; process-event($event); last if $event-no &amp;gt;= 5; }  如果你正在调试, 或者你正尝试在单行中节省空间, Perl 6 实际上有一个匿名状态变量(anonymous state variables)标记, 用不含名字的 $符号来标示(你还可以在很多可迭代对象身上使用 kv 方法来完成类似的东西, 但是匿名的 $ 更普遍。)
for get_events() -&amp;gt; $event { process-event($event); last if ++$ &amp;gt;= 5; }  然而, 注意; 下面这样的用法是没有效果的:
for get_events() -&amp;gt; $event { process-event($event); $++; last if $ &amp;gt;= 5; }  好了, 为什么是那样的？</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2009)</title>
      <link>https://ohmysummer.github.io/post/2016-03-11-perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2009/</link>
      <pubDate>Fri, 11 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-11-perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2009/</guid>
      <description>2009 有用的和有意思的循环 让我们来看一个基本的例子.
for 1, 2, 3, 4 { .say }  这是一个最简单清晰的语法的例子.在这并没有使用括号来包起整个列表的语句,象这种写法可以贯穿整个 Perl 6. 通常比起 Perl 5 来你没有必要写那么多的括号了.
很象 Perl 5 , 这个循环中的值会默认存到 $_ .在这个方法调用的 say 其实就是 $_.say.注意在 Perl 6 中,你不能直接只打一个 say 而不加参数,它会默认使用 $_ 来传参.你需要使用 .say 。要么明确的指定是 $_.
下面这个语法块并不是一个普通的块.它能通过一个尖的指向,来告诉你的 循环变量传进去的参数的名字 .
for 1, 2, 3, 4 -&amp;gt; $i { $i .say }  如果你调用的 return 内部有这个,将返回闭合的子函数. 这个尖尖也能取 多个 参数.象下面这样.
1 2 3
for 1, 2, 3, 4 -&amp;gt; $i , $j { &amp;quot;$i, $j&amp;quot; .</description>
    </item>
    
    <item>
      <title>token 和 rule 的区别</title>
      <link>https://ohmysummer.github.io/post/2016-03-11-token%E5%92%8Crule%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 11 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-11-token%E5%92%8Crule%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>在 grammar 中, 有两个 regex 的变体, rule 和 token。rule 默认不会回溯. rule 与 token 的一个重要区别就是, rule 这样的正则采取了 :sigspace 修饰符。 rule 实际上是
 regex :ratchet :sigspace { ... }  的简写. ratchet 这个单词的意思是: (防倒转的)棘齿, 意思它是不能回溯的! 而 :sigspace 表明正则中的空白是有意义的, 而 token 实际上是
 regex :ratchet { ... }  的简写。 所以在 token 中, 若不是显式的写上 \s、\h、\n 等空白符号, 其它情况下就好像空白隐身了一样, 虽然你写了, 但是编译器却视而不见。
use v6; use Grammar::Debugger; grammar Token::Rule::Difference { # 下面三者等价 # rule TOP { [\w+]+ % &#39; &#39; | [\d+]+ % &#39; &#39; } 等价于 # rule TOP { | [\w+]+ % &#39; &#39; | [\d+]+ % &#39; &#39; } 等价于 rule TOP { | [\w+]+ % &#39; &#39; | [\d+]+ % &#39; &#39; } } # $=finish.</description>
    </item>
    
    <item>
      <title>Perl 6 中的模式匹配</title>
      <link>https://ohmysummer.github.io/post/2016-03-09-perl6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-09-perl6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>模式匹配 my $name = &amp;quot;twostraws&amp;quot;; given $name { when &amp;quot;bilbo&amp;quot; { say &amp;quot;Hello, Bilbo Baggins!&amp;quot;} when &amp;quot;twostraws&amp;quot; { say &amp;quot;Hello, Paul Hudson!&amp;quot; } default { say &amp;quot;身份验证失败&amp;quot; } }  同时检查名字和密码 my $name = &amp;quot;twostraws&amp;quot;; my $password = &amp;quot;fr0st1es&amp;quot;; given ($name, $password) { when (&amp;quot;bilbo&amp;quot;, &amp;quot;bagg1n5&amp;quot;) { say &amp;quot;Hello, Bilbo Baggins!&amp;quot; } when (&amp;quot;twostraws&amp;quot;, &amp;quot;fr0st1es&amp;quot;) { say &amp;quot;Hello, Paul Hudson!&amp;quot; } default { say &amp;quot;你是谁?&amp;quot; } }  使用单个元组 my $authentication = (&amp;quot;twostraws&amp;quot;, &amp;quot;fr0st1es&amp;quot;); given $authentication { when (&amp;quot;bilbo&amp;quot;, &amp;quot;bagg1n5&amp;quot;) { say &amp;quot;Hello, Bilbo Baggins!</description>
    </item>
    
    <item>
      <title>Perl 6 中的正则表达式(一)</title>
      <link>https://ohmysummer.github.io/post/2016-03-08-perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80/</link>
      <pubDate>Tue, 08 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-08-perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80/</guid>
      <description>标题 Synopsis 5: Regexes and Rules
版本 创建于: 2002/06/24 上次修改: 2015/05/12 版本: 180  不论何时, 在 grammar 中引用递归模式时, 通常更偏好使用 token 和 rule, 而不是 regex.
概览 作为常规表达式记法的扩展, Perl 6 原生地实现了 Parsing Expression Grammars(PEGs). PEGs 要求你为有歧义的那部分提供一个 主从秩序. Perl 6 的 主从秩序 由一个多级的平局择优法测试决定:
 1) Most-derived only/proto hides less-derived of the same name 2) 最长 token 匹配: food\s+ beats foo by 2 or more positions 3) 最长字面值前缀: food\w* beats foo\w* by 1 position 4) 对于一个给定的 proto, multis from a more-derived grammar win 5) 在一个给定的编译单元中, 出现较早的备选分支或 multi 胜出.</description>
    </item>
    
    <item>
      <title>Perl 6 中的动态变量</title>
      <link>https://ohmysummer.github.io/post/2016-02-29-perl6%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 29 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-29-perl6%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</guid>
      <description>Perl 6 中的动态变量
$*ARGFILES  $*ARGFILES Magic command-line input handle.
 argfiles.pl6
use v6; $*ARGFILES.perl.say; #=&amp;gt; IO::Handle.new(:path(Any),:chomp) # 按行读取 for $*ARGFILES.lines -&amp;gt; $line { say &amp;quot;$line&amp;quot;; } # 一次性读取 # say $*ARGFILES.slurp;  USAGE
$ perl6 argfiles.pl6 file1 file2 file3 ...   class IO::Handle - Perl 6 Documentation Input/Output - Perl 6 Documentation Perl6文件操作 - Qiita  @*ARGS  @*ARGS - Arguments from the command line. 命令行中的参数。
 agrs.</description>
    </item>
    
    <item>
      <title>bless</title>
      <link>https://ohmysummer.github.io/post/2016-02-26-bless/</link>
      <pubDate>Fri, 26 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-26-bless/</guid>
      <description>bless 方法 method bless(*%attrinit) returns Mu:D  相比 new方法来说更低层级别的对象构造方法。
创建一个和调用者同类型的新对象, 使用具名参数来初始化属性, 并返回创建后的对象。
在自定义构造函数时可以使用该方法:
class Point { has $.x; has $.y; # multi 是可选的 multi method new($x, $y) { self.bless(:$x, :$y); } } # 重写构造函数后, 不需要传具名参数了 my $p = Point.new(-1, 1); say $p.x; # -1   虽然你可以自定义构造函数, 记得它会让子类继承变得更困难。
 use v6; # bless 的原理 class Dog { has $.name; my $.counter; # 类方法 # 重写 new 方法, 使用位置参数创建实例 method new ($newName) { $.</description>
    </item>
    
    <item>
      <title>Array language</title>
      <link>https://ohmysummer.github.io/post/2016-02-23-reddit-array-language/</link>
      <pubDate>Tue, 23 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-23-reddit-array-language/</guid>
      <description>[2015-12-09] Challenge #244 [Easy]er - Array language (part 3) - J Forks
Forks *fork 是一个接收三个函数作为参数的函数
给三个函数 f(y, x = defalut):, g(y, x = default):, h(y, x = default):, 其中函数 g 是含有两个参数的真实的函数。
然后调用 Fork(f, g, h)执行函数合成:
g(f(y, x), h(y, x)) (data1, data2)  1. 从字符串输入执行函数调用来产生字符串 sum divide count  (上面的输入是 Fork 函数的三个函数名)
2. 根据你喜欢的原生语言, 从上面的字符串输入中创建一个执行函数 3. 或创建一个接收三个函数作为输入的函数并返回一个函数 Fork(sum, divide, count) (array data)  应该返回数组的平均数。
4. 扩展上面的函数使函数参数接收基数 对于 5 个参数, Fork(a, b, c, d, e) 是:</description>
    </item>
    
    <item>
      <title>Perl 6 中的智能匹配</title>
      <link>https://ohmysummer.github.io/post/2016-02-19-perl6%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-19-perl6%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%B9%E9%85%8D/</guid>
      <description>智能匹配 这儿有一个标准 Perl 6（即在你的编译单元开始的时候所生效的 Perl 方言） 的智能匹配表格。智能匹配通常作用在当前「主题」(topic)上, 即作用在 $_ 变量上. 在下面的表格中, $_ 代表 ~~ 操作符的左侧, 或者代表 given 的参数, 或者代表其它主题化的参数。 X 代表 ~~ 操作符右侧要与之($_)相匹配的模式, 或者在 when 后面的模式。(并且, 实际上, ~~ 操作符充当着一个小型的主题(topicalizer); 即, 为了右侧的计算, 它把 $_ 绑定到左侧的值上。 使用底层的 .ACCEPTS 形式来避免这种主题化.)
第一节包含了特殊的(privileged)语法; 如果匹配能通过那些条目之一完成, 那它就会那样做。 这些特别的语法是通过它们的外形(form)而非它们的类型(type)进行分派的。 否则就使用表格中的剩余部分,并且匹配会根据正常的方法分派规则进行分派。 优化器(optimizer)被允许假定在编译时之后没有定义额外的匹配操作符, 所以, 如果在编译时模式类型就是显而易见的话, 那么跳转表(jump table)就可以被优化。 然而, 只要 ~~ 操作符是 Perl 中少有的几个不使用多重分派的操作符之一, 那么这部分表格的语法仍然有些特殊。 相反, 基于类型的智能匹配被直截了当地分派给了属于 X 模式对象的底层方法.
换句话说, 智能匹配首先根据模式(pattern)的外形/形式(form)或类型(下面的X)进行分派(dispatch), 然后那个模式自身决定是否关注和怎样关注主题($_)的类型。 所以, 下表中的第二列实际上是初始(primary)列。 第一列中的 Any 条目标示了模式要么不关心主题的类型, 要么挑选那个条目作为默认项, 因为上面列出的类型越具体，它越不匹配。
$_ X 所隐含的匹配类型 Match if (given $_) ====== ===== ===================== =================== Any True ~~ True (parsewarn on literal token) Any False ~~ False match (parsewarn on literal token) Any Match ~~ Successful match (parsewarn on literal token) Any Nil ~~ Benign failure (parsewarn on literal token) Any Failure Failure type check (okay, 与类型相匹配) Any * block 签名匹配 block 成功绑定到 |$_ Any Callable:($) item sub truth X($_)  S03-smartmatch/any-callable.</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2013)</title>
      <link>https://ohmysummer.github.io/post/2016-02-15-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2013/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-15-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2013/</guid>
      <description>2013 Heredocs, Theredocs, Everywheredocs docs So let’s say you’ve got a bit of documentation to print out, a help statement perhaps. You could use an ordinary string, but it always looks like something you really shouldn’t be doing.
sub USAGE { say &amp;quot;foobar Usage: ./foobar &amp;lt;args&amp;gt; &amp;lt;file&amp;gt; Options: ... &amp;quot;; }  Perl 6 has a much better idea for you, fortunately: heredocs! They work a bit differently from Perl 5, and are now invoked using the adverb :heredoc on quoting constructs:</description>
    </item>
    
    <item>
      <title>Perl 6 Examples</title>
      <link>https://ohmysummer.github.io/post/2016-02-14-perl-6-examples/</link>
      <pubDate>Sun, 14 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-14-perl-6-examples/</guid>
      <description>斐波拉契数列（Fibonacci Sequence）  analytic  use v6; sub fibonacci (Int $n where 0..* --&amp;gt; Int) { constant phi = (1 + sqrt 5) / 2; return round( phi**($n+1) / sqrt 5); } for 0..1000 -&amp;gt; $i { say $i.fmt(&#39;%3d&#39;), &#39;: &#39;, fibonacci($i); }  这种方法计算前1000个斐波拉契数大约为0.746s（2015.7.Rakudo, 以下都是）。
 迭代  use v6; sub fibonacci (Int $n) { state @sequence = 1,1; while @sequence.elems &amp;lt;= $n { @sequence.push( @sequence[*-2] + @sequence[*-1] ); } return @sequence[$n]; } for 0.</description>
    </item>
    
    <item>
      <title>S07-Lists</title>
      <link>https://ohmysummer.github.io/post/2016-02-12-s07-lists/</link>
      <pubDate>Fri, 12 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-12-s07-lists/</guid>
      <description>push 和 append 的表现不同, push 一次只添加单个参数到列表末端, append 一次可以添加多个参数。
use v6; my @d = ( [ 1 .. 3 ] ); @d.push( [ 4 .. 6 ] ); @d.push( [ 7 .. 9 ] ); for @d -&amp;gt; $r { say &amp;quot;$r[]&amp;quot;; } # 1 # 2 # 3 # 4 5 6 # 7 8 9 for @d -&amp;gt; $r { say $r.WHAT() } # (Int) # (Int) # (Int) # (Array) 整个数组作为单个参数 # (Array) say @d.</description>
    </item>
    
    <item>
      <title>适当的使用proto</title>
      <link>https://ohmysummer.github.io/post/2016-02-11-%E6%81%B0%E5%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8proto/</link>
      <pubDate>Thu, 11 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-11-%E6%81%B0%E5%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8proto/</guid>
      <description>原文在此Apropos proto: Perl6.c multi thoughts
Multi 程序相当整洁, 但对于我来说是不彻底的。一些背景 — 有人可能这样计算阶乘:
multi fac(0) { 1 } multi fac(Int $n where 1..Inf) { $n * fac( $n-1 ) } say fac(4); # 24  现在假设我们要把我们的递归 multi-sub 作为一个回调传递会怎样呢？
given &amp;amp;fac -&amp;gt; $some_fun { say &amp;quot;some_fun(4)=&amp;quot;, $some_fun(4) }  现在&amp;hellip; 定义一个匿名的 multi-sub 怎么样？
my $anon_fac = do { multi hidden_fac(0) { 1 } multi hidden_fac(Int $n where 1..Inf) { $n * fac( $n - 1 ) } &amp;amp;hidden_fac }; say $anon_fac(4); # 24  这也会有作用, 但是有点 hack 的味道, 并且我们的 multi-sub 并不是真正的匿名。它仅仅是被隐藏了。真正匿名的对象不会在任何作用域中安装, 而在这个例子中, &amp;ldquo;hidden_fac&amp;rdquo; 被安装在 &amp;ldquo;do&amp;rdquo; block 中的本地作用域中。</description>
    </item>
    
    <item>
      <title>given when和模式匹配</title>
      <link>https://ohmysummer.github.io/post/2016-02-06-given-when%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 06 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-06-given-when%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>Perl 6 中的模式匹配
use v6; my $bool1 = 1; my $bool2 = 0; given ($bool1, $bool2) { when (0, 0) {say &amp;quot;0, 0&amp;quot;} when (0, 1) {say &amp;quot;0, 1&amp;quot;} when (1, 0) {say &amp;quot;1, 0&amp;quot;} when (1, 1) {say &amp;quot;1, 1&amp;quot;} } given (&amp;quot;15&amp;quot;, &amp;quot;example&amp;quot;, &amp;quot;3.14&amp;quot;) { say $_.WHAT; # (&amp;quot;15&amp;quot;, &amp;quot;example&amp;quot;, &amp;quot;3.14&amp;quot;) =&amp;gt; List when ($, $, Str) { say &amp;quot;I got a String of $_[2]&amp;quot; } # $ 代表一个匿名变量, 表示元组的前两个不参与智能匹配?</description>
    </item>
    
    <item>
      <title>Grammars</title>
      <link>https://ohmysummer.github.io/post/2016-02-05-perl-6-grammars/</link>
      <pubDate>Fri, 05 Feb 2016 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-05-perl-6-grammars/</guid>
      <description>Grammars Grammars - 一组具名 regexes 组成正式的 grammar
Grammars 是一个很强大的工具用于析构文本并通常返回数据结构。
例如, Perl 6 是使用 Perl 6 风格 grammar 解析并执行的。
对普通 Perl 6 使用者更实用的一个例子是 JSON::Tiny模块, 它能反序列化任何合法的 JSON 文件, 而反序列代码只有不到 100 行, 还能扩展。
Grammars 允许你把 regexes 组织到一块儿, 就像类(class) 中组织方法那样。
具名正则 (Named Regexes) 　grammars 的主要组成部分是 regexes。 而 Perl 6 的 regexes语法不在该文档的讨论范围, 具名正则(named regexes) 有它自己的特殊语法, 这跟子例程(subroutine) 的定义很像:
my regex number { \d+ [ \. \d+ ]? } # 普通 regex 中空格被忽略, [] 是非捕获组  上面的代码使用 my 关键字指定了本地作用域的 regex, 因为具名正则(named regexes) 通常用在 grammars 里面。</description>
    </item>
    
    <item>
      <title>comb - 操作字符串的利器</title>
      <link>https://ohmysummer.github.io/post/2016-02-03-comb-%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A9%E5%99%A8/</link>
      <pubDate>Wed, 03 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-03-comb-%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A9%E5%99%A8/</guid>
      <description>comb - 操作字符串的利器
comb 子例程 comb 子例程的定义为：
multi sub comb(Regex $matcher, Str(Cool) $input, $limit = *) returns List:D multi method comb(Regex $matcher, $limit = *) returns List:D  用法：
comb /PATTERN/, STRING, LIMIT? # 子例程形式 STRING.comb(/PATTERN/, LIMIT?) # 方法形式  返回调用者（方法形式）的所有（或者至多 $limit 个，如果提供了的话）匹配，或者返回第二个参数（sub 形式）与 Regex 相匹配的字符串列表。
say &amp;quot;6 or 12&amp;quot;.comb(/\d+/).join(&amp;quot;, &amp;quot;); # 6, 12  Str 类中的 comb multi sub comb(Str:D $matcher, Str:D $input, $limit = Inf) multi sub comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match) multi sub comb(Int:D $size, Str:D $input, $limit = Inf) multi method comb(Str:D $input:) multi method comb(Str:D $input: Str:D $matcher, $limit = Inf) multi method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match) multi method comb(Str:D $input: Int:D $size, $limit = Inf)  在 $input 中搜索 $matcher 并返回所有匹配（默认是 Str，或者是 Match 对象，如果 $match 为真的话）的一个列表。$limit 表示至多返回 $limit 个匹配。</description>
    </item>
    
    <item>
      <title>Perl 6 中的 S/// 操作符</title>
      <link>https://ohmysummer.github.io/post/2016-01-28-perl6%E4%B8%AD%E7%9A%84s%E6%93%8D%E4%BD%9C%E7%AC%A6/</link>
      <pubDate>Thu, 28 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-28-perl6%E4%B8%AD%E7%9A%84s%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid>
      <description>Perl 6: S/// 操作符 By Zoffix Znet
来自 Perl 5 背景的我， 第一次使用 Perl 6 的非破坏性替换操作符 S/// 的经历就像下面这样:
进展会更好的。我不但会改善错误信息，而且会解释当前的所有事情。
智能匹配 我有问题的原因是因为，看到外形相似的操作符，我就简单地把 Perl 5 中的绑定操作符(=~)转换为 Perl 6 中的智能匹配操作符(~~) 还期望它能正常工作。事实上我是异想天开。S/// 操作符没有文档，并且结合令人困惑的(那个时候)警告信息，这就是我痛苦的根源：
my $orig = &#39;meowmix&#39;; my $new = $orig ~~ S/me/c/; say $new; # OUTPUT warning: # Smartmatch with S/// can never succeed  这个丑陋的警告说这儿的 ~~ 操作符是个错误的选择并且确实如此。~~ 操作符不是 Perl 5 的 =~ 操作符的等价物。~~ 智能操作符把它左边的东西起了个叫做 $_ 的别名，然后 ~~ 计算它右侧的东西，然后在右侧这个东西身上调用 .ACCEPTS($_) 方法。这就是所有的魔法。
所以上面的例子实际上发生了:
 我们到达 S/// 的时候， $orig 被起了个叫做 $_ 的别名。 S/// 非破坏性地在 $_ 身上执行了替换并返回那个结果字符串。这是智能匹配将要操作的东西。 智能匹配，按照 Str 与 Str 相匹配的规则，会根据替换是否发生来给出 True 或 False（令人困惑的是，True 意味着没发生）  结果一路下来，我们并没有得到我们想要的：替换过的字符串。</description>
    </item>
    
    <item>
      <title>Roles</title>
      <link>https://ohmysummer.github.io/post/2016-01-21-roles/</link>
      <pubDate>Thu, 21 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-21-roles/</guid>
      <description>Protocol 在 Swift 中是一组方法和属性的集合, 可用于代码复用。 Perl 6 中有与之类似的结构, 叫做 Role, 下面转换一个 Swift 的 Protocol 为 Perl 6 的 Role, 把部门人员的相关信息打印为一个表格:
Protocol in Swift 　import UIKit func padding(amount: Int) -&amp;gt; String { var paddingString = &amp;quot;&amp;quot; for _ in 0..&amp;lt;amount { paddingString += &amp;quot; &amp;quot; } return paddingString } // 协议 protocol TabularDataSource { var numberOfRows: Int { get } var numberOfColumns: Int { get } func labelForRow(row: Int) -&amp;gt; String // 行标签 func labelForColumn(column: Int) -&amp;gt; String // 列标签 func itemForRow(row: Int, column: Int) -&amp;gt; Int // 表格中的单元格 } struct Person { let name: String let age: Int let yearsOfExperience: Int } // 让 **Department** 遵守 **TabularDataSource**协议 struct Department: TabularDataSource { let name: String var people = [Person]() init(name: String) { self.</description>
    </item>
    
    <item>
      <title>Fallout Hacking Game</title>
      <link>https://ohmysummer.github.io/post/2016-01-12-fallout-hacking-game/</link>
      <pubDate>Tue, 12 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-12-fallout-hacking-game/</guid>
      <description>流行游戏辐射3: New Vegas 有一台计算机, 玩家必须正确地从同样长度的单词列表中猜出正确的密码。你的挑战是你自己实现这个游戏。
玩家有只 4 次机会, 每一次不正确的猜测计算机会提示有多少个字母位置是正确的。
例如, 如果密码是 MIND , 玩家猜测为 MEND, 游戏会提示4个位置中的3个是正确的(M_ND)。如果密码是 COMPUT, 玩家猜测为 PLAYFUL, 游戏会报告 0/7。虽然某些字符是匹配的, 但是位置不匹配。
询问玩家难度设置为几（非常简单, 简单, 中等, 困难, 非常困难）, 然后给玩家展示5到15的同样长度的单词。长度可以是 4到15个字符。
这儿有一个游戏例子:
Difficulty (1-5)? 3 SCORPION FLOGGING CROPPERS MIGRAINE FOOTNOTE REFINERY VAULTING VICARAGE PROTRACT DESCENTS Guess (4 left)? migraine 0/8 correct Guess (3 left)? protract 2/8 correct Guess (2 left)? croppers 8/8 correct You win!  你可以从我们的字典文件中获取单词：enable1.txt 。 你的程序应该在做位置检查时完全忽略大小写。
能增加游戏的难度, 或许甚至不能保证有解决方法, 根据你特别挑选的单词。例如, 你的程序能提供某些位置重叠的字符以至于暴露给玩家的信息越少越好。</description>
    </item>
    
    <item>
      <title>从正则表达式到Grammars - Part 2</title>
      <link>https://ohmysummer.github.io/post/2016-01-04-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammars-part-2/</link>
      <pubDate>Mon, 04 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-04-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammars-part-2/</guid>
      <description>省略啰嗦的一堆。
使用量词匹配前面的东西至少 min 次, 至多 max 次, item ** min .. max
my regex Date { \d ** 4 &#39;-&#39; \d ** 2 &#39;-&#39; \d ** 2 }  还能精确地匹配 N 次。
 /literal string here/ 匹配一个字母数字序列。任何不是字母数字(顺便说一下, 这里的字母数字不一定严格地限制为 USe ASCII, 任何带有 &amp;lsquo;Letter&amp;rsquo; 或 &amp;lsquo;Number&amp;rsquo; Unicode 属性的字符都符合要求)的东西都需要用引号引起来或者以某种形式转义。
如果你想让某个东西是可选的, 使用 ?：
&amp;quot;Skyfall&amp;quot; ~~ /Sky &#39;fall&#39;?/;  这会匹配 &amp;lsquo;Sky&amp;rsquo; 或 &amp;lsquo;Skyfall&amp;rsquo;。
Perl 6 的正则表达式, 就像大多数 RE 引擎一样, 当它们找到了一个匹配后会停止匹配。从左到右, 以 &amp;lsquo;Skyfalling&amp;rsquo; 为例：
&amp;quot;Skyfalling&amp;quot; ~~ /Sky &#39;fall&#39;?</description>
    </item>
    
    <item>
      <title>使用Perl6的subsets和multiple辨别年龄</title>
      <link>https://ohmysummer.github.io/post/2016-01-04-%E4%BD%BF%E7%94%A8perl6%E7%9A%84subsets%E5%92%8Cmultiple%E8%BE%A8%E5%88%AB%E5%B9%B4%E9%BE%84/</link>
      <pubDate>Mon, 04 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-04-%E4%BD%BF%E7%94%A8perl6%E7%9A%84subsets%E5%92%8Cmultiple%E8%BE%A8%E5%88%AB%E5%B9%B4%E9%BE%84/</guid>
      <description>举个例子, 假设 person 有一个 age 属性. 我能写一个 multimethod, 让它接收一个 person 作为参数, 并返回这样的结果吗:
return &amp;quot;child&amp;quot; if age &amp;lt; 16; return &amp;quot;adult&amp;quot; if 16 &amp;lt;= age &amp;lt; 66; return &amp;quot;senior&amp;quot; if age &amp;gt;= 66;  class Person { has Int $.age; has Str $.name; }  这仅仅定义了一个拥有两个属性, 叫做 Person 的类. age 必须是 Int 型, name 必须是 Str 型. . 语法会生成一个只读访问器, 以使我们能从类的外部访问 getter 方法.
现在我们来定义一个 age-group multi 来告诉一个 person 属于哪个 age-group:
multi age-group ($person where (*.</description>
    </item>
    
    <item>
      <title>Perl 6 博文收集</title>
      <link>https://ohmysummer.github.io/post/2016-01-02-perl-6-%E5%8D%9A%E6%96%87%E6%94%B6%E9%9B%86/</link>
      <pubDate>Sat, 02 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-02-perl-6-%E5%8D%9A%E6%96%87%E6%94%B6%E9%9B%86/</guid>
      <description>本文意在收集 Perl 6 方面的博文, 如有侵权请告知删除。
Perl 6 的 Grammar 学习总结 Perl 6 的正则表达式 Perl 6 的正则表达式 Perl 6 的列表 Perl 6 的字符串 Perl 6 URB 解析 Perl 6 格式化帮助信息 Perl 6 解决 24 Game Perl 6 神的90亿名字整数版 Perl 6 计算矩阵占比 Perl 6 24游戏 Perl 6 temporary Perl 6 括号匹配 Perl 6 上传文件 译 Perl 6 Object Orientation [译 Perl 6] Native Calling Interface](https://segmentfault.com/a/1190000004864391) 译 Perl 6 5to6-nutshell c++ Perl 6 括号的匹配 [c++ Perl 6] 神的90亿名字整数版](https://segmentfault.</description>
    </item>
    
    <item>
      <title>Perl 6 核心骇客--词法的胡言乱语</title>
      <link>https://ohmysummer.github.io/post/2016-01-01-perl-6-%E6%A0%B8%E5%BF%83%E9%AA%87%E5%AE%A2-%E8%AF%8D%E6%B3%95%E7%9A%84%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/</link>
      <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-01-perl-6-%E6%A0%B8%E5%BF%83%E9%AA%87%E5%AE%A2-%E8%AF%8D%E6%B3%95%E7%9A%84%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/</guid>
      <description>Perl 6 核心骇客: 词法的胡言乱语
喜欢修复 Perl 6 编译器中的 bug? 这儿有一个great grammar bugglet: 当 „” 引号用在引起的用空白分割的单词列表构造器中时看起来好像不能工作:
say „hello world”; .say for qww&amp;lt;„hello world”&amp;gt;; .say for qww&amp;lt;&amp;quot;hello world&amp;quot;&amp;gt;; # OUTPUT: # hello world # „hello # world” # hello world  ” 引号不应该出现在输出中并且在输出中我们应该只有 3 行输出; 这 3 行输出都是 hello world。看起来像是一个待修复的有趣的 bug! 我们进去看看。
你怎样拼写它? 事实上这段代码没能正确解析表明这是一个 grammar bug。大部分的 grammar 住在 src/Perl6/Grammar.nqp中, 但是在我们的手变脏之前, 让我们来解决我们应该查看什么。
二进制 perl6 有一个 --target 命令行参数来接收其中之一的编译步骤并且会导致那个步骤的输出被产生出来。那儿有哪些步骤? 根据你正使用的后端它们也会有所不同, 但是你可以仅仅运行 perl6 --stagestats -e &#39;&#39; 把它们都打印出来:</description>
    </item>
    
    <item>
      <title>perl6intro 翻译</title>
      <link>https://ohmysummer.github.io/post/2015-12-21-perl6intro-%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Mon, 21 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-12-21-perl6intro-%E7%BF%BB%E8%AF%91/</guid>
      <description>第八章 函数式编程 在本章中，我们将看看一些有利于函数式编程的功能。
函数是一等公民 　函数/子例程是一等公民:
 它们能作为参数传递 它们能从另外一个函数中返回 它们能被赋值给变量  map 函数是用来说明这个概念的极好例子。map 是高阶函数, 它接收另外一个函数作为参数。
脚本
my @array = &amp;lt;1 2 3 4 5&amp;gt;; sub squared($x) { $x ** 2 } say map(&amp;amp;squared, @array);  输出
(1 4 9 16 25)  解释
我们定义了一个叫做 squared 的子例程, 它接收一个数字并返回该数字的二次幂。下一步, 我们使用 map 这个高阶函数并传递给它两个参数, 一个子例程和一个数组。结果是所有数组元素的平方组成的列表。
注意当传递子例程作为参数时, 我们需要在子例程的名字前添加一个 &amp;amp; 符号。
闭包 　在 Perl 6 中所有的代码对象都是闭包, 这意味着它们能从外部作用域(outer scope)引用词法变量(lexical variables)。
匿名函数 　匿名函数也叫做拉姆达(lambda)。
匿名函数没有绑定到标识符(匿名函数没有名字)。
让我们使用匿名函数重写 map 那个例子。</description>
    </item>
    
    <item>
      <title>stackoverflow0902</title>
      <link>https://ohmysummer.github.io/post/2015-12-18-stackoverflow0902/</link>
      <pubDate>Fri, 18 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-12-18-stackoverflow0902/</guid>
      <description>How do I chain to an inline block in Perl 6?
我想修改一个数组(我在这个例子中使用了 splice, 但是它也可能是修改数组的任何操作)并返回修改后的数组 - 和 slice 不一样, slice 返回的是从数组中抠出的项。我可以很容易地通过在数组中存储一个 block 来做到, 就像下面这样:
my $1 = -&amp;gt; $a { splice($a,1,3,[1,2,3]); $a }; say (^6).map( { $_ &amp;lt; 4 ?? 0 !! $_ } ).Array; # [0 0 0 0 4 5] say (^6).map( { $_ &amp;lt; 4 ?? 0 !! $_ } ).Array.$1; # [0 1 2 3 4 5]  我怎么把由 $1 代表的 block 内联到单个表达式中呢？ 下面的解决方法不正确:</description>
    </item>
    
    <item>
      <title>给数字添加千分位分割符</title>
      <link>https://ohmysummer.github.io/post/2015-12-14-%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E5%88%86%E5%89%B2%E7%AC%A6/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-12-14-%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E5%88%86%E5%89%B2%E7%AC%A6/</guid>
      <description>使用链式函数调用 考虑最简单的一种情况, 不带小数点的数字:
&amp;quot;1234567890&amp;quot;.comb.reverse.rotor(3,:partial).map(*.join(&#39;&#39;)).join(&#39;,&#39;).comb.reverse.join(&#39;&#39;) # 1,234,567,890  使用 \\ 转义空白, 使代码对齐:
&amp;quot;1234567890&amp;quot;.comb\ .reverse\ .rotor(3,:partial)\ .map(*.join(‘’))\ .join(‘,’)\ .comb\ .reverse\ .join(‘’)\ .say;  使用正则表达式 comming soon!
使用 Grammar comming soon!</description>
    </item>
    
    <item>
      <title>类中的twigils</title>
      <link>https://ohmysummer.github.io/post/2015-12-11-%E7%B1%BB%E4%B8%AD%E7%9A%84twigils/</link>
      <pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-12-11-%E7%B1%BB%E4%B8%AD%E7%9A%84twigils/</guid>
      <description>Perl 6中的 . 和 ! twigil 是什么？ . twigil 的意思是&amp;rdquo;这是类公用的&amp;rdquo;, ! twigil 的意思是“这是类私有的”, 只能用在类的内部。
class ScoreKeeper { has @.options; has %!player-points; }  普通的符号表明了词法作用域或包作用域, 但是 twigils 就像是 sigils 的兄弟, 表明了不同的作用域, 它影响了变量的作用域。. 和 ! 是二级 sigils。
属性存在于每个类的实例中, 在类的内部, 可以直接使用 !访问到实例的属性:
class Point { has $.x; has $.y; method Str() { &amp;quot;($!x, $!y)&amp;quot; } }  那么 . twigil 和 ! twigil 之间有什么关系呢？下面看一个例子:
use v6; class Point { has $.x; has $.</description>
    </item>
    
    <item>
      <title>扩展 Perl 6 中的类型</title>
      <link>https://ohmysummer.github.io/post/2015-11-25-%E6%89%A9%E5%B1%95perl6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 25 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-25-%E6%89%A9%E5%B1%95perl6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B/</guid>
      <description>扩展 Perl 6 中的类型 使用继承 class BetterInt is Int { method even { self %% 2 } } my BetterInt $x .= new: 42; say $x.even; $x .= new: 71; say $x.even; say $x + 42; # OUTPUT: # True # False # 113  my BetterInt $x 约束 $x 只能包含 BetterInt 或它的子类这种类型的对象。.= new: 42 等价于 = BetterInt.new: 42。 下面的子例程期望接收一个 Int 型的参数，但是你给它传递一个 BetterInt 类型的参数它会很高兴:
sub foo(Int $x) { say &amp;quot;\$x is $x&amp;quot;} my BetterInt $x .</description>
    </item>
    
    <item>
      <title>简单字符串解析</title>
      <link>https://ohmysummer.github.io/post/2015-11-25-%E7%AE%80%E5%8D%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 25 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-25-%E7%AE%80%E5%8D%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90/</guid>
      <description>简单字符串解析 我已经以好几种方式使用 Perl 6 解析用引号引起的字符串了。 但是我想知道有没有更好更干净的方法。下面有一个为引起的字符串准备的小型 grammar 而且还有一些测试:
grammar String::Simple::Grammar { our $quote; rule TOP {^ &amp;lt;string&amp;gt; $} # Note for now, {} gets around a rakudo binding issue token string { &amp;lt;quote&amp;gt; {} :temp $quote = $&amp;lt;quote&amp;gt;; &amp;lt;quotebody&amp;gt; $&amp;lt;quote&amp;gt; } token quote { &#39;&amp;quot;&#39; | &amp;quot;&#39;&amp;quot; } token quotebody { ( &amp;lt;escaped&amp;gt; | &amp;lt;!before $quote&amp;gt; . )* } token escaped { &#39;\\&#39; ( $quote | &#39;\\&#39; ) } } class String::Simple::Actions { method TOP($/) { make $&amp;lt;string&amp;gt;.</description>
    </item>
    
    <item>
      <title>项</title>
      <link>https://ohmysummer.github.io/post/2015-11-21-%E9%A1%B9/</link>
      <pubDate>Sat, 21 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-21-%E9%A1%B9/</guid>
      <description>Perl 6 中的大部分句法结构能归类为项和操作符. 这儿你能找到各种不同类型的项的概览.
Literals Int 42 12_300_00 :16&amp;lt;DEAD_BEEF&amp;gt; #十六进制  Int 字面量由数字组成, 并且能在数字之间包含下划线. 使用 :radix&amp;lt;number&amp;gt; 冒号对儿形式能指定 10 进制外的其它进制.
Rat 有理数 12.34 1_200.345_678  Rat(有理数)字面量由一个点号分割的两部分整数组成. 注意尾部的点号是不允许的, 所以你必须写成 1.0 而非 1. ( 这个规则很重要, 因为有一个以点号开头的中缀操作符, 例如 .. 范围操作符 ).
Num 浮点数 12.3e-32 3e8  Num(浮点数)字面量由 Rat 或 Int 字面量后面再跟着一个字母 e 和 一个指数(可能为负)组成. 3e8 使用 值 3* 10**8 构建了一个 Num.
Str &#39;a string&#39;&#39;I\&#39;m escaped!&#39; &amp;quot;I don&#39;t need to be&amp;quot; &amp;quot;\&amp;quot;But I still can be,\&amp;quot; he said.</description>
    </item>
    
    <item>
      <title>Guess Who</title>
      <link>https://ohmysummer.github.io/post/2015-11-20-reddit-guess-who/</link>
      <pubDate>Fri, 20 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-20-reddit-guess-who/</guid>
      <description>你是一个刚成立的小公司里的一名软件工程师, 有天晚上你收到了一封来自CEO 的电子邮件:
 亲爱的工程师,
​ 好新闻！看起来我们的网站越来越受欢迎。我们要变的有钱了! 每秒钟有成千上万的人在同时访问我们的网站, 而且还在快速增长。
我们必须立即识别出谁的通信量最大。幸运的是我的朋友给我发送了一份巨大的 IP 地址和名字的列表。很酷不是吗？你能写一段程序接收我们大量的访问者, 把它和地址/ 名字列表相比, 并创建一些统计吗？我的意思是, 生成一个国家的名字列表, 每个
做好了的话我给你们开个披萨聚会。
 邮件的附件文件包含了一个 IP 地址和名字的列表。写一个程序来统计下有多少 IP 访问了你的网站。
输入描述 输入来自两部分。第一个是一个文本文件, 包含 IP 地址范围。每行一项,使用两个空格分割 IP 和名字。
第二个文件是一个 IP 地址的列表, 每行一个, 它们是必须被查询的IP。
IP 输入样本 输入是有包含两个 IP 地址和一个跟 IP 范围关联的名字的大量行组成。
123.45.17.8 123.45.123.45 University of Vestige 123.50.1.1 123.50.10.1 National Center for Pointlessness 188.0.0.3 200.0.0.250 Mayo Tarkington 200.0.0.251 200.0.0.255 Daubs Haywire Committee 200.0.1.1 200.255.255.255 Geopolitical Encyclopedia 222.222.222.222 233.233.233.233 SAP Rostov 250.</description>
    </item>
    
    <item>
      <title>Perl6 中的可变 Grammar</title>
      <link>https://ohmysummer.github.io/post/2015-11-16-perl6%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98grammar/</link>
      <pubDate>Mon, 16 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-16-perl6%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98grammar/</guid>
      <description>## A Mutable Grammar For Perl 6 Rules Rules 就像 perl5的 regexes，并且更好。它们像子例程和方法那样申明，并且还能调用其它 rules
下面是一个解析 Perl 6 基本变量名的例子：
grammar Perl6 { # among other stuff: # token alpha 是一个预定义好的 rule token identifier { &amp;lt;alpha&amp;gt; \w+ } # 匹配一个全限定名标识符 # [ ... ] 是非捕获组 token name { &amp;lt;identifier&amp;gt; [ &#39;::&#39; &amp;lt;identifier&amp;gt; ] * } # .. | .. 是分支. 最长匹配胜出. token sigil { &#39;$&#39; | &#39;@&#39; | &#39;&amp;amp;&#39; | &#39;%&#39; | &#39;::&#39; } # &amp;lt;rule&amp;gt; 调用命名 rule, 隐式地锚定在当前位置 token variable { &amp;lt;sigil&amp;gt; &amp;lt;name&amp;gt; } }  Grammars Grammar 跟类很像，含有 rules 而不是 methods。 grammars 是 rules 的集合并支持继承。</description>
    </item>
    
    <item>
      <title>roles冲突</title>
      <link>https://ohmysummer.github.io/post/2015-11-16-roles%E5%86%B2%E7%AA%81/</link>
      <pubDate>Mon, 16 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-16-roles%E5%86%B2%E7%AA%81/</guid>
      <description>学会了怎么创建类, 我们继续用它来构建我们的中心内容:
class Hammer { method hammer($stuff) { say &amp;quot;You hammer on $stuff. BAM BAM BAM!&amp;quot;; } } class Gavel { method hammer($stuff) { say &amp;quot;You hammer on $stuff. BAM BAM BAM!&amp;quot;; } } class Mallet { method hammer($stuff) { say &amp;quot;You hammer on $stuff. BAM BAM BAM!&amp;quot;; } }  但是注意到了吗？ 这三个方法包含了同样的方法, 在类中重复了。我们必须那样做如果我们想让每个 Hammar、Gavel 和 Mallet 有能力击打的话。（并且那是合理的）。 但是遗憾的是我们不得不把那个方法一式三份。
为什么遗憾？ 因为一方面在真实世界中, 方法并不是很彼此相似, 有一天你决定在 hammer 方法中更改某些东西, 并没有意识到这个方法在三个不同的地方&amp;hellip; 这导致了一堆痛苦和难受。
所以我们的新玩具, 类, 展现出了一个问题。我们想在每个类中重用 hammer 方法。一个新的概念, role 来拯救我们来了:</description>
    </item>
    
    <item>
      <title>圆括号和方括号在创建数组时的区别</title>
      <link>https://ohmysummer.github.io/post/2015-11-14-%E5%9C%86%E6%8B%AC%E5%8F%B7%E5%92%8C%E6%96%B9%E6%8B%AC%E5%8F%B7%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 14 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-14-%E5%9C%86%E6%8B%AC%E5%8F%B7%E5%92%8C%E6%96%B9%E6%8B%AC%E5%8F%B7%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>[ ] 和 ( ) 的区别 # 无法正常排序 my @s = [2443,5,33, 90, -9, 2, 764]; say @s.sort; # 2443 5 33 90 -9 2 764 say @s.WHAT; # (Array) say @s.perl; # [[2443, 5, 33, 90, -9, 2, 764]]&amp;lt;&amp;gt; # 正常排序 my $array = [2443,5,33, 90, -9, 2, 764]; say $array.sort; # -9 2 5 33 90 764 2443 say $array.WHAT; # (Array) say $array.perl; # [2443, 5, 33, 90, -9, 2, 764] my @s = (2443,5,33,90,-9,2,764); say @s.</description>
    </item>
    
    <item>
      <title>在 Perl 6 中怎么为已存在的类添加方法</title>
      <link>https://ohmysummer.github.io/post/2015-11-11-%E5%9C%A8perl6%E4%B8%AD%E6%80%8E%E4%B9%88%E4%B8%BA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 11 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-11-%E5%9C%A8perl6%E4%B8%AD%E6%80%8E%E4%B9%88%E4%B8%BA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/</guid>
      <description>How do you add a method to an existing class in Perl 6? Perl 6 中怎么为已存在的类添加方法?
Int 类有一个方法叫做 is-prime, 我想为 Int类型添加其它的方法。
class MyInt is Int { method is-even () returns Bool:D { return False if self % 2; return True; } } my $n = MyInt.new(138); say $n.is-even;  通过类的继承也是一种方法, 但是不是我想要的。Swift 中可以通过扩展来实现, Perl 6 中有一个 add_method方法:
method add_method(Metamodel::MethodContainer: $obj, $name, $code)  这会给元类(meta class)添加一个方法, 使用 $name 作为调用的方法名。这只会在类型被组合前使用。
Int.^add_method( &#39;is-even&#39;, method () returns Bool:D { return False if self % 2; return True; } ); say 137.</description>
    </item>
    
    <item>
      <title>D 在 Perl 6 中是什么意思</title>
      <link>https://ohmysummer.github.io/post/2015-11-05-d%E5%9C%A8perl6%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</link>
      <pubDate>Thu, 05 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-05-d%E5%9C%A8perl6%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</guid>
      <description>一个裸的 :D、:U、:T 或 :_ 是限制默认类型为定义、未定义、类型对象或任何对象的类型约束。所以
class Con { method man(:U: :D $x) }  其签名等价于 (Con:U: Any:D $x)。
Con:U 是调用者, 在调用者后面加上一个冒号。要标记一个显式的调用者, 在它后面放上一个冒号就好了:
method doit ($x: $a, $b, $c) { ... }  Abstract vs Concrete types 　对于任何有名字的类型, 某些其它子集类型可以自动地通过在类型的名字后面追加一个合适的状语来派生出来：
Int:_ 允许定义或未定的 Int 值 Int:D 只允许有定义的(强制的)Int 值 Int:U 只允许未定义值(抽象或失败)Int 值 Int:T 允许Int只作为类型对象  即, 它们的意思有点像:
Int:D Int:_ where DEFINITE($_) Int:U Int:_ where not(DEFINITE($_)) Int:T Int:U where none(Failure)  where DEFINITE 是一个布尔宏, 它说正处理的对象是否有一个合法的强制表示。(查看下面的自省) .</description>
    </item>
    
    <item>
      <title>Perl 6 中的正则表达式(三)</title>
      <link>https://ohmysummer.github.io/post/2015-11-05-perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%89/</link>
      <pubDate>Thu, 05 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-05-perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%89/</guid>
      <description>预定义 Subrules 下面这些是为任意 grammar 或 regex 预定义好的 subrules:
 ident   匹配一个标识符.
 upper   匹配单个大写字符.
 lower   匹配单个小写字符.
 alpha   匹配单个字母字符, 或者是一个下划线.
要匹配不带下划线的 Unicode 字母字符, 使用 &amp;lt;:alpha&amp;gt;.
 digit   匹配单个数字.
 xdigit   匹配单个十六进制数字.
 print   匹配单个可打印字符.
 graph   匹配单个图形字符.
 cntrl   匹配单个控制字符. (等价于 &amp;lt;:Cc&amp;gt; 属性). 控制字符通常不产生输出, 相反, 它们以某种方式控制末端:例如换行符和退格符都是控制字符. 所有使用 ord() 之后小于 32 的字符通常归类为控制字符.</description>
    </item>
    
    <item>
      <title>从正则表达式到 Grammar</title>
      <link>https://ohmysummer.github.io/post/2015-10-29-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammar/</link>
      <pubDate>Thu, 29 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-10-29-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammar/</guid>
      <description>「原文链接」
如果你是正则表达式新人(至少当它们用于 Perl 6 中时), 那我建议你从这个系列的第一部分开始。那些掌握了一定正则表达式的人可以跳过上周的文章。现在, 继续演示!
上周轶事 我们开始开发一个接收诸如
var a = 3; console.log(&amp;quot;Hey, did you konw a = &amp;quot; + a + &amp;quot;?&amp;quot;);  Javascript 表达式的 Perl 6 编译器, 并把这段代码转换为 Rakudo Perl 那样的编译器能运行的 Perl 6 代码。在我们开始之前, 想想转换后的 Perl 6 代码看起来是什么样的可能会是个好主意。如果你已经知道了 Perl 5, 那么你应该熟悉这样的代码。
my $a = 3; say &amp;quot;Hey, did you konw a = &amp;quot; ~ $a ~ &amp;quot;?&amp;quot;;  我们将需要确保我们的正则表达式捕获到了 Javascript 的要素。如果你还记得上一次, 我们使用这样一组正则表达式来捕获我们的文本:
my rule Number { \d+ }; my rule Variable { \w+ }; my rule String { &#39;&amp;quot;&#39; &amp;lt;-[&amp;quot; ]&amp;gt;+ &#39;&amp;quot;&#39; }; my rule Assignment-Expression { var &amp;lt;Variable&amp;gt; &#39;=&#39; &amp;lt;Number&amp;gt; }; my rule Function-Call { console &#39;.</description>
    </item>
    
    <item>
      <title>IO 操作</title>
      <link>https://ohmysummer.github.io/post/2015-10-11-io%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 11 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-10-11-io%E6%93%8D%E4%BD%9C/</guid>
      <description>文件存在、文件的时间戳、文件的修改时间等等
批量插入文本 use v6; my @filenames = dir &#39;.&#39;, test =&amp;gt; any(/\.md$/, /\.markdown/); for @filenames -&amp;gt; $filePath { my $path = $filePath.path(); $path ~~ s/.md//; $path ~~ s/.markdown//; my $date = DateTime.new(now); my $head = qq:heredoc &#39;EOT&#39;; title: $path.IO.basename() date: $date tags: Perl6 categories: Perl 6 --- &amp;lt;blockquote class=&amp;quot;blockquote-center&amp;quot;&amp;gt;这城市有太多风景都在提醒那过去！&amp;lt;/blockquote&amp;gt; [TOC] EOT my @content = slurp $filePath; spurt($filePath.path, &amp;quot;$head\n@content[]&amp;quot;); }  在当前目录中查找所有以 .md (.markdown)结尾的文件（即markdown文件）, 并在文件最前面插入一段文本， 形如：
title: Perl6 date: 2015-08-20T23:19:13Z tags: Perl6 categories: Perl 6 --- &amp;lt;blockquote class=&amp;quot;blockquote-center&amp;quot;&amp;gt;我站在天桥上念你, 有点狼狈&amp;lt;/blockquote&amp;gt;  类 IO::Path 提供了 basename, path, parts, 等方法供使用, 具体用法请看文档:</description>
    </item>
    
    <item>
      <title>proto</title>
      <link>https://ohmysummer.github.io/post/2015-10-06-proto/</link>
      <pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-10-06-proto/</guid>
      <description>proto proto 意思为原型。proto 从形式上声明了 multi 候选者之间的共性。 proto 充当作能检查但不会修改参数的包裹。看看这个基本的例子:
proto congratulate(Str $reason, Str $name, |) {*} multi congratulate($reason, $name) { say &amp;quot;Hooray for your $reason, $name&amp;quot;; } multi congratulate($reason, $name, Int $rank) { say &amp;quot;Hooray for your $reason, $name -- you got rank $rank!&amp;quot;; } congratulate(&#39;being a cool number&#39;, &#39;Fred&#39;); # OK congratulate(&#39;being a cool number&#39;, &#39;Fred&#39;, 42); # OK congratulate(&#39;being a cool number&#39;, 42); # Proto match error  所有的 multi congratulate 会遵守基本的签名, 这个签名中有两个字符串参数, 后面跟着可选的更多的参数。 | 是一个未命名的 Capture 形参, 这允许 multi 接收额外的参数。第三个 congratulate 调用在编译时失败, 因为第一行的 proto 的签名变成了所有三个 multi congratulate 的共同签名, 而 42 不匹配 Str。</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2010)</title>
      <link>https://ohmysummer.github.io/post/2015-10-05-perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2010/</link>
      <pubDate>Mon, 05 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-10-05-perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2010/</guid>
      <description>2010 第二天:用main函数控制命令行交互 2010 年 Perl6 圣诞月历(二)用 main 函数控制命令行交互
在 UNIX 环境下，很多脚本都是要从命令行里获取运行参数的。Perl6 上，实现这个相当简单~比如下面这样：
$ cat add.pl sub MAIN ($x, $y) { say $x + $y } $ perl6 add.pl 3 4 7 $ perl6 add.pl too many arguments Usage: add.pl x y  只要定义一个带命名变量的 MAIN 函数，你就可以获得一个命令行分析器。然后命令行参数就被自动绑定到 $x 和 $y 上了。如果不匹配，还有温馨的 Usage 提示~~
当然，你可能更喜欢自己定制 Usage 信息。那么自己动手，编写 USAGE 函数好了：
$ cat add2.pl sub MAIN($x, $y) { say $x + $y } sub USAGE () { say &amp;quot;Usage: add.</description>
    </item>
    
    <item>
      <title>空白格</title>
      <link>https://ohmysummer.github.io/post/2015-09-18-%E7%A9%BA%E7%99%BD%E6%A0%BC/</link>
      <pubDate>Fri, 18 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-18-%E7%A9%BA%E7%99%BD%E6%A0%BC/</guid>
      <description> 空格最少化 在数组或散列的开括号(即下标左边的那个括号)之前不允许有空格, 参数列表的圆开括号前面也是不能有空格的. 即:
@deadbeef[$x] # okay %monsters{&#39;cookie&#39;} # okay saymewant(&#39;cookie&#39;) # okay @a [$b] # WRONG %people {&#39;john&#39;} # WRONG mewant (&#39;cookie&#39;) # WRONG  这种限制的的几个副作用之一就是条件控制结构的周围不再需要圆括号了:
if $value eq $target { print &amp;quot;Bullseye!&amp;quot;; } while $i &amp;lt; 10 { $i++ }  然而, 显式的使用 unspace 语法仍然能够让你对齐下标和后缀操作符:
%squirrels{&#39;fluffy&#39;} = Squirrel.new; %monsters.{&#39;cookie&#39;} = Monster.new; %beatles\.{&#39;ringo&#39;} = Beatle.new; %people\ .{&#39;john&#39;} = Person.new;  </description>
    </item>
    
    <item>
      <title>Perl 6 中的 polymod 方法</title>
      <link>https://ohmysummer.github.io/post/2015-09-17-perl6%E4%B8%AD%E7%9A%84polymod%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 17 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-17-perl6%E4%B8%AD%E7%9A%84polymod%E6%96%B9%E6%B3%95/</guid>
      <description>Perl 6 中的 .polymod 方法 - 把数字分解成分母
 命名 .polymod 方法接受几个除数并把它的调用者分解成一份一份的:
my $seconds = 1 * 60*60*24 # days + 3 * 60*60 # hours + 4 * 60 # minutes + 5; # seconds say $seconds.polymod: 60, 60; say $seconds.polymod: 60, 60, 24; # OUTPUT: # (5 4 27) # (5 4 3 1)  这种情况下我们作为参数传递的除数是和时间相关的: 60(每分钟有多少秒)， 60(每小时有多少分钟)，和24(每天有多少小时)。从最小的单位开始， 我们一直前进到最大的单位。
输出和输入的除数是相匹配的 - 从最小的单位到最大的单位： 5 秒，4 分钟，3 小时和 1 天。</description>
    </item>
    
    <item>
      <title>日期难题</title>
      <link>https://ohmysummer.github.io/post/2015-09-15-%E6%97%A5%E6%9C%9F%E9%9A%BE%E9%A2%98/</link>
      <pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-15-%E6%97%A5%E6%9C%9F%E9%9A%BE%E9%A2%98/</guid>
      <description>reddit 上使用 Perl 6 处理日期
描述 下面的日期, 有些使用了 M D Y 格式, 有些使用了 Y M D 格式, 还使用了任意分隔符! 请把这些散乱的文本解析成合适的 ISO 8601 (YYYY-MM-DD) 格式化日期。
假设只有以 4 个数字开头的日期使用 Y M D 格式, 其它的使用 M D Y 格式。
输入样本 2/13/15 1-31-10 5 10 2015 2012 3 17 2001-01-01 2008/01/07  输出样本 2015-02-13 2010-01-31 2015-05-10 2012-03-17 2001-01-01 2008-01-07  扩展挑战 [中级] 使用 2014-12-24 作为相对日期的基准。
当添加 days(天数) 时, 要考虑到每月会有不同的天数, 忽略闰年。
当添加月和年时, 使用整个 units, 以至于:</description>
    </item>
    
    <item>
      <title>Perl 6 Weekly(一)</title>
      <link>https://ohmysummer.github.io/post/2015-09-11-perl-6-weekly%E4%B8%80/</link>
      <pubDate>Fri, 11 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-11-perl-6-weekly%E4%B8%80/</guid>
      <description>1、在 Perl 6 中怎样检查文件的时间戳属性？
在 Perl 6 中怎样检查文件的时间戳属性？ 在 Perl 5 中是使用文件测试操作符 file test operators , 在 Perl 6 中是使用来自于 IO::FileTestable role 的方法 (e.g. .modified, .accessed and .changed) 。
例如:
my $filename = &amp;quot;sample.txt&amp;quot;; my $seconds_since_epoch = $filename.IO.accessed; my $readable_timestamp = DateTime.new($filename.IO.accessed); say &amp;quot;File &#39;$filename&#39; was last accessed at &#39;$readable_timestamp&#39;, which is {$seconds_since_epoch.Num} seconds since the epoch&amp;quot;;  2、我正尝试生成包含 10 个随机随机序列的 FASTQ 文件， 序列由随机品质分数构成。我原来是使用下面的代码，它工作良好:
my @seq = (rand_fa_seq() for ^10); my @qual = (rand_qual() for ^10); @seq.</description>
    </item>
    
    <item>
      <title>Perl 6 中的正则表达式(四)</title>
      <link>https://ohmysummer.github.io/post/2015-09-11-perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%9B/</link>
      <pubDate>Fri, 11 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-11-perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%9B/</guid>
      <description>最长 token 匹配 注意，下面进入糟糕区域，如果看不懂请查看英文原文!
S05-metasyntax/longest-alternative.t lines 53–460
因为 &amp;rdquo;longest-token matching&amp;rdquo; 是一个很长的短语, 我们会经常将这个概念叫做 LTM. 这个基本的概念就是人们在头脑中倾向于怎么去解析文本, 所以计算机应该像人一样尝试做同样的事情. 而使用 LTM 解析文本就是关于计算机怎样决定匹配一组备选分支中的哪一个备选分支的.
在 Perl 6 中, | 代表使用声明性的 longest-token 语义的逻辑备选分支.(你现在能使用 || 来标示旧的暂存的备选分支. 就是, | 和 || 现在在正则语法内的运作方式和在正则语法外的运作方式很像, 在正则语法外部, | 和 || 代表 junctional 和 短路的 OR. 这也包括事实上 | 的优先级比 || 的优先级高.)
在过去, Perl 中正则表达式是通过一个能回溯的 NFA 算法来处理的. 这很强大, 但是很多解析器通过并行地处理 rules , 而不是一个接着一个地处理, 工作起来更高效, 至少达到某种程度. 如果你看一下像 yacc grammar 这样的东西, 你会发现很多 pattern/action 声明, 其中的 patterns 被认为是并行的, 并且最终由 grammar 决定触发哪个 action.</description>
    </item>
    
    <item>
      <title>Perl 6 中的操作符(一)</title>
      <link>https://ohmysummer.github.io/post/2015-08-31-perl6%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%80/</link>
      <pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-31-perl6%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%80/</guid>
      <description>操作符优先级 S03-operators/arith.t lines 46–342
S03-operators/precedence.t lines 5–200
Perl 6 拥有和 Perl 5 同等数量的优先级级别，但是它们散布在不同的地方。这儿，我们列出了从最紧凑到最松散的级别，每一级别还有几个例子：
最高优先级到最低优先级：
A Level Examples = ===== ======== N Terms 42 3.14 &amp;quot;eek&amp;quot; qq[&amp;quot;foo&amp;quot;] $x :!verbose @$array L Method postfix .meth .+ .? .* .() .[] .{} .&amp;lt;&amp;gt; .«» .:: .= .^ .: N Autoincrement ++ -- R Exponentiation ** L Symbolic unary ! + - ~ ? | || +^ ~^ ?^ ^ L Multiplicative * / % %% +&amp;amp; +&amp;lt; +&amp;gt; ~&amp;amp; ~&amp;lt; ~&amp;gt; ?</description>
    </item>
    
    <item>
      <title>探索Perl6的Signatures,第二部分</title>
      <link>https://ohmysummer.github.io/post/2015-08-29-%E6%8E%A2%E7%B4%A2perl6%E7%9A%84signatures%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</link>
      <pubDate>Sat, 29 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-29-%E6%8E%A2%E7%B4%A2perl6%E7%9A%84signatures%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</guid>
      <description>在我们探索 Perl 6 签名的第一部分中, 我们了解了怎么使用 Perl 6 强大而灵活的类型系统来约束具名参数和位置参数是如何被传递给子例程和方法的。我们还涉及了怎么使用 slurp 签名来创建能接收任意具名和位置参数列表的可变函数。
Perl 6 的签名系统提供了更多。在这篇文章中我们将验证其中更高级的特性, 它们让 Perl 6 的调用语义更强大。
Class 约束 你可以使用签名来指定传递进函数中的参数的类型约束。你使用的类型可以是任意类名。
sub foo( Numeric $foo, Str $bar) { say &amp;quot;my string is $bar and my number is $foo&amp;quot; }  这个签名要求我们传递 Numeric 和 Str 类型的参数。但是因为 Perl 6 的内置类型实际上就是类(classes), 并且因为 Numeric 拥有几个子类型, 我们可以传递进任何数字类型, 它都能工作:
foo(42, &amp;quot;blah&amp;quot;); foo(42.99, &amp;quot;yoohoo&amp;quot;); foo(3+9i, &amp;quot;hellooooooo&amp;quot;); # etc  我们自己定义的类中签名的工作原理也一样。
class Foo { has $.prop is rw; } sub inspect-a-foo( Foo $my-foo ) { say &amp;quot;this foo&#39;s property is &amp;quot; ~ $my-foo.</description>
    </item>
    
    <item>
      <title>Perl 6 中的变量</title>
      <link>https://ohmysummer.github.io/post/2015-08-25-perl6%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</link>
      <pubDate>Tue, 25 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-25-perl6%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</guid>
      <description>变量名以一个叫做魔符 sigil 的特殊字符开头, 后面跟着一个可选的第二个叫做 twigil 的特殊字符, 然后是一个标识符.
Sigils    符号 类型约束 默认类型 Flattens Assignment     $ Mu (no type constraint) Any No item   &amp;amp; Callable Callable No item   @ Positional Array Yes list   % Associative Hash Yes list    例子:
my $square = 9 ** 2; my @array = 1, 2, 3; # Array variable with three elements my %hash = London =&amp;gt; &#39;UK&#39;, Berlin =&amp;gt; &#39;Germany&#39;;  默认类型可以使用 is 关键字设置。</description>
    </item>
    
    <item>
      <title>Perl 6 单行程序</title>
      <link>https://ohmysummer.github.io/post/2015-08-25-perl-6-%E5%8D%95%E8%A1%8C%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 25 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-25-perl-6-%E5%8D%95%E8%A1%8C%E7%A8%8B%E5%BA%8F/</guid>
      <description>Perl 6 单行程序 这本书在进行之中。我希望你能觉得它有趣，甚至可能有用！如果你想贡献反馈的话，那么很欢迎提问题还有新的或有提升的正则表达式。
作者 戴维法瑞尔 PerlTricks.com
版本 版本 0.01
许可 FreeBSD
贡献者  Alexander Moquin Bruce Gray Carl Mäsak David H. Adler FROGGS Helmut Wollmersdorfer japhb Larry Wall Matt Oates Moritz Lenz Mouq Salve J Nilsen Sam S Skids timotimo  致谢 启发于 Peteris Krumins 的 Perl 5 example 文件。他逐字逐句地写了一本关于 Perl 5 单行 的书。
irc上有很好地 folks。
内容  介绍 教程 文件间距 行号 计算 创建字符串和创建数组 文本转换和替换 文本分析 选择性的行打印 使用管道转换数据(进行中) WWW(进行中) 转换到 Windows  介绍 把 Perl 和其它语言区别开的一件事情是在单行代码中写小程序的能力，即人们所熟知的&amp;rdquo;单行&amp;rdquo;。在终端里直接键入一个程序比写一个废弃的脚本往往更快。并且单行程序也很强大；它们是羽翼丰满的程序，能够加载外部库，但是也能集成到终端中。你可以在单行程序中输入或输出数据。</description>
    </item>
    
    <item>
      <title>cookbook</title>
      <link>https://ohmysummer.github.io/post/2015-08-25-cookbook/</link>
      <pubDate>Tue, 25 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-25-cookbook/</guid>
      <description>字符串处理  将每行从第二列到最后一列数值为0的且数目多于6个的行删除
 数据：
OG004240: 1 3 1 1 9 0 4 5 1 1 6 1 2 OG004241: 1 2 1 4 7 2 1 3 1 2 9 1 1 OG004242: 1 2 1 2 4 1 3 9 2 2 4 2 2 OG004243: 0 4 1 2 9 2 4 5 1 2 3 1 1 OG004244: 0 2 1 3 8 3 3 2 2 3 4 2 2 OG004245: 0 3 1 2 7 3 3 0 3 2 7 2 2 OG004246: 0 0 2 0 1 15 0 15 0 0 1 0 1  use v6; my @lines = &amp;quot;a.</description>
    </item>
    
    <item>
      <title>Perl 6 中的引号</title>
      <link>https://ohmysummer.github.io/post/2015-08-24-perl6%E4%B8%AD%E7%9A%84%E5%BC%95%E5%8F%B7/</link>
      <pubDate>Mon, 24 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-24-perl6%E4%B8%AD%E7%9A%84%E5%BC%95%E5%8F%B7/</guid>
      <description>除了 q 和 qq 之外，现在还有一种基本形式的 Q，它不会进行插值，除非显式地修改它那样做。所以，q 实际上是 Q:q 的简称，qq 实际上是 Q:qq 的简称。实际上所有的 quote-like 形式都派生自带有副词的 Q 形式：
S02-literals/quoting.t lines 95–116 S02-literals/quoting.t lines 132–139
q// Q :q // qq// Q :qq // rx// Q :regex // s/// Q :subst /// tr/// Q :trans ///  诸如 :regex 的副词通过转换到不同的解析器改变了语言的解析。这能完全改变任何之后的副词还有所引起的东西自身的解释。
q:s// Q :q :scalar // rx:s// Q :regex :scalar //  就像 q[...] 拥有简写形式的 &amp;lsquo;&amp;hellip;&amp;rsquo;, 并且 qq[...] 拥有简写形式的 &amp;ldquo;&amp;hellip;&amp;rdquo; 一样，完整的 Q[...] 引用也有一种使用半角括号 ｢&amp;hellip;｣ 的短形式。</description>
    </item>
    
    <item>
      <title>Perl6 Weekly(二)</title>
      <link>https://ohmysummer.github.io/post/2015-08-22-perl6weekly%E7%AC%AC%E4%BA%8C%E6%9C%9F/</link>
      <pubDate>Sat, 22 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-22-perl6weekly%E7%AC%AC%E4%BA%8C%E6%9C%9F/</guid>
      <description>:my $foo 的作用域和用途 在 *regex*、token 或 rule 中, 定义像下面这样的变量是可能的:
token directive { :my $foo = &amp;quot;in command&amp;quot;; &amp;lt;command&amp;gt; &amp;lt;subject&amp;gt; &amp;lt;value&amp;gt;? }  在中提到了一点有关该变量的东西, 我引用过来:
 任何 grammar regex 实际上是一种方法, 并且你可以在这样一个子例程中使用一个冒号跟着任何作用域声明符来声明一个变量, 这些声明符包括 my, our, state 和 constant (作为类似的声明符, temp 和 let 也能被识别). 单个语句(直到结尾的分号或行末尾的闭括号为止) 被解析为普通的 Perl 6 代码:
 token prove-nondeterministic-parsing { :my $threshold = rand; &#39;maybe&#39; \s+ &amp;lt;it($threshold)&amp;gt; }  有谁能解释下这段代码的应用场景吗？
what scope does :my $foo; have? :my $foo 在它所出现的 rule/token/regex 中拥有词法作用域(lexical scope)。你所得到的作用域要么很大要么很小:</description>
    </item>
    
    <item>
      <title>在 Perl 6 中为自定义的类添加下标(subscripts)</title>
      <link>https://ohmysummer.github.io/post/2015-08-18-%E5%9C%A8perl6%E4%B8%AD%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%A0%87subscripts/</link>
      <pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-18-%E5%9C%A8perl6%E4%B8%AD%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%A0%87subscripts/</guid>
      <description>为自定义的类添加下标(subscripts) 假如你定义了一个类，你想把类的实例用作散列那样，可以索引其中的元素， 那么你需要让你得自定义遵守 Associative 接口，并重写 AT-KEY 、EXISTS-KEY 、DELETE-KEY 、push 等跟散列有关的方法:
use v6; class HTTPHeader { ... } class HTTPHeader does Associative { has %!fields handles &amp;lt;self.AT-KEY self.EXISTS-KEY self.DELETE-KEY self.push list kv keys values&amp;gt;; method Str { say self.hash.fmt; } multi method EXISTS-KEY ($key) { %!fields{normalize-key $key}:exists } multi method DELETE-KEY ($key) { %!fields{normalize-key $key}:delete } multi method push (*@_) { %!fields.push: @_ } sub normalize-key ($key) { $key.subst(/\w+/, *.tc, :g) } # titileCase 驼峰式的键 method AT-KEY (::?</description>
    </item>
    
    <item>
      <title>S12-Objects</title>
      <link>https://ohmysummer.github.io/post/2015-08-09-s12-objects/</link>
      <pubDate>Sun, 09 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-09-s12-objects/</guid>
      <description>标题 大纲 12： 对象(Objects)
版本 创建于： 2004-08-27
上次修改时间： 2014-8-26
版本：134
概述 这个大纲总结了第12个启示录, 它探讨关于面向对象的编程。
类 (Classes) S12-class/lexical.t lines 12–61
S12-class/basic.t lines 13–50
S14-roles/lexical.t lines 12–47
类是使用关键字 class 声明的模块。 至于模块, 即公共存储, 接口, 并且类的名字通过包和它的名字来表示, 这总是(但不必须)一个全局的名字。 类是一个模块, 因此能导出东西, 但是类添加了更多的行为来支持 Perl 6 的标准的基于类的 OO。
作为类型对象(type object), 类名代表了它的类型的所有可能值, 因此在计算那种类型的普通对象能做什么时, 类型对象能用作任何属于该类型的&amp;rdquo;真实&amp;rdquo;对象的代理。 类对象是一个对象, 但是它不是一个类(Class), 因为 Perl 6 中没有强制性的 Class 类, 还因为在Perl 6 中类型对象被认为是未定义的。 我们想基于类的和基于原型的 OO 编程这两个都支持。所以, 所有的元编程是通过当前对象的 HOW 对象来完成的, 这可以把元编程代理给任何它喜欢的元模型上。 然而, 默认地, 从 Mu 派生的对象支持相当标准的基于类的模型。
有两种基本的类声明语法:
unit class Foo; # 文件的剩余部分是类的定义 has $.</description>
    </item>
    
    <item>
      <title>rotor</title>
      <link>https://ohmysummer.github.io/post/2015-08-08-rotor/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-08-rotor/</guid>
      <description>method rotor(*@cycle, Bool() :$partial)  rotor 返回一个 list, 这个 list 的元素也是 list, 其中每个子列表由调用者中的元素组成. 在最简单的情况下, @cycle 只包含一个整数, 这时调用者列表被分割为多个子列表, 每个子列表中的元素尽可能多的为那个整数指定的个数. 如果 :$partial 为 True, 不够分的最后那部分也会被包括进去, 即使它不满足长度的要求:
say (&#39;a&#39;..&#39;h&#39;).rotor(3).join(&#39;|&#39;); # a b c|d e f say (&#39;a&#39;..&#39;h&#39;).rotor(3, :partial).join(&#39;|&#39;); # a b c|d e f|g h  如果 @cycle 的元素是一个 /type/Pair, 则 pair 的键指定了所返回子列表的长度(即每个子列表中含有的元素数), pair 的键值指定两个列表之间的间隙; 负的间隙会产生重叠:
say (&#39;a&#39;..&#39;h&#39;).rotor(2 =&amp;gt; 1).join(&#39;|&#39;); # a b|d e|g h say (&#39;a&#39;..&#39;h&#39;).rotor(3 =&amp;gt; -1).join(&#39;|&#39;); # a b c|c d e|e f g &amp;gt; my $pair = 2 =&amp;gt; 1;&amp;gt; my $key = $pair.</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2015)</title>
      <link>https://ohmysummer.github.io/post/2015-08-05-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2015/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-05-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2015/</guid>
      <description>Comming Soon!</description>
    </item>
    
    <item>
      <title>Introspection</title>
      <link>https://ohmysummer.github.io/post/2015-07-25-introspection/</link>
      <pubDate>Sat, 25 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-25-introspection/</guid>
      <description>Perl 6 支持&amp;rdquo;泛型, roles 和 多重分发&amp;rdquo;, 它们都是很好的特点, 并且已经在其它 advent calendar 中发布过了。
但是今天我们要看的是 MOP。 &amp;ldquo;MOP&amp;rdquo;代表着元对象协议(&amp;ldquo;Meta-Object Protocol&amp;rdquo;)。那意味着, 它们实际上是你能从用户那边改变的一部分, 而不是对象、类等定义语言的东西。
实际上, 在 Perl 6中, 你可以为类型添加方法, 移除某个方法, 包裹方法, 使用更多能力增强类(OO::Actors 和 OO::Monitors 就是两个这样的例子), 或者你可以完全重定义它(并且, 例如, 使用 Ruby-like 的对象系统。这儿有个例子)。
但是今天, 我们首先看一下第一部分: 自省。在类型创建完之后查看它的类型, 了解它, 并使用这些信息。
我们将要创建的模块是基于 Sixcheck 模块(一个 QuickCheck-like 模块)的需求: 为某个类型生成一些随机数据, 然后把数据喂给我们正测试的函数, 并检查某些后置条件(post-condition)。
所以, 我们先写出第一个版本:
my %special-cases{Mu} = (Int) =&amp;gt; -&amp;gt; { (1..50).pick }, (Str) =&amp;gt; -&amp;gt; { (&#39;a&#39;..&#39;z&#39;).pick(50).join(&#39;&#39;) }, ; sub generate-data(Mu:U \t) { %special-cases{t} ?? %special-cases{t}() !</description>
    </item>
    
    <item>
      <title>元对象协议</title>
      <link>https://ohmysummer.github.io/post/2015-07-16-%E5%85%83%E5%AF%B9%E8%B1%A1%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Thu, 16 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-16-%E5%85%83%E5%AF%B9%E8%B1%A1%E5%8D%8F%E8%AE%AE/</guid>
      <description>自省和 Perl 6 的对象系统 Perl 6 是构建在元对象层上面的。那意味着有些对象(元对象)控制着各种面向对象结构(例如类、roles、方法、属性、枚举,…)怎样去表现。
要感受类的元对象, 这儿有一个同样的例子出现2次: 一次一种 Perl 6中的普通声明, 一次通过元模型来表达:
class A { method x() { say 42 } } A.x(); # 42  对应于:
constant A := Metamodel::ClassHOW.new_type( name =&amp;gt; &#39;A&#39; ); # class A { A.^add_method(&#39;x&#39;, my method x(A:) { say 42 }); # method x() .. . A.^compose; # } A.x(); # 42  (除了声明形式的运行在编译时, 后面这种形式不是)
对象后面的元对象能使用 $obj.HOW获取, 这儿的 HOW 代表着 Higher Order Workings(或者 HOW the *%@$ does this work?</description>
    </item>
    
    <item>
      <title>Perl 6 中的 Role</title>
      <link>https://ohmysummer.github.io/post/2015-07-15-perl6%E4%B8%AD%E7%9A%84role/</link>
      <pubDate>Wed, 15 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-15-perl6%E4%B8%AD%E7%9A%84role/</guid>
      <description>Composition and mix-ins Sigils Typed data structures Traits  所以到底什么是 role 呢？ role 是零个或多个方法和属性的集合。
role 不像 class，它不能被实例化（如果你尝试了，会生成一个 class）。Perl 6 中 Classes 是可变的，而 roles 是不可变的。
申明 Roles 就像申明 Class 一样： 使用关键字 role来引入 role, 在 role 中声明属性和方法就像在 Perl 6 的类中声明属性和方法那样。
role DebugLog { has @.log_lines; has $.log_size is rw = 100; method log_message($message) { @!log_lines.shift if @!log_lines.elems &amp;gt;= $!log_size; @!log_lines.push($message); } }  Role Composition  使用 does trait 将 role 组合到 Class 中：  class WebCrawler does DebugLog { .</description>
    </item>
    
    <item>
      <title>Perl 6 rotor--列表操作之王</title>
      <link>https://ohmysummer.github.io/post/2015-07-14-perl-6-rotor-%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%8E%8B/</link>
      <pubDate>Tue, 14 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-14-perl-6-rotor-%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%8E%8B/</guid>
      <description>Perl 6 .rotor - The King of List Manipulation
对于 Perl 6 程序员, .rotor是一个强大的列表操作工具。
分段 最简单的, .rotor接收一个整数$number并把列表分成多个子列表, 每个子列表含有 $number 个元素:
say &amp;lt;a b c d e f g h&amp;gt;.rotor: 3 # ((a b c) (d e f))  我们有一个含有 8 个元素的列表, 我们在该列表上调用接收参数 3 的 .rotor方法, 它返回 2 个列表, 每个列表中含有 3 个元素。不包括原列表中的最后 2 个元素, 因为它们没有组成一个完整的3个元素的列表。然而它们可以被包含进来, 使用 :partial具名参数设置为 True:
say &amp;lt;a b c d e f g h&amp;gt;.rotor: 3, :partial # ((a b c) (d e f) (g h)) say &amp;lt;a b c d e f g h&amp;gt;.</description>
    </item>
    
    <item>
      <title>Grammar 笔记</title>
      <link>https://ohmysummer.github.io/post/2015-07-11-grammar%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 11 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-11-grammar%E7%AC%94%E8%AE%B0/</guid>
      <description>一个 Grammar 解析复杂文本的例子。
一个 Grammar 调了很久, 先分解下：
 解析[ ] 里面的数据：  use v6; use Grammar::Debugger; grammar Lines { token TOP { ^ &amp;lt;line&amp;gt;+ $ } token line { \[ &amp;lt;student&amp;gt;+ % &amp;lt;semicolon&amp;gt; \] \n # 换行 \n 是最容易被忽略的地方, 坑了很多次了！ } token student { &amp;lt;myname&amp;gt;+ % &amp;lt;comma&amp;gt; # 分隔符也可以是一个 subrule } token myname { &amp;lt;[A..Za..z-]&amp;gt;+ # 字符类的写法 &amp;lt;[...]&amp;gt; } token comma { &#39;,&#39; \s+ # 逗号, 分号 不能裸露出现在 token 中 } token semicolon { &#39;;&#39; \s+ } } my $parse = Lines.</description>
    </item>
    
    <item>
      <title>MAIN 中的冒号</title>
      <link>https://ohmysummer.github.io/post/2015-07-05-main-%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</link>
      <pubDate>Sun, 05 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-05-main-%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</guid>
      <description>假如我有多个文本文件, 我要写一段脚本来进行替换操作。在命令行中提供一些列选项供配置。文本格式如下:
Perl 6 很灵活 Perl 6 很强大 Perl 6 很复杂 I 123 Love Perl Six 尽管它456还很稚嫩789 对了, 它的 logo 是一个可爱的456花蝴蝶。  我想把每行中第一次出现的 3 位数字替换为 &amp;ldquo;在木星&amp;rdquo;。
@蘑菇 的脚本:
use v6; use MONKEY-SEE-NO-EVAL; sub MAIN(Str :$regex, Str :$substr, Str :$ext = &#39;.out&#39;, Int :$ignore-line = 0, *@files) { for @files -&amp;gt; $file { my $out = open $file ~ &amp;quot;.out&amp;quot;, :w; # 写入文件 for $file.IO.lines.kv -&amp;gt; $index, $line is copy { next if $index &amp;lt;= $ignore-line; # 忽略前 $ignore-line几行 $line ~~ EVAL &amp;quot;s/&amp;quot; ~ $regex ~ &amp;quot;/&amp;quot; ~ $substr ~ &amp;quot;/&amp;quot;; # 根据正则表达式进行替换 say $/; $out.</description>
    </item>
    
    <item>
      <title>散列也是容器</title>
      <link>https://ohmysummer.github.io/post/2015-06-28-%E6%95%A3%E5%88%97%E4%B9%9F%E6%98%AF%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sun, 28 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-06-28-%E6%95%A3%E5%88%97%E4%B9%9F%E6%98%AF%E5%AE%B9%E5%99%A8/</guid>
      <description>散列也是容器 假设我们想计算某个东西的出现次数, 我们通常的做法是弄一个 &amp;ldquo;seen-hash&amp;rdquo; 散列。有时候我们有一组待查询的键, 其中有些键可能不在我们所扫描的数据中。那是一种特殊情况, 但是 Perl 6 能够完美地解决, 因为散列也是容器, 因此我们能够拥有默认值。
my $words = &amp;lt;Hashes are containers too&amp;gt;.lc; constant alphabet = &#39;a&#39; .. &#39;z&#39;; my %seen of Int is default(0); %seen{$_}++ for $words.comb; put &amp;quot;$_: %seen{$_}&amp;quot; for alphabet;  输出结果:
a: 3 b: 0 c: 1 d: 0 e: 3 f: 0 g: 0 h: 2 i: 1 j: 0 k: 0 l: 0 m: 0 n: 2 o: 3 p: 0 q: 0 r: 2 s: 3 t: 2 u: 0 v: 0 w: 0 x: 0 y: 0 z: 0  $words 中没有出现的特殊字符由 is default(0) 处理了。 默认值可以被精心设计。我们来弄一个在数值上下文中为默认值为 0 但是在字符串上下文中为默认值为 NULL 并且总是被定义的一个散列。</description>
    </item>
    
    <item>
      <title>找到两个文件中共有的行</title>
      <link>https://ohmysummer.github.io/post/2015-06-18-%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E5%85%B1%E6%9C%89%E7%9A%84%E8%A1%8C/</link>
      <pubDate>Thu, 18 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-06-18-%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E5%85%B1%E6%9C%89%E7%9A%84%E8%A1%8C/</guid>
      <description>找出两个文件中共有的行, 顺序无关紧要 在 Perl 5 里, 你可以这样:
#!/usr/bin/env perl use 5.010; use warnings; use strict; my %filea = map { $_ =&amp;gt; 1 } do { open my $fa, &#39;&amp;lt;&#39;, &#39;filea&#39; or die $!; &amp;lt;$fa&amp;gt; }; my %fileb = map { $_ =&amp;gt; 1 } do { open my $fb, &#39;&amp;lt;&#39;, &#39;fileb&#39; or die $!; &amp;lt;$fb&amp;gt; }; for( keys %filea ){ print if $fileb{$_}; }  在 Perl 6 中就长这样:</description>
    </item>
    
    <item>
      <title>面向对象的 Perl 6</title>
      <link>https://ohmysummer.github.io/post/2015-06-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84perl6/</link>
      <pubDate>Mon, 15 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-06-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84perl6/</guid>
      <description>https://docs.perl6.org/language/objects
Perl 6 为面向对象编程(OOP)提供强大支持。尽管 Perl 6 允许程序员以多种范式进行编程，但面向对象编程是该语言的核心。
Perl 6 带有丰富的预定义类型，可分为两类：常规类型和原生类型。所有你能存储到变量中的东西要么是一个原生的 value, 要么是一个对象。这包括字面值、类型（类型对象）、code 和容器。
原生类型用于底层类型（例如 uint64）。尽管原生类型没有和对象同样的功能，如果在其上调用方法，它们也会自动装入普通对象。
一切不是原生值的东西都是一个对象。对象确实允许继承和封装。
使用对象 要在对象上调用方法，请在对象名上添加一个点，然后添加方法名称：
say &amp;quot;abc&amp;quot;.uc; # OUTPUT: «ABC␤»  这将在 &amp;ldquo;abc&amp;rdquo; 上调用 uc 方法, 这是一个 Str 类型的对象。要为方法提供参数, 请在方法后面的括号内添加参数。
my $formatted-text = &amp;quot;Fourscore and seven years ago...&amp;quot;.indent(8); say $formatted-text; # OUTPUT: « Fourscore and seven years ago... »  $formatted-text 现在包含上面的文本，但缩进了8个空格。
多个参数由逗号分隔：
my @words = &amp;quot;Abe&amp;quot;, &amp;quot;Lincoln&amp;quot;; @words.push(&amp;quot;said&amp;quot;, $formatted-text.comb(/\w+/)); say @words; # OUTPUT: «[Abe Lincoln said (Fourscore and seven years ago)]␤»  类似地，可以通过在方法后放置冒号并使用逗号分隔参数列表来指定多个参数：</description>
    </item>
    
    <item>
      <title>正则表达式一例</title>
      <link>https://ohmysummer.github.io/post/2015-06-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%E4%BE%8B/</link>
      <pubDate>Sun, 14 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-06-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%E4%BE%8B/</guid>
      <description>以指定音量随机播放音频文件：
#!/usr/bin/env perl6 use v6; my %v; # hash to hold data my token filename { .+? \.\S\S\S }; # filenames end in .??? my token volume { \d+ }; # any digits for volume my regex extra { .+ \S }; # anything following that my $mixer = &#39;mixer&#39;; my $player = &#39;mplayer -vf dsize=600:-2 -geometry +200-10 &#39;; my $lockfile = &#39;/tmp/myplayer&#39;; $lockfile.IO.spurt( $*PID ); # store the process ID so other process can kill this one END { $lockfile.</description>
    </item>
    
    <item>
      <title>class-List</title>
      <link>https://ohmysummer.github.io/post/2015-06-10-class-list/</link>
      <pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-06-10-class-list/</guid>
      <description>my class List is Iterable does Positional { .. }  List 以序列化的方式存储 items并且潜在是惰性的。
默认列表和数组的索引从 0 开始。
你可以给列表中的元素赋值如果它们是容器的话。使用数组以使列表中的每个元素存储在容器中。
Items, Flattening and Sigils 在 Perl 6 中, 把 List 赋值给一个标量变量不会丢死信息。不同之处在于迭代通常会把标量中的列表(或其它任何像列表的东西, 例如 Parcel 和 数组)当作单个元素。
my @a = 1, 2, 3; for @a { } # 三次迭代  my $s = @a; for $s { } # 一次迭代 for @a.item { } # 一次迭代 for $s.list { } # 三次迭代  Lists 通常会插值(展开)除非它们通过一个 item(scalar)容器访问:(GLR 的影响？)</description>
    </item>
    
    <item>
      <title>Slip一例</title>
      <link>https://ohmysummer.github.io/post/2015-05-19-slip%E4%B8%80%E4%BE%8B/</link>
      <pubDate>Tue, 19 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-19-slip%E4%B8%80%E4%BE%8B/</guid>
      <description> 描述 有 7 块板子放在一个&amp;rdquo;袋子&amp;rdquo;中, 随机从袋子中移除一个板子展示到玩家面前直到袋子变空。当袋子变空时, 它会被重新装填, 如果需要额外的板子, 则重复前面那个过程。
输出 使用随机 bag 系统随机输出 50 块板子。
板子如下:
 O I S Z L J T  输出样本  LJOZISTTLOSZIJOSTJZILLTZISJOOJSIZLTZISOJTLIOJLTSZO OTJZSILILTZJOSOSIZTJLITZOJLSLZISTOJZTSIOJLZOSILJTS ITJLZOSILJZSOTTJLOSIZIOLTZSJOLSJZITOZTLJISTLSZOIJO  在 Perl 6 中我会这样写 (smls):
say (|&amp;lt;O I S Z L J T&amp;gt;.pick(*) xx *).[^50].join;  注意:
 | 操作符把每次迭代的项展开进外部的列表中, 以使你不必在结果上显式地调用 .flat 方法 使用 &amp;lt; &amp;gt; 字符串列表字面量看起来比在字符串字面量上使用 .comb 方法更合适 xx 操作符每次都会重新计算它左侧的表达式  </description>
    </item>
    
    <item>
      <title>怎么在 Perl 6 中自定义存取器</title>
      <link>https://ohmysummer.github.io/post/2015-05-19-%E6%80%8E%E4%B9%88%E5%9C%A8perl6%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%8F%96%E5%99%A8/</link>
      <pubDate>Tue, 19 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-19-%E6%80%8E%E4%B9%88%E5%9C%A8perl6%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%8F%96%E5%99%A8/</guid>
      <description>How does one write custom accessor methods in Perl6? 我有一个类:
class Wizard { has Int $.mana is rw; }  我可以这样做:
my Wizard $gandalf .= new; $gandalf.mana = 150;  我想在不放弃使用$gandalf.mana = 150; 的情况下, 在 setter里面做一些检查。换句话说, 我不想这样写: $gandalf.setMana(150)。 如果程序尝试设置一个负值的话, 就退出。
class Wizard { has Int $!mana; method mana() is rw { return Proxy.new: FETCH =&amp;gt; sub ($) { return $!mana }, STORE =&amp;gt; sub ($, $mana) { die &amp;quot;It&#39;s over 9000!</description>
    </item>
    
    <item>
      <title>下标副词</title>
      <link>https://ohmysummer.github.io/post/2015-05-18-%E4%B8%8B%E6%A0%87%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-18-%E4%B8%8B%E6%A0%87%E5%89%AF%E8%AF%8D/</guid>
      <description>下标副词 为了使切片下标返回除了值以外的其它东西，那么给下标(subscript)添加合适的副词。
@array = &amp;lt;A B&amp;gt;; @array[0,1,2]; # returns &#39;A&#39;, &#39;B&#39;, (Any) @array[0,1,2] :p; # returns 0 =&amp;gt; &#39;A&#39;, 1 =&amp;gt; &#39;B&#39; @array[0,1,2] :kv; # returns 0, &#39;A&#39;, 1, &#39;B&#39; @array[0,1,2] :k; # returns 0, 1 @array[0,1,2] :v; # returns &#39;A&#39;, &#39;B&#39; %hash = (:a&amp;lt;A&amp;gt;, :b&amp;lt;B&amp;gt;); %hash&amp;lt;a b c&amp;gt;; # returns &#39;A&#39;, &#39;B&#39;, (Any) %hash&amp;lt;a b c&amp;gt; :p; # returns a =&amp;gt; &#39;A&#39;, b =&amp;gt; &#39;B&#39; %hash&amp;lt;a b c&amp;gt; :kv; # returns &#39;a&#39;, &#39;A&#39;, &#39;b&#39;, &#39;B&#39; %hash&amp;lt;a b c&amp;gt; :k; # returns &#39;a&#39;, &#39;b&#39; %hash&amp;lt;a b c&amp;gt; :v; # returns &#39;A&#39;, &#39;B&#39;  如果副词为真，那么这些副词形式都会清除不存在的条目；如果为假的话，就会留下不存在的项，就像普通的切片那样。所以：</description>
    </item>
    
    <item>
      <title>在 Perl 6 中异步地执行外部程序</title>
      <link>https://ohmysummer.github.io/post/2015-05-14-%E5%9C%A8perl6%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%9C%B0%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Thu, 14 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-14-%E5%9C%A8perl6%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%9C%B0%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>Execute an external program with timeout in Perl6
Proc::Async 允许我们异步地执行外部程序。
my $proc = Proc::Async.new(&amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;-o&amp;quot;, &amp;quot;index.html&amp;quot;, &amp;quot;http://www.cpan.org&amp;quot;); my $res = await $proc.start;  我们可以在 Proc::Async 中使用超时吗? Proc::Async 没有正式支持该功能，但是我们可以很容易地实现它。看一下这个：
class Proc::Async::Timeout is Proc::Async { has $.timeout is rw; method start($self: |) { return callsame unless $.timeout; my $killer = Promise.in($.timeout).then: { $self.kill }; my $promise = callsame; Promise.anyof($promise, $killer).then: { $promise.result }; } } my $proc = Proc::Async::Timeout.new(&amp;quot;perl&amp;quot;, &amp;quot;-E&amp;quot;, &amp;quot;sleep 5; warn &#39;end&#39;&amp;quot;); $proc.</description>
    </item>
    
    <item>
      <title>Perl 6 入门指南</title>
      <link>https://ohmysummer.github.io/post/2015-05-08-perl-6-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 08 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-08-perl-6-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</guid>
      <description>exit，warn，die exit
#!/usr/bin/env perl6 use v6; say &amp;quot;hello&amp;quot;; exit; say &amp;quot;world&amp;quot;; # 这句不会执行了  #!/usr/bin/env perl6 use v6; warn &amp;quot;This is a warning&amp;quot;; # 打印警告，带行号 say &amp;quot;Hello World&amp;quot;;  die
#!/usr/bin/env perl6 use v6; say &amp;quot;Before calling die&amp;quot;; die &amp;quot;This will kill the script&amp;quot;; say &amp;quot;This will not show up&amp;quot;;  Hello World Hello World
使用关键字 say打印出字符串，并在字符串结尾自动添加一个换行符。字符串被双引号包裹住。Perl 6 中语句以分号结束。 examples/intro/hello_world.p6
#!/usr/bin/env perl6 use v6; say &amp;quot;Hello Perl 6 World&amp;quot;;  同样地， OOP 风格: examples/intro/hello_world_oop.</description>
    </item>
    
    <item>
      <title>Sneaky methods</title>
      <link>https://ohmysummer.github.io/post/2015-05-01-sneaky-methods/</link>
      <pubDate>Fri, 01 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-01-sneaky-methods/</guid>
      <description>Sneaky methods
就像你想的那样, 在类的定义中可以声明和定义方法。你期望不高的甚至文档中都很少提及是用 my 关键字声明的免费浮点方法。现在为什么你想要:
my method foo(SomeClass:D:) { self }  明显的答案是元对象协议中的 add_method 方法, 在 Rakudo 里你能找到它：
src/core/Bool.pm 32: Bool.^add_method(&#39;pred&#39;, my method pred() { Bool::False }); 33: Bool.^add_method(&#39;succ&#39;, my method succ() { Bool::True }); 35: Bool.^add_method(&#39;enums&#39;, my method enums() { self.^enum_values });  这种方法还有另外一种更诡异的用法。你可能很想知道在链式方法调用中究竟发生了什么。我们可以扯开最上面的那个表达式并插入一个短的变量, 输出我们的调试, 并且继续链式调用。好的名字很重要并且把它们浪费在一个短变量上没有必要。
&amp;lt;a b c&amp;gt;.&amp;amp;(my method ::(List:D) { dd self; self } ).say; # output # (&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;) # (a b c)  没有显式调用我们就不能没有名字, 因为 Perl 6 不允许我们这样做, 所以我们使用了空的作用域 :: 以使解析器高兴。使用一个合适的调用, 我们就不需要它了。还有, 那个匿名方法不是 List 中的一员。我们需要使用后缀 .</description>
    </item>
    
    <item>
      <title>Perl 6 中的正则表达式(五)</title>
      <link>https://ohmysummer.github.io/post/2015-04-28-perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%94/</link>
      <pubDate>Tue, 28 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-28-perl6%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%94/</guid>
      <description>从匹配中返回值 Match 对象  成功的匹配总是返回一个 Match 对象, 这个对象通常也被放进 $/ 中, (具名 regex, token, 或 rule 是一个子例程, 因此会声明它们自己的本地 $/ 变量, 它通常指 rule 中最近一次的 submatch, 如果有的话)。当前的匹配状态被保存到 regex 的 $¢ 变量中, 当匹配结束时它最终会被绑定到用户的 $/变量中  不成功的匹配会返回 Nil (并把 $/ 设置为 Nil, 如果匹配已经设置了 $/的话)
 名义上, Match 对象包含一个布尔的成功值, 一个有序的子匹配对象(submatch objects)数组, 一个具名的子匹配对象(submatch objects)散列.(它也可选地包含一个用于创建抽象语法树(AST)的抽象对象) 为了提供访问这些各种各样值的便捷方法, Match 对象在不同上下文中求值也不同:
 在布尔上下文中 Match 对象被求值为真或假
  if /pattern/ {...} # 或: /pattern/; if $/ {...}  如果模式使用 :global 或 :overlap 或 :exhaustive 修饰符, 会在第一个匹配处返回布尔真值.</description>
    </item>
    
    <item>
      <title>从正则表达式到Grammars - Part 1</title>
      <link>https://ohmysummer.github.io/post/2015-04-27-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammars-part-1/</link>
      <pubDate>Mon, 27 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-27-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammars-part-1/</guid>
      <description>原文
略去啰嗦的前半部分。
Into the Breach 假设我们 的日志文件中有一个时间戳 2016-02-06T14:36+02:00, 我们使用智能匹配:
say $logfile ~~ /2016-02-06T14:36+02:00/;  这会报错:
 Unrecognized regex metacharacter - (must be quoted to match literally)
 在 Perl 6 的正则表达式中任何非字母数字字符(&amp;lsquo;a&amp;rsquo;..&amp;lsquo;z&amp;rsquo;, &amp;lsquo;A&amp;rsquo;..&amp;lsquo;Z&amp;rsquo;, 0..9)都必须用引号引起来:
say $logfile ~~ /2016 &#39;-&#39; 02 &#39;-&#39; 06T14 &#39;:&#39; 36 &#39;+&#39; 02 &#39;:&#39; 00/;  现在我们得到等价的奇怪的表达式:
｢2016-01-29T13:25+01:00｣  这仅仅告诉我们, ~~智能匹配操作符匹配了一些文本, 这就是它匹配到的文本。｢｣ 是日语引文标记, 故意和剩余的文本区分开来。
在 Perl 6 中, 默认打印出带有明确标记的匹配对象, 它准确地告诉你匹配从哪里开始, 到哪里结束。
归纳 我们想让该正则表达式更具普遍性, 例如匹配 2016 年的日志:
say $logfile ~~ /2015 | 2016 &#39;-&#39; 02 &#39;-&#39; 06T14 &#39;:&#39; 36 &#39;+&#39; 02 &#39;:&#39; 00/;  但是这还会匹配到我们不想要的东西, 例如 &amp;rsquo;/post/2015/02&amp;rsquo; 或者甚至 &amp;lsquo;/number/120153&amp;rsquo;。因为 |的优先级没有字符间的连接优先级高。所以:</description>
    </item>
    
    <item>
      <title>Grammars generating grammars</title>
      <link>https://ohmysummer.github.io/post/2015-04-15-grammars-generating-grammars/</link>
      <pubDate>Wed, 15 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-15-grammars-generating-grammars/</guid>
      <description>现在你可能已经习惯了 Perl 6 中到处出现的前缀&amp;rdquo;meta&amp;rdquo;。Metaclasses, Metaobjects, Metaoperators, 还有迷一般的 Meta-Object 协议。听起来一点也不可怕, 你都见过了不是吗？今天, 在 Perl 6 Advent Calendar 上, 我们将进行完全的 meta 化(full meta)。我们将拥有能解析 grammars 的 grammars, 然后生成将用于解析 grammars 的 grammars。
Grammars 无疑是 Perl 6 的杀手级功能。我们拥有了正则表达式曾经没有的东西: 可读性、可组合性当然还有解析 Perl 6 自身的能力。— 如果这不能展示它的强大, 那我不知道什么能够!
为预定义好的 grammars(例如以 Bachus-Naur 形式)写解析器总是有点无趣, 几乎和复制粘贴一样。如果你曾经坐下来重头开始写一个解析器(或者期间温习一遍那本优秀的&amp;rdquo;让我们构建一个编译器&amp;rdquo;图书), 你可能会意识到模式是如此相似:从你的 grammar 中拿出单个 rule, 为它写一个子例程, 让它调用(可能是递归的)其它类似的为其它 grmmars rules 定义的子例程, 清洗, 重复。现在我们有了Perl 6 Grammars! 在这个新世界中, 我们不必为每个 token 写上子例程来完成工作了。 现在我们写 grammar 类, 里面放上 *tokens*、*rules*、regexes 标志。在标志里写正则表达式(或代码)并引用(可能是递归的) Perl 6 gramamr 中的其它标志。如果你曾经使用过这些东西, 你肯定会意识到 Perl 6 中的 gramamrs 是多么的方便。</description>
    </item>
    
    <item>
      <title>Perl 6圣诞月历-(2012)</title>
      <link>https://ohmysummer.github.io/post/2015-04-15-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2012/</link>
      <pubDate>Wed, 15 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-15-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2012/</guid>
      <description>2012 一个日历 #!/usr/bin/env perl6 constant @months = &amp;lt;January February March April May June July August September October November December&amp;gt;; constant @days = &amp;lt;Su Mo Tu We Th Fr Sa&amp;gt;; sub center(Str $text, Int $width) { my $prefix = &#39; &#39; x ($width - $text.chars) div 2; my $suffix = &#39; &#39; x $width - $text.chars - $prefix.chars; return $prefix ~ $text ~ $suffix; } sub MAIN(:$year = Date.today.year, :$month = Date.</description>
    </item>
    
    <item>
      <title>Capture</title>
      <link>https://ohmysummer.github.io/post/2015-04-01-capture/</link>
      <pubDate>Wed, 01 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-01-capture/</guid>
      <description>Capture 的定义:
class Capture does Positional does Associative { }  Capture 是一个用于给 code 对象传递参数的容器。Captures 是签名的另一面 — Captures 在调用方定义实参, 而签名(Signatures) 在被调用方定义形式参数。
当你调用 print $a, $b 时, $a, $b 这部分就是一个 Capture。$a, $b 在这儿是实参。
Captures 包含一个 list-like 部分的位置参数和一个 hash-like 部分的具名参数。对于具名参数, Captures 使用一种略微不同的语法而不是普通的 List。有两种简单的方法生成一个具名参数：
 使用一个未引起的键命名一个形参, 后面跟着 =&amp;gt;, 然后跟着参数 使用以形参命名的冒号对儿字面量  say unique 1, -2, 2, 3, as =&amp;gt; { abs $_ }; # 1, -2, 3 # ... is the same thing as: say unique 1, -2, 2, 3, :as({ abs $_ }); # 1, -2, 3 # Be careful not to quote the name of a named parameter: say unique 1, -2, 2, 3, &#39;as&#39; =&amp;gt; { abs $_ }; # 1, -2, 2, 3, &amp;quot;as&amp;quot; =&amp;gt; { .</description>
    </item>
    
    <item>
      <title>Perl 6 中的模块</title>
      <link>https://ohmysummer.github.io/post/2015-03-23-perl6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 23 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-23-perl6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/</guid>
      <description>Modules Exporting and Selective Importing is export packages(包), subroutines(子例程), variables(变量), constants(常量) 和 enums(枚举) , 通过在它们的名字后面添加 is export 特性来导出。
unit module MyModule; our $var is export = 3; sub foo is export { ... }; constant $FOO is export = &amp;quot;foobar&amp;quot;; enum FooBar is export &amp;lt;one two three&amp;gt;; # Packages like classes can be exported too class MyClass is export {}; # If a subpackage is in the namespace of the current package # it doesn&#39;t need to be explicitly exported class MyModule::MyClass {};  就像所有的 traits 一样, 如果应用到子例程(routine)上, &amp;ldquo;is export&amp;rdquo; 应该出现在参数列表的后面:</description>
    </item>
    
    <item>
      <title>Sneaking into a loop</title>
      <link>https://ohmysummer.github.io/post/2015-03-23-sneaking-into-a-loop/</link>
      <pubDate>Mon, 23 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-23-sneaking-into-a-loop/</guid>
      <description>Sneaking into a loop [Sneaking into a loop]https://gfldex.wordpress.com/2016/08/10/sneaking-into-a-loop/
Zoffix 回答了一个关于 Perl 5s &amp;lt;&amp;gt; 操作符的问题。
slurp.words.Bag.sort(-*.value).fmt(&amp;quot;%10s3d\n&amp;quot;).say;  slurp 会从 STDIN 中读取整个 &amp;ldquo;file&amp;rdquo; 并返回一个 Str。方法 Str::words 会按照某种 Unicode 意义的单词把该字符串分割成一个列表。把列表强转为 Bag 则创建一个计数 Hash, 它是如下表述的快捷方式。
my %h; %h{$_}++ for &amp;lt;peter paul marry&amp;gt;; dd %h; # # OUTPUT«Hash %h = {:marry(1), :paul(1), :peter(1)}␤»  在关联数组上调用 .sort(-*.value) 会按照值的降序排序并返回一个排序后的 Pairs 列表。List::fmt 会调用 Pair::fmt, 它调用 fmt 方法, .key 作为其第二个参数, .value 也作为参数。say 会会使用一个空格连接各个元素并输出到标准输出。最后一步有一点错误因为除了第一行之外的每一行前面都会有一个额外的空格。
slurp.words.Bag.sort(-*.value).fmt(&amp;quot;%10s =&amp;gt; %3d&amp;quot;).join(&amp;quot;\n&amp;quot;).say;  手动连接字符串更好。这对于简短的单行程序来说有点多了。我们需要找到最长的单词并使用 .</description>
    </item>
    
    <item>
      <title>Perl 6 的薛定谔的猫--Junctions</title>
      <link>https://ohmysummer.github.io/post/2015-03-22-perl-6-%E7%9A%84%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E7%8C%AB-junctions/</link>
      <pubDate>Sun, 22 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-22-perl-6-%E7%9A%84%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E7%8C%AB-junctions/</guid>
      <description>薛定谔欧文应该是喜欢 Perl 6 的, 因为他的著名的薛定谔的猫可以用 Perl 6 的 Junction表达:
my $cat = &#39;dead&#39; | &#39;alive&#39;; say &amp;quot;cat is both dead and alive&amp;quot; if $cat eq &#39;dead&#39; and $cat eq &#39;alive&#39;; # OUTPUT: # cat is both dead and alive  这里面发生了什么事情? 我会告诉你全部的!
Anyone 游戏? 拿最简单的来说, Junctions 允许你把一堆值当作单个值。例如, 你可以使用 any Junction 来测试一个变量是否等于所给定值中的任意一个:
say &#39;it matches!&#39; if &#39;foo&#39; eq &#39;foo&#39; | &#39;bar&#39; | &#39;ber&#39;; say &#39;single-digit prime&#39; if 5 == any ^9.</description>
    </item>
    
    <item>
      <title>Subset</title>
      <link>https://ohmysummer.github.io/post/2015-03-19-subset/</link>
      <pubDate>Thu, 19 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-19-subset/</guid>
      <description>Subset 子集 Subset 可用于声明某一类型的子集。
输入一个密码， 要求密码必须满足如下条件：
1、 至少 8 位 2、 必须包含大写字母、小写字母 和 数字
use v6; subset Length8 of Str where *.chars &amp;lt; 8; subset UpCase of Str where none(&#39;A&#39;..&#39;Z&#39;) ∈ *.comb.Set; subset LowerCase of Str where none(&#39;a&#39;..&#39;z&#39;) ∈ *.comb.Set; subset IntNumber of Str where none(&#39;0&#39;..&#39;9&#39;) ∈ *.comb.Set; my $guess = prompt(&#39;Enter your password:&#39;); given $guess { when Length8 { say &#39;密码长度必须为 8 位 以上&#39;; proceed } when UpCase { say &#39;密码必须包括大写字母&#39;; proceed } when LowerCase { say &#39;密码必须包含小写字母&#39;; proceed } when IntNumber { say &#39;密码必须包含数字&#39;; } }  该程序具有可扩展性， 要增加一种密码验证， 只有添加一个 subset 就好了，然后在 given/When 里面增加一个处理。</description>
    </item>
    
    <item>
      <title>操作符</title>
      <link>https://ohmysummer.github.io/post/2015-03-16-%E6%93%8D%E4%BD%9C%E7%AC%A6/</link>
      <pubDate>Mon, 16 Mar 2015 13:16:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-16-%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid>
      <description>操作符 操作符优先级 在像 1 + 2 * 3 这样的表达式中， 2 * 3 被首先计算， 因为中缀操作符 * 的优先级比 + 的优先级高。下面的表中总结了 Perl 6 中 的优先级级别， 从最牢固到最松散：
A Level Examples N Terms 42 3.14 &amp;quot;eek&amp;quot; qq[&amp;quot;foo&amp;quot;] $x :!verbose @$array L 方法后缀 .meth .+ .? .* .() .[] .{} .&amp;lt;&amp;gt; .«» .:: .= .^ .: N 自增 ++ -- R 求幂 ** L Symbolic unary ! + - ~ ? | || +^ ~^ ?</description>
    </item>
    
    <item>
      <title>Perl 6 中的特性(二)</title>
      <link>https://ohmysummer.github.io/post/2015-03-16-perl6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%BA%8C/</link>
      <pubDate>Mon, 16 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-16-perl6%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%BA%8C/</guid>
      <description>Set my $keywords = set &amp;lt;if for unless while&amp;gt;; # create a set sub has-keyword(*@words) { for @words -&amp;gt; $word { return True if $word (elem) $keywords; # 依次检查数组中的元素是否属于集合 $keywords } False; } say has-keyword &#39;not&#39;, &#39;one&#39;, &#39;here&#39;; # False say has-keyword &#39;but&#39;, &#39;here&#39;, &#39;for&#39;; # True  Series Operator my @a=&amp;lt;A G C T&amp;gt;; my $x=@a; for 1 ... * -&amp;gt; $a { (( [X~] $x xx $a )).</description>
    </item>
    
    <item>
      <title>When and Where</title>
      <link>https://ohmysummer.github.io/post/2015-03-15-when%E5%92%8Cwhere/</link>
      <pubDate>Sun, 15 Mar 2015 13:15:00 +0300</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-15-when%E5%92%8Cwhere/</guid>
      <description>When 可以用在主题化($_)的语句中 Perl 里面有个特殊的变量叫 $_, 即主题化变量, the variable in question.
&amp;gt; for (&#39;Swift&#39;, &#39;PHP&#39;, &#39;Python&#39;, &#39;Perl&#39;) -&amp;gt; $item { say $item when $item ~~ /^P/ } PHP Python Perl  &amp;gt; for (12, 24, 56, 42) {.say when *&amp;gt;40 } 56 42  而 where 用于对类型进行约束.
&amp;gt; for (&#39;Swift&#39;, &#39;PHP&#39;, &#39;Python&#39;, &#39;Perl&#39;, 42) -&amp;gt; $item where $item ~~ Str {say $item} Swift PHP Python Perl Constraint type check failed for parameter &#39;$item&#39;  未完待续.</description>
    </item>
    
    <item>
      <title>Using Perl 6(一)</title>
      <link>https://ohmysummer.github.io/post/2015-03-14-using-perl-6%E4%B8%80/</link>
      <pubDate>Sat, 14 Mar 2015 13:14:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-14-using-perl-6%E4%B8%80/</guid>
      <description>第一章 概要 Comming soon!
第二章 基础 假设有一场乒乓球比赛，比赛结果以这种格式记录： Player1 Player2 | 3:2 这意味着选手1与选手2的比分为3:2, 你需要一个脚本算出每位选手赢了几场比赛并且胜了几局。 输入数据（存储在一个叫做scores的文件中）像下面这样：
Beth Ana Charlie Dave Ana Dave | 3:0 Charlie Beth | 3:1 Ana Beth | 2:3 Dave Charlie | 3:0 Ana Charlie | 3:1 Beth Dave | 0:3  第一行是选手清单。随后每一行记录着比赛结果。
这里使用Perl6给出一种解决方案：
use v6; my $file = open &#39;scores&#39;; my @names = $file.get.words ; #get方法读入一行，每调用一次get，读取一行 # &amp;gt; @names.perl # Array.new(&amp;quot;1&amp;quot;, &amp;quot;Beth&amp;quot;, &amp;quot;Ana&amp;quot;, &amp;quot;Charlie&amp;quot;, &amp;quot;Dave&amp;quot;) my %matches; # 赢得比赛次数 my %sets; # 赢得比赛局数 for $file.</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2014)</title>
      <link>https://ohmysummer.github.io/post/2014-12-19-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2014/</link>
      <pubDate>Fri, 19 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2014-12-19-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2014/</guid>
      <description>2014 Data munging in Perl 6 vs Perl 5 案例学习: 生成成绩报告单
example.txt STDOUT Peter B Celine A- Zsófia B+ João F Maryam B+ 秀英 B- Finn D+ Aarav A Emma F Omar B  输出报告单：
Zsófia&#39;s grade: B+ List of students with a failing grade: João, Emma Distribution of grades by letter: A: 2 students B: 5 students D: 1 student F: 2 students  example.txt 是一个文本文件， 每行一个学生姓名和分数，中间用空格分割。 我们希望我们的脚本能解析这样的文件并打印含有如下信息的报告：</description>
    </item>
    
    <item>
      <title>Perl 6 Grammars, Part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-13-perl-6-grammers-part-1/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-13-perl-6-grammers-part-1/</guid>
      <description>Perl 6 Grammars, Part 1 Perl 6 语言内置了对 grammar 的支持。您可以将 grammars 视为众所周知的正则表达式和诸如 yacc 或 bison 等实用程序或更复杂的 grammar 工具（如ANTLR）的组合。所有这些 - 词法分析器，语法分析器和语义处理 - 通常是编译器的独立部分，在 Perl 6 中它们都是内置的，并且可以通过全新的 Perl 6 安装 进行开箱即用。
要感受 grammar 的力量，Perl 6 自己的 grammar 就是用 Perl 6 庞大的 grammar 类 Perl6::Grammar写成的就足以说明了。
在本文中，我将通过几个例子来说明 grammar 的基础知识。所有必需的语言结构将在我们进行的时候进行解释。
解析数字 在你开始思考用户可以使用不同格式的数字,包括负数，浮点数，科学记数法中的数字，特殊形式的数字（如C的长整数）之前，解析数字似乎是一项简单的任务。
让我们从最简单的形式开始：一个数字作为数字序列。例如，1,42,123 或 1000. Perl 6 中的 grammar 是一种特殊的类，它有自己的关键字。grammar 的第一个 rule 必须（默认情况下）称为 TOP，以下是解析第一组数字的完整程序：
grammar N { token TOP { &amp;lt;digit&amp;gt;+ } } for &amp;lt;1 42 123 1000&amp;gt; -&amp;gt; $n { say N.</description>
    </item>
    
    <item>
      <title>Perl 6 from Haskell - Nutshell</title>
      <link>https://ohmysummer.github.io/post/2017-04-29-perl-6-from-haskell-nutshell/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-04-29-perl-6-from-haskell-nutshell/</guid>
      <description>Haskell 和 Perl 6 是非常不同的语言。这很明显。 但是，这并不意味着没有相似之处或共同的想法！ 此页面尝试让一个 Haskell 用户启动并运行 Perl 6。Haskell 用户可能会发现，在用 Perl 6 编写脚本时，他们不需要放弃所有 Haskelly 的想法。
请注意，这不应该被误认为是初学者教程或 Perl 6 概述; 它旨在作为具有强大 Haskell 背景的 Perl 6 学习者的技术参考。
类型 类型 vs 值 在 Haskell 中, 您有类型级编程, 然后进行值级编程。
plusTwo :: Integer -&amp;gt; Integer -- Types plusTwo x = x + 2 -- Values  您不要像下面那样在 Haskell 中混合类型和值。
plusTwo 2 -- This is valid plusTwo Integer -- This is not valid  在 Perl 6 中, 类型(亦称为类型对象)和值处于同样的级别</description>
    </item>
    
  </channel>
</rss>