<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perl 6 on Rakudo Perl 6</title>
    <link>https://ohmysummer.github.io/categories/perl-6/</link>
    <description>Recent content in Perl 6 on Rakudo Perl 6</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 10 May 2018 10:54:24 +0200</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/categories/perl-6/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>饭否客户端</title>
      <link>https://ohmysummer.github.io/post/2018-05-10-%E9%A5%AD%E5%90%A6%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>Thu, 10 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-10-%E9%A5%AD%E5%90%A6%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid>
      <description>Inspired by fanfou-py
use Digest::HMAC; use Digest; use Digest::SHA; use MIME::Base64; use URI::Encode; use URI; use Cro::HTTP::Client; # URL 编码 sub oauth_escape($s){ return uri_encode_component($s.Str); } # 返回当前时间戳 sub oauth_timestamp() { return time; } # 单次值, 返回一个8位的随机字符串, 防止重复请求 sub oauth_nonce($size=8) { return ((1..9).pick for 1..$size).join(&amp;quot;&amp;quot;); } # 返回按一定顺序拼接好的字符串 sub oauth_query(%args) { return (sprintf &amp;quot;%s=%s&amp;quot;, $_, oauth_escape(~%args{$_}) for %args.keys.sort).join(&#39;&amp;amp;&#39;); } # URL 正规化 sub oauth_normalized_url($url){ my URI $u .= new($url); return sprintf(&#39;%s://%s%s&#39;, $u.</description>
    </item>
    
    <item>
      <title>Perl 6 CookBook</title>
      <link>https://ohmysummer.github.io/post/2018-05-08-perl6cookbook/</link>
      <pubDate>Tue, 08 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-08-perl6cookbook/</guid>
      <description>Perl 6 CookBook(inspired by Python cookbook)
数据结构和算法 解压序列赋值给多个变量 问题 现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值 给 N 个变量？
解决方案 任何的序列 (或者是可迭代对象) 可以通过一个简单的赋值语句解压并赋值给多个 变量。唯一的前提就是变量的数量必须跟序列元素的数量是一样的。
代码示例：
&amp;gt; my @p = (4,5); [4 5] &amp;gt; my ($x, $y) = @p; (4 5) &amp;gt; $x 4 &amp;gt; $y 5 &amp;gt; my @data = (&#39;ACME&#39;, 50, 91.1, (2012, 12, 21) ); [ACME 50 91.1 (2012 12 21)] &amp;gt; my ($name, $shares, $price, ($year, $mon, $day)) = (&#39;ACME&#39;, 50, 91.</description>
    </item>
    
    <item>
      <title>Dateish</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-dateish/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-dateish/</guid>
      <description>role Dateish { ... }  Date 和 DateTime 都支持访问 year, month 和 day-of-month 以及相关的函数，例如计算星期几。
方法 year 方法 定义为：
method year(Date:D: --&amp;gt; Int:D)  返回日期的月份(1..12)。
say Date.new(&#39;2015-12-31&#39;).month; # OUTPUT: «12» say DateTime.new(date =&amp;gt; Date.new(&#39;2015-12-24&#39;), hour =&amp;gt; 1).month; # OUTPUT: «12»  day 方法 定义为：
method day(Date:D: --&amp;gt; Int:D)  返回日期中月份的天(1..31)。
say Date.new(&#39;2015-12-31&#39;).day; # OUTPUT: «31» say DateTime.new(date =&amp;gt; Date.new(&#39;2015-12-24&#39;), hour =&amp;gt; 1).day; # OUTPUT: «24»  formatter 方法 定义为：</description>
    </item>
    
    <item>
      <title>Make</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-make/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-make/</guid>
      <description>方法 make 的文档由以下类型组装而成：
Match 类 来自于 Match
make 方法 method make(Match:D: Mu $payload) sub make(Mu $payload)  将任意有效载荷(payload)存储到 Match 对象中，稍后可通过 .made / .ast 方法重新取回它。
这通常用于 grammar 的 action 类方法中，其中一个方法存储一段数据，然后由另一个方法取回。这取决于你存储什么数据。它可以是树节点，计算结果或值的列表。
sub 形式的 make 操作当前的 $/，这可能是一个简写：
method my-action ($/) { make &amp;quot;foo: $/&amp;quot;; }  make 会把数据结构附加到各自的 Match 对象上, 随后通过 .made 方法取回。使用 Match.perl 方法可以看到, Match 里面有一个 made 属性：
&amp;gt; if &#39;abc&#39; ~~ /\w+/ { $/.make: {&#39;a&#39; =&amp;gt; &#39;bc&#39;, &#39;d&#39; =&amp;gt; &#39;wsl&#39;}; say $/.</description>
    </item>
    
    <item>
      <title>Slip</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-slip/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-slip/</guid>
      <description>有时您想要将列表的元素插入到另一个列表中。这可以通过称为 Slip 的特殊类型的列表完成。
say (1, (2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «False␤» say (1, Slip.new(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, slip(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤»  另一种方法是使用 | 前缀运算符。请注意，这比逗号的优先级更高，因此它只影响单个值，但与上述选项不同，它会打破标量。
say (1, |(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, |$(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, slip($(2, 3)), 4) eqv (1, 2, 3, 4); # OUTPUT: «False␤»  Slip class Slip is List {}  Slip 是一个 List，自动展平到一个外部列表（或其他类似列表的容器或 iterable）中。</description>
    </item>
    
    <item>
      <title>类和对象</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</guid>
      <description>Perl 6 有一个丰富的内置语法来定义和使用类。
默认构造函数允许为创建的对象设置属性：
class Point { has Int $.x; has Int $.y; } class Rectangle { has Point $.lower; has Point $.upper; method area() returns Int { ($!upper.x - $!lower.x) * ( $!upper.y - $!lower.y); } } # Create a new Rectangle from two Points my $r = Rectangle.new(lower =&amp;gt; Point.new(x =&amp;gt; 0, y =&amp;gt; 0), upper =&amp;gt; Point.new(x =&amp;gt; 10, y =&amp;gt; 10)); say $r.area(); # OUTPUT: «100␤»  您也可以提供自己的构建和构建实现。下面更详细的例子展示了 Perl 6 中依赖处理器的外观。它展示了自定义构造函数，私有属性和公共属性，方法以及签名的各个方面。它代码不多，但结果是有趣和有用的。</description>
    </item>
    
    <item>
      <title>DateTime</title>
      <link>https://ohmysummer.github.io/post/2018-05-05-datetime/</link>
      <pubDate>Sat, 05 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-05-datetime/</guid>
      <description>DateTime class DateTime does Dateish {}  对于在国内处理点数，DateTime 对象存储年，月，日，小时，分钟（全部为 Int），秒（可能为小数）和时区。
它提供了用日期和时间计算的方法。
DateTime 方法是不可变的;如果你试图修改它，请改为创建修改后的副本。
时区的处理时间为以 UTC 为单位的整数，而不是时区名称。
use v6.c; my $dt = DateTime.new( year =&amp;gt; 2015, month =&amp;gt; 11, day =&amp;gt; 21, hour =&amp;gt; 16, minute =&amp;gt; 1, ); say $dt; # OUTPUT: «2015-11-21T16:01:00Z␤» say $dt.later(days =&amp;gt; 20); # OUTPUT: «2015-12-11T16:01:00Z␤» say $dt.truncated-to(&#39;hour&#39;); # OUTPUT: «2015-11-21T16:00:00Z␤» say $dt.in-timezone(-8 * 3600); # OUTPUT: «2015-11-21T08:01:00-0800␤» my $now = DateTime.now(formatter =&amp;gt; { sprintf &amp;quot;%02d:%02d&amp;quot;, .</description>
    </item>
    
    <item>
      <title>Awesome Async Interfaces with Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-04-27-perl-6%E4%B8%AD%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 26 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-27-perl-6%E4%B8%AD%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3/</guid>
      <description>IRC::Client: Perl 6 Multi-Server IRC (or Awesome Async Interfaces with Perl 6) 我在 2015 年圣诞节编写了我的第一个 Perl 6 程序 - 一个新年 IRC 派对机器人工具。这项工作包括发布 IRC::Client 模块. 我从这个语言中找到了童年的乐趣并且在假期喝了不少酒, 结果就是这个模块差强人意。
最近，我需要一个用于某些 Perl 6 bug 队列工作的工具，因此我决定花费一个周末，从头开始重新设计并重写这个模块。在过去的几个月中，有好几个人请求我这么做，所以我想我还会写一篇关于如何使用该模块的教程 - 作为一名主拖延者的道歉。如果你对 IRC 不感兴趣，我希望本教程将作为 Perl 6 中异步，非阻塞接口的一个通用示例。
基础 要创建一个 IRC 机器人，实例化一个 IRC::Client 对象，给它一些基本信息，并调用 .run 方法。实现所需的所有功能，并将它们作为方法名称匹配要收听的事件的类，并通过 .plugins 属性传递。当发生 IRC 事件时，它会按照您指定的顺序传递给所有插件，如果某个插件要求它处理事件，则停止。
这里有一个简单的 IRC 机器人，它可以响应在频道中发送的消息，通知和发送给它的私人消息。响应是 bot 收到的大写原始消息：
use IRC::Client; .run with IRC::Client.new: :nick&amp;lt;MahBot&amp;gt; :host&amp;lt;irc.freenode.net&amp;gt; :channels&amp;lt;#perl6&amp;gt; :debug :plugins(class { method irc-to-me ($_) { .</description>
    </item>
    
    <item>
      <title>Cro::HTTP::Client</title>
      <link>https://ohmysummer.github.io/post/2018-04-16-cro-http-client/</link>
      <pubDate>Mon, 16 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-16-cro-http-client/</guid>
      <description>Cro::HTTP::Client Cro::HTTP::Client 类提供了一个灵活的 HTTP 和 HTTPS 客户端实现，可以从简单到更复杂的情况进行扩展。它可以通过两种方式消费：
通过对类型对象（ Cro::HTTP::Client.get($url) ）进行调用。这对于一次性请求很有用，但在向同一服务器发出多个请求时（例如使用 keep-alive）不提供连接重用。
通过创建一个 Cro::HTTP::Client 实例。默认情况下，这可以重用连接池。它还可以配置默认的 base URL，传递的默认授权数据，甚至是插入到请求/响应处理管道中的中间件。 Cro::HTTP::Client 实例可以并发地使用。
一般来说，如果您打算发起一次性请求，请使用类型对象。如果您要向同一台服务器或一组服务器发出很多请求，请创建一个实例。
默认情况下，HTTPS 请求将使用 ALPN 来协商是否执行 HTTP/2 或 HTTP/1.1，并且 HTTP 请求将始终使用 HTTP/1.1。
发起基本请求 可以在类型对象或 Cro::HTTP::Client 的实例上调用 get，post，put，delete，patch 和 head 方法。他们都会返回一个 Promise，如果请求成功则会被保留(kept), 如果失败则被毁掉(broken)。
my $resp = await Cro::HTTP::Client.get(&#39;https://www.perl6.org/&#39;);  响应($resp) 是一个 Cro::HTTP::Response 对象。它将在请求头可用时立即生成;请求体可能尚未收到。默认情况下，错误（4xx和5xx状态码）将导致遵守 X::Cro::HTTP::Error 角色的异常，该角色具有包含 Cro::HTTP::Response 对象的 response 属性。
my $resp = await Cro::HTTP::Client.delete($product-url); CATCH { when X::Cro::HTTP::Error { if .response.status == 404 { say &amp;quot;Product not found!</description>
    </item>
    
    <item>
      <title>使用 flip-flop 和 gather-take 提取文本块儿</title>
      <link>https://ohmysummer.github.io/post/2018-04-15-flip-flop/</link>
      <pubDate>Sun, 15 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-15-flip-flop/</guid>
      <description>使用 flip-flop 和 gather-take 提取文本块儿 my $excerpt = q:to/END/; Here&#39;s some unimportant text. =begin code This code block is what we&#39;re after. We&#39;ll use &#39;ff&#39; to get it. =end code More unimportant text. =begin code Today rains heavy. Long live AI . HaHa =end code More unimport text. =begin code Like to go home. =end code END my @lines = gather { my @current; for $excerpt.lines { if &amp;quot;=begin code&amp;quot; ^ff^ &amp;quot;=end code&amp;quot; { # collect the values between matches push @current, .</description>
    </item>
    
    <item>
      <title>Perl 6 中散列的键和值</title>
      <link>https://ohmysummer.github.io/post/2018-04-14-keys-values-of-hashes-in-perl-6/</link>
      <pubDate>Sat, 14 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-14-keys-values-of-hashes-in-perl-6/</guid>
      <description>Perl 6 中散列的键和值 今天，我们将看看 Hash 类的几个返回散列所有键或值或同时返回键和值的方法:
&amp;gt; my %h = H =&amp;gt; &#39;Hydrogen&#39;, He =&amp;gt; &#39;Helium&#39;, Li =&amp;gt; &#39;Lithium&#39;; {H =&amp;gt; Hydrogen, He =&amp;gt; Helium, Li =&amp;gt; Lithium} &amp;gt; %h.keys; (H Li He) &amp;gt; %h.values; (Hydrogen Lithium Helium) &amp;gt; %h.kv; (H Hydrogen Li Lithium He Helium)  虽然你可能想直接进入 src/core/Hash.pm6 文件来查看方法的定义，但你会一无所获。 Hash 类是 Map 的子类，所有这些方法都定义在 src/core/Map.pm6 文件中。获取键和值很简单:
multi method keys(Map:D:) { Seq.new(Rakudo::Iterator.Mappy-keys(self)) } multi method values(Map:D:) { Seq.new(Rakudo::Iterator.Mappy-values(self)) }  对于 kv 方法, 需要多做点工作:</description>
    </item>
    
    <item>
      <title>Perl 6 中的列表解析</title>
      <link>https://ohmysummer.github.io/post/2018-04-13-perl-6-%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 13 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-13-perl-6-%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>Perl 6 中的列表解析 看一看 Python 中关于列表推导的页面。
S = {x² : x in {0 ... 9}} V = (1, 2, 4, 8, ..., 2¹²) M = {x | x in S and x even}  Python 列表解析:
S = [x**2 for x in range(10)] V = [2**i for i in range(13)] M = [x for x in S if x % 2 == 0]  在原始定义中我没有看到 10 或 13 , Perl 6 与原始语言最接近的语法是:</description>
    </item>
    
    <item>
      <title>在 Perl 6 中设置超时</title>
      <link>https://ohmysummer.github.io/post/2018-04-12-setting-timeouts-in-perl-6/</link>
      <pubDate>Thu, 12 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-12-setting-timeouts-in-perl-6/</guid>
      <description>在 Perl 6 中设置超时 在 Perl 5 中，我曾经使用信号设置超时（至少，这是一种简单且可预测的方式）。在 Perl 6 中，您可以使用 promise。让我们看看如何做到这一点。
要模仿长时间运行的任务，请创建一个无限循环，然后打印其状态。开始吧:
for 1 .. * { .say if $_ %% 100_000; }  只要循环得到控制，它将永远不会退出。我们的任务是在几秒钟内停止程序，因此计时器应在循环之前设置:
Promise.in(2).then({ exit; }); for 1 .. * { .say if $_ %% 100_000; }  在这里，Promise.in 方法创建一个 promise，在给定秒数后自动 kept。在 promise 的基础上，使用 then，我们添加了另一个 promise，其代码将在超时后运行。这里唯一的语句就是退出，停止主程序。
运行该程序以查看它的工作原理：
$ time perl6 timeout.pl 100000 200000 300000 . . . 3700000 3800000 3900000 real 0m2.196s user 0m2.120s sys 0m0.068s  该程序在我的计算机上计数达四百万，并在两秒内退出。这正是我们需要的行为。</description>
    </item>
    
    <item>
      <title>Typed hashes in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-04-11-typed-hashes-in-perl-6/</link>
      <pubDate>Wed, 11 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-11-typed-hashes-in-perl-6/</guid>
      <description>Typed hashes in Perl 6 在 Perl 6 中, 你可以通过指定变量的类型来限制变量容器的内容, 例如：
my Int $i;  标量变量中只有一个值。你可以将该概念扩展到数组, 并让其元素仅保存整数, 如下例所示：
&amp;gt; my Int @i; [] &amp;gt; @i.push(42); [42] &amp;gt; @i.push(&#39;Hello&#39;); Type check failed in assignment to @i; expected Int but got Str (&amp;quot;Hello&amp;quot;) in block &amp;lt;unit&amp;gt; at &amp;lt;unknown file&amp;gt; line 1  哈希中保存的是 pairs, 所以你可以同时指定键和值的类型。语法和上面的例子并无不同。
首先, 让我们声明值的类型：
my Str %s;  现在, 可以将字符串作为哈希的值：
&amp;gt; %s&amp;lt;Hello&amp;gt; = &#39;World&#39; World &amp;gt; %s&amp;lt;42&amp;gt; = &#39;Fourty-two&#39; Fourty-two  但这个哈希不能保存整数:</description>
    </item>
    
    <item>
      <title>Perl 6 中的 gist 方法</title>
      <link>https://ohmysummer.github.io/post/2018-04-10-what-does-gist-do-in-perl-6/</link>
      <pubDate>Tue, 10 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-10-what-does-gist-do-in-perl-6/</guid>
      <description>当你打印对象的时候, 例如 say $x, Perl 6 调用 gist 方法. 这个方法是为所有内建类型定义的：对于其中一些类型，它调用 Str 方法，对于某些类型它调用 perl 方法，对于某些类型，它使字符串表示有所不同。
让我们看看如何使用该方法来创建您自己的变体：
class X { has $.value; method gist { &#39;[&#39; ~ $!value ~ &#39;]&#39; } } my $x = X.new(value =&amp;gt; 42); say $x; # [42] $x.say; # [42]  当你调用 say 时，该程序在方括号中打印一个数字：[42]。
请注意，双引号字符串中的插值使用 Str，而不是 gist。你可以在这里看到它：
say $x.Str; # X&amp;lt;140586830040512&amp;gt; say &amp;quot;$x&amp;quot;; # X&amp;lt;140586830040512&amp;gt;  如果您需要自定义插值，请重新定义 Str 方法:
class X { has $.value; method gist { &#39;[&#39; ~ $!</description>
    </item>
    
    <item>
      <title>Perl 6 中的 Superscripts</title>
      <link>https://ohmysummer.github.io/post/2018-04-09-perl-6-%E4%B8%AD%E7%9A%84%E4%B8%8A%E6%A0%87/</link>
      <pubDate>Mon, 09 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-09-perl-6-%E4%B8%AD%E7%9A%84%E4%B8%8A%E6%A0%87/</guid>
      <description>Perl 6 中的 Superscripts 在 Perl 6 中，可以使用上标索引来计算数字的幂数，例如:
&amp;gt; 2⁵ 32 &amp;gt; 7³ 343  也可以在上标中使用多个数字：
&amp;gt; 10¹² 1000000000000  你可以猜到，上面的代码等同于这样：
&amp;gt; 2**5 32 &amp;gt; 7**3 343 &amp;gt; 10**12 1000000000000  但问题是：上标到底是如何工作的？让我们找出答案。
对于 Numeric 角色，定义了以下操作：
proto sub postfix:&amp;lt;ⁿ&amp;gt;(Mu $, Mu $) is pure {*} multi sub postfix:&amp;lt;ⁿ&amp;gt;(\a, \b) { a ** b }  啊哈，这就是我们需要的，上标符号在这里转换为简单的 ** 运算符。
您可以通过打印操作数来可视化传递给操作的确切内容：
multi sub postfix:&amp;lt;ⁿ&amp;gt;(\a, \b) { nqp::say(&#39;# a = &#39; ~ a); nqp::say(&#39;# b = &#39; ~ b); a ** b }  这个时候，你会看到上面的测试示例输出如下：</description>
    </item>
    
    <item>
      <title> More on the proto keyword in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-21-more-on-the-proto-keyword-in-perl-6/</link>
      <pubDate>Wed, 21 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-21-more-on-the-proto-keyword-in-perl-6/</guid>
      <description>在深入研究 EVAL 子例程的细节之前，我们必须揭示一些关于 protos 原型和多重分派的更多信息。检查以下程序：
proto sub f($x) { say &amp;quot;proto f($x)&amp;quot;; } multi sub f($x) { say &amp;quot;f($x)&amp;quot; } multi sub f(Int $x) { say &amp;quot;f(Int $x)&amp;quot; } multi sub f(Str $x) { say &amp;quot;f(Str $x)&amp;quot; } f(2); f(&#39;2&#39;); f(3); f(&#39;3&#39;);  这里有三个 multi 函数和一个用 proto 关键字声明的函数。早些时候，我们只看到了函数体为空的原型函数，如:
proto sub f($x) {*}  但这不是必需的。正如我们在示例中所看到的，该函数可以承载正常的函数体：
proto sub f($x) { say &amp;quot;proto f($x)&amp;quot;; }  运行这个程序：
proto f(2) proto f(2) proto f(3) proto f(3)  所有的调用都被 proto-候选者抓住了。现在，更新它并返回一些专用值的 {*} 块;</description>
    </item>
    
    <item>
      <title>Examining the Real role of Perl 6, part 2</title>
      <link>https://ohmysummer.github.io/post/2018-02-18-examining-the-real-role-of-perl-6-part-2/</link>
      <pubDate>Sun, 18 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-18-examining-the-real-role-of-perl-6-part-2/</guid>
      <description>今天，我们继续对几天前开始的 Real 角色进行初步探索。
与其方法一起，角色包含许多子例程（放置在角色之外），它们使用 Real 类型的对象定义中缀运算符。名单不长，所以让我把它复制在这里：
multi sub infix:&amp;lt;+&amp;gt;(Real \a, Real \b) { a.Bridge + b.Bridge } multi sub infix:&amp;lt;-&amp;gt;(Real \a, Real \b) { a.Bridge - b.Bridge } multi sub infix:&amp;lt;*&amp;gt;(Real \a, Real \b) { a.Bridge * b.Bridge } multi sub infix:&amp;lt;/&amp;gt;(Real \a, Real \b) { a.Bridge / b.Bridge } multi sub infix:&amp;lt;%&amp;gt;(Real \a, Real \b) { a.Bridge % b.Bridge } multi sub infix:&amp;lt;**&amp;gt;(Real \a, Real \b) { a.Bridge ** b.</description>
    </item>
    
    <item>
      <title>Everyone Loves Porgs</title>
      <link>https://ohmysummer.github.io/post/2018-02-17-everyone-loves-porgs/</link>
      <pubDate>Sat, 17 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-17-everyone-loves-porgs/</guid>
      <description>这个想法有一阵子了。我在完成的各个阶段都有几个发文的想法，有时候很难优先考虑这个问题。所以我想我要开始发布我一直在玩的更短的想法和事情，以免这个博客变成那些永不更新的博客之一。所以，我们开始吧。
类在 Perl 6 中很容易定义。它们非常容易，我发现自己使用它们来封装小型的 Hash-like 那样的东西，其中我也可能会使用一两种方法。
class Contact { has $.name; has $.phone; has $.bday; method age { (Date.new($.bday), *.later(:1year) ...^ * &amp;gt; Date.today).end } }  是的，这是一种低效率的计算年龄的方法&amp;hellip;&amp;hellip;就像生活中的很多事情一样，你越老，这种方法变得越慢。
无论如何，现在我已经定义了一个简单的小类来保存一些数据，但要实际实例化一个我不得不 bust out 一些命名参数。
my @contacts; @contacts.push: Contact.new(:name&amp;lt;John&amp;gt;, :phone&amp;lt;555-1111&amp;gt;, :bday&amp;lt;1940-10-09&amp;gt;);  谁有时间为所有这些角色？有时候我只是想用位置参数来构建它们，但这意味着要编写一个新的自定义 multi method new 来处理这些情况&amp;hellip;&amp;hellip;但我只是将一个快速肮脏的类放在一起，真的值得我花时间来构建自定义构造函数吗？
于是我开始四处游玩，并创建了一个让我用 Positional 参数的角色&amp;hellip;&amp;hellip;或一个 Array ..或 List &amp;hellip;构建我的类，嘿，I threw in a Hash for free!！
@contacts.push: Contact.new(&#39;James&#39;, &#39;555-1112&#39;, &#39;1942-06-18&#39;); @contacts.push: Contact.new(&amp;lt; George 555-1113 1943-02-25 &amp;gt;) my %hash = name =&amp;gt; &#39;Richard&#39;, phone =&amp;gt; &#39;555-1114&#39;, bday =&amp;gt; &#39;1940-07-07&#39;; @contacts.</description>
    </item>
    
    <item>
      <title>A word on polymod in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-16-a-word-on-polymod-in-perl-6/</link>
      <pubDate>Fri, 16 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-16-a-word-on-polymod-in-perl-6/</guid>
      <description>在转到 Real 角色的第二部分之前，让我们停下来研究一下 Int 类的中的 polymod 方法。
该方法接收一个数字和任意数字（单位）的列表并返回相应的乘数。所以，你可以很容易地说，例如 550 秒，是 9分 10 秒：
&amp;gt; 550.polymod(60) (10 9)  在方法调用中，60 的值是一分钟内的秒数。结果中，9 是分钟数，10 是余数，其为秒数。所以，550 秒= 10 秒 + 9 分钟。
如果你想了解更多细节，请添加更多单位。例如，什么是 32768 秒？
&amp;gt; 32768.polymod(60, 60, 24) (8 6 9 0)  这是 8 秒，6 分钟，9 小时和 0 天。
类似地，132768 秒是 1 天，12 小时，52 分钟和 48 秒：
&amp;gt; 132768.polymod(60, 60, 24) (48 52 12 1)  老实说，我很难理解它是如何工作的，以及如何读取结果。
文档中的另一个例子更加难以理解：
&amp;gt; 120.polymod(1, 10, 100) (0 0 12 0)  12 是什么意思？这显然是12倍10.</description>
    </item>
    
    <item>
      <title>如何在 Perl 6 中对散列进行排序</title>
      <link>https://ohmysummer.github.io/post/2018-02-16-%E5%A6%82%E4%BD%95%E5%9C%A8perl-6%E4%B8%AD%E5%AF%B9%E6%95%A3%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 16 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-16-%E5%A6%82%E4%BD%95%E5%9C%A8perl-6%E4%B8%AD%E5%AF%B9%E6%95%A3%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</guid>
      <description>要在 Perl 6 中对散列进行排序，首先你要知道什么是占位符变量。一旦这个概念变得清晰，对散列排序就变得非常简单。
例如，创建一个不同城市距离莫斯科远近的散列：
my %distance = Владимир =&amp;gt; 185, Волгоград =&amp;gt; 1000, Калининград =&amp;gt; 1227, Мурманск =&amp;gt; 1895, Новосибирск =&amp;gt; 3550;  现在的任务是通过比较距离来对散列进行排序。
say %distance.sort({$^a.value &amp;lt;=&amp;gt; $^b.value});  一般来说，它已经准备好了。该程序打印你需要的东西：
(Владимир =&amp;gt; 185 Волгоград =&amp;gt; 1000 Калининград =&amp;gt; 1227 Архангельск =&amp;gt; 1261 Астрахань =&amp;gt; 1411 Мурманск =&amp;gt; 1895 Новосибирск =&amp;gt; 3550)  让我们看看传递给排序方法的块内发生了什么。
首先，变量 $^a 和 $^b 是占位符，它是匿名块的参数并按字母顺序排序。也就是说，以相同的方式，他们可以被称为 $^x 和 $^y 或 $^var1 和 $^var2。
其次，这些占位符变量内部是 Pair 类型的对象，它包含键和值：
say %distance.</description>
    </item>
    
    <item>
      <title>Examining the Real role of Perl 6, part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-15-examining-the-real-role-of-perl-6-part-1/</link>
      <pubDate>Thu, 15 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-15-examining-the-real-role-of-perl-6-part-1/</guid>
      <description>在过去的几天里，我们谈了很多关于 Real 这个角色。让我们更仔细地看看它。该代码位于 src/core/Real.pm 文件中。
它包含角色本身和一些实现不同中缀的子例程。Real 角色又实现了 Numeric 角色：
my role Real does Numeric { . . . }  有趣的是，类定义还需要关于 Complex 类的一些知识，这就是为什么在文件的第一行有一个前向类声明：
my class Complex { ... }  Real 角色将许多三角函数定义为方法，正如我们已经看到的，他们正在使用 Bridge 方法：
method sqrt() { self.Bridge.sqrt } method rand() { self.Bridge.rand } method sin() { self.Bridge.sin } method asin() { self.Bridge.asin } method cos() { self.Bridge.cos } method acos() { self.Bridge.acos } method tan() { self.Bridge.tan } method atan() { self.</description>
    </item>
    
    <item>
      <title>FatRat vs Rat in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-15-fatrat-vs-rat-in-perl-6/</link>
      <pubDate>Thu, 15 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-15-fatrat-vs-rat-in-perl-6/</guid>
      <description>昨天，Solomon Foster 在 Facebook 的 Perl 6 小组上发布了一个例子:
my @x = FatRat.new(1, 1), -&amp;gt; $x { $x - ($x ** 2 - $N) / (2 * $x) } ... *  这段代码实现了牛顿找到 $N 平方根近似值的方法。重要的是它使用 FatRat 值来获得更高的准确性。
让我们运行 9 的平方根：
my $N = 9; my @x = Rat.new(1, 1), -&amp;gt; $x { $x - ($x ** 2 - $N) / (2 * $x) } ... *; .say for @x[0..7];  很快，它收敛到正确的值：</description>
    </item>
    
    <item>
      <title>A bit more on Rat vs FatRat in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-14-a-bit-more-on-rat-vs-fatrat-in-perl-6/</link>
      <pubDate>Wed, 14 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-14-a-bit-more-on-rat-vs-fatrat-in-perl-6/</guid>
      <description>昨天，我们正在深入研究 Rakudo Perl 6，以了解Rat值成为Num值的时间。事实证明，如果该值变得太小，这意味着它的分母变得越来越大，Rakudo开始使用Num值而不是Rat。
我们找到了它发生的地方。今天，让我们进行一个练习，看看Perl 6的行为是否可能不同，即扩展数据类型而不是将其切换为浮点数并且失去准确性。
改变很简单。所有你需要的是更新DIVIDE_N例程中的ifs：
--- a/src/core/Rat.pm +++ b/src/core/Rat.pm @@ -48,16 +48,14 @@ sub DIVIDE_NUMBERS(Int:D \nu, Int:D \de, \t1, \t2) { ($numerator := -$numerator), ($denominator := -$denominator))), nqp::if( - nqp::istype(t1, FatRat) || nqp::istype(t2, FatRat), + nqp::istype(t1, FatRat) || nqp::istype(t2, FatRat) || $denominator &amp;gt;= UINT64_UPPER, nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(FatRat),FatRat,&#39;$!numerator&#39;,$numerator), FatRat,&#39;$!denominator&#39;,$denominator), - nqp::if( - $denominator &amp;lt; UINT64_UPPER, nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(Rat),Rat,&#39;$!numerator&#39;,$numerator), - Rat,&#39;$!denominator&#39;,$denominator), - nqp::p6box_n(nqp::div_In($numerator, $denominator))))) + Rat,&#39;$!denominator&#39;,$denominator) + )) }  现在有两种结果：例程产生一个Rat值或一个FatRat。当子参数已经是FatRats或当前Rat太接近于零时，后者发生。</description>
    </item>
    
    <item>
      <title>Going over the Bridge, part 2. Let’s get rid of it</title>
      <link>https://ohmysummer.github.io/post/2018-02-12-going-over-the-bridge-part-2/</link>
      <pubDate>Mon, 12 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-12-going-over-the-bridge-part-2/</guid>
      <description>今天，我们继续在 Rakudo Perl 6 中使用 Bridge 方法。昨天，我们在几个预定义的数据类型中看到了方法的定义。现在是时候看看如何使用该方法。
里面有什么? 该方法的主要用途在 Real 角色中，该角色包含以下一组方法：
method sqrt() { self.Bridge.sqrt } method rand() { self.Bridge.rand } method sin() { self.Bridge.sin } method asin() { self.Bridge.asin } method cos() { self.Bridge.cos } method acos() { self.Bridge.acos } method tan() { self.Bridge.tan } method atan() { self.Bridge.atan } . . . method sec() { self.Bridge.sec } method asec() { self.Bridge.asec } method cosec() { self.Bridge.cosec } method acosec() { self.</description>
    </item>
    
    <item>
      <title>Going over the Bridge, part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-11-going-over-the-bridge-part-1/</link>
      <pubDate>Sun, 11 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-11-going-over-the-bridge-part-1/</guid>
      <description>在处理 Perl 6 中的数字的类中，我们看到了 Bridge 方法，该方法以多态方式使用。让我们花一些时间，并试图了解 1）它是如何工作的，2）是否有必要。
类和角色 我们的第一步是查看方法定义在哪里。以下是我们需要的类和角色列表：
 Duration Instant Int Num Rational Real  为了预测下一步，让我们添加一些关于他们关系的更多细节：
 class Duration is Cool does Real class Instant is Cool does Real class Int is Cool does Real class Num is Cool does Real role Rational does Real role Real does Numeric  在斜体字体中，我添加了伪声明，这些伪声明没有在 src/core 的相应文件中明确拼写，而是通过 src/Perl6/Metamodel/BOOTSTRAP.nqp 设置:
Int.HOW.add_parent(Int, Cool); . . . Num.HOW.add_parent(Num, Cool);  对于完整的图片，我们可以查看其他类的位置，例如 Rat 或 Complex，但让我们先关注上面的列表。</description>
    </item>
    
    <item>
      <title>Perl 6 中的命名参数</title>
      <link>https://ohmysummer.github.io/post/2018-02-10-perl-6%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 10 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-10-perl-6%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</guid>
      <description> Perl 6 中的函数（和类方法）能够接受命名参数。最简单的方法是用箭头分隔名称和值：
sub f(:$a, :$b) { $a ** $b } say f(a =&amp;gt; 2, b =&amp;gt; 3); # 8  但另一种语法是可能的，在冒号的帮助下。有几个主要品种。
:key(value) 所有内容都以冒号开头，数值在括号内：
say f(:a(2), :b(3));  例如，不用圆括号，尖角括号也是允许的：
say f(:a&amp;lt;2&amp;gt;, :b&amp;lt;3&amp;gt;);  ：Nkey 对于整数值，仍然有这样一个奇怪的语法：
say f(:2a, :3b);  :key 和 :!key 如果命名参数用作标记，则不需要指定值。在这种情况下，您可以传递 True 和 False，如下所示：
sub g(:$key) { $key } say g(:key); # True say g(:!key); # False  实际上，所有冒号对儿都会创建键值对，因此您可以在创建散列时执行相同的操作
my %data = :alpha(10), :beta(20), :gamma(30); say %data&amp;lt;beta&amp;gt;; # 20  </description>
    </item>
    
    <item>
      <title>Perl 6 Grammar 中的冒号对儿</title>
      <link>https://ohmysummer.github.io/post/2018-02-08-perl-6-grammar%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7%E5%AF%B9%E5%84%BF/</link>
      <pubDate>Thu, 08 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-08-perl-6-grammar%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7%E5%AF%B9%E5%84%BF/</guid>
      <description>欢迎来到这个系列的第 50 篇文章!
今天, 我们将讨论一个小的语法结构, 然而就 Grammar 来说这是非常复杂的。首先让我们看看整个 colonpair token:
token colonpair { :my $*key; :my $*value; &#39;:&#39; :dba(&#39;colon pair&#39;) [ | &#39;!&#39; [ &amp;lt;identifier&amp;gt; || &amp;lt;.panic: &amp;quot;Malformed False pair; expected identifier&amp;quot;&amp;gt; ] [ &amp;lt;[ \[ \( \&amp;lt; \{ ]&amp;gt; { $/.typed_panic(&#39;X::Syntax::NegatedPair&#39;, key =&amp;gt; ~$&amp;lt;identifier&amp;gt;) } ]? { $*key := $&amp;lt;identifier&amp;gt;.Str; $*value := 0 } | $&amp;lt;num&amp;gt; = [\d+] &amp;lt;identifier&amp;gt; [ &amp;lt;?before &amp;lt;.[ \[ \( \&amp;lt; \{ ]&amp;gt;&amp;gt; {} &amp;lt;.</description>
    </item>
    
    <item>
      <title>Perl 6 中的数据类型 Bag</title>
      <link>https://ohmysummer.github.io/post/2018-02-07-perl-6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/</link>
      <pubDate>Wed, 07 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-07-perl-6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/</guid>
      <description>数据类型 Bag 是一种 Perl 5 中没有的新的数据类型。
它可以被认为是一个容器，它一方面知道它里面有多少个单独的元素，另一方面可以说有多少种不同类型的商品。您可以用不同的方式描述此类型：Bag 是一个哈希，默认情况下，您添加的键的值为1。我们来看看例子。
把一个 1 放进 bag 里，看看 perl 的输出：
my $b1 = bag(1); say $b1.perl;  该程序打印以下输出：
(1=&amp;gt;1).Bag  也就是说，我们有一个 1。
如果你把另一个数字也放进 bag 里面：
my $b2 = bag(1, 2); say $b2.perl;  现在有一个 1 和一个 2：
(1=&amp;gt;1,2=&amp;gt;1).Bag  好的，如果你添加另一个 1 呢?
my $b3 = bag(1, 2, 1); say $b3.perl;  现在有两个 1：
(1=&amp;gt;2,2=&amp;gt;1).Bag  让我们稍微离题一下：所有显示的例子都可以把括号去掉：
my $b1 = bag 1; my $b2 = bag 1, 2; my $b3 = bag 1, 2, 1;  比较典型的是，bag 不止能存储数字，还可以存储字符串，例如：</description>
    </item>
    
    <item>
      <title>Perl 6 Core Hacking: QASTalicious</title>
      <link>https://ohmysummer.github.io/post/2018-01-28-perl-6-core-hacking-qastalicious/</link>
      <pubDate>Sun, 28 Jan 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-01-28-perl-6-core-hacking-qastalicious/</guid>
      <description>在过去的一个月中，我在 Rakudo 的 QAST 地区花了一些时间写了一些优化，修复了包含警告的错误，并且用一个单一的提交压缩了一个10个thunk范围的bug的怪物蜂巢。 在今天的文章中，我们将详细介绍最后一个专长，以及了解QAST是什么以及如何使用它。
第一部分: QAST &amp;ldquo;QAST&amp;rdquo; 代表 &amp;ldquo;Q&amp;rdquo; Abstract Syntax Tree.(&amp;ldquo;Q&amp;rdquo; 抽象语法树.) 为什么会有个字母 &amp;ldquo;Q&amp;rdquo; 在那里呢, 因为 Q 是 P 的下一个字母, 而 &amp;ldquo;P&amp;rdquo; 过去是在 &amp;ldquo;PAST&amp;rdquo; 里面的, 代表 &amp;ldquo;Parrot&amp;rdquo;(鹦鹉), 是很早之前的一个实验性的 Perl 6 实现(或者说, 它的虚拟机). 我们来看看什么是 QAST!
Dumping QAST 每个 Rakudo Perl 6 程序都编译到 QAST 节点树上，如果在编译程序或模块时给 perl6 指定 --target=ast 或 --target=optimize 命令行选项，则可以转储该树:
$ perl6 --target=ast -e &#39;say &amp;quot;Hello, World!&amp;quot;&#39; [...] - QAST::Op(call &amp;amp;say) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;?&amp;gt; say \&amp;quot;Hello, World!\&amp;quot; - QAST::Want &amp;lt;wanted&amp;gt; Hello, World!</description>
    </item>
    
    <item>
      <title>Perl 6 logo</title>
      <link>https://ohmysummer.github.io/post/2018-01-28-perl-6-logo/</link>
      <pubDate>Sun, 28 Jan 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-01-28-perl-6-logo/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Playing with the code of Rakudo Perl 6</title>
      <link>https://ohmysummer.github.io/post/2017-12-23-playing-with-the-code-of-rakudo-perl-6/</link>
      <pubDate>Sat, 23 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-23-playing-with-the-code-of-rakudo-perl-6/</guid>
      <description>昨天，我们查看了返回字符串的 Bool 类的两个方法。函数产生的字符串表示在源代码中被硬编码。
让我们使用这个观察并尝试改变文本。
所以，这里是我们要修改的片段：
Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) { self ?? &#39;True&#39; !! &#39;False&#39; });  该 gist 方法用于对已定义的变量进行字符串化。
要做到这一点，你需要在计算机上安装 Rakudo 的源代码，以便编译它们。首先从 GitHub 克隆项目：
$ git clone https://github.com/rakudo/rakudo.git  编译 MoarVM：
$ cd rakudo $ perl Configure.pl --gen-moar --gen-nqp --backends=moar $ make  完成之后，你会在 rakudo 目录下获得 perl6 可执行文件。
现在，打开 src/core/Bool.pm 文件，并将 gist 方法的字符串更改为使用 Unicode 大拇指代替纯文本：
Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) { self ?? &#39;👍&#39; !! &#39;👎&#39; });  保存文件后，您需要重新编译 Rakudo。 Bool.</description>
    </item>
    
    <item>
      <title>Exploring the Bool type in Perl 6, part 1</title>
      <link>https://ohmysummer.github.io/post/2017-12-22-exploring-the-bool-type-in-perl-6-part-1/</link>
      <pubDate>Fri, 22 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-22-exploring-the-bool-type-in-perl-6-part-1/</guid>
      <description>今天，我们将使用 GitHub 上提供的 Rakudo 源代码挖掘 Bool 类型的内部。
Perl 6 是用 Perl 6 和 NQP（Not Quite Perl 6）语言编写的，这使得阅读源代码变得相对容易。当然，有很多东西不容易理解，或者没有反映在 Perl 6 语言的公开文档中。到目前为止，您都无法在 Perl 6 书籍中找到深入的细节。无论如何，对 Perl 6 有一些中级的理解，这仍然是可能的。
好的，回到 src/core/Bool.pm 文件。它以一些 BEGIN phasers 开始，它为 Bool 类添加了一些方法和 multi 方法。下一次我们将讨论元模型和类构造的细节。今天，对我们来说更有趣的是 Bool 类的方法在做什么。
gist 和 perl gist 和 perl 方法返回对象的字符串表示形式：当变量被字符串化时隐式调用 gist，perl 应该直接调用。它适用于 Perl 6 中的任何对象，但这种行为当然应该定义在某处。他们在这里：
Bool.^add_method(&#39;gist&#39;, my proto method gist(|) {*}); Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) { self ?? &#39;True&#39; !! &#39;False&#39; }); Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:U:) { &#39;(Bool)&#39; }); Bool.</description>
    </item>
    
    <item>
      <title>Perl 6 中的 proto 关键字</title>
      <link>https://ohmysummer.github.io/post/2017-12-21-perl-6-%E4%B8%AD%E7%9A%84-proto-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Thu, 21 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-21-perl-6-%E4%B8%AD%E7%9A%84-proto-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>今天，我们正在关注 proto 关键字。它向编译器提供了关于你打算创建 multi-subs 的提示。
例子 1 考虑一个翻转字符串或使整数变成负数的函数示例。
multi sub f(Int $x) { return -$x; } multi sub f(Str $x) { return $x.flip; } say f(42); # -42 say f(&#39;Hello&#39;); # olleH  如果我们创建另一个接收两个参数的函数的变体，会怎么样？
multi sub f($a, $b) { return $a + $b; } say f(1, 2); # 3  这个代码完美的工作，但它看起来像它的和谐是破碎的。即使函数的名称没有提及它的作用，我们也打算设置一个函数，以某种方式返回它的参数的“反射”版本。将两个数字相加的函数不适合这个想法。
所以，现在是在 proto 关键字的帮助下清楚地宣布意图的时候了。
proto sub f($x) {*}  现在，尝试调用双参数函数将无法编译：
===SORRY!=== Error while compiling proto.pl Calling f(Int, Int) will never work with proto signature ($x) at proto.</description>
    </item>
    
    <item>
      <title>根据select结果生成insert语句</title>
      <link>https://ohmysummer.github.io/post/2017-09-16-%E6%A0%B9%E6%8D%AEselect%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90insert%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sat, 16 Sep 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-09-16-%E6%A0%B9%E6%8D%AEselect%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90insert%E8%AF%AD%E5%8F%A5/</guid>
      <description>想根据 MySQL select 语句的结果生成 insert 语句。
use v6; for $=finish.lines -&amp;gt; $line { next if $++ &amp;lt; 3 || $line ~~ / &#39;-&#39; /; say &#39;insert into convert_path (id, path_name, events, app_key, create_at, update_at) values (&#39; ~ ($line.split: /&amp;lt;[\s+ |]&amp;gt;/, :skip-empty)&amp;gt;&amp;gt;.&amp;amp;quote.join(&amp;quot;,&amp;quot;) ~ &amp;quot;);&amp;quot;; } sub quote(Str $ele) { return &#39;&amp;quot;&#39; ~ $ele ~ &#39;&amp;quot;&#39;; } =finish +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+ | id | path_name | events | app_key | create_at | update_at | +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+ | 308 | 新增打听流程1 | 新增打听,提交打听 | 10c29cf8bd6e61f9ae4a0212eed803c8 | 1505098067 | 1505098067 | | 309 | 用户购买流程 | 浏览商品,加入购物车,结算购物车中的商品,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505283224 | 1505283224 | | 311 | 用户购买流程2 | 浏览商品,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505284039 | 1505284039 | | 312 | 朗读模板付费转化流程 | 访问朗读首页,访问朗读模板,输入或导入文本,开始朗读,进入下载支付页,微信支付 | 54117664fad164a634c57571ba7c5aa7 | 1505284047 | 1505284047 | | 313 | 用户购买流程3 | 浏览商品,填写配送地址,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505284110 | 1505284110 | | 315 | 用户购买流程4 | 浏览商品,填写配送地址,完成配送地址,点击立即购买,付款,付款完成 | c10606f35c85bac58625c95006fba769 | 1505284303 | 1505284303 | | 316 | 新建朗读付费转化流程 | 访问朗读首页,访问新建朗读,输入或导入文本,开始朗读,进入下载支付页,微信支付 | 54117664fad164a634c57571ba7c5aa7 | 1505284351 | 1505284351 | | 321 | goodsDetail | onLoad,onShow | c10606f35c85bac58625c95006fba769 | 1505451421 | 1505451421 | +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+  最后生成的结果如下：</description>
    </item>
    
    <item>
      <title>开启 Disqus 评论</title>
      <link>https://ohmysummer.github.io/post/2017-09-15-%E5%BC%80%E5%90%AFdisqus%E8%AF%84%E8%AE%BA/</link>
      <pubDate>Fri, 15 Sep 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-09-15-%E5%BC%80%E5%90%AFdisqus%E8%AF%84%E8%AE%BA/</guid>
      <description>要开启 Disqus 评论, 需要先在 Disqus 官网注册账号, 获得 disqusShortname。
#use Grammar::Tracer; #use Grammar::Debugger; my $scene = q:to/END/; ★ 二维码 1011 扫描二维码 1047 扫描小程序码 1012 长按图片识别二维码 1013 手机相册选取二维码 1031 长按图片识别一维码 1032 手机相册选取一维码 1048 长按图片识别小程序码 1049 手机相册选取小程序码 1025 扫描一维码 1072 二维码收款页面 ★ 搜索 1005 顶部搜索框的搜索结果页 1006 发现栏小程序主入口搜索框的搜索结果页 1042 添加好友搜索框的搜索结果页 1053 搜一搜的结果页 1027 顶部搜索框搜索结果页“使用过的小程序”列表 ★ 公众号 1043 公众号模板消息 1020 公众号 profile 页相关小程序列表 1035 公众号自定义菜单 1058 公众号文章 1074 公众号会话下发的小程序消息卡片 ★ 分享 1036 App 分享消息卡片 1007 单人聊天会话中的小程序消息卡片 1008 群聊会话中的小程序消息卡片 1044 带 shareTicket 的小程序消息卡片 ★ 模板消息 1014 小程序模版消息 1034 微信支付完成页 ★ 测试 1059 体验版小程序绑定邀请页 1017 前往体验版的入口页 ★ 卡券 1028 我的卡包 1029 卡券详情页 1052 卡券的适用门店列表 ★ 小程序之间跳转 1037 小程序打开小程序 1038 从另一个小程序返回 ★ 快捷入口 1001 发现栏小程序主入口 1022 聊天顶部置顶小程序入口 1023 安卓系统桌面图标 1024 小程序 profile 页 ★ 广告投放 1068 附近小程序列表广告 1067 公众号文章广告 ★ 其他 1039 摇电视 1056 音乐播放器菜单 1019 微信钱包 1026 附近小程序列表 1064 微信连Wifi状态栏 1073 客服消息列表下发的小程序消息卡片 END grammar Scene { token TOP { ^ &amp;lt;entry&amp;gt;+ $ } # 一个或多个块 token entry { &amp;lt;head&amp;gt; \s* # 每个块都有一个标题 &amp;lt;line&amp;gt;+ \s* # 每个标题下面有很多非标题行 } token head { &#39;★&#39; \s+ &amp;lt;title&amp;gt; } token line { [ &amp;lt;!</description>
    </item>
    
    <item>
      <title>Perl 6 中的笑脸</title>
      <link>https://ohmysummer.github.io/post/2017-03-11-perl6%E4%B8%AD%E7%9A%84%E7%AC%91%E8%84%B8/</link>
      <pubDate>Sat, 11 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-11-perl6%E4%B8%AD%E7%9A%84%E7%AC%91%E8%84%B8/</guid>
      <description>在 Perl 6 中在调用者的类型身上使用 :D 或 :U 类型笑脸来制造 type/instance 方法:
class Foo { multi method foo (Foo:D:) { say &amp;quot;instance&amp;quot; } multi method foo (Foo:U:) { say &amp;quot;type object&amp;quot; } } Foo .foo; # 输出 type object Foo.new.foo; # 输出 instance # Can use compile time vars to aovid re-typing the actual name everywhere: class Bar { multi method foo (::?CLASS:D:) { say &amp;quot;instance&amp;quot; } multi method foo (::?CLASS:U:) { say &amp;quot;type object&amp;quot; } } Bar .</description>
    </item>
    
    <item>
      <title>关于 Perl 6 你要知道的 10 件事</title>
      <link>https://ohmysummer.github.io/post/2016-10-22-%E5%85%B3%E4%BA%8Eperl6%E4%BD%A0%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8410%E4%BB%B6%E4%BA%8B/</link>
      <pubDate>Sat, 22 Oct 2016 00:52:52 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-22-%E5%85%B3%E4%BA%8Eperl6%E4%BD%A0%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8410%E4%BB%B6%E4%BA%8B/</guid>
      <description>Ten Things You Need To Know about Perl 6 Jeffrey Goff, Evozon Systems LLC OSCON London 2016 https://github.com/drforr http://theperlfisher.blogspot.ro  资源  perl6.org (obviously) docs.perl6.org - Online documentation modules.perl6.org - CPAN Lite
 rakudo.org - Where to get the latest
 https://github.com/tadzik/rakudobrew - Perlbrew for Perl 6
 https://github.com/tadzik/panda/ - Module installer
 irc://irc.freenode.org/perl6 - #perl6 on IRC.freenode.org
 http://rosettacode.org/wiki/Category:Perl_6 - Sample source
  要闻  干净, 一次性的可解析的文法 对用户友好的错误信息 友好的 Unicode 对初学者有帮助的符号 Math that works 函数签名 用正则表达式引导 OO with a type lattice built on a Metaprogramming model 自定义运算符 内置并发  一次性文法 my @doctor = { :first(&#39;Christopher&#39;), :last(&#39;Eccleston&#39;), years =&amp;gt; 1 }, { :first(&#39;David&#39;), :last(&#39;Tennant&#39;), years =&amp;gt; 4 }, { :first(&#39;Matt&#39;), :last(&#39;Smith&#39;), years =&amp;gt; 4 }, { :first(&#39;Peter&#39;), :last(&#39;Capaldi&#39;), years =&amp;gt; 3 }; say &#39;First New Who Doctor: &#39;, @doctor[0]{&#39;first&#39;}, &#39; &#39;, @doctor[0]&amp;lt;last&amp;gt;; say &amp;quot;Average run: &amp;quot; ~ @doctor.</description>
    </item>
    
    <item>
      <title>Perl 6 中的 Subscripts</title>
      <link>https://ohmysummer.github.io/post/2016-06-01-perl6%E4%B8%AD%E7%9A%84subscripts/</link>
      <pubDate>Wed, 01 Jun 2016 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-01-perl6%E4%B8%AD%E7%9A%84subscripts/</guid>
      <description>Subscripts 通过索引或键访问数据结构中的元素。
通常，人们需要引用集合或数据结构中的一个特定的元素（或特定的元素切片）。从数学标记法中偷学到的，向量 v 的组成部分用 v₁, v₂, v₃ 来引用，在 Perl 6 中这个概念叫做 “下标” （或“索引”）。
Basics Perl 6 提供了两个通用的下标接口：
elements are identified by interface name supported by [ ] zero-based indices Positional Array, List, Buf, Match, ... { } string or object keys Associative Hash, Bag, Mix, Match, ...   Positional 下标 (通过 postcircumfix [ ] 通过元素在有序集合中的位置来寻址元素。)索引 0 引用第一个元素， 索引 1 引用第二个元素， 以此类推：  my @chores = &amp;quot;buy groceries&amp;quot;, &amp;quot;feed dog&amp;quot;, &amp;quot;wash car&amp;quot;; say @chores[0]; #-&amp;gt; buy groceries say @chores[1]; #-&amp;gt; feed dog say @chores[2]; #-&amp;gt; wash car   Associative 下标 (通过 postcircumfix { }), 不要求集合以任何特定的顺序保存元素 - 相反，它使用一个唯一的键来寻址每个值。键的种类取决于使用的集合： 举个例子， 一个标准的散列 使用字符串作为键， 而一个 Mix 能使用任意的对象作为键， 等等:  my %grade = Zoe =&amp;gt; &amp;quot;C&amp;quot;, Ben =&amp;gt; &amp;quot;B+&amp;quot;; say %grade{&amp;quot;Zoe&amp;quot;}; #-&amp;gt; C say %grade{&amp;quot;Ben&amp;quot;}; #-&amp;gt; B+ my $stats = ( Date.</description>
    </item>
    
    <item>
      <title>Perl 6 中的签名</title>
      <link>https://ohmysummer.github.io/post/2016-04-12-perl6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/</link>
      <pubDate>Tue, 12 Apr 2016 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-12-perl6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/</guid>
      <description>签名也是对象 class Signature {}  签名是代码对象参数列表的静态描述。即, 签名描述了你需要什么参数和多少参数传递给代码或函数以调用它们。
传递参数给签名把包含在 Capture 中的参数绑定到了签名上。
&amp;gt; sub a($a, $b) {}; &amp;gt; &amp;amp;a.signature.perl.say :($a, $b) &amp;gt; my $b = -&amp;gt; $a, $b {}; &amp;gt; $b.signature.perl.say :($a, $b)  签名是一个对象, 就像 Perl 6 中的任何其它东西一样。 任何 Callable 类型中都有签名, 并且它能使用 .signature方法获取到。
class Signature { ... }  签名字面量 签名出现在子例程和方法名后面的圆括号中, 对于 blocks 签名出现在 -&amp;gt;或 &amp;lt;-&amp;gt; 箭头后面, 或者作为变量声明符(例如 [my](https://docs.perl6.org/syntax/my) )的输入, 或者以冒号开头作为单独的项。
sub f($x) { } # ^^^^ sub f 的签名 method x() { } # ^^ 方法 x 的签名 my $s = sub (*@a) { } # ^^^^^ 匿名函数的签名 for &amp;lt;a b c&amp;gt; -&amp;gt; $x { } # ^^ Block 的签名 my ($a, @b) = 5, (6,7,8); # ^^^^^^^^ 变量声明符的签名 my $sig = :($a, $b); # ^^^^^^^^ 独立的签名对象  签名字面量可以用于定义回调或闭包的签名。</description>
    </item>
    
    <item>
      <title>Grammars</title>
      <link>https://ohmysummer.github.io/post/2016-02-05-perl-6-grammars/</link>
      <pubDate>Fri, 05 Feb 2016 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-05-perl-6-grammars/</guid>
      <description>Grammars Grammars - 一组具名 regexes 组成正式的 grammar
Grammars 是一个很强大的工具用于析构文本并通常返回数据结构。
例如, Perl 6 是使用 Perl 6 风格 grammar 解析并执行的。
对普通 Perl 6 使用者更实用的一个例子是 JSON::Tiny模块, 它能反序列化任何合法的 JSON 文件, 而反序列代码只有不到 100 行, 还能扩展。
Grammars 允许你把 regexes 组织到一块儿, 就像类(class) 中组织方法那样。
具名正则 (Named Regexes) 　grammars 的主要组成部分是 regexes。 而 Perl 6 的 regexes语法不在该文档的讨论范围, 具名正则(named regexes) 有它自己的特殊语法, 这跟子例程(subroutine) 的定义很像:
my regex number { \d+ [ \. \d+ ]? } # 普通 regex 中空格被忽略, [] 是非捕获组  上面的代码使用 my 关键字指定了本地作用域的 regex, 因为具名正则(named regexes) 通常用在 grammars 里面。</description>
    </item>
    
    <item>
      <title>Perl 6 Grammars, Part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-13-perl-6-grammers-part-1/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-13-perl-6-grammers-part-1/</guid>
      <description>Perl 6 Grammars, Part 1 Perl 6 语言内置了对 grammar 的支持。您可以将 grammars 视为众所周知的正则表达式和诸如 yacc 或 bison 等实用程序或更复杂的 grammar 工具（如ANTLR）的组合。所有这些 - 词法分析器，语法分析器和语义处理 - 通常是编译器的独立部分，在 Perl 6 中它们都是内置的，并且可以通过全新的 Perl 6 安装 进行开箱即用。
要感受 grammar 的力量，Perl 6 自己的 grammar 就是用 Perl 6 庞大的 grammar 类 Perl6::Grammar写成的就足以说明了。
在本文中，我将通过几个例子来说明 grammar 的基础知识。所有必需的语言结构将在我们进行的时候进行解释。
解析数字 在你开始思考用户可以使用不同格式的数字,包括负数，浮点数，科学记数法中的数字，特殊形式的数字（如C的长整数）之前，解析数字似乎是一项简单的任务。
让我们从最简单的形式开始：一个数字作为数字序列。例如，1,42,123 或 1000. Perl 6 中的 grammar 是一种特殊的类，它有自己的关键字。grammar 的第一个 rule 必须（默认情况下）称为 TOP，以下是解析第一组数字的完整程序：
grammar N { token TOP { &amp;lt;digit&amp;gt;+ } } for &amp;lt;1 42 123 1000&amp;gt; -&amp;gt; $n { say N.</description>
    </item>
    
  </channel>
</rss>