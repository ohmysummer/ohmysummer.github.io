<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perl 6 on Young For Perl 6</title>
    <link>https://ohmysummer.github.io/categories/perl-6/</link>
    <description>Recent content in Perl 6 on Young For Perl 6</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 10 May 2018 10:54:24 +0200</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/categories/perl-6/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>饭否客户端</title>
      <link>https://ohmysummer.github.io/post/2018-05-10-%E9%A5%AD%E5%90%A6%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>Thu, 10 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-10-%E9%A5%AD%E5%90%A6%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid>
      <description>Inspired by fanfou-py
use Digest::HMAC; use Digest; use Digest::SHA; use MIME::Base64; use URI::Encode; use URI; use Cro::HTTP::Client; # URL 编码 sub oauth_escape($s){ return uri_encode_component($s.Str); } # 返回当前时间戳 sub oauth_timestamp() { return time; } # 单次值, 返回一个8位的随机字符串, 防止重复请求 sub oauth_nonce($size=8) { return ((1..9).pick for 1..$size).join(&amp;quot;&amp;quot;); } # 返回按一定顺序拼接好的字符串 sub oauth_query(%args) { return (sprintf &amp;quot;%s=%s&amp;quot;, $_, oauth_escape(~%args{$_}) for %args.keys.sort).join(&#39;&amp;amp;&#39;); } # URL 正规化 sub oauth_normalized_url($url){ my URI $u .= new($url); return sprintf(&#39;%s://%s%s&#39;, $u.</description>
    </item>
    
    <item>
      <title>Perl 6 CookBook</title>
      <link>https://ohmysummer.github.io/post/2018-05-08-perl6cookbook/</link>
      <pubDate>Tue, 08 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-08-perl6cookbook/</guid>
      <description>Perl 6 CookBook(inspired by Python cookbook)
数据结构和算法 解压序列赋值给多个变量 问题 现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值 给 N 个变量？
解决方案 任何的序列 (或者是可迭代对象) 可以通过一个简单的赋值语句解压并赋值给多个 变量。唯一的前提就是变量的数量必须跟序列元素的数量是一样的。
代码示例：
&amp;gt; my @p = (4,5); [4 5] &amp;gt; my ($x, $y) = @p; (4 5) &amp;gt; $x 4 &amp;gt; $y 5 &amp;gt; my @data = (&#39;ACME&#39;, 50, 91.1, (2012, 12, 21) ); [ACME 50 91.1 (2012 12 21)] &amp;gt; my ($name, $shares, $price, ($year, $mon, $day)) = (&#39;ACME&#39;, 50, 91.</description>
    </item>
    
    <item>
      <title>Dateish</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-dateish/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-dateish/</guid>
      <description>role Dateish { ... }  Date 和 DateTime 都支持访问 year, month 和 day-of-month 以及相关的函数，例如计算星期几。
方法 year 方法 定义为：
method year(Date:D: --&amp;gt; Int:D)  返回日期的月份(1..12)。
say Date.new(&#39;2015-12-31&#39;).month; # OUTPUT: «12» say DateTime.new(date =&amp;gt; Date.new(&#39;2015-12-24&#39;), hour =&amp;gt; 1).month; # OUTPUT: «12»  day 方法 定义为：
method day(Date:D: --&amp;gt; Int:D)  返回日期中月份的天(1..31)。
say Date.new(&#39;2015-12-31&#39;).day; # OUTPUT: «31» say DateTime.new(date =&amp;gt; Date.new(&#39;2015-12-24&#39;), hour =&amp;gt; 1).day; # OUTPUT: «24»  formatter 方法 定义为：</description>
    </item>
    
    <item>
      <title>Make</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-make/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-make/</guid>
      <description>方法 make 的文档由以下类型组装而成：
Match 类 来自于 Match
make 方法 method make(Match:D: Mu $payload) sub make(Mu $payload)  将任意有效载荷(payload)存储到 Match 对象中，稍后可通过 .made / .ast 方法重新取回它。
这通常用于 grammar 的 action 类方法中，其中一个方法存储一段数据，然后由另一个方法取回。这取决于你存储什么数据。它可以是树节点，计算结果或值的列表。
sub 形式的 make 操作当前的 $/，这可能是一个简写：
method my-action ($/) { make &amp;quot;foo: $/&amp;quot;; }  make 会把数据结构附加到各自的 Match 对象上, 随后通过 .made 方法取回。使用 Match.perl 方法可以看到, Match 里面有一个 made 属性：
&amp;gt; if &#39;abc&#39; ~~ /\w+/ { $/.make: {&#39;a&#39; =&amp;gt; &#39;bc&#39;, &#39;d&#39; =&amp;gt; &#39;wsl&#39;}; say $/.</description>
    </item>
    
    <item>
      <title>Slip</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-slip/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-slip/</guid>
      <description>有时您想要将列表的元素插入到另一个列表中。这可以通过称为 Slip 的特殊类型的列表完成。
say (1, (2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «False␤» say (1, Slip.new(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, slip(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤»  另一种方法是使用 | 前缀运算符。请注意，这比逗号的优先级更高，因此它只影响单个值，但与上述选项不同，它会打破标量。
say (1, |(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, |$(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, slip($(2, 3)), 4) eqv (1, 2, 3, 4); # OUTPUT: «False␤»  Slip class Slip is List {}  Slip 是一个 List，自动展平到一个外部列表（或其他类似列表的容器或 iterable）中。</description>
    </item>
    
    <item>
      <title>类和对象</title>
      <link>https://ohmysummer.github.io/post/2018-05-06-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sun, 06 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-06-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</guid>
      <description>Perl 6 有一个丰富的内置语法来定义和使用类。
默认构造函数允许为创建的对象设置属性：
class Point { has Int $.x; has Int $.y; } class Rectangle { has Point $.lower; has Point $.upper; method area() returns Int { ($!upper.x - $!lower.x) * ( $!upper.y - $!lower.y); } } # Create a new Rectangle from two Points my $r = Rectangle.new(lower =&amp;gt; Point.new(x =&amp;gt; 0, y =&amp;gt; 0), upper =&amp;gt; Point.new(x =&amp;gt; 10, y =&amp;gt; 10)); say $r.area(); # OUTPUT: «100␤»  您也可以提供自己的构建和构建实现。下面更详细的例子展示了 Perl 6 中依赖处理器的外观。它展示了自定义构造函数，私有属性和公共属性，方法以及签名的各个方面。它代码不多，但结果是有趣和有用的。</description>
    </item>
    
    <item>
      <title>DateTime</title>
      <link>https://ohmysummer.github.io/post/2018-05-05-datetime/</link>
      <pubDate>Sat, 05 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-05-datetime/</guid>
      <description>DateTime class DateTime does Dateish {}  对于在国内处理点数，DateTime 对象存储年，月，日，小时，分钟（全部为 Int），秒（可能为小数）和时区。
它提供了用日期和时间计算的方法。
DateTime 方法是不可变的;如果你试图修改它，请改为创建修改后的副本。
时区的处理时间为以 UTC 为单位的整数，而不是时区名称。
use v6.c; my $dt = DateTime.new( year =&amp;gt; 2015, month =&amp;gt; 11, day =&amp;gt; 21, hour =&amp;gt; 16, minute =&amp;gt; 1, ); say $dt; # OUTPUT: «2015-11-21T16:01:00Z␤» say $dt.later(days =&amp;gt; 20); # OUTPUT: «2015-12-11T16:01:00Z␤» say $dt.truncated-to(&#39;hour&#39;); # OUTPUT: «2015-11-21T16:00:00Z␤» say $dt.in-timezone(-8 * 3600); # OUTPUT: «2015-11-21T08:01:00-0800␤» my $now = DateTime.now(formatter =&amp;gt; { sprintf &amp;quot;%02d:%02d&amp;quot;, .</description>
    </item>
    
    <item>
      <title>Awesome Async Interfaces with Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-04-27-perl-6%E4%B8%AD%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 26 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-27-perl-6%E4%B8%AD%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3/</guid>
      <description>IRC::Client: Perl 6 Multi-Server IRC (or Awesome Async Interfaces with Perl 6) 我在 2015 年圣诞节编写了我的第一个 Perl 6 程序 - 一个新年 IRC 派对机器人工具。这项工作包括发布 IRC::Client 模块. 我从这个语言中找到了童年的乐趣并且在假期喝了不少酒, 结果就是这个模块差强人意。
最近，我需要一个用于某些 Perl 6 bug 队列工作的工具，因此我决定花费一个周末，从头开始重新设计并重写这个模块。在过去的几个月中，有好几个人请求我这么做，所以我想我还会写一篇关于如何使用该模块的教程 - 作为一名主拖延者的道歉。如果你对 IRC 不感兴趣，我希望本教程将作为 Perl 6 中异步，非阻塞接口的一个通用示例。
基础 要创建一个 IRC 机器人，实例化一个 IRC::Client 对象，给它一些基本信息，并调用 .run 方法。实现所需的所有功能，并将它们作为方法名称匹配要收听的事件的类，并通过 .plugins 属性传递。当发生 IRC 事件时，它会按照您指定的顺序传递给所有插件，如果某个插件要求它处理事件，则停止。
这里有一个简单的 IRC 机器人，它可以响应在频道中发送的消息，通知和发送给它的私人消息。响应是 bot 收到的大写原始消息：
use IRC::Client; .run with IRC::Client.new: :nick&amp;lt;MahBot&amp;gt; :host&amp;lt;irc.freenode.net&amp;gt; :channels&amp;lt;#perl6&amp;gt; :debug :plugins(class { method irc-to-me ($_) { .</description>
    </item>
    
    <item>
      <title>Cro::HTTP::Client</title>
      <link>https://ohmysummer.github.io/post/2018-04-16-cro-http-client/</link>
      <pubDate>Mon, 16 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-16-cro-http-client/</guid>
      <description>Cro::HTTP::Client Cro::HTTP::Client 类提供了一个灵活的 HTTP 和 HTTPS 客户端实现，可以从简单到更复杂的情况进行扩展。它可以通过两种方式消费：
通过对类型对象（ Cro::HTTP::Client.get($url) ）进行调用。这对于一次性请求很有用，但在向同一服务器发出多个请求时（例如使用 keep-alive）不提供连接重用。
通过创建一个 Cro::HTTP::Client 实例。默认情况下，这可以重用连接池。它还可以配置默认的 base URL，传递的默认授权数据，甚至是插入到请求/响应处理管道中的中间件。 Cro::HTTP::Client 实例可以并发地使用。
一般来说，如果您打算发起一次性请求，请使用类型对象。如果您要向同一台服务器或一组服务器发出很多请求，请创建一个实例。
默认情况下，HTTPS 请求将使用 ALPN 来协商是否执行 HTTP/2 或 HTTP/1.1，并且 HTTP 请求将始终使用 HTTP/1.1。
发起基本请求 可以在类型对象或 Cro::HTTP::Client 的实例上调用 get，post，put，delete，patch 和 head 方法。他们都会返回一个 Promise，如果请求成功则会被保留(kept), 如果失败则被毁掉(broken)。
my $resp = await Cro::HTTP::Client.get(&#39;https://www.perl6.org/&#39;);  响应($resp) 是一个 Cro::HTTP::Response 对象。它将在请求头可用时立即生成;请求体可能尚未收到。默认情况下，错误（4xx和5xx状态码）将导致遵守 X::Cro::HTTP::Error 角色的异常，该角色具有包含 Cro::HTTP::Response 对象的 response 属性。
my $resp = await Cro::HTTP::Client.delete($product-url); CATCH { when X::Cro::HTTP::Error { if .response.status == 404 { say &amp;quot;Product not found!</description>
    </item>
    
    <item>
      <title>使用 flip-flop 和 gather-take 提取文本块儿</title>
      <link>https://ohmysummer.github.io/post/2018-04-15-flip-flop/</link>
      <pubDate>Sun, 15 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-15-flip-flop/</guid>
      <description>使用 flip-flop 和 gather-take 提取文本块儿 my $excerpt = q:to/END/; Here&#39;s some unimportant text. =begin code This code block is what we&#39;re after. We&#39;ll use &#39;ff&#39; to get it. =end code More unimportant text. =begin code Today rains heavy. Long live AI . HaHa =end code More unimport text. =begin code Like to go home. =end code END my @lines = gather { my @current; for $excerpt.lines { if &amp;quot;=begin code&amp;quot; ^ff^ &amp;quot;=end code&amp;quot; { # collect the values between matches push @current, .</description>
    </item>
    
    <item>
      <title>Perl 6 中散列的键和值</title>
      <link>https://ohmysummer.github.io/post/2018-04-14-keys-values-of-hashes-in-perl-6/</link>
      <pubDate>Sat, 14 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-14-keys-values-of-hashes-in-perl-6/</guid>
      <description>Perl 6 中散列的键和值 今天，我们将看看 Hash 类的几个返回散列所有键或值或同时返回键和值的方法:
&amp;gt; my %h = H =&amp;gt; &#39;Hydrogen&#39;, He =&amp;gt; &#39;Helium&#39;, Li =&amp;gt; &#39;Lithium&#39;; {H =&amp;gt; Hydrogen, He =&amp;gt; Helium, Li =&amp;gt; Lithium} &amp;gt; %h.keys; (H Li He) &amp;gt; %h.values; (Hydrogen Lithium Helium) &amp;gt; %h.kv; (H Hydrogen Li Lithium He Helium)  虽然你可能想直接进入 src/core/Hash.pm6 文件来查看方法的定义，但你会一无所获。 Hash 类是 Map 的子类，所有这些方法都定义在 src/core/Map.pm6 文件中。获取键和值很简单:
multi method keys(Map:D:) { Seq.new(Rakudo::Iterator.Mappy-keys(self)) } multi method values(Map:D:) { Seq.new(Rakudo::Iterator.Mappy-values(self)) }  对于 kv 方法, 需要多做点工作:</description>
    </item>
    
    <item>
      <title>Perl 6 中的列表解析</title>
      <link>https://ohmysummer.github.io/post/2018-04-13-perl-6-%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 13 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-13-perl-6-%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>Perl 6 中的列表解析 看一看 Python 中关于列表推导的页面。
S = {x² : x in {0 ... 9}} V = (1, 2, 4, 8, ..., 2¹²) M = {x | x in S and x even}  Python 列表解析:
S = [x**2 for x in range(10)] V = [2**i for i in range(13)] M = [x for x in S if x % 2 == 0]  在原始定义中我没有看到 10 或 13 , Perl 6 与原始语言最接近的语法是:</description>
    </item>
    
    <item>
      <title>在 Perl 6 中设置超时</title>
      <link>https://ohmysummer.github.io/post/2018-04-12-setting-timeouts-in-perl-6/</link>
      <pubDate>Thu, 12 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-12-setting-timeouts-in-perl-6/</guid>
      <description>在 Perl 6 中设置超时 在 Perl 5 中，我曾经使用信号设置超时（至少，这是一种简单且可预测的方式）。在 Perl 6 中，您可以使用 promise。让我们看看如何做到这一点。
要模仿长时间运行的任务，请创建一个无限循环，然后打印其状态。开始吧:
for 1 .. * { .say if $_ %% 100_000; }  只要循环得到控制，它将永远不会退出。我们的任务是在几秒钟内停止程序，因此计时器应在循环之前设置:
Promise.in(2).then({ exit; }); for 1 .. * { .say if $_ %% 100_000; }  在这里，Promise.in 方法创建一个 promise，在给定秒数后自动 kept。在 promise 的基础上，使用 then，我们添加了另一个 promise，其代码将在超时后运行。这里唯一的语句就是退出，停止主程序。
运行该程序以查看它的工作原理：
$ time perl6 timeout.pl 100000 200000 300000 . . . 3700000 3800000 3900000 real 0m2.196s user 0m2.120s sys 0m0.068s  该程序在我的计算机上计数达四百万，并在两秒内退出。这正是我们需要的行为。</description>
    </item>
    
    <item>
      <title>Typed hashes in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-04-11-typed-hashes-in-perl-6/</link>
      <pubDate>Wed, 11 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-11-typed-hashes-in-perl-6/</guid>
      <description>Typed hashes in Perl 6 在 Perl 6 中, 你可以通过指定变量的类型来限制变量容器的内容, 例如：
my Int $i;  标量变量中只有一个值。你可以将该概念扩展到数组, 并让其元素仅保存整数, 如下例所示：
&amp;gt; my Int @i; [] &amp;gt; @i.push(42); [42] &amp;gt; @i.push(&#39;Hello&#39;); Type check failed in assignment to @i; expected Int but got Str (&amp;quot;Hello&amp;quot;) in block &amp;lt;unit&amp;gt; at &amp;lt;unknown file&amp;gt; line 1  哈希中保存的是 pairs, 所以你可以同时指定键和值的类型。语法和上面的例子并无不同。
首先, 让我们声明值的类型：
my Str %s;  现在, 可以将字符串作为哈希的值：
&amp;gt; %s&amp;lt;Hello&amp;gt; = &#39;World&#39; World &amp;gt; %s&amp;lt;42&amp;gt; = &#39;Fourty-two&#39; Fourty-two  但这个哈希不能保存整数:</description>
    </item>
    
    <item>
      <title>Perl 6 中的 gist 方法</title>
      <link>https://ohmysummer.github.io/post/2018-04-10-what-does-gist-do-in-perl-6/</link>
      <pubDate>Tue, 10 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-10-what-does-gist-do-in-perl-6/</guid>
      <description>当你打印对象的时候, 例如 say $x, Perl 6 调用 gist 方法. 这个方法是为所有内建类型定义的：对于其中一些类型，它调用 Str 方法，对于某些类型它调用 perl 方法，对于某些类型，它使字符串表示有所不同。
让我们看看如何使用该方法来创建您自己的变体：
class X { has $.value; method gist { &#39;[&#39; ~ $!value ~ &#39;]&#39; } } my $x = X.new(value =&amp;gt; 42); say $x; # [42] $x.say; # [42]  当你调用 say 时，该程序在方括号中打印一个数字：[42]。
请注意，双引号字符串中的插值使用 Str，而不是 gist。你可以在这里看到它：
say $x.Str; # X&amp;lt;140586830040512&amp;gt; say &amp;quot;$x&amp;quot;; # X&amp;lt;140586830040512&amp;gt;  如果您需要自定义插值，请重新定义 Str 方法:
class X { has $.value; method gist { &#39;[&#39; ~ $!</description>
    </item>
    
    <item>
      <title>Perl 6 中的 Superscripts</title>
      <link>https://ohmysummer.github.io/post/2018-04-09-perl-6-%E4%B8%AD%E7%9A%84%E4%B8%8A%E6%A0%87/</link>
      <pubDate>Mon, 09 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-09-perl-6-%E4%B8%AD%E7%9A%84%E4%B8%8A%E6%A0%87/</guid>
      <description>Perl 6 中的 Superscripts 在 Perl 6 中，可以使用上标索引来计算数字的幂数，例如:
&amp;gt; 2⁵ 32 &amp;gt; 7³ 343  也可以在上标中使用多个数字：
&amp;gt; 10¹² 1000000000000  你可以猜到，上面的代码等同于这样：
&amp;gt; 2**5 32 &amp;gt; 7**3 343 &amp;gt; 10**12 1000000000000  但问题是：上标到底是如何工作的？让我们找出答案。
对于 Numeric 角色，定义了以下操作：
proto sub postfix:&amp;lt;ⁿ&amp;gt;(Mu $, Mu $) is pure {*} multi sub postfix:&amp;lt;ⁿ&amp;gt;(\a, \b) { a ** b }  啊哈，这就是我们需要的，上标符号在这里转换为简单的 ** 运算符。
您可以通过打印操作数来可视化传递给操作的确切内容：
multi sub postfix:&amp;lt;ⁿ&amp;gt;(\a, \b) { nqp::say(&#39;# a = &#39; ~ a); nqp::say(&#39;# b = &#39; ~ b); a ** b }  这个时候，你会看到上面的测试示例输出如下：</description>
    </item>
    
    <item>
      <title> More on the proto keyword in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-21-more-on-the-proto-keyword-in-perl-6/</link>
      <pubDate>Wed, 21 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-21-more-on-the-proto-keyword-in-perl-6/</guid>
      <description>在深入研究 EVAL 子例程的细节之前，我们必须揭示一些关于 protos 原型和多重分派的更多信息。检查以下程序：
proto sub f($x) { say &amp;quot;proto f($x)&amp;quot;; } multi sub f($x) { say &amp;quot;f($x)&amp;quot; } multi sub f(Int $x) { say &amp;quot;f(Int $x)&amp;quot; } multi sub f(Str $x) { say &amp;quot;f(Str $x)&amp;quot; } f(2); f(&#39;2&#39;); f(3); f(&#39;3&#39;);  这里有三个 multi 函数和一个用 proto 关键字声明的函数。早些时候，我们只看到了函数体为空的原型函数，如:
proto sub f($x) {*}  但这不是必需的。正如我们在示例中所看到的，该函数可以承载正常的函数体：
proto sub f($x) { say &amp;quot;proto f($x)&amp;quot;; }  运行这个程序：
proto f(2) proto f(2) proto f(3) proto f(3)  所有的调用都被 proto-候选者抓住了。现在，更新它并返回一些专用值的 {*} 块;</description>
    </item>
    
    <item>
      <title>Examining the Real role of Perl 6, part 2</title>
      <link>https://ohmysummer.github.io/post/2018-02-18-examining-the-real-role-of-perl-6-part-2/</link>
      <pubDate>Sun, 18 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-18-examining-the-real-role-of-perl-6-part-2/</guid>
      <description>今天，我们继续对几天前开始的 Real 角色进行初步探索。
与其方法一起，角色包含许多子例程（放置在角色之外），它们使用 Real 类型的对象定义中缀运算符。名单不长，所以让我把它复制在这里：
multi sub infix:&amp;lt;+&amp;gt;(Real \a, Real \b) { a.Bridge + b.Bridge } multi sub infix:&amp;lt;-&amp;gt;(Real \a, Real \b) { a.Bridge - b.Bridge } multi sub infix:&amp;lt;*&amp;gt;(Real \a, Real \b) { a.Bridge * b.Bridge } multi sub infix:&amp;lt;/&amp;gt;(Real \a, Real \b) { a.Bridge / b.Bridge } multi sub infix:&amp;lt;%&amp;gt;(Real \a, Real \b) { a.Bridge % b.Bridge } multi sub infix:&amp;lt;**&amp;gt;(Real \a, Real \b) { a.Bridge ** b.</description>
    </item>
    
    <item>
      <title>Everyone Loves Porgs</title>
      <link>https://ohmysummer.github.io/post/2018-02-17-everyone-loves-porgs/</link>
      <pubDate>Sat, 17 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-17-everyone-loves-porgs/</guid>
      <description>这个想法有一阵子了。我在完成的各个阶段都有几个发文的想法，有时候很难优先考虑这个问题。所以我想我要开始发布我一直在玩的更短的想法和事情，以免这个博客变成那些永不更新的博客之一。所以，我们开始吧。
类在 Perl 6 中很容易定义。它们非常容易，我发现自己使用它们来封装小型的 Hash-like 那样的东西，其中我也可能会使用一两种方法。
class Contact { has $.name; has $.phone; has $.bday; method age { (Date.new($.bday), *.later(:1year) ...^ * &amp;gt; Date.today).end } }  是的，这是一种低效率的计算年龄的方法&amp;hellip;&amp;hellip;就像生活中的很多事情一样，你越老，这种方法变得越慢。
无论如何，现在我已经定义了一个简单的小类来保存一些数据，但要实际实例化一个我不得不 bust out 一些命名参数。
my @contacts; @contacts.push: Contact.new(:name&amp;lt;John&amp;gt;, :phone&amp;lt;555-1111&amp;gt;, :bday&amp;lt;1940-10-09&amp;gt;);  谁有时间为所有这些角色？有时候我只是想用位置参数来构建它们，但这意味着要编写一个新的自定义 multi method new 来处理这些情况&amp;hellip;&amp;hellip;但我只是将一个快速肮脏的类放在一起，真的值得我花时间来构建自定义构造函数吗？
于是我开始四处游玩，并创建了一个让我用 Positional 参数的角色&amp;hellip;&amp;hellip;或一个 Array ..或 List &amp;hellip;构建我的类，嘿，I threw in a Hash for free!！
@contacts.push: Contact.new(&#39;James&#39;, &#39;555-1112&#39;, &#39;1942-06-18&#39;); @contacts.push: Contact.new(&amp;lt; George 555-1113 1943-02-25 &amp;gt;) my %hash = name =&amp;gt; &#39;Richard&#39;, phone =&amp;gt; &#39;555-1114&#39;, bday =&amp;gt; &#39;1940-07-07&#39;; @contacts.</description>
    </item>
    
    <item>
      <title>A word on polymod in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-16-a-word-on-polymod-in-perl-6/</link>
      <pubDate>Fri, 16 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-16-a-word-on-polymod-in-perl-6/</guid>
      <description>在转到 Real 角色的第二部分之前，让我们停下来研究一下 Int 类的中的 polymod 方法。
该方法接收一个数字和任意数字（单位）的列表并返回相应的乘数。所以，你可以很容易地说，例如 550 秒，是 9分 10 秒：
&amp;gt; 550.polymod(60) (10 9)  在方法调用中，60 的值是一分钟内的秒数。结果中，9 是分钟数，10 是余数，其为秒数。所以，550 秒= 10 秒 + 9 分钟。
如果你想了解更多细节，请添加更多单位。例如，什么是 32768 秒？
&amp;gt; 32768.polymod(60, 60, 24) (8 6 9 0)  这是 8 秒，6 分钟，9 小时和 0 天。
类似地，132768 秒是 1 天，12 小时，52 分钟和 48 秒：
&amp;gt; 132768.polymod(60, 60, 24) (48 52 12 1)  老实说，我很难理解它是如何工作的，以及如何读取结果。
文档中的另一个例子更加难以理解：
&amp;gt; 120.polymod(1, 10, 100) (0 0 12 0)  12 是什么意思？这显然是12倍10.</description>
    </item>
    
    <item>
      <title>如何在 Perl 6 中对散列进行排序</title>
      <link>https://ohmysummer.github.io/post/2018-02-16-%E5%A6%82%E4%BD%95%E5%9C%A8perl-6%E4%B8%AD%E5%AF%B9%E6%95%A3%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 16 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-16-%E5%A6%82%E4%BD%95%E5%9C%A8perl-6%E4%B8%AD%E5%AF%B9%E6%95%A3%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</guid>
      <description>要在 Perl 6 中对散列进行排序，首先你要知道什么是占位符变量。一旦这个概念变得清晰，对散列排序就变得非常简单。
例如，创建一个不同城市距离莫斯科远近的散列：
my %distance = Владимир =&amp;gt; 185, Волгоград =&amp;gt; 1000, Калининград =&amp;gt; 1227, Мурманск =&amp;gt; 1895, Новосибирск =&amp;gt; 3550;  现在的任务是通过比较距离来对散列进行排序。
say %distance.sort({$^a.value &amp;lt;=&amp;gt; $^b.value});  一般来说，它已经准备好了。该程序打印你需要的东西：
(Владимир =&amp;gt; 185 Волгоград =&amp;gt; 1000 Калининград =&amp;gt; 1227 Архангельск =&amp;gt; 1261 Астрахань =&amp;gt; 1411 Мурманск =&amp;gt; 1895 Новосибирск =&amp;gt; 3550)  让我们看看传递给排序方法的块内发生了什么。
首先，变量 $^a 和 $^b 是占位符，它是匿名块的参数并按字母顺序排序。也就是说，以相同的方式，他们可以被称为 $^x 和 $^y 或 $^var1 和 $^var2。
其次，这些占位符变量内部是 Pair 类型的对象，它包含键和值：
say %distance.</description>
    </item>
    
    <item>
      <title>Examining the Real role of Perl 6, part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-15-examining-the-real-role-of-perl-6-part-1/</link>
      <pubDate>Thu, 15 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-15-examining-the-real-role-of-perl-6-part-1/</guid>
      <description>在过去的几天里，我们谈了很多关于 Real 这个角色。让我们更仔细地看看它。该代码位于 src/core/Real.pm 文件中。
它包含角色本身和一些实现不同中缀的子例程。Real 角色又实现了 Numeric 角色：
my role Real does Numeric { . . . }  有趣的是，类定义还需要关于 Complex 类的一些知识，这就是为什么在文件的第一行有一个前向类声明：
my class Complex { ... }  Real 角色将许多三角函数定义为方法，正如我们已经看到的，他们正在使用 Bridge 方法：
method sqrt() { self.Bridge.sqrt } method rand() { self.Bridge.rand } method sin() { self.Bridge.sin } method asin() { self.Bridge.asin } method cos() { self.Bridge.cos } method acos() { self.Bridge.acos } method tan() { self.Bridge.tan } method atan() { self.</description>
    </item>
    
    <item>
      <title>FatRat vs Rat in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-15-fatrat-vs-rat-in-perl-6/</link>
      <pubDate>Thu, 15 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-15-fatrat-vs-rat-in-perl-6/</guid>
      <description>昨天，Solomon Foster 在 Facebook 的 Perl 6 小组上发布了一个例子:
my @x = FatRat.new(1, 1), -&amp;gt; $x { $x - ($x ** 2 - $N) / (2 * $x) } ... *  这段代码实现了牛顿找到 $N 平方根近似值的方法。重要的是它使用 FatRat 值来获得更高的准确性。
让我们运行 9 的平方根：
my $N = 9; my @x = Rat.new(1, 1), -&amp;gt; $x { $x - ($x ** 2 - $N) / (2 * $x) } ... *; .say for @x[0..7];  很快，它收敛到正确的值：</description>
    </item>
    
    <item>
      <title>A bit more on Rat vs FatRat in Perl 6</title>
      <link>https://ohmysummer.github.io/post/2018-02-14-a-bit-more-on-rat-vs-fatrat-in-perl-6/</link>
      <pubDate>Wed, 14 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-14-a-bit-more-on-rat-vs-fatrat-in-perl-6/</guid>
      <description>昨天，我们正在深入研究 Rakudo Perl 6，以了解Rat值成为Num值的时间。事实证明，如果该值变得太小，这意味着它的分母变得越来越大，Rakudo开始使用Num值而不是Rat。
我们找到了它发生的地方。今天，让我们进行一个练习，看看Perl 6的行为是否可能不同，即扩展数据类型而不是将其切换为浮点数并且失去准确性。
改变很简单。所有你需要的是更新DIVIDE_N例程中的ifs：
--- a/src/core/Rat.pm +++ b/src/core/Rat.pm @@ -48,16 +48,14 @@ sub DIVIDE_NUMBERS(Int:D \nu, Int:D \de, \t1, \t2) { ($numerator := -$numerator), ($denominator := -$denominator))), nqp::if( - nqp::istype(t1, FatRat) || nqp::istype(t2, FatRat), + nqp::istype(t1, FatRat) || nqp::istype(t2, FatRat) || $denominator &amp;gt;= UINT64_UPPER, nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(FatRat),FatRat,&#39;$!numerator&#39;,$numerator), FatRat,&#39;$!denominator&#39;,$denominator), - nqp::if( - $denominator &amp;lt; UINT64_UPPER, nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(Rat),Rat,&#39;$!numerator&#39;,$numerator), - Rat,&#39;$!denominator&#39;,$denominator), - nqp::p6box_n(nqp::div_In($numerator, $denominator))))) + Rat,&#39;$!denominator&#39;,$denominator) + )) }  现在有两种结果：例程产生一个Rat值或一个FatRat。当子参数已经是FatRats或当前Rat太接近于零时，后者发生。</description>
    </item>
    
    <item>
      <title>Going over the Bridge, part 2. Let’s get rid of it</title>
      <link>https://ohmysummer.github.io/post/2018-02-12-going-over-the-bridge-part-2/</link>
      <pubDate>Mon, 12 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-12-going-over-the-bridge-part-2/</guid>
      <description>今天，我们继续在 Rakudo Perl 6 中使用 Bridge 方法。昨天，我们在几个预定义的数据类型中看到了方法的定义。现在是时候看看如何使用该方法。
里面有什么? 该方法的主要用途在 Real 角色中，该角色包含以下一组方法：
method sqrt() { self.Bridge.sqrt } method rand() { self.Bridge.rand } method sin() { self.Bridge.sin } method asin() { self.Bridge.asin } method cos() { self.Bridge.cos } method acos() { self.Bridge.acos } method tan() { self.Bridge.tan } method atan() { self.Bridge.atan } . . . method sec() { self.Bridge.sec } method asec() { self.Bridge.asec } method cosec() { self.Bridge.cosec } method acosec() { self.</description>
    </item>
    
    <item>
      <title>Going over the Bridge, part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-11-going-over-the-bridge-part-1/</link>
      <pubDate>Sun, 11 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-11-going-over-the-bridge-part-1/</guid>
      <description>在处理 Perl 6 中的数字的类中，我们看到了 Bridge 方法，该方法以多态方式使用。让我们花一些时间，并试图了解 1）它是如何工作的，2）是否有必要。
类和角色 我们的第一步是查看方法定义在哪里。以下是我们需要的类和角色列表：
 Duration Instant Int Num Rational Real  为了预测下一步，让我们添加一些关于他们关系的更多细节：
 class Duration is Cool does Real class Instant is Cool does Real class Int is Cool does Real class Num is Cool does Real role Rational does Real role Real does Numeric  在斜体字体中，我添加了伪声明，这些伪声明没有在 src/core 的相应文件中明确拼写，而是通过 src/Perl6/Metamodel/BOOTSTRAP.nqp 设置:
Int.HOW.add_parent(Int, Cool); . . . Num.HOW.add_parent(Num, Cool);  对于完整的图片，我们可以查看其他类的位置，例如 Rat 或 Complex，但让我们先关注上面的列表。</description>
    </item>
    
    <item>
      <title>Perl 6 中的命名参数</title>
      <link>https://ohmysummer.github.io/post/2018-02-10-perl-6%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 10 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-10-perl-6%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</guid>
      <description> Perl 6 中的函数（和类方法）能够接受命名参数。最简单的方法是用箭头分隔名称和值：
sub f(:$a, :$b) { $a ** $b } say f(a =&amp;gt; 2, b =&amp;gt; 3); # 8  但另一种语法是可能的，在冒号的帮助下。有几个主要品种。
:key(value) 所有内容都以冒号开头，数值在括号内：
say f(:a(2), :b(3));  例如，不用圆括号，尖角括号也是允许的：
say f(:a&amp;lt;2&amp;gt;, :b&amp;lt;3&amp;gt;);  ：Nkey 对于整数值，仍然有这样一个奇怪的语法：
say f(:2a, :3b);  :key 和 :!key 如果命名参数用作标记，则不需要指定值。在这种情况下，您可以传递 True 和 False，如下所示：
sub g(:$key) { $key } say g(:key); # True say g(:!key); # False  实际上，所有冒号对儿都会创建键值对，因此您可以在创建散列时执行相同的操作
my %data = :alpha(10), :beta(20), :gamma(30); say %data&amp;lt;beta&amp;gt;; # 20  </description>
    </item>
    
    <item>
      <title>Perl 6 Grammar 中的冒号对儿</title>
      <link>https://ohmysummer.github.io/post/2018-02-08-perl-6-grammar%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7%E5%AF%B9%E5%84%BF/</link>
      <pubDate>Thu, 08 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-08-perl-6-grammar%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7%E5%AF%B9%E5%84%BF/</guid>
      <description>欢迎来到这个系列的第 50 篇文章!
今天, 我们将讨论一个小的语法结构, 然而就 Grammar 来说这是非常复杂的。首先让我们看看整个 colonpair token:
token colonpair { :my $*key; :my $*value; &#39;:&#39; :dba(&#39;colon pair&#39;) [ | &#39;!&#39; [ &amp;lt;identifier&amp;gt; || &amp;lt;.panic: &amp;quot;Malformed False pair; expected identifier&amp;quot;&amp;gt; ] [ &amp;lt;[ \[ \( \&amp;lt; \{ ]&amp;gt; { $/.typed_panic(&#39;X::Syntax::NegatedPair&#39;, key =&amp;gt; ~$&amp;lt;identifier&amp;gt;) } ]? { $*key := $&amp;lt;identifier&amp;gt;.Str; $*value := 0 } | $&amp;lt;num&amp;gt; = [\d+] &amp;lt;identifier&amp;gt; [ &amp;lt;?before &amp;lt;.[ \[ \( \&amp;lt; \{ ]&amp;gt;&amp;gt; {} &amp;lt;.</description>
    </item>
    
    <item>
      <title>Perl 6 中的数据类型 Bag</title>
      <link>https://ohmysummer.github.io/post/2018-02-07-perl-6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/</link>
      <pubDate>Wed, 07 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-07-perl-6%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/</guid>
      <description>数据类型 Bag 是一种 Perl 5 中没有的新的数据类型。
它可以被认为是一个容器，它一方面知道它里面有多少个单独的元素，另一方面可以说有多少种不同类型的商品。您可以用不同的方式描述此类型：Bag 是一个哈希，默认情况下，您添加的键的值为1。我们来看看例子。
把一个 1 放进 bag 里，看看 perl 的输出：
my $b1 = bag(1); say $b1.perl;  该程序打印以下输出：
(1=&amp;gt;1).Bag  也就是说，我们有一个 1。
如果你把另一个数字也放进 bag 里面：
my $b2 = bag(1, 2); say $b2.perl;  现在有一个 1 和一个 2：
(1=&amp;gt;1,2=&amp;gt;1).Bag  好的，如果你添加另一个 1 呢?
my $b3 = bag(1, 2, 1); say $b3.perl;  现在有两个 1：
(1=&amp;gt;2,2=&amp;gt;1).Bag  让我们稍微离题一下：所有显示的例子都可以把括号去掉：
my $b1 = bag 1; my $b2 = bag 1, 2; my $b3 = bag 1, 2, 1;  比较典型的是，bag 不止能存储数字，还可以存储字符串，例如：</description>
    </item>
    
    <item>
      <title>Perl 6 Core Hacking: QASTalicious</title>
      <link>https://ohmysummer.github.io/post/2018-01-28-perl-6-core-hacking-qastalicious/</link>
      <pubDate>Sun, 28 Jan 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-01-28-perl-6-core-hacking-qastalicious/</guid>
      <description>在过去的一个月中，我在 Rakudo 的 QAST 地区花了一些时间写了一些优化，修复了包含警告的错误，并且用一个单一的提交压缩了一个10个thunk范围的bug的怪物蜂巢。 在今天的文章中，我们将详细介绍最后一个专长，以及了解QAST是什么以及如何使用它。
第一部分: QAST &amp;ldquo;QAST&amp;rdquo; 代表 &amp;ldquo;Q&amp;rdquo; Abstract Syntax Tree.(&amp;ldquo;Q&amp;rdquo; 抽象语法树.) 为什么会有个字母 &amp;ldquo;Q&amp;rdquo; 在那里呢, 因为 Q 是 P 的下一个字母, 而 &amp;ldquo;P&amp;rdquo; 过去是在 &amp;ldquo;PAST&amp;rdquo; 里面的, 代表 &amp;ldquo;Parrot&amp;rdquo;(鹦鹉), 是很早之前的一个实验性的 Perl 6 实现(或者说, 它的虚拟机). 我们来看看什么是 QAST!
Dumping QAST 每个 Rakudo Perl 6 程序都编译到 QAST 节点树上，如果在编译程序或模块时给 perl6 指定 --target=ast 或 --target=optimize 命令行选项，则可以转储该树:
$ perl6 --target=ast -e &#39;say &amp;quot;Hello, World!&amp;quot;&#39; [...] - QAST::Op(call &amp;amp;say) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;?&amp;gt; say \&amp;quot;Hello, World!\&amp;quot; - QAST::Want &amp;lt;wanted&amp;gt; Hello, World!</description>
    </item>
    
    <item>
      <title>Perl 6 logo</title>
      <link>https://ohmysummer.github.io/post/2018-01-28-perl-6-logo/</link>
      <pubDate>Sun, 28 Jan 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-01-28-perl-6-logo/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Playing with the code of Rakudo Perl 6</title>
      <link>https://ohmysummer.github.io/post/2017-12-23-playing-with-the-code-of-rakudo-perl-6/</link>
      <pubDate>Sat, 23 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-23-playing-with-the-code-of-rakudo-perl-6/</guid>
      <description>昨天，我们查看了返回字符串的 Bool 类的两个方法。函数产生的字符串表示在源代码中被硬编码。
让我们使用这个观察并尝试改变文本。
所以，这里是我们要修改的片段：
Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) { self ?? &#39;True&#39; !! &#39;False&#39; });  该 gist 方法用于对已定义的变量进行字符串化。
要做到这一点，你需要在计算机上安装 Rakudo 的源代码，以便编译它们。首先从 GitHub 克隆项目：
$ git clone https://github.com/rakudo/rakudo.git  编译 MoarVM：
$ cd rakudo $ perl Configure.pl --gen-moar --gen-nqp --backends=moar $ make  完成之后，你会在 rakudo 目录下获得 perl6 可执行文件。
现在，打开 src/core/Bool.pm 文件，并将 gist 方法的字符串更改为使用 Unicode 大拇指代替纯文本：
Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) { self ?? &#39;👍&#39; !! &#39;👎&#39; });  保存文件后，您需要重新编译 Rakudo。 Bool.</description>
    </item>
    
    <item>
      <title>Exploring the Bool type in Perl 6, part 1</title>
      <link>https://ohmysummer.github.io/post/2017-12-22-exploring-the-bool-type-in-perl-6-part-1/</link>
      <pubDate>Fri, 22 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-22-exploring-the-bool-type-in-perl-6-part-1/</guid>
      <description>今天，我们将使用 GitHub 上提供的 Rakudo 源代码挖掘 Bool 类型的内部。
Perl 6 是用 Perl 6 和 NQP（Not Quite Perl 6）语言编写的，这使得阅读源代码变得相对容易。当然，有很多东西不容易理解，或者没有反映在 Perl 6 语言的公开文档中。到目前为止，您都无法在 Perl 6 书籍中找到深入的细节。无论如何，对 Perl 6 有一些中级的理解，这仍然是可能的。
好的，回到 src/core/Bool.pm 文件。它以一些 BEGIN phasers 开始，它为 Bool 类添加了一些方法和 multi 方法。下一次我们将讨论元模型和类构造的细节。今天，对我们来说更有趣的是 Bool 类的方法在做什么。
gist 和 perl gist 和 perl 方法返回对象的字符串表示形式：当变量被字符串化时隐式调用 gist，perl 应该直接调用。它适用于 Perl 6 中的任何对象，但这种行为当然应该定义在某处。他们在这里：
Bool.^add_method(&#39;gist&#39;, my proto method gist(|) {*}); Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) { self ?? &#39;True&#39; !! &#39;False&#39; }); Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:U:) { &#39;(Bool)&#39; }); Bool.</description>
    </item>
    
    <item>
      <title>Perl 6 中的 proto 关键字</title>
      <link>https://ohmysummer.github.io/post/2017-12-21-perl-6-%E4%B8%AD%E7%9A%84-proto-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Thu, 21 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-21-perl-6-%E4%B8%AD%E7%9A%84-proto-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>今天，我们正在关注 proto 关键字。它向编译器提供了关于你打算创建 multi-subs 的提示。
例子 1 考虑一个翻转字符串或使整数变成负数的函数示例。
multi sub f(Int $x) { return -$x; } multi sub f(Str $x) { return $x.flip; } say f(42); # -42 say f(&#39;Hello&#39;); # olleH  如果我们创建另一个接收两个参数的函数的变体，会怎么样？
multi sub f($a, $b) { return $a + $b; } say f(1, 2); # 3  这个代码完美的工作，但它看起来像它的和谐是破碎的。即使函数的名称没有提及它的作用，我们也打算设置一个函数，以某种方式返回它的参数的“反射”版本。将两个数字相加的函数不适合这个想法。
所以，现在是在 proto 关键字的帮助下清楚地宣布意图的时候了。
proto sub f($x) {*}  现在，尝试调用双参数函数将无法编译：
===SORRY!=== Error while compiling proto.pl Calling f(Int, Int) will never work with proto signature ($x) at proto.</description>
    </item>
    
    <item>
      <title>第九天 – HTTP and Web Sockets with Cro</title>
      <link>https://ohmysummer.github.io/post/2017-12-09-%E7%AC%AC%E4%B9%9D%E5%A4%A9http-and-web-sockets-with-cro/</link>
      <pubDate>Sat, 09 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-09-%E7%AC%AC%E4%B9%9D%E5%A4%A9http-and-web-sockets-with-cro/</guid>
      <description>Day 9 – HTTP and Web Sockets with Cro 礼物不仅仅是圣诞节的时候才有。今年夏天，在瑞士 Perl 工作室 - 精美地坐落在阿尔卑斯山 - 我有幸透露了 Cro。 Cro 是一组用于在 Perl 6 中构建服务的库，以及一些用于 stub，run 和跟踪服务的开发工具。 Cro 主要关注使用 HTTP（包括HTTP/2.0）和 Web 套接字构建服务，但可以提供对 ZeroMQ 的早期支持，并计划在未来推出一系列其他选项。
响应式管道 Cro 遵循 Perl 的设计原则，使简单的事情变得简单，并且让困难的事情变得可能。就像 Git 一样，Cro 可以被认为是具有瓷器（使简单的事情变得简单）和管道（使困难的事情成为可能）。管道水平由组成管道的组件组成。这些组件具有不同的形状，例如源，传输和下沉。这是一个将 HTTP 请求转换为 HTTP 响应的转换：
use Cro; use Cro::HTTP::Request; use Cro::HTTP::Response; class MuskoxApp does Cro::Transform { method consumes() { Cro::HTTP::Request } method produces() { Cro::HTTP::Response } method transformer(Supply $pipeline --&amp;gt; Supply) { supply whenever $pipeline -&amp;gt; $request { given Cro::HTTP::Response.</description>
    </item>
    
    <item>
      <title>第八天 – Adventures in NQP Land: Hacking the Rakudo Compiler</title>
      <link>https://ohmysummer.github.io/post/2017-12-08-%E7%AC%AC%E5%85%AB%E5%A4%A9adventures-in-nqp-land-hacking-the-rakudo-compiler/</link>
      <pubDate>Fri, 08 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-08-%E7%AC%AC%E5%85%AB%E5%A4%A9adventures-in-nqp-land-hacking-the-rakudo-compiler/</guid>
      <description>Day 8 – Adventures in NQP Land: Hacking the Rakudo Compiler/ 对旧圣诞节经典“圣诞节十二天”的道歉，我给你一个 Perl 6 版本的第一行：
在圣诞节的第一天，我真正的爱给了 pod 树上的 Perl 表格&amp;hellip;&amp;hellip;
但是我得到的表格不是很漂亮！
背景 我与 Perl 6 的第一次真正联系是在 2015 年春天，当时我决定检查它的状态，发现它已经准备好迎接黄金时段。在获得了该语言的一些经验之后，我开始在我可以提供帮助的地方贡献文档。我对文档的第一个贡献是清理其中没有很好呈现的表格。在我对本地主机上的 pod 表进行实验期间，我尝试了下表格：
=begin table -r0c0 r0c1 =end table  这导致 Perl 6 抛出一个丑陋的, LTA（非常搓）的异常消息：
&amp;quot;===SORRY!=== Cannot iterate object with P6opaque representation&amp;quot;  我解决了这个问题，但它让我感觉不爽，所以我开始调查 pod 和 tables 的内部。这导致我在 github.com/rakudo/src/Perl6/Pod.nqp 中发现了问题的根源。
事实上，许多 pod 表格问题的真正问题最终都出现在该文件中。
Not Quite Perl (NQP) nqp 是用于构建 Rakudo Perl 6 编译器的中间语言。它的 git 仓库在这里。本文的其余部分是关于修改 rakudo 编译器中的 nqp 代码，其仓库地址在这里。 Rakudo 在这里也有一个网站。</description>
    </item>
    
    <item>
      <title>第七天 – Test All The Things</title>
      <link>https://ohmysummer.github.io/post/2017-12-07-%E7%AC%AC%E4%B8%83%E5%A4%A9test-all-the-things/</link>
      <pubDate>Thu, 07 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-07-%E7%AC%AC%E4%B8%83%E5%A4%A9test-all-the-things/</guid>
      <description>https://perl6advent.wordpress.com/2017/12/07/day-7-test-all-the-things/
Perl 6 与其大姐姐 Perl 5一样，具有很悠久的测试传统。当您安装任何 Perl 模块时，安装程​​序通常会运行该模块的测试套件。当然，作为新兴的 Perl 6 模块作者，您需要创建自己的测试套件。或者，也许你会在创建模块之前勇于创建测试套件。这实际上有几个好处，其中最主要的是你的第一个用户，甚至在它被写之前。
但在实际代码之前，我想提一下我经常使用的两个 shell 别名 -
alias 6=&#39;perl6 -Ilib&#39; alias 6p=&amp;quot;prove -e&#39;perl6 -Ilib&#39;&amp;quot;  这些别名使我可以快速运行测试文件，而不必去安装我的代码。如果我在项目目录中，我可以运行
$ 6 t/01-core.t ok 1 - call with number ok 2 - call with text ok 3 - call with formatted string 1..3  它会告诉我我运行了哪些测试以及它们是否全部通过。就像它的大姐姐Perl 5一样，Perl 6使用&amp;rsquo;t /&amp;lsquo;目录作为测试文件，并按照惯例使用后缀&amp;rsquo;.t&amp;rsquo;来区分测试文件和软件包或脚本。它还有一个内置的单元测试模块，我们在上面使用。如果我们正在测试sprintf（）内部，它可能看起来像
use Test; ok sprintf(1), &#39;call with number&#39;; ok sprintf(&amp;quot;text&amp;quot;), &#39;call with text&#39;; ok sprintf(&amp;quot;%d&amp;quot;,1), &#39;call with formatted string&#39;; done-testing;  ok和done-testing功能会自动导出给我们。我在这里使用规范的Perl 6风格，而不是太依赖括号。在这种情况下，我确实需要使用圆括号来确保sprintf（）不会“认为”“空调用”是它的参数。</description>
    </item>
    
    <item>
      <title>第六天-Perl 6 书评</title>
      <link>https://ohmysummer.github.io/post/2017-12-06-%E7%AC%AC%E5%85%AD%E5%A4%A9-perl-6-%E4%B9%A6%E8%AF%84/</link>
      <pubDate>Wed, 06 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-06-%E7%AC%AC%E5%85%AD%E5%A4%A9-perl-6-%E4%B9%A6%E8%AF%84/</guid>
      <description>https://perl6advent.wordpress.com/2017/12/06/</description>
    </item>
    
    <item>
      <title>第五天 - 使用 Perl 6 签名解构参数</title>
      <link>https://ohmysummer.github.io/post/2017-12-05-%E7%AC%AC%E4%BA%94%E5%A4%A9-%E4%BD%BF%E7%94%A8perl6%E7%AD%BE%E5%90%8D%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0/</link>
      <pubDate>Tue, 05 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-05-%E7%AC%AC%E4%BA%94%E5%A4%A9-%E4%BD%BF%E7%94%A8perl6%E7%AD%BE%E5%90%8D%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0/</guid>
      <description>第五天 - 使用 Perl 6 签名解构参数 在许多其他关键的 Perl 6 特性中，我认为 Signatures 是众多&amp;rdquo;杀手级&amp;rdquo;特性之一。 它们的功能如此丰富而强大，我怀疑关于如何使用它们可以写一整本书。 我想探索一下我原来忽略但是非常珍惜的一些特定功能。
您可能已经看到了基本的子程序签名：
sub myfunc($x, $y, $z) {...}  它给函数声明了 3 个标量参数, 并在函数体里面给了它们 $x, $y, $z 的名字。
太简单了。
你可以更有爱心, 给它们加上指定的类型:
sub myfunc(Str $x, Int $y, Rat $z) {...}  你可以使用笑脸符号 :D 让参数值是有定义的:
sub myfunc(Str:D $x, Int:D $y, Rat:D $z) {...}  还有很多其它花哨的说明符你可以使用，在这里我不深入了。
但是如果你的参数更复杂呢？ （不是 Complex - 虽然它也起作用..）
For example, you might want to restrict a specific parameter to a Positional argument like an Array, or an Associative one like a Hash using the respective sigils, @ or %.</description>
    </item>
    
    <item>
      <title>第四天-使用 Grammars 进行解析</title>
      <link>https://ohmysummer.github.io/post/2017-12-04-%E7%AC%AC%E5%9B%9B%E5%A4%A9-%E4%BD%BF%E7%94%A8grammars%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 04 Dec 2017 10:08:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-04-%E7%AC%AC%E5%9B%9B%E5%A4%A9-%E4%BD%BF%E7%94%A8grammars%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90/</guid>
      <description>第四天-使用 Grammars 进行解析 下面是从 Parsing with Perl 6 Regexes and Grammars: A Recursive Descent into Parsing 这本书里面提取出来的一章, 作者是 Moritz Lenz, 由 Apress Media 出版社出版。版权经过允许。
这本书马上就要出版了。至少该书的电子版这个月应该可以购买, 纸质版的可以在 亚马逊 预定了。原本最迟会在 2018 年元月发出, 但是幸运的是, 圣诞节你就可以看到了。
下面你会看到第九章, 使用 Grammars 进行解析。前面的章节详细探讨了创建正则表达式块儿、正则表达式怎么和 Perl 6 代码进行交互、匹配对象、正则力学、常用正则技术，还有重用和组合正则。你可以通过阅读正则表达式官方文档来获取更多关于正则的背景。
后面的章节涵盖了 action 类和对象, 怎么报告高质量的解析错误, Unicode 支持, 最后还有三个案例研究。
现在, 尽情享受吧！
Grammar 是众人皆知的用于解析的瑞士军刀。
在本章中，我们将更详细地探讨它们。 最重要的是，我们将讨论如何利用他们的威力。
理解 Grammars Grammars 实现了自顶向下的解析方法。 入口点，通常是 TOP regex 正则表达式，它知道粗粒度的结构，并调用下降到繁复细节的更深一步的正则表达式。 也会涉及到递归。 例如，如果解析算术表达式，则操作符可以是一对括号内的任意表达式。
这是一个自顶向下的结构，或者更确切地说是一个递归下降分析方法。 如果不涉及回溯，我们称之为*预测分析法*，因为在字符串中的每个位置，我们确切地知道我们在寻找什么 - 我们可以预测下一个 token 将会是什么（即使我们只能预测它可能是一组可选分支的其中之一）。
结果匹配树在结构上完全对应于 grammar 中正则表达式的调用结构。 让我们考虑解析一个只包含运算符 *，+和用于分组的括号的算术表达式：</description>
    </item>
    
    <item>
      <title>第三天 – LetterOps with Perl6</title>
      <link>https://ohmysummer.github.io/post/2017-12-03-%E7%AC%AC%E4%B8%89%E5%A4%A9letterops-with-perl6/</link>
      <pubDate>Sun, 03 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-03-%E7%AC%AC%E4%B8%89%E5%A4%A9letterops-with-perl6/</guid>
      <description>Day 3 – LetterOps with Perl6 规模 “规模！规模就是一切！“。
当圣诞老人的声音传到他们身上时，精灵散落在四面八方。
“这个 operation 是为三十四个孩子准备的？现在我们有无数的！大人也送信！“
小精灵 Buzzius 站了出来，喷出“但现在我们有电脑！”，又回到他精灵的追求。
“他们有什么好处？请告诉我，如果我仍然需要阅读每一封信，我该怎么办？“。
小精灵 Diodius 短暂地从藏身处抬起头，说：“告诉孩子们发一封文字信”。
圣诞老人停止了叫喊，并抓住了他有胡子的下巴。 “我可以做到这一点”。早期的儿童采用者就像这样发了一封信。
Dear Santa: I have been a good boy so I want you to bring me a collection of scythes and an ocean liner with a captain and a purser and a time travel machine and instructions to operate it and I know I haven&#39;t been so good at times but that is why I&#39;m asking the time machine so that I can make it good and well and also find out what happened on July 13th which I completely forgot.</description>
    </item>
    
    <item>
      <title>第二天-Perl 6: 符号, 变量和容器</title>
      <link>https://ohmysummer.github.io/post/2017-12-02-%E7%AC%AC%E4%BA%8C%E5%A4%A9-perl6%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sat, 02 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-02-%E7%AC%AC%E4%BA%8C%E5%A4%A9-perl6%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%B9%E5%99%A8/</guid>
      <description>第二天-Perl 6: 符号, 变量和容器 对容器的基本理解对于在 Perl 6 中进行愉快的编程是至关重要的。它们无处不在，不仅影响你获得的变量类型，还决定了 List 和 Map 在迭代时的行为方式。
今天，我们将学习什么是容器，以及如何使用它们，但是首先，我希望你暂时忘记你对 Perl 6 的符号和变量的所有知识或怀疑，特别是如果你来自 Perl 5 的背景。 忘记一切。
把钱拿出来 在 Perl 6 中，变量以 $ 符号为前缀，用绑定运算符（:=）赋值。 像这样：
my $foo := 42; say &amp;quot;The value is $foo&amp;quot;; # OUTPUT: «The value is 42␤»  如果你已经按照我的建议来忘记你所知道的一切，那么学习 List 和 Hash 类型也是一样：
my $ordered-things := &amp;lt;foo bar ber&amp;gt;; my $named-things := %(:42foo, :bar&amp;lt;ber&amp;gt;); say &amp;quot;$named-things&amp;lt;foo&amp;gt; bottles of $ordered-things[2] on the wall&amp;quot;; # OUTPUT: «42 bottles of ber on the wall␤» .</description>
    </item>
    
    <item>
      <title>第一天 – Perl 6 鬼精灵: 圣诞节实用指南</title>
      <link>https://ohmysummer.github.io/post/2017-12-01-%E7%AC%AC%E4%B8%80%E5%A4%A9-perl6%E9%AC%BC%E7%B2%BE%E7%81%B5-%E5%9C%A3%E8%AF%9E%E8%8A%82%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 01 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-01-%E7%AC%AC%E4%B8%80%E5%A4%A9-perl6%E9%AC%BC%E7%B2%BE%E7%81%B5-%E5%9C%A3%E8%AF%9E%E8%8A%82%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>第一天 – Perl 6 鬼精灵: 圣诞节实用指南 看看他们！同事、朋友和亲近的家人都在开心地笑着。他们都在享受着使用 Perl 6 的 6.c “圣诞”版编程的乐趣。给力的并发原语, 核心文法, 还有非常棒的对象模型。它让我印象深刻！
但是等一下&amp;hellip; 就一秒。我有个想法。一个可怕的想法。我想到了一个鬼主意! 我们可以在他们的&amp;rdquo;圣诞&amp;rdquo;上捣乱。需要的只有一点花招。哈哈哈哈哈哈！！
欢迎来到 2017 年的 Perl 6 圣诞日历！每天，从今天直到圣诞节，我们都会有一篇很赞的关于 Perl6 的博客推送到你面前。
今天，我们会展示我们淘气的一面并且故意地做些淘气的事情。确实，这有点用，但是淘气点更快乐。我们开始吧！
But True does False 你听过 but 操作符吗？一个好玩的东西：
say True but False ?? &#39;Tis true&#39; !! &#39;Tis false&#39;; # OUTPUT: «Tis false␤» my $n = 42 but &#39;forty two&#39;; say $n; # OUTPUT: «forty two␤» say $n + 7; # OUTPUT: «49␤»  它是一个中缀操作符，它首先拷贝它左边的对象，然后把它右边提供的 role 混进这个拷贝中：</description>
    </item>
    
    <item>
      <title>根据select结果生成insert语句</title>
      <link>https://ohmysummer.github.io/post/2017-09-16-%E6%A0%B9%E6%8D%AEselect%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90insert%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sat, 16 Sep 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-09-16-%E6%A0%B9%E6%8D%AEselect%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90insert%E8%AF%AD%E5%8F%A5/</guid>
      <description>想根据 MySQL select 语句的结果生成 insert 语句。
use v6; for $=finish.lines -&amp;gt; $line { next if $++ &amp;lt; 3 || $line ~~ / &#39;-&#39; /; say &#39;insert into convert_path (id, path_name, events, app_key, create_at, update_at) values (&#39; ~ ($line.split: /&amp;lt;[\s+ |]&amp;gt;/, :skip-empty)&amp;gt;&amp;gt;.&amp;amp;quote.join(&amp;quot;,&amp;quot;) ~ &amp;quot;);&amp;quot;; } sub quote(Str $ele) { return &#39;&amp;quot;&#39; ~ $ele ~ &#39;&amp;quot;&#39;; } =finish +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+ | id | path_name | events | app_key | create_at | update_at | +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+ | 308 | 新增打听流程1 | 新增打听,提交打听 | 10c29cf8bd6e61f9ae4a0212eed803c8 | 1505098067 | 1505098067 | | 309 | 用户购买流程 | 浏览商品,加入购物车,结算购物车中的商品,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505283224 | 1505283224 | | 311 | 用户购买流程2 | 浏览商品,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505284039 | 1505284039 | | 312 | 朗读模板付费转化流程 | 访问朗读首页,访问朗读模板,输入或导入文本,开始朗读,进入下载支付页,微信支付 | 54117664fad164a634c57571ba7c5aa7 | 1505284047 | 1505284047 | | 313 | 用户购买流程3 | 浏览商品,填写配送地址,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505284110 | 1505284110 | | 315 | 用户购买流程4 | 浏览商品,填写配送地址,完成配送地址,点击立即购买,付款,付款完成 | c10606f35c85bac58625c95006fba769 | 1505284303 | 1505284303 | | 316 | 新建朗读付费转化流程 | 访问朗读首页,访问新建朗读,输入或导入文本,开始朗读,进入下载支付页,微信支付 | 54117664fad164a634c57571ba7c5aa7 | 1505284351 | 1505284351 | | 321 | goodsDetail | onLoad,onShow | c10606f35c85bac58625c95006fba769 | 1505451421 | 1505451421 | +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+  最后生成的结果如下：</description>
    </item>
    
    <item>
      <title>开启 Disqus 评论</title>
      <link>https://ohmysummer.github.io/post/2017-09-15-%E5%BC%80%E5%90%AFdisqus%E8%AF%84%E8%AE%BA/</link>
      <pubDate>Fri, 15 Sep 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-09-15-%E5%BC%80%E5%90%AFdisqus%E8%AF%84%E8%AE%BA/</guid>
      <description>要开启 Disqus 评论, 需要先在 Disqus 官网注册账号, 获得 disqusShortname。
#use Grammar::Tracer; #use Grammar::Debugger; my $scene = q:to/END/; ★ 二维码 1011 扫描二维码 1047 扫描小程序码 1012 长按图片识别二维码 1013 手机相册选取二维码 1031 长按图片识别一维码 1032 手机相册选取一维码 1048 长按图片识别小程序码 1049 手机相册选取小程序码 1025 扫描一维码 1072 二维码收款页面 ★ 搜索 1005 顶部搜索框的搜索结果页 1006 发现栏小程序主入口搜索框的搜索结果页 1042 添加好友搜索框的搜索结果页 1053 搜一搜的结果页 1027 顶部搜索框搜索结果页“使用过的小程序”列表 ★ 公众号 1043 公众号模板消息 1020 公众号 profile 页相关小程序列表 1035 公众号自定义菜单 1058 公众号文章 1074 公众号会话下发的小程序消息卡片 ★ 分享 1036 App 分享消息卡片 1007 单人聊天会话中的小程序消息卡片 1008 群聊会话中的小程序消息卡片 1044 带 shareTicket 的小程序消息卡片 ★ 模板消息 1014 小程序模版消息 1034 微信支付完成页 ★ 测试 1059 体验版小程序绑定邀请页 1017 前往体验版的入口页 ★ 卡券 1028 我的卡包 1029 卡券详情页 1052 卡券的适用门店列表 ★ 小程序之间跳转 1037 小程序打开小程序 1038 从另一个小程序返回 ★ 快捷入口 1001 发现栏小程序主入口 1022 聊天顶部置顶小程序入口 1023 安卓系统桌面图标 1024 小程序 profile 页 ★ 广告投放 1068 附近小程序列表广告 1067 公众号文章广告 ★ 其他 1039 摇电视 1056 音乐播放器菜单 1019 微信钱包 1026 附近小程序列表 1064 微信连Wifi状态栏 1073 客服消息列表下发的小程序消息卡片 END grammar Scene { token TOP { ^ &amp;lt;entry&amp;gt;+ $ } # 一个或多个块 token entry { &amp;lt;head&amp;gt; \s* # 每个块都有一个标题 &amp;lt;line&amp;gt;+ \s* # 每个标题下面有很多非标题行 } token head { &#39;★&#39; \s+ &amp;lt;title&amp;gt; } token line { [ &amp;lt;!</description>
    </item>
    
    <item>
      <title>Perl 6 中的笑脸</title>
      <link>https://ohmysummer.github.io/post/2017-03-11-perl6%E4%B8%AD%E7%9A%84%E7%AC%91%E8%84%B8/</link>
      <pubDate>Sat, 11 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-11-perl6%E4%B8%AD%E7%9A%84%E7%AC%91%E8%84%B8/</guid>
      <description>在 Perl 6 中在调用者的类型身上使用 :D 或 :U 类型笑脸来制造 type/instance 方法:
class Foo { multi method foo (Foo:D:) { say &amp;quot;instance&amp;quot; } multi method foo (Foo:U:) { say &amp;quot;type object&amp;quot; } } Foo .foo; # 输出 type object Foo.new.foo; # 输出 instance # Can use compile time vars to aovid re-typing the actual name everywhere: class Bar { multi method foo (::?CLASS:D:) { say &amp;quot;instance&amp;quot; } multi method foo (::?CLASS:U:) { say &amp;quot;type object&amp;quot; } } Bar .</description>
    </item>
    
    <item>
      <title>关于 Perl 6 你要知道的 10 件事</title>
      <link>https://ohmysummer.github.io/post/2016-10-22-%E5%85%B3%E4%BA%8Eperl6%E4%BD%A0%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8410%E4%BB%B6%E4%BA%8B/</link>
      <pubDate>Sat, 22 Oct 2016 00:52:52 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-22-%E5%85%B3%E4%BA%8Eperl6%E4%BD%A0%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8410%E4%BB%B6%E4%BA%8B/</guid>
      <description>Ten Things You Need To Know about Perl 6 Jeffrey Goff, Evozon Systems LLC OSCON London 2016 https://github.com/drforr http://theperlfisher.blogspot.ro  资源  perl6.org (obviously) docs.perl6.org - Online documentation modules.perl6.org - CPAN Lite
 rakudo.org - Where to get the latest
 https://github.com/tadzik/rakudobrew - Perlbrew for Perl 6
 https://github.com/tadzik/panda/ - Module installer
 irc://irc.freenode.org/perl6 - #perl6 on IRC.freenode.org
 http://rosettacode.org/wiki/Category:Perl_6 - Sample source
  要闻  干净, 一次性的可解析的文法 对用户友好的错误信息 友好的 Unicode 对初学者有帮助的符号 Math that works 函数签名 用正则表达式引导 OO with a type lattice built on a Metaprogramming model 自定义运算符 内置并发  一次性文法 my @doctor = { :first(&#39;Christopher&#39;), :last(&#39;Eccleston&#39;), years =&amp;gt; 1 }, { :first(&#39;David&#39;), :last(&#39;Tennant&#39;), years =&amp;gt; 4 }, { :first(&#39;Matt&#39;), :last(&#39;Smith&#39;), years =&amp;gt; 4 }, { :first(&#39;Peter&#39;), :last(&#39;Capaldi&#39;), years =&amp;gt; 3 }; say &#39;First New Who Doctor: &#39;, @doctor[0]{&#39;first&#39;}, &#39; &#39;, @doctor[0]&amp;lt;last&amp;gt;; say &amp;quot;Average run: &amp;quot; ~ @doctor.</description>
    </item>
    
    <item>
      <title>Perl 6 中的 Subscripts</title>
      <link>https://ohmysummer.github.io/post/2016-06-01-perl6%E4%B8%AD%E7%9A%84subscripts/</link>
      <pubDate>Wed, 01 Jun 2016 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-01-perl6%E4%B8%AD%E7%9A%84subscripts/</guid>
      <description>Subscripts 通过索引或键访问数据结构中的元素。
通常，人们需要引用集合或数据结构中的一个特定的元素（或特定的元素切片）。从数学标记法中偷学到的，向量 v 的组成部分用 v₁, v₂, v₃ 来引用，在 Perl 6 中这个概念叫做 “下标” （或“索引”）。
Basics Perl 6 提供了两个通用的下标接口：
elements are identified by interface name supported by [ ] zero-based indices Positional Array, List, Buf, Match, ... { } string or object keys Associative Hash, Bag, Mix, Match, ...   Positional 下标 (通过 postcircumfix [ ] 通过元素在有序集合中的位置来寻址元素。)索引 0 引用第一个元素， 索引 1 引用第二个元素， 以此类推：  my @chores = &amp;quot;buy groceries&amp;quot;, &amp;quot;feed dog&amp;quot;, &amp;quot;wash car&amp;quot;; say @chores[0]; #-&amp;gt; buy groceries say @chores[1]; #-&amp;gt; feed dog say @chores[2]; #-&amp;gt; wash car   Associative 下标 (通过 postcircumfix { }), 不要求集合以任何特定的顺序保存元素 - 相反，它使用一个唯一的键来寻址每个值。键的种类取决于使用的集合： 举个例子， 一个标准的散列 使用字符串作为键， 而一个 Mix 能使用任意的对象作为键， 等等:  my %grade = Zoe =&amp;gt; &amp;quot;C&amp;quot;, Ben =&amp;gt; &amp;quot;B+&amp;quot;; say %grade{&amp;quot;Zoe&amp;quot;}; #-&amp;gt; C say %grade{&amp;quot;Ben&amp;quot;}; #-&amp;gt; B+ my $stats = ( Date.</description>
    </item>
    
    <item>
      <title>Perl 6 中的签名</title>
      <link>https://ohmysummer.github.io/post/2016-04-12-perl6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/</link>
      <pubDate>Tue, 12 Apr 2016 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-12-perl6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/</guid>
      <description>签名也是对象 class Signature {}  签名是代码对象参数列表的静态描述。即, 签名描述了你需要什么参数和多少参数传递给代码或函数以调用它们。
传递参数给签名把包含在 Capture 中的参数绑定到了签名上。
&amp;gt; sub a($a, $b) {}; &amp;gt; &amp;amp;a.signature.perl.say :($a, $b) &amp;gt; my $b = -&amp;gt; $a, $b {}; &amp;gt; $b.signature.perl.say :($a, $b)  签名是一个对象, 就像 Perl 6 中的任何其它东西一样。 任何 Callable 类型中都有签名, 并且它能使用 .signature方法获取到。
class Signature { ... }  签名字面量 签名出现在子例程和方法名后面的圆括号中, 对于 blocks 签名出现在 -&amp;gt;或 &amp;lt;-&amp;gt; 箭头后面, 或者作为变量声明符(例如 [my](https://docs.perl6.org/syntax/my) )的输入, 或者以冒号开头作为单独的项。
sub f($x) { } # ^^^^ sub f 的签名 method x() { } # ^^ 方法 x 的签名 my $s = sub (*@a) { } # ^^^^^ 匿名函数的签名 for &amp;lt;a b c&amp;gt; -&amp;gt; $x { } # ^^ Block 的签名 my ($a, @b) = 5, (6,7,8); # ^^^^^^^^ 变量声明符的签名 my $sig = :($a, $b); # ^^^^^^^^ 独立的签名对象  签名字面量可以用于定义回调或闭包的签名。</description>
    </item>
    
    <item>
      <title>Grammars</title>
      <link>https://ohmysummer.github.io/post/2016-02-05-perl-6-grammars/</link>
      <pubDate>Fri, 05 Feb 2016 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-05-perl-6-grammars/</guid>
      <description>Grammars Grammars - 一组具名 regexes 组成正式的 grammar
Grammars 是一个很强大的工具用于析构文本并通常返回数据结构。
例如, Perl 6 是使用 Perl 6 风格 grammar 解析并执行的。
对普通 Perl 6 使用者更实用的一个例子是 JSON::Tiny模块, 它能反序列化任何合法的 JSON 文件, 而反序列代码只有不到 100 行, 还能扩展。
Grammars 允许你把 regexes 组织到一块儿, 就像类(class) 中组织方法那样。
具名正则 (Named Regexes) 　grammars 的主要组成部分是 regexes。 而 Perl 6 的 regexes语法不在该文档的讨论范围, 具名正则(named regexes) 有它自己的特殊语法, 这跟子例程(subroutine) 的定义很像:
my regex number { \d+ [ \. \d+ ]? } # 普通 regex 中空格被忽略, [] 是非捕获组  上面的代码使用 my 关键字指定了本地作用域的 regex, 因为具名正则(named regexes) 通常用在 grammars 里面。</description>
    </item>
    
    <item>
      <title>Perl 6 Grammars, Part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-13-perl-6-grammers-part-1/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-13-perl-6-grammers-part-1/</guid>
      <description>Perl 6 Grammars, Part 1 Perl 6 语言内置了对 grammar 的支持。您可以将 grammars 视为众所周知的正则表达式和诸如 yacc 或 bison 等实用程序或更复杂的 grammar 工具（如ANTLR）的组合。所有这些 - 词法分析器，语法分析器和语义处理 - 通常是编译器的独立部分，在 Perl 6 中它们都是内置的，并且可以通过全新的 Perl 6 安装 进行开箱即用。
要感受 grammar 的力量，Perl 6 自己的 grammar 就是用 Perl 6 庞大的 grammar 类 Perl6::Grammar写成的就足以说明了。
在本文中，我将通过几个例子来说明 grammar 的基础知识。所有必需的语言结构将在我们进行的时候进行解释。
解析数字 在你开始思考用户可以使用不同格式的数字,包括负数，浮点数，科学记数法中的数字，特殊形式的数字（如C的长整数）之前，解析数字似乎是一项简单的任务。
让我们从最简单的形式开始：一个数字作为数字序列。例如，1,42,123 或 1000. Perl 6 中的 grammar 是一种特殊的类，它有自己的关键字。grammar 的第一个 rule 必须（默认情况下）称为 TOP，以下是解析第一组数字的完整程序：
grammar N { token TOP { &amp;lt;digit&amp;gt;+ } } for &amp;lt;1 42 123 1000&amp;gt; -&amp;gt; $n { say N.</description>
    </item>
    
  </channel>
</rss>