<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Raku</title>
  <meta property="og:title" content="Raku" />
  <meta name="twitter:title" content="Raku" />
  <meta name="author" content="焉知非鱼"/>
  <link href='https://ohmysummer.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:image" content="https://ohmysummer.github.io/img/rakudo.png" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://ohmysummer.github.io/categories/raku/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="Raku Programming" />

  <meta name="generator" content="Hugo 0.53" />
  <link rel="canonical" href="https://ohmysummer.github.io/categories/raku/" />
  <link rel="alternate" href="https://ohmysummer.github.io/categories/raku/index.xml" type="application/rss+xml" title="Raku Programming">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/main.css" /><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://ohmysummer.github.io/css/highlight.min.css" /><link rel="stylesheet" href="https://ohmysummer.github.io/css/codeblock.css" />



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'ohmycloudy', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://ohmysummer.github.io/">Raku Programming</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="博客" href="/">博客</a>
            </li>
          
        
          
            <li>
              <a title="归档" href="/categories">归档</a>
            </li>
          
        
          
            <li>
              <a title="关于" href="/page/about/">关于</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/tags">标签</a>
            </li>
          
        

        

        
          <li>
            <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
              <span class="hidden-sm hidden-md hidden-lg">Search</span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
            </a>
          </li>
        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
          <a title="Raku Programming" href="https://ohmysummer.github.io/">
            <img class="avatar-img" src="https://ohmysummer.github.io/img/rakudo.png" alt="Raku Programming" />
          </a>
        
      </div>
    </div>

  </div>
</nav>



  <div id="modalSearch" class="modal fade" role="dialog">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal">&times;</button>
          <h4 class="modal-title">Search Raku Programming</h4>
        </div>
        <div class="modal-body">
          <gcse:search></gcse:search>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>


    
  <header class="header-section ">
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="page-heading">
              <h1>#Raku</h1>
              <hr class="small">
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>

    
  <div class="container" role="main">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        
        <div class="posts-list">
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-07-31-parse-with-raku-regexes-and-grammars/">
                <h2 class="post-title">Parse with Raku Regexes and Grammars</h2>

                
                  <h3 class="post-subtitle">
                    楽土
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 31, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (1 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  <p>启动翻译。</p>

                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-07-16-encode-decode/">
                <h2 class="post-title">Encode-Decode</h2>

                
                  <h3 class="post-subtitle">
                    楽土
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 16, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 5 minutes (882 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  http://blogs.perl.org/users/damian_conway/2019/07/vigenere-vs-vigenere.html
第15 届 Perl 每周挑战赛的第二项任务是为 Vigenère Cipher 实现编码器和解码器。但这比看起来要复杂得多，因为以 Blaisede Vigenère 命名的密码实际上并不是由他发明的，而 Vigenère 实际发明的密码并不是以他的名字命名的。
那么我们应该实现 Vigenère Cipher 加密&hellip;还是 Vigenère 加密？为什么不两个都要呢！
Vigenère Cipher 是由吉奥万·巴蒂斯塔·贝拉索于 1553 年制定的，然后错误归因到约三百年后的 Vigenère 身上。它使用tabularēcta 把消息文本转换为密文，然后再转回去。
给定用户提供的密钥（例如 &ldquo;BELLASO&rdquo;），我们通过匹配密钥和消息的相应字母来加密消息（例如 &quot;VIGENEREDIDNOTINVENTTHIS&quot;），然后将它们用作两个索引以在 rēcta 表的适当列和行中查找对应的密码字符。如果密钥短于消息，我们只需根据需要多次循环密钥。
例如：
 Key: B E L L A S O B E L L A S O B E L L A S O B E L L A... Text: V I G E N E R E D I D N O T I N V E N T T H I S Table: ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓↓ ↓ ↓ Cipher: W M R P N W F F H T O N G H J R G P N L H I M D  换句话说，tabularēcta 的每一列是单独的Caesar Cipher （或ROT-N转录），其中每个连续的密钥字母选择在消息中的相应字母上执行哪个替换。
                  <a href="https://ohmysummer.github.io/post/2019-07-16-encode-decode/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-06-29-odd-even-sort-in-raku/">
                <h2 class="post-title">Raku 中的 奇偶排序</h2>

                
                  <h3 class="post-subtitle">
                    Odd even sort in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 29, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 0 minutes (0 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-06-27-pancake-sort-in-raku/">
                <h2 class="post-title">Raku 中的煎饼排序</h2>

                
                  <h3 class="post-subtitle">
                    Pancake sort in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 29, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 0 minutes (0 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-06-28-gnome-sort-in-raku/">
                <h2 class="post-title">Raku 中的 Gnome sort</h2>

                
                  <h3 class="post-subtitle">
                    Gnome sort in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 28, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 0 minutes (0 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-06-26-stooge-sort-in-raku/">
                <h2 class="post-title">Raku 中的 Stooge Sort</h2>

                
                  <h3 class="post-subtitle">
                    Stooge sort in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 26, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 0 minutes (0 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-06-25-merge-sort-in-raku/">
                <h2 class="post-title">Raku 中的合并排序</h2>

                
                  <h3 class="post-subtitle">
                    Merge sort in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 25, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 0 minutes (0 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-06-24-insertion-sort-in-raku/">
                <h2 class="post-title">Raku 中的插入排序</h2>

                
                  <h3 class="post-subtitle">
                    Insertion sort in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 24, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (171 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  今天，我们研究插入排序算法及其在 Raku 中的可能实现。算法的复杂性是 O(n2)，但它是练习 Raku 的一个很好的选择。
这个想法很简单。您可以在数组中找到最小值并将其放在第一个位置。然后从第二个位置开始扫描数据（因为第一个位置已经被最低元素占用）。然后你向右走，找到最小值并将它们放到当前位置直到你到达终点。
它类似于选择排序，但不是交换两个元素，而是插入一个（因此，移动其他元素）。让我们从简单的方法和两个嵌套循环开始：
sub insertion-sort(@data) { for ^@data -&gt; $i { for ^$i -&gt; $j { if @data[$i] &lt; @data[$j] { @data.splice($j, 0, @data[$i]); @data.splice($i + 1, 1); } } } } my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10; insertion-sort @data; say @data;  在Raku中，数组的拼接方法可以完成两个任务：用另一个元素列表替换数组的一部分，或者只是删除元素或一行中的一些元素。
在上面的代码中，使用了该方法的两个应用程序。首先，将新找到的元素插入当前位置。其次，它从之前的位置删除（数组刚刚增长，因此索引变为$ i + 1）。
由于splice方法也返回已删除的元素，我们可以将第二个调用放到正在读取元素的位置：@data [$ i]。因此，可以使用以下嵌套调用替换这两行
@data.splice($j, 0, @data.splice($i, 1))  请注意，索引现在只是$ i，因为数组尚未修改。
                  <a href="https://ohmysummer.github.io/post/2019-06-24-insertion-sort-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-06-23-quick-sort-in-raku/">
                <h2 class="post-title">Raku 中的快速排序</h2>

                
                  <h3 class="post-subtitle">
                    Quick sort in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 23, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (317 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  今天，我们来看看另一个，也许是最着名的数据排序方法，快速排序。
该算法要求您选择所谓的枢轴，其中一个元素来自数据，并将其余部分分成两部分：小于枢轴的元素，以及大于或等于枢轴的元素。然后再次递归地对每个部分进行排序。在每次迭代中，部件变得越来越小，直到子列表是一个或甚至零个元素的平凡数据集。
一个单独的理论是如何选择正确的枢轴。有几种方法，例如，从列表中间取值，或取第一项，或最后一项，或随机项。还有更复杂的方法，您可以调整它以在您的数据集类型上实现最佳性能。
为简单起见，让我们选择第一个元素作为轴点，这是代码
sub quick-sort(@data) { return @data if @data.elems &lt;= 1; my $pivot = @data[0]; my @left; my @right; for @data[1..*] -&gt; $x { if $x &lt; $pivot { push @left, $x; } else { push @right, $x; } } return flat(quick-sort(@left), $pivot, quick-sort(@right)); } my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10; @data = quick-sort @data; say @data;  与之前的冒泡排序示例不同，此程序不会就地排序，而是返回新列表。
现在是时候将代码转换为更具 Raku 风格代码的时候了。
                  <a href="https://ohmysummer.github.io/post/2019-06-23-quick-sort-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-06-22-bubble-sort-in-raku/">
                <h2 class="post-title">Raku 中的冒泡排序</h2>

                
                  <h3 class="post-subtitle">
                    Bubble sort in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 22, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (397 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  嘿大家好，让我们在 Raku 中实现一些算法。
第一个将是经典的冒泡排序。实质上，您从左到右扫描数据并交换两个相邻的项（如果它们尚未正确排序）。重复这个过程，直到整个数据列表被排序。
这是最初的直接实现：
sub bubble-sort(@data) { my Bool $done = False; while !$done { $done = True; for 1 .. @data.elems - 1 -&gt; $n { if @data[$n - 1] &gt; @data[$n] { (@data[$n - 1], @data[$n]) = (@data[$n], @data[$n - 1]); $done = False; } } } } my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10; bubble-sort @data; say @data;  此实现执行就地排序，但您不需要将函数参数声明为 is rw。实际上，编译器会告诉您这是多余的，并将停止进一步编译:
                  <a href="https://ohmysummer.github.io/post/2019-06-22-bubble-sort-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-06-21-selection-sort-in-raku/">
                <h2 class="post-title">Raku 中的选择排序</h2>

                
                  <h3 class="post-subtitle">
                    楽土
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 21, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (69 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  <pre><code class="language-raku">sub find-smallest(@arr) {
    my $smallest = @arr[0];
    my $smallest_index = 0;
    for @arr.kv -&gt; $k, $v {
        if $v &lt; $smallest {
            $smallest = $v;       # 存储最小的值
            $smallest_index = $k; # 存储最小元素的索引
        }
    }
    return $smallest_index
}

sub selection-sort(@arr) {
    my @new-arr = [];

    for @arr.clone.kv -&gt; $k, $v {                             # 对数组进行排序
        my $smallest_index = find-smallest(@arr);
        @new-arr.append(@arr.splice($smallest_index,1).head); # 找出数组中最小的元素,并将其加入到新数组中
    }
    return @new-arr
}

say selection-sort([5, 3, 6, 2, 10]);
</code></pre>

                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-06-01-binary-search-in-raku/">
                <h2 class="post-title">Raku 实现二分查找</h2>

                
                  <h3 class="post-subtitle">
                    楽土
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 1, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (86 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  <pre><code class="language-raku">sub binary_search(@list, $item) {
    my $low  = 0;                        # low 和 high 用于跟踪要在其中查找的列表部分
    my $high = @list.elems -1;           #

    while $low &lt;= $high {                # 只要范围没有缩小到只包含一个元素
        my $mid   = ($low + $high) / 2;  # 就检查中间的元素
        my $guess = @list[$mid];

        return $mid if $guess == $item;  # 找到了就返回
        if $guess &gt; $item {              # 猜的数字大了
            $high = $mid -1 
        } else {                         # 才的数字小了
            $low = $mid + 1
        }  
    }
}

my @list = [1, 3, 5, 7, 9];
say binary_search(@list, 3);
say binary_search(@list, -1);
</code></pre>

                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-03-26-perl6-colonoscopy/">
                <h2 class="post-title">Raku Colonoscopy</h2>

                
                  <h3 class="post-subtitle">
                    Raku 中的冒号
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on March 26, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 9 minutes (1893 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Raku Colonoscopy I promise, this will not hurt. Much&hellip;
In this article we&rsquo;ll look into colons in Raku, where to place them, and what they mean. 我保证，这不会受到伤害。许多&hellip;
在本文中，我们将研究Raku中的冒号，放置它们的位置以及它们的含义。
Sigils But first a short detour. A newcomer to the Raku universe cannot miss the significance of sigils when dealing with variables. They are:
 $ (Anything) @ (Array) % (Hash) &amp; (Callable)  The sigil is part of the variable name, and is not changed depending on the context (as in Perl 5):
                  <a href="https://ohmysummer.github.io/post/2019-03-26-perl6-colonoscopy/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-02-24-special-variables/">
                <h2 class="post-title">Perl 5 to Raku guide - special variables</h2>

                
                  <h3 class="post-subtitle">
                    A comparison of special variables in Perl 5 and Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 25, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 5 minutes (963 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  描述 一个（希望）全面的 Perl 5 特殊变量列表及其 Raku 等价物，并在必要时记录它们之间的变化。
注意 本文档试图引导读者从 Perl 5 中的特殊变量到 Raku 中的等效变量。有关 Raku 特殊变量的完整文档，请参阅每个变量的 Raku 文档。
特殊变量 通用变量  $ARG
 $_
  值得庆幸的是， $_ 是 Perl 5 中的常规默认变量。Raku 的主要区别在于现在你可以在它身上调用方法。 例如，Perl 5 的 say $_ 可以在 Raku 中以 $_.say 表示。 此外，因为它是默认变量，您甚至不需要使用变量名称。 前面的例子也可以 通过使用 .say 实现。
 @ARG
 @_
  由于 Raku 现在具有函数签名，您的参数可以去那里，而不是依赖于 @_。 事实上，如果你使用函数签名，使用 @_ 会吐出你告诉它不能覆盖一个现有签名。
但是，如果您不使用函数签名，则 @_ 将包含您传递给函数的参数, 就像它在Perl 5中那样。再次，与 $_ 一样 ，您可以在其上调用方法。 与 $_ 不同，你不能假设 @_ 为 这些方法的默认变量（即 @_.
                  <a href="https://ohmysummer.github.io/post/2019-02-24-special-variables/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2019-02-25-python-to-raku-nutshell/">
                <h2 class="post-title">Python to Raku - nutshell</h2>

                
                  <h3 class="post-subtitle">
                    Learning Raku from Python, in a nutshell
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 25, 2019
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 8 minutes (1590 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  此页面试图为来自 Python 背景的人们提供学习 Raku 的方法。我们在 Raku 中讨论了许多 Python 构造和惯用法的等价语法。
基本语法 Hello, world 让我们从打印 &ldquo;Hello, world!&rdquo; 开始吧。 Raku 中的 put 关键字相当于 Python 中的 print。与 Python 2 一样，括号是可选的。换行符添加到行尾。
 Python 2  print &quot;Hello, world!&quot;   Python 3  print(&quot;Hello, world!&quot;)   Raku  put &quot;Hello, world!&quot;  还有 say 关键字，其行为类似，但会调用其参数的 gist 方法。
 Raku  my $hello = &quot;Hello, world!&quot;; say $hello; # also prints &quot;Hello, world!&quot; # same as: put $hello.
                  <a href="https://ohmysummer.github.io/post/2019-02-25-python-to-raku-nutshell/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-11-23-send-data-to-socket/">
                <h2 class="post-title">Send-Data-to-Socket</h2>

                
                  <h3 class="post-subtitle">
                    发送数据到 Socket
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on November 23, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (92 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  发送数据到 Socket 的 3333 端口，并把所发送的数据保存到文件中。
my $vin = 'LSJA0000000000091'; my $last_meter = 0; react { whenever IO::Socket::Async.listen('0.0.0.0', 3333) -&gt; $conn { my $fh = open 'events.txt', :w; react { my Bool:D $ignore = True; whenever Supply.interval(5).rotor(1, 1 =&gt; 1) { $ignore = !$ignore; } whenever Supply.interval(1) { next if $ignore; $fh.print: sprintf(&quot;\{'vin':'%s','createTime':%s,'mileage':%s}\n&quot;, $vin, DateTime.now.posix, $last_meter); $conn.print: sprintf(&quot;\{'vin':'%s','createTime':%s,'mileage':%s}\n&quot;, $vin, DateTime.now.posix, $last_meter++); } whenever signal(SIGINT) { say &quot;Done.&quot;; $fh.close; done; } } } CATCH { default { say .
                  <a href="https://ohmysummer.github.io/post/2018-11-23-send-data-to-socket/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/socket/">socket</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/react/">react</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/whenever/">whenever</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-11-15-make-empty/">
                <h2 class="post-title">Make Empty</h2>

                
                  <h3 class="post-subtitle">
                    make
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on November 15, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (245 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  my $str = q :to/EOF/; Raku,Rust -- this is a comment Rakudo,Raku -- this is another comment Camelia,Camel EOF grammar MakeEmpty { token TOP { ^ &lt;sentence&gt;+ % &lt;comment&gt; $} token sentence { &lt;words&gt;+ % ',' \n } token comment { '-- ' &lt;words&gt;+ % ' ' \n } token words { \w+ } } class Action { method TOP($/) { make $/.values».ast } method sentence($/) { make ~$/.trim } method comment($/) { make Empty } method words($/) { make ~$/ } } my $parsed = MakeEmpty.
                  <a href="https://ohmysummer.github.io/post/2018-11-15-make-empty/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/ast/">ast</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-10-07-traps-to-avoid/">
                <h2 class="post-title">Traps to Avoid</h2>

                
                  <h3 class="post-subtitle">
                    Traps to avoid when getting started with Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on October 7, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 3 minutes (629 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  在学习一门编程语言时，可能有熟悉另一门编程语言的背景，总有一些事情会让您感到惊讶，并且可能会耗费宝贵的调试和发现时间。
本文件旨在展示常见的误解，以避免它们。
在编写 Raku 的过程中，我们付出了巨大的努力来消除语法中的瑕疵。然而，当你消灭一个瑕疵的时候，有时另一个会突然冒出来。所以我们花了很多时间去寻找最小数量的瑕疵或者试图把它们放在它们很少被看到的地方。正因为如此，Raku 的瑕疵出现在了不同的地方，而不是来自另一种语言时所期望的那样。
变量和常量 常量在编译时计算 常量是在编译时计算的，所以如果在模块中使用它们，请记住，由于模块本身的预编译，它们的值将被冻结:
# WRONG (most likely): unit module Something::Or::Other; constant $config-file = &quot;config.txt&quot;.IO.slurp;  $config-file 将在预编译时一次性被读入。config.txt 文件的更改不会在你再次启动脚本时重新加载;只有当模块被重新编译时才会重新加载。
避免使用容器，而倾向于将值绑定到提供类似于常量行为的变量上，但允许更新值:
# Good; file gets updated from 'config.txt' file on each script run: unit module Something::Or::Other; my $config-file := &quot;config.txt&quot;.IO.slurp;  赋值为 Nil 产生不同的值, 通常是 Any 实际上，赋给 Nil 会将变量还原为其默认值。所以:
my @a = 4, 8, 15, 16; @a[2] = Nil; say @a; # OUTPUT: «[4 8 (Any) 16]␤»  在本例中，Any 是 Array 元素的默认值。
                  <a href="https://ohmysummer.github.io/post/2018-10-07-traps-to-avoid/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/traps/">Traps</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/p6doc/">p6doc</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-10-05-command-line-arguments-in-raku/">
                <h2 class="post-title">Raku 中的命令行参数</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on October 5, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 4 minutes (823 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Sub MAIN 在 Raku 中，命令行参数的解析是通过 MAIN 子例程完成的，MAIN 子例程是一种特殊的子例程，它根据 MAIN 子例程的签名解析命令行参数。与其他子例程一样，MAIN 子例程可以具有命名参数和位置参数、可选(和必需)参数、多重分派等等。
有了 MAIN 子例程的定义，USAGE 子例程将由编译器自动生成。可以修改此子例程以返回定制的使用消息。所有命令行参数也可以在特殊变量 @*ARGS 中使用，它可以在 MAIN 处理之前发生转变。
命名参数和位置参数 命名参数 让我们从一个简单的程序开始(保存为 prog.p6):
use v6; sub MAIN( Str :$name = 'John', Str :$last-name = 'Doe', ) { my $formatted-name = &quot;$name.tc() $last-name.tc()&quot;; say $formatted-name; }  在这个 MAIN 子句中，我们通过前置 : 到子例程签名中的每个变量上，创建了两个带有类型约束(Str)的命名参数，$name 和 $last-name。这些参数也有默认值，这是通过给参数赋值来实现的。在本例中，我们将 $name 设置为默认值 “John”，将 $last-name 设置为 “Doe”。如果执行 prog.p6 时命令行参数与 MAIN 签名匹配，则会打印出一个格式化的全名:
$ raku prog.p6 John Doe $ raku prog.
                  <a href="https://ohmysummer.github.io/post/2018-10-05-command-line-arguments-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/main/">MAIN</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-10-04-raku-code-in-rmarkdown/">
                <h2 class="post-title">Rmarkdown 中的 Raku 代码</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on October 4, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 3 minutes (499 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  安装 首先，首先安装 R 编程语言。在此之后，运行 R 并执行以下命令来安装 rmarkdown: install.packages(&quot;rmarkdown&quot;)。在安装 rmarkdown 时，我收到以下错误消息:
Error: .onLoad failed in loadNamespace() for 'tcltk', details: call: dyn.load(file, DLLpath = DLLpath, ...) error: unable to load shared object '/usr/lib/R/library/tcltk/libs/tcltk.so': libtk8.6.so: cannot open shared object file: No such file or directory  这可以通过安装包 tk 来解决，然后继续安装 rmarkdown。
Rmarkdown 的代码块 你可以用 rmarkdown 做的几乎所有都可以用“常规” markdown 来做的事情。然而，rmarkdown 的一个突出特性是它能够执行代码块并返回结果。为此，rmarkdown 使用了 knitr 包，这是一个使用 R 生成动态报告的引擎，除了 R 之外，它还支持其他语言引擎，您可以使用这些引擎来计算来自其他语言的代码。要列出可用引擎的名称，请在 R REPL 中执行 names(knitr::knit_engines$get()) 命令。就像“常规” markdown 一样，代码块可以用三个反勾号创建，然后是代码，最后是另外三个反勾号。如果希望计算代码块，请在花括号 {} 中指定语言，该语言位于前三个反勾号之后。例如，要执行 Perl 5 代码，可以在 {} 中指定 perl:
                  <a href="https://ohmysummer.github.io/post/2018-10-04-raku-code-in-rmarkdown/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/rmarkdown/">Rmarkdown</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/">
                <h2 class="post-title">Raku 面向对象简单入门</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on October 3, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 13 minutes (2590 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  序言 介绍 本教程最多只关注 Raku 中的面向对象编程(OOP)的基本知识。因此，对语句/表达式、变量、条件、循环、子例程(函数)等有一个基本的了解是很重要的，如果不在 Raku 中，至少在另一种编程语言中是这样的。此外，您至少应该对类、属性和方法有一般的了解。作为对 Raku 的介绍，我强烈推荐 Raku introduction。下一步是 Raku 文档。
确保你已经设置好了 Raku 编译器。如果你还没有设置好，请看这里。 从这里开始，你可能会厌倦代词“我们”，但它的使用是经过深思熟虑的。这是一个教程，希望你能跟上。所以，是的，我们在一起工作，你应该做好准备。顺便说一下，本教程是冗长的，这是故意的，但也是手把手教程的副产品。
问题陈述 我们将从现实生活中的问题开始，并尝试以面向对象的方式对其进行建模。问题陈述如下: 在她的数学101课程中，一位教授记录了三个作业(2个作业和1个考试)的分数，按照学生交作业的顺序:
Bill Jones:1:35 Sara Tims:2:45 Sara Tims:1:39 Bill Jones:1:42 Bill Jones:E1:72  在一个名为 MATH-101 的简单文本文件中。您可以假设有更多的学生，而这只是数据文件的一个代表性块。在这个文件中，每行记录学生的姓名、作业编号(作业编号为1,2，第一次考试为E1)和学生获得的原始分数。 教授使用另一个扩展名为 .std 的文件存储她课程的学生名单:
Bill Jones Ana Smith Sara Tims Frank Horza  除了 MATH-101，这位教授还教其他课程，并设计了一个扩展名为 .cfg 的配置文件来存储给定课程的配置格式。她这样做的目的是在她的其他课程中也使用它。配置文件格式指定了作业的类型、作业编号、作业的总分以及作业对最终课程成绩的贡献。她的数学101课程的 .cfg 文件如下:
Homework:1:50:25 Homework:2:50:25 Exam:1:75:50  您的任务是创建一个名为 report.p6 的程序。该程序生成一个报告，其中列出了班级中每个学生的姓名、每次作业的分数和最终成绩。该程序应该假设具有扩展名 .cgf 和 .std 的文件在执行该程序的目录中可用。另一方面，包含学生成绩的文件必须通过命令行传递给程序。为了简单起见，您可以假设每个文件都是根据课程命名的。对于她的数学101课程，教授会有以下的文件: MATH-101, MATH-101.std 和 MATH-101.cfg，还有脚本 report.p6。
分析 如果我们看问题陈述，我们可以把所有的东西分成三类:课程，学生和作业。就目前而言，每个类别都可以被视为具有状态和行为的类。我们将从最简单的类别，作业类别，到最一般的类别，课程类别。为了做到这一点，我们首先学习 Raku 中类的定义。
                  <a href="https://ohmysummer.github.io/post/2018-10-03-a-naive-introduction-to-object-orientation-in-perl-6/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/object/">Object</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-09-28-how-naming-of-variables-works-in-raku/">
                <h2 class="post-title">How Naming of Variables Works in Raku</h2>

                
                  <h3 class="post-subtitle">
                    变量的命名
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on September 28, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 4 minutes (770 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  在本系列的第 5 篇文章中，比较 Perl 5 和 Raku，了解在 Raku 中使用 sigils。
在本系列的前 4 篇文章中，我们比较了 Perl 5 和 Raku，讨论了迁移代码时可能遇到的一些问题，垃圾收集是如何工作的，为什么容器替换了引用，以及在 Raku 中使用(子例程)签名，以及这些与 Perl 5 的区别。
在第 5 篇文章中，我们将查看 Perl 5 和 Raku 之间 sigils(变量名开头的符号)的细微差别。
概览 让我们从 Perl 5 和 Raku 中的 sigils 的概述开始:
   Sigil Perl 5 Raku     @ Array Positional   % Hash Associative   &amp; Subroutine Callable   $ Scalar Item   * Typeglob n/a    @ (Array vs.
                  <a href="https://ohmysummer.github.io/post/2018-09-28-how-naming-of-variables-works-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-09-13-toptic-variable/">
                <h2 class="post-title">Toptic Variable</h2>

                
                  <h3 class="post-subtitle">
                    楽土
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on September 14, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 4 minutes (710 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  $_ 变量 $_ 是主题变量。它是没有显式签名的块的默认参数，因此 for @array {...} 和 given $var {...} 这样的构造通过调用块绑定到 $_。
for for &lt;a b c&gt; { say $_ } # sets $_ to 'a', 'b' and 'c' in turn say $_ for &lt;a b c&gt;; # same, even though it's not a block  given given 'a' { say $_ } # sets $_ to 'a' say $_ given 'a'; # same, even though it's not a block  设置默认的主题变量可以省去很多打字：
                  <a href="https://ohmysummer.github.io/post/2018-09-13-toptic-variable/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/toptic/">Toptic</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-08-29-raku%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/">
                <h2 class="post-title">Raku 中的容器</h2>

                
                  <h3 class="post-subtitle">
                    binding and containers
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on August 29, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 3 minutes (462 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  在本系列的第一篇文章中，将 Perl 5 与 Raku 进行了比较，我们研究了将代码迁移到 Raku 时可能遇到的一些问题。在第二篇文章中，我们研究了垃圾收集在 Raku 中的工作原理。第三篇文章，我们将重点介绍 Perl 5 的引用以及如何在 Raku 中处理它们，并介绍绑定和容器的概念。
引用 Raku 中没有引用，这对许多习惯于 Perl 5 语义的人来说都是令人惊讶的。但不要担心：因为没有引用，所以您不必担心是否应该解引用某些内容。
# Perl 5 my $foo = \@bar; # must add reference \ to make $foo a reference to @bar say @bar[1]; # no dereference needed say $foo-&gt;[1]; # must add dereference -&gt;  # Raku my $foo = @bar; # $foo now contains @bar say @bar[1]; # no dereference needed, note: sigil does not change say $foo[1]; # no dereference needed either  有人可能会说 Raku 中的所有东西都是引用。来自 Perl 5（其中一个对象是一个受祝福的引用），这将是关于 Raku 的逻辑结论，其中所有的东西都是对象（或者可以被认为是一个对象）。但这并不能完全符合 Raku 中的情况，并且会妨碍你理解 Raku 的工作原理。谨防虚假的朋友！
                  <a href="https://ohmysummer.github.io/post/2018-08-29-raku%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/container/">container</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-08-07-command-line-arguments-in-raku/">
                <h2 class="post-title">Command Line Arguments in Raku</h2>

                
                  <h3 class="post-subtitle">
                    Raku 中的命令行参数
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on August 7, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 4 minutes (754 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  MAIN 子例程 命名参数和位置参数  命名参数 位置参数 Multi dispatch 组合命名参数和位置参数  可选参数和必选参数 别名或备用命名参数 USAGE 子例程  Sub MAIN 在 Raku 中，命令行参数的解析是使用 MAIN 子例程完成的，MAIN 子例程是一个特殊的子例程，它根据签名解析命令行参数。与其他子程序一样，您可以使用命名参数和位置参数，可选（和必需）参数，multiple dispatch 等。 通过定义 MAIN 子例程，编译器会自动生成 USAGE 子例程。可以修改此子例程以返回自定义的 usage 信息。所有的命令行参数也可以在特殊变量 @*ARGS 中使用，它可以在 MAIN 处理之前进行更改。
命名参数和位置参数 命名参数
我们从一个简单的程序开始（保存为 prog.p6）:
use v6; sub MAIN( Str :$name = 'John', Str :$last-name = 'Doe', ) { my $formatted-name = &quot;$name.tc() $last-name.tc()&quot;; say $formatted-name; }  在这个 MAIN 子程序中，我们创建了两个命名参数，$name 和 $last-name，带有类型约束（Str），方法是在子例程的签名给每个变量添加 :。这些参数还具有默认值，这是通过为参数赋值来实现的。在这种情况下，我们将 $name 设置为默认值 &lsquo;John&rsquo;，将 $last-name 设置为 &lsquo;Doe&rsquo;。如果执行 prog.
                  <a href="https://ohmysummer.github.io/post/2018-08-07-command-line-arguments-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-08-04-intro-into-raku-regexes-and-grammars/">
                <h2 class="post-title">Intro Into Raku Regexes and Grammars</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on August 4, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 8 minutes (1624 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  tpm-regex.raku.party
STATUS QUO: PCRE “Perl 兼容的正则表达式”非常神秘，但许多语言只是盲目地遵循现状。
它们是 &lt;?!, &lt;=?!, or &lt;!#?@$%^( 吗？
/(?&lt;!foo)bar(?=baz)/  更好的正则表达式语法 Raku 并不害怕拒绝现状。
/&lt;!after foo&gt; bar &lt;before baz&gt;/  空格可以自由使用 文字字符串：字母数字字符可以按原样使用。 其他的字符，只需使用引号或反斜杠：
say so &quot;I ♥ Raku&quot; ~~ /I \♥ Raku/; # False say so &quot;I ♥ Raku&quot; ~~ / 'I ♥ Raku' /; # True say so &quot;I ♥ Raku&quot; ~~ / I #`(BTW, you can use inline,) &quot; ♥ &quot; &quot;Raku&quot; # as well as end-of-line comments /; # True  文本内容的变量 默认设置是将内容与纯文本匹配。将变量放入尖括号中以将其解释为正则表达式。
                  <a href="https://ohmysummer.github.io/post/2018-08-04-intro-into-raku-regexes-and-grammars/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/grammars/">Grammars</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-08-03-ping-pang-in-raku/">
                <h2 class="post-title">Ping Pang in Raku</h2>

                
                  <h3 class="post-subtitle">
                    Message passing between threads using channels
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on August 3, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 4 minutes (676 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Ping Pang in Raku 使用 channels 在线程之间传递消息是一种管理并发的简单方法。
一位朋友最近向我展示了一个很酷的程序，用 elixir 来演示消息传递 - 两个线程通过来回传递递增的数字来计数。快速搜索出现了一些例子。
我决定在 Raku 中实现这个。这就是我想出来的→
my ($ping, $pong) = Channel.new xx 2; sub ping { while $ping.receive -&gt; $n { say &quot;ping $n (thread #{$*THREAD.id})&quot;; $pong.send: $n + 1; } } sub pong { while $pong.receive -&gt; $n { last if $n &gt;= 5; say &quot;pong $n (thread #{$*THREAD.id})&quot;; $ping.send: $n + 1; } } $ping.send: 1; await Promise.anyof( (start ping), (start pong) );  $ping 和 $pong 都是 channel。子程序 ping 和 pong 从它们相应的 channel 接收并发送到另一个。
                  <a href="https://ohmysummer.github.io/post/2018-08-03-ping-pang-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/channel/">Channel</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-08-02-%E4%BD%BF%E7%94%A8cro%E5%88%9B%E5%BB%BA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/">
                <h2 class="post-title">使用 Cro 创建单页应用程序</h2>

                
                  <h3 class="post-subtitle">
                    Building a Single Page Application with Cro
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on August 2, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 15 minutes (3173 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  使用 Cro 创建单页应用 本教程将介绍如何使用 Cro 作为后端构建简单的单页应用程序。对于前端，我们将使用 webpack，ES6，React 和 Redux。你不需要事先了解这些信息，但如果您想在自己的应用程序中很好地使用它们，则需要进一步阅读。
代码可以在这里获取。在教程的各个阶段，提交了当前的状态。仓库历史记录与教程完全匹配，因此你可以使用它来获取各步骤变更的概述，或者如果你试图通过从头开始构建这些东西，可以知道你错过了什么。
你需要什么  要安装 Cro (请参阅本指南获取相关帮助)
 要安装 npm (即 Node.js 的包管理器, 我们要用它来获取需要的包来构建前端); 在基于 Debian 的 Linux 发行版上，只需 sudo apt install npm。
  我们要构建什么 所以我们正在举办美食节或者啤酒节。或者任何带有一堆我们可以尝试的东西的活动。但是&hellip;尝试什么？如果有这样一些应用程序就好了，人们可以留下他们关于什么火和什么不火的提示，我们可以实时看到他们。如果在去过的上一届啤酒节上有过这样的东西，我可能会幸免于那杯绿茶啤酒&hellip;&hellip;
所以, 我们会制作一个单页应用程序以支持:
 提交新的提示 (POST 到后端)
 现场发布最新提示 (通过网络套接字提供)
 能够同意或不同意某提示 (也是 POST) 能够看到按照最愉快到最不愉快 (通过 GE T获取) 排序的提示列表  Stubbing 后端 给应用程序想一个有创意的名称。我叫它 &ldquo;tipsy&rdquo;。然后使用 cro stub 来存根 HTTP 应用程序。为了简单起见，我们将跳过 HTTPS（也就是HTTP/2.0），但会包含 Web 套接字支持。
$ cro stub http tipsy tipsy Stubbing a HTTP Service 'tipsy' in 'tipsy'.
                  <a href="https://ohmysummer.github.io/post/2018-08-02-%E4%BD%BF%E7%94%A8cro%E5%88%9B%E5%BB%BA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/cro/">cro</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-20-%E4%BD%BF%E7%94%A8raku%E8%BF%9E%E6%8E%A5kafka/">
                <h2 class="post-title">使用 Raku 连接 Kafka</h2>

                
                  <h3 class="post-subtitle">
                    Using Raku to consumer Kafka
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 20, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (398 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  有这样一个场景, 数据发送方将压缩文件读成字节数组后发往 Kafka, 然后第三方的 Kafka Client 从中读取字节数组解压缩, 每条 message 对应一个压缩文件, 每个压缩文件中包含 _log.txt 和 _result.txt。
Raku 可以从 Kafka 中读取消息并完成解析。
首先安装相关模块: Pkafka 用于和 Kafka 交互； Archive::Libarchive 用于解压缩字节数组。 Cro 用于 HTTP 请求，DBiish 用于数据库读写。
zef install Pkafka zef install Archive::Libarchive zef install Cro zef install DBIish  代码片段如下:
use PKafka::Consumer; use PKafka::Message; use PKafka::Producer; use Archive::Libarchive; use Archive::Libarchive::Constants; use Cro::HTTP::Client; use JSON::Fast; use JSON::Path; use DBIish; sub MAIN () { my $brokers = &quot;127.0.0.1&quot;; my $test = PKafka::Consumer.
                  <a href="https://ohmysummer.github.io/post/2018-07-20-%E4%BD%BF%E7%94%A8raku%E8%BF%9E%E6%8E%A5kafka/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/kafka/">Kafka</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-14-io-guide/">
                <h2 class="post-title">Io Guide</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 14, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 3 minutes (501 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  基础知识 绝大多数常见的 IO 工作都是由 IO::Path 类型完成的。如果你想以某种形式或形状读取或写入文件，这就是你想要的类。它抽象出文件句柄（或“文件描述符”）的细节，因此你甚至不必考虑它们。
在幕后， IO::Path 与 IO::Handle 一起使用 ; 如果你需要比 IO::Path 提供的更多控制，你可以直接使用的类。当与其他进程，例如通过工作 Proc 或 Proc::Async 类型，你还可以处理一个子类的 IO::Handle 在 IO::Pipe。
最后，你有 IO::CatHandle ，以及 IO::Spec 及其子类，你很少直接使用它们。这些类为你提供了高级功能，例如将多个文件作为一个句柄进行操作，或者进行低级路径操作。
除了所有这些类之外，Raku还提供了几个子程序，可以让你间接使用这些类。如果你喜欢函数式编程风格或Raku 单行程序，这些就派上用场了。
虽然 IO::Socket 及其子类也与输入和输出有关，但本指南并未涵盖它们。
路径导航 什么是 IO::Path？ 要将路径表示为文件或目录，请使用 IO::Path 类型。获取该类型对象的最简单方法是通过在 Str 上调用 .IO 方法将字符串强制为 IO 类型：
say 'my-file.txt'.IO; # OUTPUT: «&quot;my-file.txt&quot;.IO␤»  看起来这里似乎缺少某些东西 - 没有涉及卷或绝对路径 - 但该信息实际上存在于该 IO 对象中。你可以通过使用 .perl 方法看到它：
say 'my-file.txt'.IO.perl; # OUTPUT: «IO::Path.new(&quot;my-file.txt&quot;, :SPEC(IO::Spec::Unix), :CWD(&quot;/home/camelia&quot;))␤»  这两个额外的属性 - SPEC 和 - CWD 指定路径应该使用的操作系统语义类型以及路径的“当前工作目录”，即如果它是相对路径，则它相对于该目录。
                  <a href="https://ohmysummer.github.io/post/2018-07-14-io-guide/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/io/">IO</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-14-cro-http-test/">
                <h2 class="post-title">Cro Http Test</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 14, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (351 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Cro::HTTP::Test 原则上可以通过使用 Cro::HTTP::Server托管应用程序, 使用 Cro::HTTP::Client向其发出请求, 并使用标准 Test 库检查结果来编写 Cro HTTP 服务的测试。该库使编写此类测试更容易, 并通过以下方式更快地执行它们：
 为发出测试请求和检查结果提供更方便的 API 跳过网络并将 Cro::TCP 对象从客户端管道传递到服务器管道, 反之亦然  基本示例 给定模块 MyService::Routes, 如下所示：
sub routes() is export { route { get -&gt; { content 'text/plain', 'Nothing to see here'; } post -&gt; 'add' { request-body 'application-json' =&gt; -&gt; (:$x!, :$y!) { content 'application/json', { :result($x + $y) }; } } } }  我们可以像这样编写测试：
use Cro::HTTP::Test; use MyService::Routes; test-service routes(), { test get('/'), status =&gt; 200, content-type =&gt; 'text/plain', body =&gt; /nothing/; test-given '/add', { test post(json =&gt; { :x(37), :y(5) }), status =&gt; 200, json =&gt; { :result(42) }; test post(json =&gt; { :x(37) }), status =&gt; 400; test get(json =&gt; { :x(37) }), status =&gt; 405; } } done-testing;  设置要测试的服务 test-service 函数有两个候选者。
                  <a href="https://ohmysummer.github.io/post/2018-07-14-cro-http-test/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/cro/">Cro</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-08-class-channel/">
                <h2 class="post-title">Class Channel</h2>

                
                  <h3 class="post-subtitle">
                    Thread-safe queue for sending values from producers to consumers
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 8, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (303 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  class Channel {}  Channel 是一个线程安全的队列，可帮助你将一个或多个生产者的一系列对象发送给一个或多个消费者。每个对象将仅到达由调度程序选择的一个这样的消费者。如果只有一个消费者和一个生产者，则保证保留对象的顺序。在 Channel 上发送是非阻塞的。
my $c = Channel.new; await (^10).map: { start { my $r = rand; sleep $r; $c.send($r); } } $c.close; say $c.list;  可以在并发页面中找到更多示例。
方法 send 方法 定义为：
method send(Channel:D: \item)  将项目排入频道。如果通道已经关闭，则抛出类型X :: Channel :: SendOnClosed的异常。此调用不会阻止等待使用者获取该对象。对可排队的项目数量没有设定限制，因此应注意防止失控排队。
my $c = Channel.new; $c.send(1); $c.send([2, 3, 4, 5]); $c.close; say $c.list; # OUTPUT: «(1 [2 3 4 5])␤»  receive 方法 定义为：
method receive(Channel:D:)  从频道接收和删除项目。如果没有项目存在，它会阻塞，等待来自另一个线程的发送。
                  <a href="https://ohmysummer.github.io/post/2018-07-08-class-channel/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/channel/">Channel</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-07-class-supply/">
                <h2 class="post-title">class Supply</h2>

                
                  <h3 class="post-subtitle">
                    Asynchronous data stream with multiple subscribers
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 8, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 7 minutes (1281 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  class Supply {}  supply 是一种线程安全的异步数据流，如 Channel，但它可以有多个订阅者（taps: 水龙头），所有订阅者都可以获得流经 supply 的相同值。
它是 观察者模式 的线程安全实现，是支持 Raku 中的反应式编程的核心。
有两种类型的 Supplies：实时(live)和按需(on demand)。当水龙头接入到实时(live)供应时，水龙头将仅在创建水龙头之后看到流经 supply 的值。这种供应(supplies)通常是无限的，例如鼠标移动。关闭这样的水龙头(tap)不会阻止鼠标事件的发生，它只是意味着值将看不见了。所有的开孔器(tappers )都看到了相同的值流(flow of values)。
在按需供应上轻敲(tap)将发起值的产生，再次轻敲(tap)供应可能会产生一组新的值。例如，每次轻敲时，Supply.interval 都会生成一个具有适当间隔的新计时器。如果水龙头(tap)关闭，计时器只会停止向该水龙头发射值。
从 Supplier 的工厂方法 Supply 获得 live Supply（实时供应）。通过在 Supplier 对象上调用 emit 来发出新值。
my $supplier = Supplier.new; my $supply = $supplier.Supply; $supplier.tap( -&gt; $v { say &quot;$v&quot; }); $supplier.emit(42); # Will cause the tap to output &quot;42&quot;  实时方法在实时供应上返回 True。工厂方法如 interval，from-list 会返回按需供应(on demand supplies)。
可以使用 Supplier::Preserving创建一个直到第一次轻敲的保存值的实时供应（Supply）。
                  <a href="https://ohmysummer.github.io/post/2018-07-07-class-supply/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/supply/">Supply</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-07-raku-pod/">
                <h2 class="post-title">Raku Pod</h2>

                
                  <h3 class="post-subtitle">
                    An easy-to-use markup language
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 7, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 6 minutes (1119 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Raku Pod 是一种易于使用的标记语言。 Pod 可用于编写语言文档，用于文档化程序和模块，以及其他类型的文档组合。
每个 Pod 文档必须以 =begin pod 开头，以 =end pod 结束。这两个分隔符之间的所有内容都将被处理并用于生成文档。
=begin pod A very simple Raku Pod document =end pod  块结构 Pod 文档可能包含多个 Pod 块。有四种方法可以定义块（分隔符，段落，缩写和声明符）; 前三个产生相同的结果，但第四个不同。你可以使用最方便你的特定文档任务的任何形式。
分割符块 分隔块由 =begin 和 =end 标记限定，两者都后跟有效的 Raku 标识符，后者是块的 typename。完全小写的类型名称（例如 =begin head1）或完全大写（例如：=begin SYNOPSIS）保留。
=begin head1 Top Level Heading =end head1  配置信息 在 typename 之后， =begin 标记行的其余部分被视为块的配置信息。此信息由不同类型的块以不同方式使用，但始终使用 Raku-ish 选项对指定。也就是说，任何：
   alue is&hellip; Specify with&hellip; Or with&hellip; Or with&hellip;     List :key[$e1, $e2, &hellip;] :key($e1, $e2, &hellip;)    Hash :key{$k1=&gt;$v1, $k2=&gt;$v2}     Boolean (true) :key :key(True) :key[True]   Boolean (false) :!
                  <a href="https://ohmysummer.github.io/post/2018-07-07-raku-pod/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/pod/">Pod</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-07-doing-math-with-perl6/">
                <h2 class="post-title">Doing Math With Raku</h2>

                
                  <h3 class="post-subtitle">
                    Different mathematical paradigms and how they are implemented in this language.
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 7, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 3 minutes (576 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Sets Raku 包括 Set 数据类型，以及对大多数 set 操作的支持。并集和交集不仅是原生操作，它们使用自然符号 ∩ 和 ∪。例如，此代码将检查有限数量集的集算术的基本定律：
my @arbitrary-numbers = ^100; my \U = @arbitrary-numbers.Set; my @sets; @sets.push: Set.new( @arbitrary-numbers.pick( @arbitrary-numbers.elems.rand)) for @arbitrary-numbers; my (@union, @intersection); for @sets -&gt; $set { @union.push: $set ∩ $set === $set; @intersection.push: $set ∪ $set === $set; } say &quot;Idempotent union is &quot;, so @union.all; # OUTPUT: «Idempotent union is True» say &quot;Idempotent intersection is &quot;, so @intersection.all; # OUTPUT: «Idempotent intersection is True» my (@universe, @empty-set, @id-universe, @id-empty); for @sets -&gt; \A { @universe.
                  <a href="https://ohmysummer.github.io/post/2018-07-07-doing-math-with-perl6/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/math/">Math</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-07-date-and-time-functions/">
                <h2 class="post-title">Date and Time Functions</h2>

                
                  <h3 class="post-subtitle">
                    Processing date and time in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 7, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (224 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Raku 包括几个处理时态信息的类：Date，DateTime，Instant 和 Duration。前三个是 dateish，所以它们混合了 Dateish 角色，它定义了处理日期的类应该采用的所有方法和属性。它还包括以 X::Temporal 为根的异常的类层次结构。
我们将尝试在下一个（稍微扩展）的示例中说明这些类，这个示例可用于处理目录中的所有文件（默认情况下）。在目录中使用特定扩展名（默认为 .p6），根据他们的年龄对其进行排序，并计算每月创建的文件数量，以及在几个月的范围内表示的特定时期内修改的文件数量：
use v6; sub MAIN( $path = &quot;.&quot;, $extension = &quot;p6&quot; ) { my DateTime $right = DateTime.now; my %metadata; my %files-month; my %files-period; for dir($path).grep( / \.$extension $/ ) -&gt; $file { CATCH { when X::Temporal { say &quot;Date-related problem&quot;, .payload } when X::IO { say &quot;File-related problem&quot;, .payload } default { .payload.say } } my Instant $modified = $file.
                  <a href="https://ohmysummer.github.io/post/2018-07-07-date-and-time-functions/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/date/">Date</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/time/">Time</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-07-hashes-and-maps/">
                <h2 class="post-title">Hashes and Maps</h2>

                
                  <h3 class="post-subtitle">
                    Working with associative arrays/dictionaries/hashes
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 7, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 6 minutes (1195 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  关联角色和关联类 关联角色是 Hash 和 Map 以及 MixHash 等其他类的基础。它定义了将在关联类中使用的两种类型; 默认情况下，您可以使用任何内容（字面意思，因为任何 Any 子类的类都可以使用）作为键和 keyof 方法。
默认情况下，使用 % sigil 声明的任何对象都将获得 Associative 角色，默认情况下将表现为散列，但此角色仅提供上述两种方法，以及默认的 Hash 行为。
say (%).^name ; # 输出 Hash  相反，如果未混入 Associative 角色，则不能使用 % sigil，但由于此角色没有任何关联属性，因此你必须重新定义散列下标操作符的行为。为此，你必须重写几个函数：
class Logger does Associative[Cool,DateTime] { has %.store; method log( Cool $event ) { %.store{ DateTime.new( now ) } = $event; } multi method AT-KEY ( ::?CLASS:D: $key) { my @keys = %.store.keys.grep( /$key/ ); %.store{ @keys }; } multi method EXISTS-KEY (::?
                  <a href="https://ohmysummer.github.io/post/2018-07-07-hashes-and-maps/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/hash/">Hash</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/map/">Map</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-06-proc-async/">
                <h2 class="post-title">Proc Async</h2>

                
                  <h3 class="post-subtitle">
                    Running process (asynchronous interface)
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 6, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 4 minutes (832 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  class Proc::Async {}  注意: 目前只有 Rakudo 的 MoarVM 后端实现了 [Proc::Async](https://docs.raku.org/type/Proc::Async)。
Proc::Async 允许你异步地运行外部命令, 捕获标准输出和错误句柄，并可选择地写入到它的标准输入中。
my $file = 'foo'.IO; spurt $file, &quot;and\nCamelia\n♡\nme\n&quot;; my $proc = Proc::Async.new: :w, 'tac', '--', $file, '-'; # my $proc = Proc::Async.new: :w, 'sleep', 15; # uncomment to try timeouts react { whenever $proc.stdout.lines { # split input on \r\n, \n, and \r say 'lines: ', $_ } whenever $proc.stderr { say 'stderr: ', $_ } whenever $proc.
                  <a href="https://ohmysummer.github.io/post/2018-07-06-proc-async/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/async/">Async</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-07-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0raku/">
                <h2 class="post-title">我为什么学习Raku</h2>

                
                  <h3 class="post-subtitle">
                    Why I’m Learning Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 6, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (116 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  http://www.evanmiller.org/why-im-learning-perl-6.html
想听一个编程笑话吗？
Raku。
想知道我最喜欢的编程语言吗？
Raku。
嘘，克隆 master 分支并运行这个：
use v6.d.PREVIEW; my $channel = Channel.new; my @ten_tasks = (^10).map: { start { my $thread = $*THREAD.id; await $channel; say &quot;HOLY MOLEY SOMEONE STOLE MY THREAD&quot; if $thread != $*THREAD.id; } } $channel.send(&quot;Ring ring&quot;) for ^10; $channel.close; await @ten_tasks;  猜猜它输出了什么？
没有！开个玩笑，你会看到很多来自任务的烦恼消息，等待电话响起，然后穿着别人的操作系统线程醒来。
为什么这很重要？并发很难，如果你想要M：N线程多路复用（即WEB SCALE CODE，其中应用程序线程没有固定到pthread）你今天的选择正是Erlang，Go，.NET和Raku。
如果你对Erlang感到困惑，被Go推迟，对.NET无动于衷，请看看Raku.认真的。当然，它的发展时间比男孩时期要长 - 从2000年开始，比电影早两年，并在2015年发布，两年之后 - 但也许如果有人在某事上工作了15年，他们实际上可能会做出一些好事。我不是说这种情况是真的（可能不是少年时代），但至少它是可能的，对吗？
有趣的是，十五年前，每个人都在说Perl是如何通过大规模的语言重新设计而自拔的，因为世界显然将转向Python和Ruby。好吧每个人都切换到Python和Ruby，但现在每个人都有了再次切换的痒，因为事实证明Python和Ruby并不是为并发代码执行而设计的。如果你需要的是仿生robo-feet，也许拍摄自己的脚并不是一个糟糕的策略。
我不会在这里回顾 Raku 作为一种语言，因为它是一个包含大量黑暗角落和奇怪边缘情况的大规模规范，但我确实希望分享一些关于语言运行时发现的事情。 Raku虚拟机MoarVM是一项出色的技术。
事件循环感知调度程序？检查。延续？你得到了他们。将两者混合后会发生什么？好吧，你可以启动数百个工作程序并让它们等待消息（比如网络），而不会占用任何操作系统线程。当例程获得消息时，它会继续执行任何可用的OS线程。因此在开场示例中所有的“圣洁的MOLEY”。这就像Go或Erlang有更多的美元符号，或者没有回调cacciatore的Nginx或Node.js。
MoarVM是用漂亮干净的C编写的，如果你喜欢挖掘，它会充满惊喜。没有GIL，因此与其他语言不同，Raku字节码可以同时执行。 Unicode很棒，让“Straße”.uc正确并使用一个聪明的恒定时间算法来解决代码点组合的字形。对象模型和垃圾收集器与FFI很好地配合，因此与C的接口很简单。代码库编写得很好，组织良好，文档齐全，经过充分测试;小东西，比如具有正确尺寸的函数和具有良好名称的变量，使得阅读愉快。
判断语言实现的快速方法是检查其字符串连接函数。如果将concat实现为realloc和memcpy，那么楼上的灯可能没有设置为全亮度。看哪，在MoarVM中，字符串被分成多个字符串，并且可以重复链而不占用更多内存。所以这个表达式：
&quot;All work and no play makes Jack a dull boy&quot; x 1000  不会生成一千个字符串的副本，甚至可以指向同一个字符串的一千个指针。它存储为短字符串和重复计数，并且VM字符串函数知道如何在具有重复子字符串的字符串上有效地操作。很聪明，对吧？制作一亿份; RAM的使用率几乎没有变化
                  <a href="https://ohmysummer.github.io/post/2018-07-07-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-06-raku%E6%A6%82%E8%A7%88/">
                <h2 class="post-title">Raku 概览</h2>

                
                  <h3 class="post-subtitle">
                    A Review of Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 6, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 15 minutes (3068 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  http://www.evanmiller.org/a-review-of-perl-6.html
Raku 让我想起了我叔叔的博士学位论文。在前五年, 我们会问（圣诞节前）他什么时候完成; 时间久了我们就越来越不相信他的答案了, 并且没有任何证据表明论文确实存在过, 我们使完成日期成为一种流行的笑话, 就像波士顿 Big Dig 或纽约的第二大道地铁线。但是, 经过多次自我强加的最后期限后, 我们已经不再拿它开玩笑了。过了那么多年, 我们不再问了。
如果你错过了, 我认为每个人都错过了, Raku 在一年半前 - 在 2015 年的圣诞节 - 碰巧发布了 - 在名义上跨越了近 16 年之后被发布了。 （我想, 但我不确定, 我的叔叔的论文也在某个时候完成了。）我在 2017 年写这篇文章的新编程语言市场虽然具有竞争力, 但并不是难以理解的 - 但就像一位新博士生, 似乎没有人确定 Raku 的市场前景, 就像一篇刚刚开始的论文, 似乎没有人知道多年的劳动成果是否真的值得一试。
除了你想要的任何简单答案之外, Raku 的提供者几乎没有提供关于你应该用这个语言做什么的一些提示。 Raku 是多范式的, 也许是全范式的; 它声称支持面向对象的编程, 函数式编程, 面向标记的编程, 数组编程和（旧的）过程式编程。这是一种新语言, 而不仅仅是 Perl 5 的清理版本, 只不过英语是德语减去变音符号。了解以前的版本, 唉, 不会让你走得太远。出于同样的原因, 对前面化身的偏见并不一定适用于今天的水。
接下来是我试图向世界提供一个对编程世界中最白的大象Raku的一个诚实的, 如果不完整的评估。我受到以下思想的激励：每个系统管理员至少知道一点 Perl, 但我不认识任何人我知道任何 Raku, 也不认识任何知道 Raku 的人。我从来没有读过任何关于 Raku 的信息。我同样可以想象一个 Raku 是一堆垃圾的世界, 还有一个语言设计的 Hope Diamond。似乎没有人知道;没有人会知道。 Raku 是一个已写入的寄存器, 仍在等待读取。
                  <a href="https://ohmysummer.github.io/post/2018-07-06-raku%E6%A6%82%E8%A7%88/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-07-05-%E6%95%A3%E5%88%97%E7%9A%84%E6%95%A3%E5%88%97/">
                <h2 class="post-title">散列的散列</h2>

                
                  <h3 class="post-subtitle">
                    a hash of hashes of numbers in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 5, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (191 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  如何在 Raku 中声明散列的数字散列？ 默认情况下，散列将所有键转换为字符串。当你的键是可能接近的数字时，会导致问题：
&gt; my %h; %h{1/3} = 1; %h{0.333333} = 2; dd %h; Hash %h = {&quot;0.333333&quot; =&gt; 2}  当然，这可以修复如下：
&gt; my %h{Real}; %h{1/3} = 1; %h{0.333333} = 2; dd %h; Hash[Any,Real] %h = (my Any %{Real} = 0.333333 =&gt; 2, &lt;1/3&gt; =&gt; 1)  但现在我需要散列的数字散列时，例如 { 1/3 =&gt; { 2/3 =&gt; 1, 0.666667 =&gt; 2 } }。
&gt; my %h{Real}; %h{1/3}{2/3} = 1; %h{1/3}{0.666667} = 2; dd %h; Hash[Any,Real] %h = (my Any %{Real} = &lt;1/3&gt; =&gt; ${&quot;0.
                  <a href="https://ohmysummer.github.io/post/2018-07-05-%E6%95%A3%E5%88%97%E7%9A%84%E6%95%A3%E5%88%97/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/hash/">Hash</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-06-19-raku-colon-pair/">
                <h2 class="post-title">Raku Colon Pair</h2>

                
                  <h3 class="post-subtitle">
                    Everything to know about colonpairs in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 19, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 7 minutes (1448 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  原文
如果我选择 Raku 编程语言中最普遍的构造，那肯定是 colonpair。哈希构造函数，命名参数和参数，副词和正则表达式修饰符 - 都涉及到 colonpair。毫不奇怪，在这样广阔的空间里，构建 colonpair 时会有很多捷径。
今天，我们将了解所有这些！这样做会让我们看到最简单的以及一些更高级的语言结构，所以如果本文的某些部分让你头脑发热，不要担心 - 你不必一次就知道所有的东西！
第一部分: 创建 Colonwhaaaa? Colonpair 的名字（通常）来自于 Pair 对象构造函数，并且（通常）里面有一个冒号。以下是一些 colonpairs 的例子：
:foo, :$bar, :meow&lt;moo&gt;, heh =&gt; hah  最后一个没有冒号，但由于它和其他 colonpairs 基本上是一样的，我个人认为它也是一个 colonpair。
我们可以通过查看它们的 0 来看到这些 colonpairs 构成 Pair 对象：
say :foo.^name; # OUTPUT: «Pair␤»  但是，在参数列表中使用时，这些 colonpairs 被特殊处理了以表示命名参数。我们将在后面的文章中介绍这一部分。
简写 这里有一个完整的可用的 colonpair 列表，你可以在深入之前浏览一下。我知道，它看起来像一个巨大的列表，但这就是我们阅读这篇文章的原因 - 要了解构成这些排列的一般模式。
# 标准的, take-any-type, 非便捷形式 :nd(2).say; # OUTPUT: «nd =&gt; 2␤» :foo('foo', 'bar').say; # OUTPUT: «foo =&gt; (foo bar)␤» :foo( %(:42a, :foo&lt;a b c&gt;) ).
                  <a href="https://ohmysummer.github.io/post/2018-06-19-raku-colon-pair/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/colonpairs/">colonpairs</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-05-10-%E9%A5%AD%E5%90%A6%E5%AE%A2%E6%88%B7%E7%AB%AF/">
                <h2 class="post-title">饭否客户端</h2>

                
                  <h3 class="post-subtitle">
                    锅里有饭
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on May 10, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 3 minutes (562 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Inspired by fanfou-py
use Digest::HMAC; use Digest; use Digest::SHA; use MIME::Base64; use URI::Encode; use URI; use Cro::HTTP::Client; # URL 编码 sub oauth_escape($s){ return uri_encode_component($s.Str); } # 返回当前时间戳 sub oauth_timestamp() { return time; } # 单次值, 返回一个8位的随机字符串, 防止重复请求 sub oauth_nonce($size=8) { return ((1..9).pick for 1..$size).join(&quot;&quot;); } # 返回按一定顺序拼接好的字符串 sub oauth_query(%args) { return (sprintf &quot;%s=%s&quot;, $_, oauth_escape(~%args{$_}) for %args.keys.sort).join('&amp;'); } # URL 正规化 sub oauth_normalized_url($url){ my URI $u .= new($url); return sprintf('%s://%s%s', $u.
                  <a href="https://ohmysummer.github.io/post/2018-05-10-%E9%A5%AD%E5%90%A6%E5%AE%A2%E6%88%B7%E7%AB%AF/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-05-08-perl6cookbook/">
                <h2 class="post-title">Raku CookBook</h2>

                
                  <h3 class="post-subtitle">
                    inspired by Python cookbook
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on May 8, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 6 minutes (1211 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Raku CookBook(inspired by Python cookbook)
数据结构和算法 解压序列赋值给多个变量 问题 现在有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值 给 N 个变量？
解决方案 任何的序列 (或者是可迭代对象) 可以通过一个简单的赋值语句解压并赋值给多个 变量。唯一的前提就是变量的数量必须跟序列元素的数量是一样的。
代码示例：
&gt; my @p = (4,5); [4 5] &gt; my ($x, $y) = @p; (4 5) &gt; $x 4 &gt; $y 5 &gt; my @data = ('ACME', 50, 91.1, (2012, 12, 21) ); [ACME 50 91.1 (2012 12 21)] &gt; my ($name, $shares, $price, ($year, $mon, $day)) = ('ACME', 50, 91.
                  <a href="https://ohmysummer.github.io/post/2018-05-08-perl6cookbook/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/cookbook/">cookbook</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-05-06-dateish/">
                <h2 class="post-title">Dateish</h2>

                
                  <h3 class="post-subtitle">
                    Object that can be treated as a date
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on May 6, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (411 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  role Dateish { ... }  Date 和 DateTime 都支持访问 year, month 和 day-of-month 以及相关的函数，例如计算星期几。
方法 year 方法 定义为：
method year(Date:D: --&gt; Int:D)  返回日期的月份(1..12)。
say Date.new('2015-12-31').month; # OUTPUT: «12» say DateTime.new(date =&gt; Date.new('2015-12-24'), hour =&gt; 1).month; # OUTPUT: «12»  day 方法 定义为：
method day(Date:D: --&gt; Int:D)  返回日期中月份的天(1..31)。
say Date.new('2015-12-31').day; # OUTPUT: «31» say DateTime.new(date =&gt; Date.new('2015-12-24'), hour =&gt; 1).day; # OUTPUT: «24»  formatter 方法 定义为：
                  <a href="https://ohmysummer.github.io/post/2018-05-06-dateish/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/date/">Date</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-05-06-make/">
                <h2 class="post-title">Make</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on May 6, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 3 minutes (541 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  方法 make 的文档由以下类型组装而成：
Match 类 来自于 Match
make 方法 method make(Match:D: Mu $payload) sub make(Mu $payload)  将任意有效载荷(payload)存储到 Match 对象中，稍后可通过 .made / .ast 方法重新取回它。
这通常用于 grammar 的 action 类方法中，其中一个方法存储一段数据，然后由另一个方法取回。这取决于你存储什么数据。它可以是树节点，计算结果或值的列表。
sub 形式的 make 操作当前的 $/，这可能是一个简写：
method my-action ($/) { make &quot;foo: $/&quot;; }  make 会把数据结构附加到各自的 Match 对象上, 随后通过 .made 方法取回。使用 Match.perl 方法可以看到, Match 里面有一个 made 属性：
&gt; if 'abc' ~~ /\w+/ { $/.make: {'a' =&gt; 'bc', 'd' =&gt; 'wsl'}; say $/.
                  <a href="https://ohmysummer.github.io/post/2018-05-06-make/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/make/">make</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-05-06-slip/">
                <h2 class="post-title">Slip</h2>

                
                  <h3 class="post-subtitle">
                    A kind of List that automatically flattens into an outer container
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on May 6, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (397 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  有时您想要将列表的元素插入到另一个列表中。这可以通过称为 Slip 的特殊类型的列表完成。
say (1, (2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «False␤» say (1, Slip.new(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, slip(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤»  另一种方法是使用 | 前缀运算符。请注意，这比逗号的优先级更高，因此它只影响单个值，但与上述选项不同，它会打破标量。
say (1, |(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, |$(2, 3), 4) eqv (1, 2, 3, 4); # OUTPUT: «True␤» say (1, slip($(2, 3)), 4) eqv (1, 2, 3, 4); # OUTPUT: «False␤»  Slip class Slip is List {}  Slip 是一个 List，自动展平到一个外部列表（或其他类似列表的容器或 iterable）中。
                  <a href="https://ohmysummer.github.io/post/2018-05-06-slip/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/slip/">Slip</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-05-06-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">
                <h2 class="post-title">类和对象</h2>

                
                  <h3 class="post-subtitle">
                    A tutorial for creating and using classes in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on May 6, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 6 minutes (1103 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Raku 有一个丰富的内置语法来定义和使用类。
默认构造函数允许为创建的对象设置属性：
class Point { has Int $.x; has Int $.y; } class Rectangle { has Point $.lower; has Point $.upper; method area() returns Int { ($!upper.x - $!lower.x) * ( $!upper.y - $!lower.y); } } # Create a new Rectangle from two Points my $r = Rectangle.new(lower =&gt; Point.new(x =&gt; 0, y =&gt; 0), upper =&gt; Point.new(x =&gt; 10, y =&gt; 10)); say $r.area(); # OUTPUT: «100␤»  您也可以提供自己的构建和构建实现。下面更详细的例子展示了 Raku 中依赖处理器的外观。它展示了自定义构造函数，私有属性和公共属性，方法以及签名的各个方面。它代码不多，但结果是有趣和有用的。
                  <a href="https://ohmysummer.github.io/post/2018-05-06-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/class/">Class</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/object/">Object</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-05-05-datetime/">
                <h2 class="post-title">DateTime</h2>

                
                  <h3 class="post-subtitle">
                    Calendar date with time
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on May 5, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 4 minutes (831 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  DateTime class DateTime does Dateish {}  对于在国内处理点数，DateTime 对象存储年，月，日，小时，分钟（全部为 Int），秒（可能为小数）和时区。
它提供了用日期和时间计算的方法。
DateTime 方法是不可变的;如果你试图修改它，请改为创建修改后的副本。
时区的处理时间为以 UTC 为单位的整数，而不是时区名称。
use v6.c; my $dt = DateTime.new( year =&gt; 2015, month =&gt; 11, day =&gt; 21, hour =&gt; 16, minute =&gt; 1, ); say $dt; # OUTPUT: «2015-11-21T16:01:00Z␤» say $dt.later(days =&gt; 20); # OUTPUT: «2015-12-11T16:01:00Z␤» say $dt.truncated-to('hour'); # OUTPUT: «2015-11-21T16:00:00Z␤» say $dt.in-timezone(-8 * 3600); # OUTPUT: «2015-11-21T08:01:00-0800␤» my $now = DateTime.now(formatter =&gt; { sprintf &quot;%02d:%02d&quot;, .
                  <a href="https://ohmysummer.github.io/post/2018-05-05-datetime/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/datetime/">DateTime</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-04-27-raku%E4%B8%AD%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3/">
                <h2 class="post-title">Awesome Async Interfaces with Raku</h2>

                
                  <h3 class="post-subtitle">
                    A tutorial for writing IRC bots with Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on April 26, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 6 minutes (1251 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  IRC::Client: Raku Multi-Server IRC (or Awesome Async Interfaces with Raku) 我在 2015 年圣诞节编写了我的第一个 Raku 程序 - 一个新年 IRC 派对机器人工具。这项工作包括发布 IRC::Client 模块. 我从这个语言中找到了童年的乐趣并且在假期喝了不少酒, 结果就是这个模块差强人意。
最近，我需要一个用于某些 Raku bug 队列工作的工具，因此我决定花费一个周末，从头开始重新设计并重写这个模块。在过去的几个月中，有好几个人请求我这么做，所以我想我还会写一篇关于如何使用该模块的教程 - 作为一名主拖延者的道歉。如果你对 IRC 不感兴趣，我希望本教程将作为 Raku 中异步，非阻塞接口的一个通用示例。
基础 要创建一个 IRC 机器人，实例化一个 IRC::Client 对象，给它一些基本信息，并调用 .run 方法。实现所需的所有功能，并将它们作为方法名称匹配要收听的事件的类，并通过 .plugins 属性传递。当发生 IRC 事件时，它会按照您指定的顺序传递给所有插件，如果某个插件要求它处理事件，则停止。
这里有一个简单的 IRC 机器人，它可以响应在频道中发送的消息，通知和发送给它的私人消息。响应是 bot 收到的大写原始消息：
use IRC::Client; .run with IRC::Client.new: :nick&lt;MahBot&gt; :host&lt;irc.freenode.net&gt; :channels&lt;#raku&gt; :debug :plugins(class { method irc-to-me ($_) { .text.uc } })  以下是运行时机器人的表现：
                  <a href="https://ohmysummer.github.io/post/2018-04-27-raku%E4%B8%AD%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/irc/">IRC</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-04-16-cro-http-client/">
                <h2 class="post-title">Cro::HTTP::Client</h2>

                
                  <h3 class="post-subtitle">
                    HTTP 客户端
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on April 16, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 4 minutes (836 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Cro::HTTP::Client Cro::HTTP::Client 类提供了一个灵活的 HTTP 和 HTTPS 客户端实现，可以从简单到更复杂的情况进行扩展。它可以通过两种方式消费：
通过对类型对象（ Cro::HTTP::Client.get($url) ）进行调用。这对于一次性请求很有用，但在向同一服务器发出多个请求时（例如使用 keep-alive）不提供连接重用。
通过创建一个 Cro::HTTP::Client 实例。默认情况下，这可以重用连接池。它还可以配置默认的 base URL，传递的默认授权数据，甚至是插入到请求/响应处理管道中的中间件。 Cro::HTTP::Client 实例可以并发地使用。
一般来说，如果您打算发起一次性请求，请使用类型对象。如果您要向同一台服务器或一组服务器发出很多请求，请创建一个实例。
默认情况下，HTTPS 请求将使用 ALPN 来协商是否执行 HTTP/2 或 HTTP/1.1，并且 HTTP 请求将始终使用 HTTP/1.1。
发起基本请求 可以在类型对象或 Cro::HTTP::Client 的实例上调用 get，post，put，delete，patch 和 head 方法。他们都会返回一个 Promise，如果请求成功则会被保留(kept), 如果失败则被毁掉(broken)。
my $resp = await Cro::HTTP::Client.get('https://www.raku.org/');  响应($resp) 是一个 Cro::HTTP::Response 对象。它将在请求头可用时立即生成;请求体可能尚未收到。默认情况下，错误（4xx和5xx状态码）将导致遵守 X::Cro::HTTP::Error 角色的异常，该角色具有包含 Cro::HTTP::Response 对象的 response 属性。
my $resp = await Cro::HTTP::Client.delete($product-url); CATCH { when X::Cro::HTTP::Error { if .response.status == 404 { say &quot;Product not found!
                  <a href="https://ohmysummer.github.io/post/2018-04-16-cro-http-client/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/cro/">Cro</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-04-15-flip-flop/">
                <h2 class="post-title">使用 flip-flop 和 gather-take 提取文本块儿</h2>

                
                  <h3 class="post-subtitle">
                    flip-flop and gather-take
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on April 15, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (160 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  使用 flip-flop 和 gather-take 提取文本块儿 my $excerpt = q:to/END/; Here's some unimportant text. =begin code This code block is what we're after. We'll use 'ff' to get it. =end code More unimportant text. =begin code Today rains heavy. Long live AI . HaHa =end code More unimport text. =begin code Like to go home. =end code END my @lines = gather { my @current; for $excerpt.lines { if &quot;=begin code&quot; ^ff^ &quot;=end code&quot; { # collect the values between matches push @current, .
                  <a href="https://ohmysummer.github.io/post/2018-04-15-flip-flop/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/flip-flop/">flip-flop</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/gather-take/">gather-take</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-04-14-keys-values-of-hashes-in-raku/">
                <h2 class="post-title">Raku 中散列的键和值</h2>

                
                  <h3 class="post-subtitle">
                    Keys, values, etc. of hashes in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on April 14, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (166 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Raku 中散列的键和值 今天，我们将看看 Hash 类的几个返回散列所有键或值或同时返回键和值的方法:
&gt; my %h = H =&gt; 'Hydrogen', He =&gt; 'Helium', Li =&gt; 'Lithium'; {H =&gt; Hydrogen, He =&gt; Helium, Li =&gt; Lithium} &gt; %h.keys; (H Li He) &gt; %h.values; (Hydrogen Lithium Helium) &gt; %h.kv; (H Hydrogen Li Lithium He Helium)  虽然你可能想直接进入 src/core/Hash.pm6 文件来查看方法的定义，但你会一无所获。 Hash 类是 Map 的子类，所有这些方法都定义在 src/core/Map.pm6 文件中。获取键和值很简单:
multi method keys(Map:D:) { Seq.new(Rakudo::Iterator.Mappy-keys(self)) } multi method values(Map:D:) { Seq.new(Rakudo::Iterator.Mappy-values(self)) }  对于 kv 方法, 需要多做点工作:
                  <a href="https://ohmysummer.github.io/post/2018-04-14-keys-values-of-hashes-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/keys/">keys</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/values/">values</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-04-13-raku%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/">
                <h2 class="post-title">Raku 中的列表解析</h2>

                
                  <h3 class="post-subtitle">
                    list comprehension in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on April 13, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (355 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Raku 中的列表解析 看一看 Python 中关于列表推导的页面。
S = {x² : x in {0 ... 9}} V = (1, 2, 4, 8, ..., 2¹²) M = {x | x in S and x even}  Python 列表解析:
S = [x**2 for x in range(10)] V = [2**i for i in range(13)] M = [x for x in S if x % 2 == 0]  在原始定义中我没有看到 10 或 13 , Raku 与原始语言最接近的语法是:
                  <a href="https://ohmysummer.github.io/post/2018-04-13-raku%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/list-comprehension/">list comprehension</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-04-12-setting-timeouts-in-raku/">
                <h2 class="post-title">在 Raku 中设置超时</h2>

                
                  <h3 class="post-subtitle">
                    Setting timeouts in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on April 12, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (98 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  在 Raku 中设置超时 在 Perl 5 中，我曾经使用信号设置超时（至少，这是一种简单且可预测的方式）。在 Raku 中，您可以使用 promise。让我们看看如何做到这一点。
要模仿长时间运行的任务，请创建一个无限循环，然后打印其状态。开始吧:
for 1 .. * { .say if $_ %% 100_000; }  只要循环得到控制，它将永远不会退出。我们的任务是在几秒钟内停止程序，因此计时器应在循环之前设置:
Promise.in(2).then({ exit; }); for 1 .. * { .say if $_ %% 100_000; }  在这里，Promise.in 方法创建一个 promise，在给定秒数后自动 kept。在 promise 的基础上，使用 then，我们添加了另一个 promise，其代码将在超时后运行。这里唯一的语句就是退出，停止主程序。
运行该程序以查看它的工作原理：
$ time raku timeout.pl 100000 200000 300000 . . . 3700000 3800000 3900000 real 0m2.196s user 0m2.120s sys 0m0.068s  该程序在我的计算机上计数达四百万，并在两秒内退出。这正是我们需要的行为。
                  <a href="https://ohmysummer.github.io/post/2018-04-12-setting-timeouts-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/superscripts/">Superscripts</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-04-11-typed-hashes-in-raku/">
                <h2 class="post-title">Typed hashes in Raku</h2>

                
                  <h3 class="post-subtitle">
                    希望你有好运气
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on April 11, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (211 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Typed hashes in Raku 在 Raku 中, 你可以通过指定变量的类型来限制变量容器的内容, 例如：
my Int $i;  标量变量中只有一个值。你可以将该概念扩展到数组, 并让其元素仅保存整数, 如下例所示：
&gt; my Int @i; [] &gt; @i.push(42); [42] &gt; @i.push('Hello'); Type check failed in assignment to @i; expected Int but got Str (&quot;Hello&quot;) in block &lt;unit&gt; at &lt;unknown file&gt; line 1  哈希中保存的是 pairs, 所以你可以同时指定键和值的类型。语法和上面的例子并无不同。
首先, 让我们声明值的类型：
my Str %s;  现在, 可以将字符串作为哈希的值：
&gt; %s&lt;Hello&gt; = 'World' World &gt; %s&lt;42&gt; = 'Fourty-two' Fourty-two  但这个哈希不能保存整数:
                  <a href="https://ohmysummer.github.io/post/2018-04-11-typed-hashes-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/typed-hashes/">Typed hashes</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-04-10-what-does-gist-do-in-raku/">
                <h2 class="post-title">Raku 中的 gist 方法</h2>

                
                  <h3 class="post-subtitle">
                    What does gist do in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on April 10, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (105 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  当你打印对象的时候, 例如 say $x, Raku 调用 gist 方法. 这个方法是为所有内建类型定义的：对于其中一些类型，它调用 Str 方法，对于某些类型它调用 perl 方法，对于某些类型，它使字符串表示有所不同。
让我们看看如何使用该方法来创建您自己的变体：
class X { has $.value; method gist { '[' ~ $!value ~ ']' } } my $x = X.new(value =&gt; 42); say $x; # [42] $x.say; # [42]  当你调用 say 时，该程序在方括号中打印一个数字：[42]。
请注意，双引号字符串中的插值使用 Str，而不是 gist。你可以在这里看到它：
say $x.Str; # X&lt;140586830040512&gt; say &quot;$x&quot;; # X&lt;140586830040512&gt;  如果您需要自定义插值，请重新定义 Str 方法:
class X { has $.value; method gist { '[' ~ $!
                  <a href="https://ohmysummer.github.io/post/2018-04-10-what-does-gist-do-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/gist/">gist</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-04-09-raku%E4%B8%AD%E7%9A%84%E4%B8%8A%E6%A0%87/">
                <h2 class="post-title">Raku 中的 Superscripts</h2>

                
                  <h3 class="post-subtitle">
                    Superscripts in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on April 9, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (202 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Raku 中的 Superscripts 在 Raku 中，可以使用上标索引来计算数字的幂数，例如:
&gt; 2⁵ 32 &gt; 7³ 343  也可以在上标中使用多个数字：
&gt; 10¹² 1000000000000  你可以猜到，上面的代码等同于这样：
&gt; 2**5 32 &gt; 7**3 343 &gt; 10**12 1000000000000  但问题是：上标到底是如何工作的？让我们找出答案。
对于 Numeric 角色，定义了以下操作：
proto sub postfix:&lt;ⁿ&gt;(Mu $, Mu $) is pure {*} multi sub postfix:&lt;ⁿ&gt;(\a, \b) { a ** b }  啊哈，这就是我们需要的，上标符号在这里转换为简单的 ** 运算符。
您可以通过打印操作数来可视化传递给操作的确切内容：
multi sub postfix:&lt;ⁿ&gt;(\a, \b) { nqp::say('# a = ' ~ a); nqp::say('# b = ' ~ b); a ** b }  这个时候，你会看到上面的测试示例输出如下：
                  <a href="https://ohmysummer.github.io/post/2018-04-09-raku%E4%B8%AD%E7%9A%84%E4%B8%8A%E6%A0%87/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/superscripts/">Superscripts</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-21-more-on-the-proto-keyword-in-raku/">
                <h2 class="post-title"> More on the proto keyword in Raku</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 21, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (105 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  在深入研究 EVAL 子例程的细节之前，我们必须揭示一些关于 protos 原型和多重分派的更多信息。检查以下程序：
proto sub f($x) { say &quot;proto f($x)&quot;; } multi sub f($x) { say &quot;f($x)&quot; } multi sub f(Int $x) { say &quot;f(Int $x)&quot; } multi sub f(Str $x) { say &quot;f(Str $x)&quot; } f(2); f('2'); f(3); f('3');  这里有三个 multi 函数和一个用 proto 关键字声明的函数。早些时候，我们只看到了函数体为空的原型函数，如:
proto sub f($x) {*}  但这不是必需的。正如我们在示例中所看到的，该函数可以承载正常的函数体：
proto sub f($x) { say &quot;proto f($x)&quot;; }  运行这个程序：
proto f(2) proto f(2) proto f(3) proto f(3)  所有的调用都被 proto-候选者抓住了。现在，更新它并返回一些专用值的 {*} 块;
                  <a href="https://ohmysummer.github.io/post/2018-02-21-more-on-the-proto-keyword-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-18-examining-the-real-role-of-raku-part-2/">
                <h2 class="post-title">Examining the Real role of Raku, part 2</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 18, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (363 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  今天，我们继续对几天前开始的 Real 角色进行初步探索。
与其方法一起，角色包含许多子例程（放置在角色之外），它们使用 Real 类型的对象定义中缀运算符。名单不长，所以让我把它复制在这里：
multi sub infix:&lt;+&gt;(Real \a, Real \b) { a.Bridge + b.Bridge } multi sub infix:&lt;-&gt;(Real \a, Real \b) { a.Bridge - b.Bridge } multi sub infix:&lt;*&gt;(Real \a, Real \b) { a.Bridge * b.Bridge } multi sub infix:&lt;/&gt;(Real \a, Real \b) { a.Bridge / b.Bridge } multi sub infix:&lt;%&gt;(Real \a, Real \b) { a.Bridge % b.Bridge } multi sub infix:&lt;**&gt;(Real \a, Real \b) { a.Bridge ** b.
                  <a href="https://ohmysummer.github.io/post/2018-02-18-examining-the-real-role-of-raku-part-2/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-17-everyone-loves-porgs/">
                <h2 class="post-title">Everyone Loves Porgs</h2>

                
                  <h3 class="post-subtitle">
                    人见人爱普落格
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 17, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (138 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  这个想法有一阵子了。我在完成的各个阶段都有几个发文的想法，有时候很难优先考虑这个问题。所以我想我要开始发布我一直在玩的更短的想法和事情，以免这个博客变成那些永不更新的博客之一。所以，我们开始吧。
类在 Raku 中很容易定义。它们非常容易，我发现自己使用它们来封装小型的 Hash-like 那样的东西，其中我也可能会使用一两种方法。
class Contact { has $.name; has $.phone; has $.bday; method age { (Date.new($.bday), *.later(:1year) ...^ * &gt; Date.today).end } }  是的，这是一种低效率的计算年龄的方法&hellip;&hellip;就像生活中的很多事情一样，你越老，这种方法变得越慢。
无论如何，现在我已经定义了一个简单的小类来保存一些数据，但要实际实例化一个我不得不 bust out 一些命名参数。
my @contacts; @contacts.push: Contact.new(:name&lt;John&gt;, :phone&lt;555-1111&gt;, :bday&lt;1940-10-09&gt;);  谁有时间为所有这些角色？有时候我只是想用位置参数来构建它们，但这意味着要编写一个新的自定义 multi method new 来处理这些情况&hellip;&hellip;但我只是将一个快速肮脏的类放在一起，真的值得我花时间来构建自定义构造函数吗？
于是我开始四处游玩，并创建了一个让我用 Positional 参数的角色&hellip;&hellip;或一个 Array ..或 List &hellip;构建我的类，嘿，I threw in a Hash for free!！
@contacts.push: Contact.new('James', '555-1112', '1942-06-18'); @contacts.push: Contact.new(&lt; George 555-1113 1943-02-25 &gt;) my %hash = name =&gt; 'Richard', phone =&gt; '555-1114', bday =&gt; '1940-07-07'; @contacts.
                  <a href="https://ohmysummer.github.io/post/2018-02-17-everyone-loves-porgs/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-16-a-word-on-polymod-in-raku/">
                <h2 class="post-title">A word on polymod in Raku</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 16, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (322 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  在转到 Real 角色的第二部分之前，让我们停下来研究一下 Int 类的中的 polymod 方法。
该方法接收一个数字和任意数字（单位）的列表并返回相应的乘数。所以，你可以很容易地说，例如 550 秒，是 9分 10 秒：
&gt; 550.polymod(60) (10 9)  在方法调用中，60 的值是一分钟内的秒数。结果中，9 是分钟数，10 是余数，其为秒数。所以，550 秒= 10 秒 + 9 分钟。
如果你想了解更多细节，请添加更多单位。例如，什么是 32768 秒？
&gt; 32768.polymod(60, 60, 24) (8 6 9 0)  这是 8 秒，6 分钟，9 小时和 0 天。
类似地，132768 秒是 1 天，12 小时，52 分钟和 48 秒：
&gt; 132768.polymod(60, 60, 24) (48 52 12 1)  老实说，我很难理解它是如何工作的，以及如何读取结果。
文档中的另一个例子更加难以理解：
&gt; 120.polymod(1, 10, 100) (0 0 12 0)  12 是什么意思？这显然是12倍10.
                  <a href="https://ohmysummer.github.io/post/2018-02-16-a-word-on-polymod-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-16-%E5%A6%82%E4%BD%95%E5%9C%A8raku%E4%B8%AD%E5%AF%B9%E6%95%A3%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/">
                <h2 class="post-title">如何在 Raku 中对散列进行排序</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 16, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (168 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  要在 Raku 中对散列进行排序，首先你要知道什么是占位符变量。一旦这个概念变得清晰，对散列排序就变得非常简单。
例如，创建一个不同城市距离莫斯科远近的散列：
my %distance = Владимир =&gt; 185, Волгоград =&gt; 1000, Калининград =&gt; 1227, Мурманск =&gt; 1895, Новосибирск =&gt; 3550;  现在的任务是通过比较距离来对散列进行排序。
say %distance.sort({$^a.value &lt;=&gt; $^b.value});  一般来说，它已经准备好了。该程序打印你需要的东西：
(Владимир =&gt; 185 Волгоград =&gt; 1000 Калининград =&gt; 1227 Архангельск =&gt; 1261 Астрахань =&gt; 1411 Мурманск =&gt; 1895 Новосибирск =&gt; 3550)  让我们看看传递给排序方法的块内发生了什么。
首先，变量 $^a 和 $^b 是占位符，它是匿名块的参数并按字母顺序排序。也就是说，以相同的方式，他们可以被称为 $^x 和 $^y 或 $^var1 和 $^var2。
其次，这些占位符变量内部是 Pair 类型的对象，它包含键和值：
say %distance.sort({ say $^a.
                  <a href="https://ohmysummer.github.io/post/2018-02-16-%E5%A6%82%E4%BD%95%E5%9C%A8raku%E4%B8%AD%E5%AF%B9%E6%95%A3%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-15-examining-the-real-role-of-perl-6-part-1/">
                <h2 class="post-title">Examining the Real role of Raku, part 1</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 15, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (211 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  在过去的几天里，我们谈了很多关于 Real 这个角色。让我们更仔细地看看它。该代码位于 src/core/Real.pm 文件中。
它包含角色本身和一些实现不同中缀的子例程。Real 角色又实现了 Numeric 角色：
my role Real does Numeric { . . . }  有趣的是，类定义还需要关于 Complex 类的一些知识，这就是为什么在文件的第一行有一个前向类声明：
my class Complex { ... }  Real 角色将许多三角函数定义为方法，正如我们已经看到的，他们正在使用 Bridge 方法：
method sqrt() { self.Bridge.sqrt } method rand() { self.Bridge.rand } method sin() { self.Bridge.sin } method asin() { self.Bridge.asin } method cos() { self.Bridge.cos } method acos() { self.Bridge.acos } method tan() { self.Bridge.tan } method atan() { self.
                  <a href="https://ohmysummer.github.io/post/2018-02-15-examining-the-real-role-of-perl-6-part-1/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-15-fatrat-vs-rat-in-raku/">
                <h2 class="post-title">FatRat vs Rat in Raku</h2>

                
                  <h3 class="post-subtitle">
                    FatRat vs Rat in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 15, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 4 minutes (685 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  昨天，Solomon Foster 在 Facebook 的 Raku 小组上发布了一个例子:
my @x = FatRat.new(1, 1), -&gt; $x { $x - ($x ** 2 - $N) / (2 * $x) } ... *  这段代码实现了牛顿找到 $N 平方根近似值的方法。重要的是它使用 FatRat 值来获得更高的准确性。
让我们运行 9 的平方根：
my $N = 9; my @x = Rat.new(1, 1), -&gt; $x { $x - ($x ** 2 - $N) / (2 * $x) } ... *; .say for @x[0..7];  很快，它收敛到正确的值：
1 5 3.
                  <a href="https://ohmysummer.github.io/post/2018-02-15-fatrat-vs-rat-in-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-14-a-bit-more-on-rat-vs-fatrat-in-perl-6/">
                <h2 class="post-title">A bit more on Rat vs FatRat in Raku</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 14, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (131 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  昨天，我们正在深入研究 Rakudo Raku，以了解Rat值成为Num值的时间。事实证明，如果该值变得太小，这意味着它的分母变得越来越大，Rakudo开始使用Num值而不是Rat。
我们找到了它发生的地方。今天，让我们进行一个练习，看看Raku的行为是否可能不同，即扩展数据类型而不是将其切换为浮点数并且失去准确性。
改变很简单。所有你需要的是更新DIVIDE_N例程中的ifs：
--- a/src/core/Rat.pm +++ b/src/core/Rat.pm @@ -48,16 +48,14 @@ sub DIVIDE_NUMBERS(Int:D \nu, Int:D \de, \t1, \t2) { ($numerator := -$numerator), ($denominator := -$denominator))), nqp::if( - nqp::istype(t1, FatRat) || nqp::istype(t2, FatRat), + nqp::istype(t1, FatRat) || nqp::istype(t2, FatRat) || $denominator &gt;= UINT64_UPPER, nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(FatRat),FatRat,'$!numerator',$numerator), FatRat,'$!denominator',$denominator), - nqp::if( - $denominator &lt; UINT64_UPPER, nqp::p6bindattrinvres( nqp::p6bindattrinvres(nqp::create(Rat),Rat,'$!numerator',$numerator), - Rat,'$!denominator',$denominator), - nqp::p6box_n(nqp::div_In($numerator, $denominator))))) + Rat,'$!denominator',$denominator) + )) }  现在有两种结果：例程产生一个Rat值或一个FatRat。当子参数已经是FatRats或当前Rat太接近于零时，后者发生。
从昨天的帖子中用牛顿算法编译并测试我们修改过的raku可执行文件：
my $N = 25; my @x = Rat.
                  <a href="https://ohmysummer.github.io/post/2018-02-14-a-bit-more-on-rat-vs-fatrat-in-perl-6/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-12-going-over-the-bridge-part-2/">
                <h2 class="post-title">Going over the Bridge, part 2. Let’s get rid of it</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 12, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 3 minutes (597 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  今天，我们继续在 Rakudo Raku 中使用 Bridge 方法。昨天，我们在几个预定义的数据类型中看到了方法的定义。现在是时候看看如何使用该方法。
里面有什么? 该方法的主要用途在 Real 角色中，该角色包含以下一组方法：
method sqrt() { self.Bridge.sqrt } method rand() { self.Bridge.rand } method sin() { self.Bridge.sin } method asin() { self.Bridge.asin } method cos() { self.Bridge.cos } method acos() { self.Bridge.acos } method tan() { self.Bridge.tan } method atan() { self.Bridge.atan } . . . method sec() { self.Bridge.sec } method asec() { self.Bridge.asec } method cosec() { self.Bridge.cosec } method acosec() { self.
                  <a href="https://ohmysummer.github.io/post/2018-02-12-going-over-the-bridge-part-2/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-11-going-over-the-bridge-part-1/">
                <h2 class="post-title">Going over the Bridge, part 1</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 11, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (167 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  在处理 Raku 中的数字的类中，我们看到了 Bridge 方法，该方法以多态方式使用。让我们花一些时间，并试图了解 1）它是如何工作的，2）是否有必要。
类和角色 我们的第一步是查看方法定义在哪里。以下是我们需要的类和角色列表：
 Duration Instant Int Num Rational Real  为了预测下一步，让我们添加一些关于他们关系的更多细节：
 class Duration is Cool does Real class Instant is Cool does Real class Int is Cool does Real class Num is Cool does Real role Rational does Real role Real does Numeric  在斜体字体中，我添加了伪声明，这些伪声明没有在 src/core 的相应文件中明确拼写，而是通过 src/Raku/Metamodel/BOOTSTRAP.nqp 设置:
Int.HOW.add_parent(Int, Cool); . . . Num.HOW.add_parent(Num, Cool);  对于完整的图片，我们可以查看其他类的位置，例如 Rat 或 Complex，但让我们先关注上面的列表。
Bridge 方法 现在，让我们看看这些类和角色中 Bridge 方法的定义。
                  <a href="https://ohmysummer.github.io/post/2018-02-11-going-over-the-bridge-part-1/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-10-raku%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/">
                <h2 class="post-title">Raku 中的命名参数</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 10, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (65 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  

<p>Raku 中的函数（和类方法）能够接受命名参数。最简单的方法是用箭头分隔名称和值：</p>

<pre><code class="language-raku">sub f(:$a, :$b) {
    $a ** $b
}

say f(a =&gt; 2, b =&gt; 3); # 8
</code></pre>

<p>但另一种语法是可能的，在冒号的帮助下。有几个主要品种。</p>

<h2 id="key-value">:key(value)</h2>

<p>所有内容都以冒号开头，数值在括号内：</p>

<pre><code class="language-raku">say f(:a(2), :b(3));
</code></pre>

<p>例如，不用圆括号，尖角括号也是允许的：</p>

<pre><code class="language-raku">say f(:a&lt;2&gt;, :b&lt;3&gt;);
</code></pre>

<h2 id="nkey">：Nkey</h2>

<p>对于整数值，仍然有这样一个奇怪的语法：</p>

<pre><code class="language-raku">say f(:2a, :3b);
</code></pre>

<h2 id="key-和-key">:key 和 :!key</h2>

<p>如果命名参数用作标记，则不需要指定值。在这种情况下，您可以传递 True 和 False，如下所示：</p>

<pre><code class="language-raku">sub g(:$key) {
    $key
}

say g(:key);  # True
say g(:!key); # False
</code></pre>

<p>实际上，所有冒号对儿都会创建键值对，因此您可以在创建散列时执行相同的操作</p>

<pre><code class="language-raku">my %data = :alpha(10), :beta(20), :gamma(30);
say %data&lt;beta&gt;; # 20
</code></pre>

                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-08-raku-grammar%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7%E5%AF%B9%E5%84%BF/">
                <h2 class="post-title">Raku Grammar 中的冒号对儿</h2>

                
                  <h3 class="post-subtitle">
                    Colonpair in Raku’s Grammar, part 1
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 8, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (267 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  欢迎来到这个系列的第 50 篇文章!
今天, 我们将讨论一个小的语法结构, 然而就 Grammar 来说这是非常复杂的。首先让我们看看整个 colonpair token:
token colonpair { :my $*key; :my $*value; ':' :dba('colon pair') [ | '!' [ &lt;identifier&gt; || &lt;.panic: &quot;Malformed False pair; expected identifier&quot;&gt; ] [ &lt;[ \[ \( \&lt; \{ ]&gt; { $/.typed_panic('X::Syntax::NegatedPair', key =&gt; ~$&lt;identifier&gt;) } ]? { $*key := $&lt;identifier&gt;.Str; $*value := 0 } | $&lt;num&gt; = [\d+] &lt;identifier&gt; [ &lt;?before &lt;.[ \[ \( \&lt; \{ ]&gt;&gt; {} &lt;.
                  <a href="https://ohmysummer.github.io/post/2018-02-08-raku-grammar%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7%E5%AF%B9%E5%84%BF/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/">
                <h2 class="post-title">Raku 中的数据类型 Bag</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 7, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (123 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  数据类型 Bag 是一种 Perl 5 中没有的新的数据类型。
它可以被认为是一个容器，它一方面知道它里面有多少个单独的元素，另一方面可以说有多少种不同类型的商品。您可以用不同的方式描述此类型：Bag 是一个哈希，默认情况下，您添加的键的值为1。我们来看看例子。
把一个 1 放进 bag 里，看看 perl 的输出：
my $b1 = bag(1); say $b1.perl;  该程序打印以下输出：
(1=&gt;1).Bag  也就是说，我们有一个 1。
如果你把另一个数字也放进 bag 里面：
my $b2 = bag(1, 2); say $b2.perl;  现在有一个 1 和一个 2：
(1=&gt;1,2=&gt;1).Bag  好的，如果你添加另一个 1 呢?
my $b3 = bag(1, 2, 1); say $b3.perl;  现在有两个 1：
(1=&gt;2,2=&gt;1).Bag  让我们稍微离题一下：所有显示的例子都可以把括号去掉：
my $b1 = bag 1; my $b2 = bag 1, 2; my $b3 = bag 1, 2, 1;  比较典型的是，bag 不止能存储数字，还可以存储字符串，例如：
                  <a href="https://ohmysummer.github.io/post/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-01-29-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/">
                <h2 class="post-title">Raku Rakudo 和 NQP 内部研讨(二)</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on January 29, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 20 minutes (4090 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  title: Rakudo and NQP Internals subtitle: The guts tormented implementers made author: Jonathan Worthington
课程概览 - 第二天 欢迎回来. 今天我们会涉及到如下话题:
 6model Bounded Serialization and Module Loading The regex and grammar engine The JVM backend The MoarVM backend  6model 对象系统的组成成分
什么是 6model? 6model 提供了一组用于构建类型和对象系统的原语.
Rakudo 的类, roles, 枚举和 subset 类型都由这些原语组装在一起. NQP 也是, 尽管 NQP 的对象系统更简单, 它仅仅提供了类和 roles.
这些原语已经在 Parrot 和 JVM 虚拟机上实现了. MoarVM 也提供了那些原语, 但是它走的更远, 它让 6model 成为 MoarVM 的对象系统.
                  <a href="https://ohmysummer.github.io/post/2018-01-29-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/nqp/">NQP</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/rakudo/">Rakudo</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-01-28-raku-core-hacking-qastalicious/">
                <h2 class="post-title">Raku Core Hacking: QASTalicious</h2>

                
                  <h3 class="post-subtitle">
                    Overview of Q Abstract Syntax Trees &#43; bug fix tutorial
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on January 28, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 25 minutes (5133 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  在过去的一个月中，我在 Rakudo 的 QAST 地区花了一些时间写了一些优化，修复了包含警告的错误，并且用一个单一的提交压缩了一个10个thunk范围的bug的怪物蜂巢。 在今天的文章中，我们将详细介绍最后一个专长，以及了解QAST是什么以及如何使用它。
第一部分: QAST &ldquo;QAST&rdquo; 代表 &ldquo;Q&rdquo; Abstract Syntax Tree.(&ldquo;Q&rdquo; 抽象语法树.) 为什么会有个字母 &ldquo;Q&rdquo; 在那里呢, 因为 Q 是 P 的下一个字母, 而 &ldquo;P&rdquo; 过去是在 &ldquo;PAST&rdquo; 里面的, 代表 &ldquo;Parrot&rdquo;(鹦鹉), 是很早之前的一个实验性的 Raku 实现(或者说, 它的虚拟机). 我们来看看什么是 QAST!
Dumping QAST 每个 Rakudo Raku 程序都编译到 QAST 节点树上，如果在编译程序或模块时给 raku 指定 --target=ast 或 --target=optimize 命令行选项，则可以转储该树:
$ raku --target=ast -e 'say &quot;Hello, World!&quot;' [...] - QAST::Op(call &amp;say) &lt;sunk&gt; :statement_id&lt;?&gt; say \&quot;Hello, World!\&quot; - QAST::Want &lt;wanted&gt; Hello, World!
                  <a href="https://ohmysummer.github.io/post/2018-01-28-raku-core-hacking-qastalicious/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-01-28-perl-6-logo/">
                <h2 class="post-title">Raku logo</h2>

                
                  <h3 class="post-subtitle">
                    封面
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on January 28, 2018
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 0 minutes (0 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  <p><img src="https://wx4.sinaimg.cn/mw690/6c9ce165ly1fnwq6lso2ij20p20p2gnf.jpg" alt="img" />
<img src="https://wx3.sinaimg.cn/mw690/6c9ce165ly1fnwq6ldgwtj206t05qt8t.jpg" alt="img" />
<img src="https://wx1.sinaimg.cn/mw690/6c9ce165ly1fnwq6mh1tmj20fk0mgabl.jpg" alt="img" />
<img src="https://wx1.sinaimg.cn/mw690/6c9ce165ly1fnwq6s779xj217c1kwwup.jpg" alt="img" />
<img src="https://wx1.sinaimg.cn/mw690/6c9ce165ly1fnwq6ofudoj20h00m0gmu.jpg" alt="img" />
<img src="https://wx4.sinaimg.cn/mw690/6c9ce165ly1fnwq6ntpyaj20dq0i0dgo.jpg" alt="img" />
<img src="https://upload.wikimedia.org/wikipedia/commons/8/85/Camelia.svg" alt="img" />
<img src="https://wx4.sinaimg.cn/mw690/6c9ce165ly1fnwq4b2wunj20be0f9go5.jpg" alt="img" />
<img src="https://wx2.sinaimg.cn/mw690/6c9ce165ly1fnwq48csvrj20as0713yn.jpg" alt="img" />
<img src="https://wx2.sinaimg.cn/mw690/6c9ce165ly1fnwq4aqrsej20dw0dw74y.jpg" alt="img" />
<img src="https://wx2.sinaimg.cn/mw690/6c9ce165ly1fnwq4bsx5oj20x2103q4n.jpg" alt="img" />
<img src="https://wx4.sinaimg.cn/mw690/6c9ce165ly1fnwq4a6tfxj2074074jrd.jpg" alt="img" />
<img src="https://wx2.sinaimg.cn/mw690/6c9ce165ly1fnwq4ekirwj21hc0xcqcx.jpg" alt="img" />
<img src="https://upload-images.jianshu.io/upload_images/326727-e05292e819fa20a0.png" alt="img" /></p>

                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2017-12-23-playing-with-the-code-of-raku/">
                <h2 class="post-title">Playing with the code of Rakudo Raku</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on December 23, 2017
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (177 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  昨天，我们查看了返回字符串的 Bool 类的两个方法。函数产生的字符串表示在源代码中被硬编码。
让我们使用这个观察并尝试改变文本。
所以，这里是我们要修改的片段：
Bool.^add_multi_method('gist', my multi method gist(Bool:D:) { self ?? 'True' !! 'False' });  该 gist 方法用于对已定义的变量进行字符串化。
要做到这一点，你需要在计算机上安装 Rakudo 的源代码，以便编译它们。首先从 GitHub 克隆项目：
$ git clone https://github.com/rakudo/rakudo.git  编译 MoarVM：
$ cd rakudo $ perl Configure.pl --gen-moar --gen-nqp --backends=moar $ make  完成之后，你会在 rakudo 目录下获得 raku 可执行文件。
现在，打开 src/core/Bool.pm 文件，并将 gist 方法的字符串更改为使用 Unicode 大拇指代替纯文本：
Bool.^add_multi_method('gist', my multi method gist(Bool:D:) { self ?? '👍' !! '👎' });  保存文件后，您需要重新编译 Rakudo。 Bool.
                  <a href="https://ohmysummer.github.io/post/2017-12-23-playing-with-the-code-of-raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2017-12-22-exploring-the-bool-type-in-raku-part-1/">
                <h2 class="post-title">Exploring the Bool type in Raku, part 1</h2>

                
                  <h3 class="post-subtitle">
                    探索 Raku 中的布尔值, 第一部分
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on December 22, 2017
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (187 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  今天，我们将使用 GitHub 上提供的 Rakudo 源代码挖掘 Bool 类型的内部。
Raku 是用 Raku 和 NQP（Not Quite Raku）语言编写的，这使得阅读源代码变得相对容易。当然，有很多东西不容易理解，或者没有反映在 Raku 语言的公开文档中。到目前为止，您都无法在 Raku 书籍中找到深入的细节。无论如何，对 Raku 有一些中级的理解，这仍然是可能的。
好的，回到 src/core/Bool.pm 文件。它以一些 BEGIN phasers 开始，它为 Bool 类添加了一些方法和 multi 方法。下一次我们将讨论元模型和类构造的细节。今天，对我们来说更有趣的是 Bool 类的方法在做什么。
gist 和 perl gist 和 perl 方法返回对象的字符串表示形式：当变量被字符串化时隐式调用 gist，perl 应该直接调用。它适用于 Raku 中的任何对象，但这种行为当然应该定义在某处。他们在这里：
Bool.^add_method('gist', my proto method gist(|) {*}); Bool.^add_multi_method('gist', my multi method gist(Bool:D:) { self ?? 'True' !! 'False' }); Bool.^add_multi_method('gist', my multi method gist(Bool:U:) { '(Bool)' }); Bool.
                  <a href="https://ohmysummer.github.io/post/2017-12-22-exploring-the-bool-type-in-raku-part-1/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2017-12-21-raku-%E4%B8%AD%E7%9A%84-proto-%E5%85%B3%E9%94%AE%E5%AD%97/">
                <h2 class="post-title">Raku 中的 proto 关键字</h2>

                
                  <h3 class="post-subtitle">
                    The proto keyword in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on December 21, 2017
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (195 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  今天，我们正在关注 proto 关键字。它向编译器提供了关于你打算创建 multi-subs 的提示。
例子 1 考虑一个翻转字符串或使整数变成负数的函数示例。
multi sub f(Int $x) { return -$x; } multi sub f(Str $x) { return $x.flip; } say f(42); # -42 say f('Hello'); # olleH  如果我们创建另一个接收两个参数的函数的变体，会怎么样？
multi sub f($a, $b) { return $a + $b; } say f(1, 2); # 3  这个代码完美的工作，但它看起来像它的和谐是破碎的。即使函数的名称没有提及它的作用，我们也打算设置一个函数，以某种方式返回它的参数的“反射”版本。将两个数字相加的函数不适合这个想法。
所以，现在是在 proto 关键字的帮助下清楚地宣布意图的时候了。
proto sub f($x) {*}  现在，尝试调用双参数函数将无法编译：
===SORRY!=== Error while compiling proto.pl Calling f(Int, Int) will never work with proto signature ($x) at proto.
                  <a href="https://ohmysummer.github.io/post/2017-12-21-raku-%E4%B8%AD%E7%9A%84-proto-%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2017-09-16-%E6%A0%B9%E6%8D%AEselect%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90insert%E8%AF%AD%E5%8F%A5/">
                <h2 class="post-title">根据select结果生成insert语句</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on September 16, 2017
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (265 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  想根据 MySQL select 语句的结果生成 insert 语句。
use v6; for $=finish.lines -&gt; $line { next if $++ &lt; 3 || $line ~~ / '-' /; say 'insert into convert_path (id, path_name, events, app_key, create_at, update_at) values (' ~ ($line.split: /&lt;[\s+ |]&gt;/, :skip-empty)&gt;&gt;.&amp;quote.join(&quot;,&quot;) ~ &quot;);&quot;; } sub quote(Str $ele) { return '&quot;' ~ $ele ~ '&quot;'; } =finish +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+ | id | path_name | events | app_key | create_at | update_at | +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+ | 308 | 新增打听流程1 | 新增打听,提交打听 | 10c29cf8bd6e61f9ae4a0212eed803c8 | 1505098067 | 1505098067 | | 309 | 用户购买流程 | 浏览商品,加入购物车,结算购物车中的商品,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505283224 | 1505283224 | | 311 | 用户购买流程2 | 浏览商品,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505284039 | 1505284039 | | 312 | 朗读模板付费转化流程 | 访问朗读首页,访问朗读模板,输入或导入文本,开始朗读,进入下载支付页,微信支付 | 54117664fad164a634c57571ba7c5aa7 | 1505284047 | 1505284047 | | 313 | 用户购买流程3 | 浏览商品,填写配送地址,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505284110 | 1505284110 | | 315 | 用户购买流程4 | 浏览商品,填写配送地址,完成配送地址,点击立即购买,付款,付款完成 | c10606f35c85bac58625c95006fba769 | 1505284303 | 1505284303 | | 316 | 新建朗读付费转化流程 | 访问朗读首页,访问新建朗读,输入或导入文本,开始朗读,进入下载支付页,微信支付 | 54117664fad164a634c57571ba7c5aa7 | 1505284351 | 1505284351 | | 321 | goodsDetail | onLoad,onShow | c10606f35c85bac58625c95006fba769 | 1505451421 | 1505451421 | +-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+  最后生成的结果如下：
                  <a href="https://ohmysummer.github.io/post/2017-09-16-%E6%A0%B9%E6%8D%AEselect%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90insert%E8%AF%AD%E5%8F%A5/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2017-09-15-%E5%BC%80%E5%90%AFdisqus%E8%AF%84%E8%AE%BA/">
                <h2 class="post-title">开启 Disqus 评论</h2>

                
                  <h3 class="post-subtitle">
                    Disqus Is Cool
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on September 15, 2017
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (193 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  要开启 Disqus 评论, 需要先在 Disqus 官网注册账号, 获得 disqusShortname。
#use Grammar::Tracer; #use Grammar::Debugger; my $scene = q:to/END/; ★ 二维码 1011 扫描二维码 1047 扫描小程序码 1012 长按图片识别二维码 1013 手机相册选取二维码 1031 长按图片识别一维码 1032 手机相册选取一维码 1048 长按图片识别小程序码 1049 手机相册选取小程序码 1025 扫描一维码 1072 二维码收款页面 ★ 搜索 1005 顶部搜索框的搜索结果页 1006 发现栏小程序主入口搜索框的搜索结果页 1042 添加好友搜索框的搜索结果页 1053 搜一搜的结果页 1027 顶部搜索框搜索结果页“使用过的小程序”列表 ★ 公众号 1043 公众号模板消息 1020 公众号 profile 页相关小程序列表 1035 公众号自定义菜单 1058 公众号文章 1074 公众号会话下发的小程序消息卡片 ★ 分享 1036 App 分享消息卡片 1007 单人聊天会话中的小程序消息卡片 1008 群聊会话中的小程序消息卡片 1044 带 shareTicket 的小程序消息卡片 ★ 模板消息 1014 小程序模版消息 1034 微信支付完成页 ★ 测试 1059 体验版小程序绑定邀请页 1017 前往体验版的入口页 ★ 卡券 1028 我的卡包 1029 卡券详情页 1052 卡券的适用门店列表 ★ 小程序之间跳转 1037 小程序打开小程序 1038 从另一个小程序返回 ★ 快捷入口 1001 发现栏小程序主入口 1022 聊天顶部置顶小程序入口 1023 安卓系统桌面图标 1024 小程序 profile 页 ★ 广告投放 1068 附近小程序列表广告 1067 公众号文章广告 ★ 其他 1039 摇电视 1056 音乐播放器菜单 1019 微信钱包 1026 附近小程序列表 1064 微信连Wifi状态栏 1073 客服消息列表下发的小程序消息卡片 END grammar Scene { token TOP { ^ &lt;entry&gt;+ $ } # 一个或多个块 token entry { &lt;head&gt; \s* # 每个块都有一个标题 &lt;line&gt;+ \s* # 每个标题下面有很多非标题行 } token head { '★' \s+ &lt;title&gt; } token line { [ &lt;!
                  <a href="https://ohmysummer.github.io/post/2017-09-15-%E5%BC%80%E5%90%AFdisqus%E8%AF%84%E8%AE%BA/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2017-03-11-raku%E4%B8%AD%E7%9A%84%E7%AC%91%E8%84%B8/">
                <h2 class="post-title">Raku 中的笑脸</h2>

                
                  <h3 class="post-subtitle">
                    :D, :U, :_
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on March 11, 2017
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 1 minutes (82 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  在 Raku 中在调用者的类型身上使用 :D 或 :U 类型笑脸来制造 type/instance 方法:
class Foo { multi method foo (Foo:D:) { say &quot;instance&quot; } multi method foo (Foo:U:) { say &quot;type object&quot; } } Foo .foo; # 输出 type object Foo.new.foo; # 输出 instance # Can use compile time vars to aovid re-typing the actual name everywhere: class Bar { multi method foo (::?CLASS:D:) { say &quot;instance&quot; } multi method foo (::?CLASS:U:) { say &quot;type object&quot; } } Bar .
                  <a href="https://ohmysummer.github.io/post/2017-03-11-raku%E4%B8%AD%E7%9A%84%E7%AC%91%E8%84%B8/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/smileys/">smileys</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/defined/">defined</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/undefined/">undefined</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2016-10-22-%E5%85%B3%E4%BA%8Eraku%E4%BD%A0%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8410%E4%BB%B6%E4%BA%8B/">
                <h2 class="post-title">关于 Raku 你要知道的 10 件事</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on October 22, 2016
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 4 minutes (791 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Ten Things You Need To Know about Raku Jeffrey Goff, Evozon Systems LLC OSCON London 2016 https://github.com/drforr http://theperlfisher.blogspot.ro  资源  raku.org (obviously) docs.raku.org - Online documentation modules.raku.org - CPAN Lite
 rakudo.org - Where to get the latest
 https://github.com/tadzik/rakudobrew - Perlbrew for Raku
 https://github.com/tadzik/panda/ - Module installer
 irc://irc.freenode.org/raku - #raku on IRC.freenode.org
 http://rosettacode.org/wiki/Category:Perl_6 - Sample source
  要闻  干净, 一次性的可解析的文法 对用户友好的错误信息 友好的 Unicode 对初学者有帮助的符号 Math that works 函数签名 用正则表达式引导 OO with a type lattice built on a Metaprogramming model 自定义运算符 内置并发  一次性文法 my @doctor = { :first('Christopher'), :last('Eccleston'), years =&gt; 1 }, { :first('David'), :last('Tennant'), years =&gt; 4 }, { :first('Matt'), :last('Smith'), years =&gt; 4 }, { :first('Peter'), :last('Capaldi'), years =&gt; 3 }; say 'First New Who Doctor: ', @doctor[0]{'first'}, ' ', @doctor[0]&lt;last&gt;; say &quot;Average run: &quot; ~ @doctor.
                  <a href="https://ohmysummer.github.io/post/2016-10-22-%E5%85%B3%E4%BA%8Eraku%E4%BD%A0%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%8410%E4%BB%B6%E4%BA%8B/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/grammar/">Grammar</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/%E7%AD%BE%E5%90%8D/">签名</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%90%E7%AE%97%E7%AC%A6/">自定义运算符</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2016-10-03-raku%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91/">
                <h2 class="post-title">Raku 中的并发</h2>

                
                  <h3 class="post-subtitle">
                    Concurrency and Asynchronous Programming
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on October 3, 2016
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 9 minutes (1742 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Concurrency
与大多数现代编程语言一样，Raku 被设计为支持并发（允许多个事件同时发生）和异步编程（有时称为事件驱动或反应式编程 - 即程序某些部分的事件或变化可能会导致程序流异步地改变程序的其它部分）。
Perl 的并发设计的目的是提供一个高层级的，可组合的，一致的接口，而不管如下所述的虚拟机通过工具层怎样为特定操作的系统来实现它。
此外，某些 Perl 的特性可以隐式地以异步的方式操作，所以为了确保这些特性可预测的互通，用户代码应在可能情况下，避免较低层级的并发的 API（即线程和调度器），并使用高层级接口。
High-level APIs Promises Promise（在其他编程环境中也被称为 *future*）封装了在获得 promise 时可能尚未完成或甚至未开始的计算结果。Promise 从 Planned 状态开始, 结果要么是 Kept 状态, 这意味着该 promise 已成功完成, 要么是 Broken 状态, 意味着该 promise 已失败。 通常这就是用户代码需要以并行或异步方式操作的使用最多的功能。
my $p1 = Promise.new; say $p1.status; # OUTPUT: «Planned␤» $p1.keep('Result'); say $p1.status; # OUTPUT: «Kept␤» say $p1.result; # OUTPUT: «Result␤» # (since it has been kept, a result is available!) my $p2 = Promise.new; $p2.break('oh no'); say $p2.
                  <a href="https://ohmysummer.github.io/post/2016-10-03-raku%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/%E5%B9%B6%E5%8F%91/">并发</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/channel/">Channel</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/concurrency/">Concurrency</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2016-06-01-raku%E4%B8%AD%E7%9A%84subscripts/">
                <h2 class="post-title">Raku 中的 Subscripts</h2>

                
                  <h3 class="post-subtitle">
                    Accessing data structure elements by index or key
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 1, 2016
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 9 minutes (1907 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Subscripts 通过索引或键访问数据结构中的元素。
通常，人们需要引用集合或数据结构中的一个特定的元素（或特定的元素切片）。从数学标记法中偷学到的，向量 v 的组成部分用 v₁, v₂, v₃ 来引用，在 Raku 中这个概念叫做 “下标” （或“索引”）。
Basics Raku 提供了两个通用的下标接口：
elements are identified by interface name supported by [ ] zero-based indices Positional Array, List, Buf, Match, ... { } string or object keys Associative Hash, Bag, Mix, Match, ...   Positional 下标 (通过 postcircumfix [ ] 通过元素在有序集合中的位置来寻址元素。)索引 0 引用第一个元素， 索引 1 引用第二个元素， 以此类推：  my @chores = &quot;buy groceries&quot;, &quot;feed dog&quot;, &quot;wash car&quot;; say @chores[0]; #-&gt; buy groceries say @chores[1]; #-&gt; feed dog say @chores[2]; #-&gt; wash car   Associative 下标 (通过 postcircumfix { }), 不要求集合以任何特定的顺序保存元素 - 相反，它使用一个唯一的键来寻址每个值。键的种类取决于使用的集合： 举个例子， 一个标准的散列 使用字符串作为键， 而一个 Mix 能使用任意的对象作为键， 等等:  my %grade = Zoe =&gt; &quot;C&quot;, Ben =&gt; &quot;B+&quot;; say %grade{&quot;Zoe&quot;}; #-&gt; C say %grade{&quot;Ben&quot;}; #-&gt; B+ my $stats = ( Date.
                  <a href="https://ohmysummer.github.io/post/2016-06-01-raku%E4%B8%AD%E7%9A%84subscripts/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/subscripts/">Subscripts</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2016-04-12-raku%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/">
                <h2 class="post-title">Raku 中的签名</h2>

                
                  <h3 class="post-subtitle">
                    Parameter list pattern
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on April 12, 2016
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 9 minutes (1817 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  签名也是对象 class Signature {}  签名是代码对象参数列表的静态描述。即, 签名描述了你需要什么参数和多少参数传递给代码或函数以调用它们。
传递参数给签名把包含在 Capture 中的参数绑定到了签名上。
&gt; sub a($a, $b) {}; &gt; &amp;a.signature.perl.say :($a, $b) &gt; my $b = -&gt; $a, $b {}; &gt; $b.signature.perl.say :($a, $b)  签名是一个对象, 就像 Raku 中的任何其它东西一样。 任何 Callable 类型中都有签名, 并且它能使用 .signature方法获取到。
class Signature { ... }  签名字面量 签名出现在子例程和方法名后面的圆括号中, 对于 blocks 签名出现在 -&gt;或 &lt;-&gt; 箭头后面, 或者作为变量声明符(例如 [my](https://docs.raku.org/syntax/my) )的输入, 或者以冒号开头作为单独的项。
sub f($x) { } # ^^^^ sub f 的签名 method x() { } # ^^ 方法 x 的签名 my $s = sub (*@a) { } # ^^^^^ 匿名函数的签名 for &lt;a b c&gt; -&gt; $x { } # ^^ Block 的签名 my ($a, @b) = 5, (6,7,8); # ^^^^^^^^ 变量声明符的签名 my $sig = :($a, $b); # ^^^^^^^^ 独立的签名对象  签名字面量可以用于定义回调或闭包的签名。
                  <a href="https://ohmysummer.github.io/post/2016-04-12-raku%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/signature/">signature</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/%E7%AD%BE%E5%90%8D/">签名</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2016-02-05-raku-grammars/">
                <h2 class="post-title">Grammars</h2>

                
                  <h3 class="post-subtitle">
                    Group of named regexes that form a formal grammar
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on February 5, 2016
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 7 minutes (1404 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Grammars Grammars - 一组具名 regexes 组成正式的 grammar
Grammars 是一个很强大的工具用于析构文本并通常返回数据结构。
例如, Raku 是使用 Raku 风格 grammar 解析并执行的。
对普通 Raku 使用者更实用的一个例子是 JSON::Tiny模块, 它能反序列化任何合法的 JSON 文件, 而反序列代码只有不到 100 行, 还能扩展。
Grammars 允许你把 regexes 组织到一块儿, 就像类(class) 中组织方法那样。
具名正则 (Named Regexes) 　grammars 的主要组成部分是 regexes。 而 Raku 的 regexes语法不在该文档的讨论范围, 具名正则(named regexes) 有它自己的特殊语法, 这跟子例程(subroutine) 的定义很像:
my regex number { \d+ [ \. \d+ ]? } # 普通 regex 中空格被忽略, [] 是非捕获组  上面的代码使用 my 关键字指定了本地作用域的 regex, 因为具名正则(named regexes) 通常用在 grammars 里面。
                  <a href="https://ohmysummer.github.io/post/2016-02-05-raku-grammars/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/grammars/">grammars</a>&nbsp;
                  
                    <a href="https://ohmysummer.github.io//tags/actions/">actions</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2015-06-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84raku/">
                <h2 class="post-title">面向对象的 Raku</h2>

                
                  <h3 class="post-subtitle">
                    Object orientation in Raku
                  </h3>
                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on June 15, 2015
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 14 minutes (2812 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  https://docs.raku.org/language/objects
Raku 为面向对象编程(OOP)提供强大支持。尽管 Raku 允许程序员以多种范式进行编程，但面向对象编程是该语言的核心。
Raku 带有丰富的预定义类型，可分为两类：常规类型和原生类型。所有你能存储到变量中的东西要么是一个原生的 value, 要么是一个对象。这包括字面值、类型（类型对象）、code 和容器。
原生类型用于底层类型（例如 uint64）。尽管原生类型没有和对象同样的功能，如果在其上调用方法，它们也会自动装入普通对象。
一切不是原生值的东西都是一个对象。对象确实允许继承和封装。
使用对象 要在对象上调用方法，请在对象名上添加一个点，然后添加方法名称：
say &quot;abc&quot;.uc; # OUTPUT: «ABC␤»  这将在 &ldquo;abc&rdquo; 上调用 uc 方法, 这是一个 Str 类型的对象。要为方法提供参数, 请在方法后面的括号内添加参数。
my $formatted-text = &quot;Fourscore and seven years ago...&quot;.indent(8); say $formatted-text; # OUTPUT: « Fourscore and seven years ago... »  $formatted-text 现在包含上面的文本，但缩进了8个空格。
多个参数由逗号分隔：
my @words = &quot;Abe&quot;, &quot;Lincoln&quot;; @words.push(&quot;said&quot;, $formatted-text.comb(/\w+/)); say @words; # OUTPUT: «[Abe Lincoln said (Fourscore and seven years ago)]␤»  类似地，可以通过在方法后放置冒号并使用逗号分隔参数列表来指定多个参数：
                  <a href="https://ohmysummer.github.io/post/2015-06-15-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84raku/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>&nbsp;
                  
                </div>
              

            </article>
          
            <article class="post-preview">
              <a href="https://ohmysummer.github.io/post/2018-02-13-raku-grammers-part-1/">
                <h2 class="post-title">Raku Grammars, Part 1</h2>

                
              </a>

              <p class="post-meta">
                <span class="post-meta">
  
  
  <i class="fa fa-calendar-o"></i>&nbsp; Posted on July 11, 2014
  
  
  &nbsp;|&nbsp;
  <i class="fa fa-clock-o"></i> 2 minutes (410 words)
  
  
</span>

              </p>
              <div class="post-entry">
                
                  Raku Grammars, Part 1 Raku 语言内置了对 grammar 的支持。您可以将 grammars 视为众所周知的正则表达式和诸如 yacc 或 bison 等实用程序或更复杂的 grammar 工具（如ANTLR）的组合。所有这些 - 词法分析器，语法分析器和语义处理 - 通常是编译器的独立部分，在 Raku 中它们都是内置的，并且可以通过全新的 Raku 安装 进行开箱即用。
要感受 grammar 的力量，Raku 自己的 grammar 就是用 Raku 庞大的 grammar 类 Raku::Grammar写成的就足以说明了。
在本文中，我将通过几个例子来说明 grammar 的基础知识。所有必需的语言结构将在我们进行的时候进行解释。
解析数字 在你开始思考用户可以使用不同格式的数字,包括负数，浮点数，科学记数法中的数字，特殊形式的数字（如C的长整数）之前，解析数字似乎是一项简单的任务。
让我们从最简单的形式开始：一个数字作为数字序列。例如，1,42,123 或 1000. Raku 中的 grammar 是一种特殊的类，它有自己的关键字。grammar 的第一个 rule 必须（默认情况下）称为 TOP，以下是解析第一组数字的完整程序：
grammar N { token TOP { &lt;digit&gt;+ } } for &lt;1 42 123 1000&gt; -&gt; $n { say N.
                  <a href="https://ohmysummer.github.io/post/2018-02-13-raku-grammers-part-1/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <div class="blog-tags">
                  
                    <a href="https://ohmysummer.github.io//tags/raku/">Raku</a>&nbsp;
                  
                </div>
              

            </article>
          
        </div>
        
      </div>
    </div>
  </div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
          <li>
            
            <a href="https://ohmysummer.github.io/categories/raku/index.xml" title="RSS">
            
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-2x"></i>
                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          </li>
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://ohmysummer.github.io/">焉知非鱼</a>
            
          

          <span style="color: red;">❤</span>&nbsp;Raku
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.53</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://ohmysummer.github.io/js/main.js"></script>
<script src="https://ohmysummer.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> $(document).ready(function() {$("pre.chroma").css("padding","0");}); </script><script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script>
<script src="https://ohmysummer.github.io/js/load-photoswipe.js"></script>


<script>
  (function() {
    var cx = '009072066163920799339:qwme9vkotxk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>





  </body>
</html>

