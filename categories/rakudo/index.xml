<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rakudo on Raku Programming</title>
    <link>https://ohmysummer.github.io/categories/rakudo/</link>
    <description>Recent content in Rakudo on Raku Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 31 Jul 2017 10:54:24 +0200</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/categories/rakudo/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Seq 和摇滚</title>
      <link>https://ohmysummer.github.io/post/2017-07-31-seq%E5%92%8C%E6%91%87%E6%BB%9A/</link>
      <pubDate>Mon, 31 Jul 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-07-31-seq%E5%92%8C%E6%91%87%E6%BB%9A/</guid>
      <description>这是这个系列的第二部分！请确保你已经阅读过第一部分, 在那里我们讨论了什么是 Seq, 并且怎么来缓存它们。
今天, 我们把 Seq 单独拎出来, 看看里面到底有什么; 是什么驱动的它; 并且怎样让它实现我们的想法。
第二部分: 快速迭代 使 Seq 做事情的主要部分是遵循 Iterator 角色的对象。 这个对象知道如何生成下一个值，什么时候从 Seq 中提取一个值，或者将其所有值推送到某个地方，或者简单地丢弃所有剩余的值。
请记住，当使用 Seq 作为值的来源时，您不需要直接使用 Iterator 的方法。 它们被间接称为各种 Raku 结构。 自己调用这些方法的场景通常是我们制作一个由另一个 Iterator 提供的迭代器的时候，就像我们会看到的那样。
Pull my finger 在最基本的形式中, 一个 Iterator 对象需要提供的只有一个方法: .pull-one
my $seq := Seq.new: class :: does Iterator { method pull-one { return $++ if $++ &amp;lt; 4; IterationEnd } }.new; .say for $seq;  输出:
# OUTPUT: # 0 # 1 # 2 # 3  上面的例子中, 我们使用 Seq 的 .</description>
    </item>
    
    <item>
      <title>Raku Sheet</title>
      <link>https://ohmysummer.github.io/post/2017-05-19-sheet/</link>
      <pubDate>Fri, 19 May 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-05-19-sheet/</guid>
      <description>正则表达式 Raku 的正则表达式允许你为你自定义的字符类混进 Unicode 属性！
constant string = &#39;The Quick 🐼 Jumped Over 57 Dogs&#39;; say string ~~ m:g/ &amp;lt;:upper-[TQ]&amp;gt; /; # (「J」 「O」 「P」) say string ~~ m:g/ &amp;lt;-[\x0..\x255]+[\x35..\x37]&amp;gt; /; # (「🐼」 「5」 「7」) say string ~~ m:g/ &amp;lt;-:digit -:Ll -:Zs&amp;gt; /; # (「T」 「Q」 「🐼」 「J」 「O」 「D」) say string ~~ m:g/ &amp;lt;[\w]-[TQJ\d]-:lower+[5]&amp;gt; /; # (「O」 「5」 「D」)  Wow! #Raku #Regex is so awesome, you can just shove an array into it and it&amp;rsquo;ll know to treat it as alternatives to match!</description>
    </item>
    
    <item>
      <title>Raku Dispatch 解密</title>
      <link>https://ohmysummer.github.io/post/2017-04-02-dispath%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Sun, 02 Apr 2017 14:24:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-04-02-dispath%E8%A7%A3%E5%AF%86/</guid>
      <description>Raku 的一个很好的特性是 multi-dispatch, 即多重分派。它允许你在函数, 方法或 Grammar token 中使用相同的名字并让它们所处理的数据的类型来决定执行哪一个。下面是一个 factorial postfix 操作符, 用两个 multies 来实现:
multi postfix:&amp;lt;!&amp;gt; (0) { 1 } multi postfix:&amp;lt;!&amp;gt; (UInt \n) { n × samewith n − 1 } say 5! # OUTPUT: 120  虽然 multi-dispatch 的主题很明显并且它还有一些说明文档, 我今天想讲的是 7 个特殊的子例程, 让你能够行走在 dispatch 迷宫中。它们是 nextwith, nextsame, samewith, callwith, callsame, nextcallee 和 lastcall.
设立实验室 Multies 从最窄到最广的候选者进行排序，并且当一个 multi 被调用时，绑定器尝试找到一个匹配并调用第一个匹配的候选者。 有时，您可能希望调用或简单地移动到链中的下一个匹配候选者，可选地使用不同的参数。 为了观察这些操作的效果，我们将使用以下设置：
class Wide { } class Middle is Wide { } class Narrow is Middle { } multi foo (Narrow $v) { say &#39;Narrow &#39;, $v; &#39;from Narrow&#39; } multi foo (Middle $v) { say &#39;Middle &#39;, $v; &#39;from Middle&#39; } multi foo (Wide $v) { say &#39;Wide &#39;, $v; &#39;from Wide&#39; } foo Narrow; # OUTPUT: Narrow (Narrow) foo Middle; # OUTPUT: Middle (Middle) foo Wide; # OUTPUT: Wide (Wide)  我们有三个类，每个类都继承自前一个类，所以我们的 Narrow 类 可以适应 Middle 和 Wide multi 候选者; Middle 也可以适应 Wide，但不能适应 Narrow; 而 Narrow 既不适用于 Middle，也不适用于 Narrow。请记住，Raku 中的所有类也都是 Any 类型，因此也适用于任何接受 Any 的候选者。</description>
    </item>
    
    <item>
      <title>Regexes</title>
      <link>https://ohmysummer.github.io/post/2017-03-18-regexes/</link>
      <pubDate>Sat, 18 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-18-regexes/</guid>
      <description>正则表达式, 简称 regexes, 是描述文本模式的字符序列。模式匹配就是将这些模式和实际的文本进行匹配的过程。
词法约定 Raku 正则表达式有特殊的写法:
m/abc/; # a regex that is immediately matched against $_ rx/abc/; # a Regex object /abc/; # a Regex object  对于前两个例子, 分隔符还能用除了斜线之外的其它字符:
m{abc}; rx{abc};  注意, 冒号和圆括号都不能用作分隔符; 禁止使用冒号作为正则表达式分割符是因为它和副词冲突, 例如 rx:i/abc/(忽略大小写的正则表达式), 而圆括号表明函数调用。
空白符在正则表达式中通常被忽略(带有 :s 或 :sigspace 副词的正则表达式除外)。
通常, 对于 Raku 来说, 正则表达式中的注释以 # 号开头, 直至行尾。
字面值 正则表达式最简单的情况是匹配字符串字面值。
if &#39;properly&#39; ~~ m/ perl / { say &amp;quot;&#39;properly&#39; contains &#39;perl&#39;&amp;quot;; }  字母数字和下划线 _ 按字面值匹配。所有其它字符要么使用反斜线转义(例如, \: 匹配一个冒号), 要么用引号引起来:</description>
    </item>
    
    <item>
      <title>Raku Gramamr 指南</title>
      <link>https://ohmysummer.github.io/post/2017-03-05-raku-grammar-%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sun, 05 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-05-raku-grammar-%E6%8C%87%E5%8D%97/</guid>
      <description>开始之前 为什么是 grammars? Grammars 解析字符串并从这些字符串返回数据结构。Grammars 可用于编写执行程序以确定程序是否可以运行（如果它是一个有效的程序），将网页分解成组成部分，或在其它的东西中识别句子的不同部分。
我什么时候该使用 grammars? 如果你有驯服或解释的字符串，grammar 提供工具来完成这项工作。
该字符串可能是一个文件, 您想把它拆分成多个章节; 也许是一个协议，比如 SMTP，你需要指定哪些“命令”来自用户提供的数据;也许你正在设计自己的领域特定语言。Grammars 可以提供帮助。
grammars 的广义概念 正则表达式（Regexes）适用于查找字符串中的模式。然而，对于一些任务来说，如同时查找多个模式，或者组合模式，或者单独测试可能围绕字符串正则表达式的模式是不够的。
在使用 HTML 时，您可以定义一个 grammar 来识别 HTML 标记，包括开始和结束元素以及它们之间的文本。然后，您可以将这些元素组织到数据结构中，例如数组或散列。
Grammar 指南 你总是会遇到令人头疼的字符串解析。举个例子, 据说 HTML 不能被有效地分解和解析，只需使用正则表达式来排序元素。另一个例子是定义单词和符号可能构成语言并提供含义的顺序。这正 和 Perl 的 Gramamr 系统完美契合。
Grammar 非常适合接受字符串，试图理解它们，然后将它们保存到一个你实际可以使用的数据结构中。如果你有某种带顺序或解释类型的字符串，Grammar 给你一些很强大的工具，使解析字符串更容易。
你的字符串可能是整个文件，你需要分成几个部分。也或许是一行一行的。也许你有一个正在使用的 SMTP 那样的协议，想要一个方便有条理的方式来定义哪些“命令”需要在用户数据的后面，使协议工作。也许你想创建自己的基于字符串的协议。也许你正在设计自己的语言。
正则表达式（regex）很好地在字符串中查找模式并操作它们。然而，当你需要同时找到多个模式，或者需要组合模式，或者测试可能围绕字符串的模式或其他模式 - 单单用正则表达式是不够的。
Grammar 提供了一种方式来定义如何使用正则表达式来检查字符串，并且可以将这些正则表达式组合在一起以提供更多的意义。
例如，在HTML的情况下，您可以定义一个语法，它可以识别HTML标记（开始和结束元素以及它们之间的文本），并通过将这些元素填充到数据结构中来对这些元素进行操作，例如数组或散列，然后可以轻松使用。实质上，Grammar 提供了一种定义可用于解析任意大小和复杂度的字符串的完整语言或规范的手段。
更多 Grammar 技术 概念描述 Gramamr 被定义为对象, 就像 Perl 中的其它东西。从技术上讲, Gramamr 是普通的类加上一点额外的魔法, 我们稍后就说到它 &amp;ndash; 还有一点限制。你像类那样命名和定义一个 Grammar, 除了使用「grammar」关键字代替「class」。
grammar My::Gram { ..methods &#39;n stuff.</description>
    </item>
    
    <item>
      <title>通过模块学习 Grammar</title>
      <link>https://ohmysummer.github.io/post/2017-03-05-%E4%BD%BF%E7%94%A8grammar%E7%9A%84%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 05 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-05-%E4%BD%BF%E7%94%A8grammar%E7%9A%84%E6%A8%A1%E5%9D%97/</guid>
      <description>学习 Raku Grammar 的一个很好的地方是 GitHub 上的模块仓库, 里面有不少模块使用了 Grammar 来编写。下面我们列举出哪些模块值得我们学习。
 Raku STD 使用 Grammar 解析 YAML 使用 Grammar 解析 TAP 测试文件 使用 Grammar 解析 CSS 解析和操纵 CSS 解析 CSS 属性定义 使用 Raku Gramamr 解析 fortran 源代码 用 Raku 写的 Grammar 引擎 解析 BNF 和 ABNF grammars 并从中生成 Raku grammars Raku Gramamr 调试 使用 Raku Grammars 解析 HTTP 头, 消息体, 和 URIs Raku PDF Grammars 解析 URI 解析 ini 文件 解析 .</description>
    </item>
    
    <item>
      <title>4 种风格的模板引擎</title>
      <link>https://ohmysummer.github.io/post/2017-03-04-4%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</link>
      <pubDate>Sat, 04 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-04-4%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</guid>
      <description>4 种风格的模板引擎. 带基准测试！ 这一次在博客上，我将告诉你如何编写自己的模板引擎 - 根据需要为你量身定制语法和行为。 我们将以四种不同的方式来分析每种方法的优缺点，以及代码速度和复杂性。 我们今天的示例任务是为用户撰写密码提醒文本，然后可以通过电子邮件发送。
use v6; my $template = q{ Hi [VARIABLE person]! You can change your password by visiting [VARIABLE link] . Best regards. }; my %fields = ( &#39;person&#39; =&amp;gt; &#39;John&#39;, &#39;link&#39; =&amp;gt; &#39;http://example.com&#39; );  所以由我们决定我们的模板语法应该是什么样子的，对于初学者，我们会有一些小的变量（虽然这不是很精确的名称，因为模板中的变量几乎总是不变的）。 我们还有用于填充模板字段的数据。 让我们开始吧！
Substitutions sub substitutions ( $template is copy, %fields ) { for %fields.kv -&amp;gt; $key, $value { $template ~~ s:g/&#39;[VARIABLE &#39; $key &#39;]&#39;/$value/; } return $template; } say substitutions($template, %fields);  输出:</description>
    </item>
    
    <item>
      <title>Raku 中的 *, $_ 和 $</title>
      <link>https://ohmysummer.github.io/post/2017-02-04-whatever-star-vs.-_-vs-/</link>
      <pubDate>Sat, 04 Feb 2017 22:55:48 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-02-04-whatever-star-vs.-_-vs-/</guid>
      <description>cale2 问了一个很难的问题 今天卡尔2拒绝问简单的问题。我们来看它今天问了什么难题：
  我需要一份关于 * vs $_ vs $ 的指南。
 这个问题问得多么好。那三种东西都是语法糖, 因为上下文转换, 它们能很好地避免折行和更少的 bugs。
我们从我们的老朋友主题变量 $_ 开始。在 Perl 5 中它刚好出现在每个 sub 的外面。在 Raku 中它出现在块的默认值之外。
my &amp;amp;block = { &#39;oi?&#39; }; &amp;amp;block.signature.say; # OUTPUT?(;; $_? is raw)??  块的默认签名是一个名为 $_ 的位置参数。因此每个块都有一个主题变量 $_。还有其他设置 $_ 主题变量的语句，而不引入一个新的块，像 with 和 given （given 的确引入了一个块，但它是特殊的，我在这里不说明细节）。
say $_ with 42; # OUTPUT ?42??  因为它是默认的, Raku 会在很多地方期待它的出现。最突出的是当没有对象方法调用时。
$_ = 42; say &#39;oi?&#39; when 42; .</description>
    </item>
    
    <item>
      <title>2017 StackOverFlow-sort,deepmap,flat</title>
      <link>https://ohmysummer.github.io/post/2017-01-02-stackoverflow/</link>
      <pubDate>Mon, 02 Jan 2017 22:56:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-01-02-stackoverflow/</guid>
      <description>raku What is the best way to match any of a group of words?  我想匹配任意一组单词，但是失败了，请问怎样才能正确地匹配到？
my @a=&amp;lt;a b c d e f&amp;gt;; my $x=&amp;quot;a1234567&amp;quot;; say $x ~~ m/ @a.any /;  Answer
my @a = &amp;lt;a b c d e f&amp;gt;; my $x = &amp;quot;a1234567&amp;quot;; say $x ~~ /@a/  /@a/ 和 /| @a/ 相同，它是最长的备选分支。对于备选分支，你可以使用 /|| @a/。
 How to build lazy lists with defined generators and is there a “takeWhile” alternative?</description>
    </item>
    
    <item>
      <title>Raku Rakudo 和 NQP 内部研讨(一)</title>
      <link>https://ohmysummer.github.io/post/2017-01-01-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/</link>
      <pubDate>Sun, 01 Jan 2017 23:01:01 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-01-01-rakudo-%E5%92%8C-nqp-%E5%86%85%E9%83%A8%E7%A0%94%E8%AE%A8/</guid>
      <description>标题: Rakudo and NQP Internals 子标题: The guts tormented implementers made 作者: Jonathan Worthington
关于这个课程 Raku 是一种大型语言, 包含许多要求正确实现的功能。
这样的软件项目很容易被难以控制的复杂性淹没。 Rakudo 和 NQP 项目的早期阶段已经遭受了这样的困难, 因为我们学到了 - 艰难的方式 - 关于复杂性, 出现并可能在实现过程中不受限制地扩散。
本课程将教您如何使用 Rakudo 和 NQP 内部。 在他们的设计中编码是一个大量学习的过程, 关于如何(以及如何不)写一个 Raku 实现, 这个过程持续了多年。 因此, 本课程还将教你事情的来龙去脉。
关于讲师  计算机科学背景 选择旅行世界,并帮助实现 Raku, 而不是做博士 有不止一种方法来获得&amp;rdquo;永久头部损伤&amp;rdquo; :-) 不知何故在 Edument AB 被聘用, 作为讲师/顾问 从 2008 年开始成为 Rakudo Raku 核心开发者 6model, MoarVM, NQP 和 Rakudo 各个方面的缔造者  课程大纲 - 第一天  鹰的视角: 编译器和 NQP/Rakudo 架构 NQP 语言 编译管道 QAST 探索 nqp::ops  课程大纲 - 第二天  6model 有界序列化和模块加载 正则表达式和 grammar 引擎 JVM 后端 MoarVM 后端  鹰的视角 编译器和 NQP/Rakudo 架构</description>
    </item>
    
    <item>
      <title>Raku Tips - 创建可重用的数据类型</title>
      <link>https://ohmysummer.github.io/post/2016-12-31-raku-tips-%E5%88%9B%E5%BB%BA%E5%8F%AF%E9%87%8D%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 31 Dec 2016 23:14:12 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-31-raku-tips-%E5%88%9B%E5%BB%BA%E5%8F%AF%E9%87%8D%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Quick Tip #19: 创建可重用的数据类型 Raku 允许你使用类型来约束变量值，但是你不必拘泥于内置类型。一旦你定义了自己的类型，它们就表现得像内置类型一样。
下面是我从布拉德的 Subsets::Common模块偷得的一些子集(subsets):
my package EXPORT::DEFAULT { ... subset Pos of Numeric where * &amp;gt; 0; subset Neg of Numeric where * &amp;lt; 0; subset Zero of Numeric where * == 0; subset UNumeric of Numeric where * &amp;gt;= 0; subset Even of Int where * % 2 == 0; subset Odd of Int where * % 2; subset Time::Hour12 of PosInt where * ~~ 1 .</description>
    </item>
    
    <item>
      <title>Raku 时间戳转换器命令行版</title>
      <link>https://ohmysummer.github.io/post/2016-12-31-raku%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88/</link>
      <pubDate>Sat, 31 Dec 2016 23:14:12 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-31-raku%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%89%88/</guid>
      <description>Raku By Example: Datetime Conversion for the Command Line 我偶尔会在数据库中存储 UNIX 时间戳, 即从 1970-01-01 开始的秒数。我在按照日期查询数据库中的数据时, 需要将 UNIX 时间戳转换为人类可读的时间, 所以我写了个很小的工具来帮助我在 UNIX 时间戳和日期/时间之间来回转换:
$ autotime 2015-12-24 1450915200 $ autotime 2015-12-24 11:23:00 1450956180 $ autotime 1450915200 2015-12-24 $ autotime 1450956180 2015-12-24 11:23:00  使用库 Raku 的 DateTime 和 Date 模块会做实际的转换。 DateTime.new 构造函数有一个接收单个整数作为 UNIX 时间戳的变体:
$ raku -e &amp;quot;say DateTime.new(1480915200)&amp;quot; 2016-12-05T05:20:00Z  看起来我们已经完成了一个方向的转换,对吗?
#!/usr/bin/env raku sub MAIN (Int $timestamp) { say DateTime.new($timestamp) }  我们来运行它:</description>
    </item>
    
    <item>
      <title>2016 年末总结</title>
      <link>https://ohmysummer.github.io/post/2016-12-31-2016-%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 31 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-31-2016-%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/</guid>
      <description> 不想总结。 总结个大西瓜。 有什么好总结的。 说多了都是泪。 还是不要总结了。  </description>
    </item>
    
    <item>
      <title>Raku Tips - 排列组合</title>
      <link>https://ohmysummer.github.io/post/2016-12-30-raku-tips-%E6%8E%A2%E7%B4%A2%E7%BB%84%E5%90%88/</link>
      <pubDate>Fri, 30 Dec 2016 23:14:12 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-30-raku-tips-%E6%8E%A2%E7%B4%A2%E7%BB%84%E5%90%88/</guid>
      <description>Quick Tip #16: 探索组合
xx 是列表重复操作符, 用于将一个列表重复指定的次数。xx 不会展平列表中的元素。
$ raku &amp;gt; my @n = &amp;lt;1 2 3&amp;gt;; [1 2 3] &amp;gt; my $n = 4; 4 &amp;gt; my @c = @n xx $n  输出：
[[1 2 3] [1 2 3] [1 2 3] [1 2 3]]  现在我想要长度为 $n 的一堆列表的所有排列（combinations）:
&amp;gt; ( [X] ( @n xx $n ) ) ((1 1 1 1) (1 1 1 2) (1 1 1 3) (1 1 2 1) (1 1 2 2) (1 1 2 3) (1 1 3 1) (1 1 3 2) (1 1 3 3) (1 2 1 1) (1 2 1 2) (1 2 1 3) (1 2 2 1) (1 2 2 2) (1 2 2 3) (1 2 3 1) (1 2 3 2) (1 2 3 3) (1 3 1 1) (1 3 1 2) (1 3 1 3) (1 3 2 1) (1 3 2 2) (1 3 2 3) (1 3 3 1) (1 3 3 2) (1 3 3 3) (2 1 1 1) (2 1 1 2) (2 1 1 3) (2 1 2 1) (2 1 2 2) (2 1 2 3) (2 1 3 1) (2 1 3 2) (2 1 3 3) (2 2 1 1) (2 2 1 2) (2 2 1 3) (2 2 2 1) (2 2 2 2) (2 2 2 3) (2 2 3 1) (2 2 3 2) (2 2 3 3) (2 3 1 1) (2 3 1 2) (2 3 1 3) (2 3 2 1) (2 3 2 2) (2 3 2 3) (2 3 3 1) (2 3 3 2) (2 3 3 3) (3 1 1 1) (3 1 1 2) (3 1 1 3) (3 1 2 1) (3 1 2 2) (3 1 2 3) (3 1 3 1) (3 1 3 2) (3 1 3 3) (3 2 1 1) (3 2 1 2) (3 2 1 3) (3 2 2 1) (3 2 2 2) (3 2 2 3) (3 2 3 1) (3 2 3 2) (3 2 3 3) (3 3 1 1) (3 3 1 2) (3 3 1 3) (3 3 2 1) (3 3 2 2) (3 3 2 3) (3 3 3 1) (3 3 3 2) (3 3 3 3))  注意，排列是不一样的，它更简单，因为有一个方法来生成排列：</description>
    </item>
    
    <item>
      <title>Raku 中的 Setty 和 Baggy 类型</title>
      <link>https://ohmysummer.github.io/post/2016-12-11-raku%E7%9A%84-setty-%E5%92%8C-baggy-%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 11 Dec 2016 23:50:12 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-11-raku%E7%9A%84-setty-%E5%92%8C-baggy-%E7%B1%BB%E5%9E%8B/</guid>
      <description>有一个很常见的计数场景。比如说计算 DNA 中各个碱基的个数:
my %counts; %counts{$_}++ for &#39;AGTCAGTCAGTCTTTCCCAAAAT&#39;.comb; say %counts&amp;lt;A T G C&amp;gt;; # (7 7 3 6)  创建一个哈希。对于每一个你想计数的东西, 每遇到一次就在那个哈希中加 1。所以有什么问题？
Raku 通常有特定的更合适的类型来做这种操作; 例如,Bag 类型：
&#39;AGTCAGTCAGTCTTTCCCAAAAT&#39;.comb.Bag&amp;lt;A T G C&amp;gt;.say; # (7 7 3 6)  我们来说说这些类型还有那些时髦的运算符！
注意 Unicode 我将在这篇文章中使用花哨的 Unicode 版本的运算符和符号,因为它们看起来很纯。 然而, 他们都有我们称之为Texas的等同物, 你可以改用它们。
准备. Set. 走起 这些类型中最简单的就是 Set。 它将仅保存每个项目之一, 因此如果您有多个相同的对象, 那么重复项将被丢弃:
say set 1, 2, 2, &amp;quot;foo&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;; # OUTPUT: set(a, foo, b, 1, 2)  集合运算符是强制的, 因此我们不需要显式地创建集合; 他们会为我们做：</description>
    </item>
    
    <item>
      <title>Raku Grammar 之分割结构化文本</title>
      <link>https://ohmysummer.github.io/post/2016-11-01-raku-grammar%E4%B9%8B%E5%88%86%E5%89%B2%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%87%E6%9C%AC/</link>
      <pubDate>Tue, 01 Nov 2016 02:05:48 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-11-01-raku-grammar%E4%B9%8B%E5%88%86%E5%89%B2%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%87%E6%9C%AC/</guid>
      <description>如何使用 Grammar 分割一个有规律的文本文件? 首先这个文本有规律, 但是却是多行的。 我想将这样的文档分为独立的. 比如下面这个例子, 我想将他们分成3个独立的文本, 每个文本包含: [时间] Title 以及下面的 content lines. 实际的文件会有上千个, 最终输出的文本的名字是按照括号里面的时间来。
sample.txt
[28/04/2015 12:32] Title1 content line 1 content line 2 content line 3 content line 4 content line 5 balabala balabala [28/04/2015 12:16] Title2 content line 6 balabala content line 7 [27/04/2015 17:30] ​Title3 content line 8 content line 9 content line 10  下面是解析：
use Grammar::Tracer; # 开启 Grammar 调试有助于排错 grammar StructedText { token TOP { ^ &amp;lt;entry&amp;gt;+ $ } token entry { &amp;lt;head&amp;gt; \s* # 每一项有一个标题 &amp;lt;line&amp;gt;+ \s* # 每个标题下面有很多行 } token head { &#39;[&#39; &amp;lt;datetime&amp;gt; &#39;]&#39; \s+ &amp;lt;title&amp;gt; } token datetime { &amp;lt;filedate&amp;gt; \s+ &amp;lt;filetime&amp;gt; } token filedate { [\d+]+ % &#39;/&#39; } token filetime { [\d+]+ % &#39;:&#39; } token title { \N+ } token line { [ &amp;lt;!</description>
    </item>
    
    <item>
      <title>Raku 中的包</title>
      <link>https://ohmysummer.github.io/post/2016-10-28-raku%E4%B8%AD%E7%9A%84%E5%8C%85/</link>
      <pubDate>Fri, 28 Oct 2016 23:17:11 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-28-raku%E4%B8%AD%E7%9A%84%E5%8C%85/</guid>
      <description>Packages - Organizing and referencing namespaced program elements
 包是指定程序元素的嵌套命名空间。 模块，类，Grammar是包类型。 像目录中的文件一样，通常可以使用其短名称（如果它们是本地的）或使用较长的名称来消除歧义的引用具名元素。
Names 名称是作为变量名称的合法部分的任何东西（不包括sigil符号）。 这包括：
$foo # 简单标识符 $Foo::Bar::baz # 通过 :: 分割的组合标识符 $Foo::($bar)::baz # 执行插值的组合标识符 $42 # numeric names $! # 某些标点符号变量  :: 用于分割嵌套的包名。
包限定名 普通的包限定名像这样:
$Foo::Bar::baz # 包 Foo::Bar 中的 $baz 变量  有时保持sigil与变量名很清晰，所以来写这个的一个替代方式是：
Foo::Bar::&amp;lt;$baz&amp;gt;  这在编译时解决，因为变量名是一个常量。
如果 :: 之前的名称部分为 null，则意味着包未指定并且必须搜索。 一般来说，这意味着跟在主sigil后面的初始 :: 是对编译时已知的名字的无操作(no-op)，但 ::() 也可以用来引入插值。 另外，在没有另一个sigil的情况下，:: 可以作为它自己的sigil，表明有意使用一个尚未声明的包名。
伪包 在名称前面保留以下伪包名称：
MY # 当前词法作用域中的符号 (aka $?SCOPE) OUR # 当前包中的符号 (aka $?</description>
    </item>
    
    <item>
      <title>Raku 中列表、序列和数组</title>
      <link>https://ohmysummer.github.io/post/2016-10-27-raku%E4%B8%AD%E5%88%97%E8%A1%A8%E5%BA%8F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 27 Oct 2016 22:33:17 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-27-raku%E4%B8%AD%E5%88%97%E8%A1%A8%E5%BA%8F%E5%88%97%E5%92%8C%E6%95%B0%E7%BB%84/</guid>
      <description>列表一直是计算机的核心部分，因为之前有计算机，在这段时间里，许多恶魔占据了他们的细节。 它们实际上是 Raku 设计中最难的部分之一，但是通过坚持和耐心，Raku 已经使用了一个优雅的系统来处理它们。
Literal Lists 字面上的列表用逗号和分号不是用圆括号创建，因此：
1, 2 # This is two-element list (1, 2) # This is also a List, in parentheses (1; 2) # same List (1) # This is not a List, just a 1 in parentheses (1,) # This is a one-element List  括号可用于标记列表的开头和结尾，因此：
(1, 2), (1, 2) # This is a list of two lists.  多维字面上的列表是通过逗号和分号组合而成的。 它们可以在常规参数列表和下标中使用。
say so (1,2; 3,4) eqv ((1,2), (3,4)); # OUTPUT«True␤» say(&#39;foo&#39;;); # a list with one element and the empty list # OUTPUT«(foo)()␤»  单个元素可以使用下标从列表中拉出。 列表的第一个元素的索引号为零：</description>
    </item>
    
    <item>
      <title>第 10000 个素数</title>
      <link>https://ohmysummer.github.io/post/2016-10-26-%E7%AC%AC10000%E4%B8%AA%E7%B4%A0%E6%95%B0/</link>
      <pubDate>Wed, 26 Oct 2016 16:41:13 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-26-%E7%AC%AC10000%E4%B8%AA%E7%B4%A0%E6%95%B0/</guid>
      <description>到目前为止(2016.10.26), Raku 的速度相比 Perl 5/Python 的差距还是很大的。以打印从 1 开始计数的第 10000 个素数为例, 使用如下版本的 Rakudo:
 This is Rakudo version 2016.07.1 built on MoarVM version 2016.07 implementing Raku.c.
 从程序执行耗费的时间来看, Raku 实在慢的如蜗牛。
并发打印第10000个素数 sub find-prime($count) { my $channel = Channel.new; my $promise = start { for ^$count { $channel.send($_) if .is-prime; } LEAVE $channel.close unless $channel.closed; } return $channel.list but role :: { method channel { $channel } };; } my @primes = find-prime(110000); #for @primes { # @primes.</description>
    </item>
    
    <item>
      <title>Raku 中的 require</title>
      <link>https://ohmysummer.github.io/post/2016-10-26-raku%E4%B8%AD%E7%9A%84require/</link>
      <pubDate>Wed, 26 Oct 2016 16:37:31 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-26-raku%E4%B8%AD%E7%9A%84require/</guid>
      <description>有时你必须不择手段地得到一个东西。 如果它是一个文件，你可以使用 Jonathan Stowes 的 URI::FetchFile。 所述模块检查四个模块中的任何一个是否可用，并且采用第一个将 URI 保存为磁盘上的文件。 在他的代码中有一个有趣的触发了 ENODOC 的行。
$type = try require :: ($class-name);  这里 require 返回一个类型对象，该类型对象由模块声明，并且具有与该模块相同的名字。
检查 roast 这个巧妙的花招并把玩整个动态模块的魔法让我意识到，我们没有真正地在文档中覆盖这一点。 当我尝试处理一个 ENODOC 时我喜欢从一个可编译的例子开始。 这一次，我们需要两个文件。
# M.pm6 unit module M; class C is export { method m { &#39;method C::m&#39; } }; class D is export { method m { &#39;method D::m&#39; } }; # dynamic-modules.p6 use v6; use lib &#39;.&#39;; subset C where ::(&#39;M::C&#39;); my C $context = try { CATCH { default { .</description>
    </item>
    
    <item>
      <title>我在查找文件时所学到的</title>
      <link>https://ohmysummer.github.io/post/2016-10-20-%E6%88%91%E5%9C%A8%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E6%97%B6%E6%89%80%E5%AD%A6%E5%88%B0%E7%9A%84/</link>
      <pubDate>Thu, 20 Oct 2016 14:19:52 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-20-%E6%88%91%E5%9C%A8%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E6%97%B6%E6%89%80%E5%AD%A6%E5%88%B0%E7%9A%84/</guid>
      <description>Things I found out while finding
Concurrent::File::Find 现在已经在生态系统中了。我在这里分享几点我学到的东西。
在子签名(sub-signature)上使用 where 从句将不会在子签名中提供变量。 如果 where 从句必须对所有参数进行操作，为了检查排他性或其他相互依赖性，那么它必须应用于最后一个参数上。 这个限制设计时就是这样的，所以我告诉了文档。 where 从句对捕获没有效果，但原意不是那样设计的并且第二天 jnthn 就修复了它。 我知道抱怨会得到你的关注，但我没想到它是这么快。
我还发现一个叫 .close 的方法, 它几乎总是需要一个 LEAVE。 让我们看一些代码。
sub find-simple ( IO(Str) $dir, :$keep-going = True, :$no-thread = False ) is export { my $channel = Channel.new; my &amp;amp;start = -&amp;gt; ( &amp;amp;c ) { c } if $no-thread; my $promise = start { for dir($dir) { CATCH { default { if $keep-going { note .</description>
    </item>
    
    <item>
      <title>Raku 中的 with</title>
      <link>https://ohmysummer.github.io/post/2016-10-19-raku%E4%B8%AD%E7%9A%84with/</link>
      <pubDate>Wed, 19 Oct 2016 19:17:03 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-19-raku%E4%B8%AD%E7%9A%84with/</guid>
      <description>with orwith without with 语句就像 if 但是是为了测试是否定义而非真假。此外, 它主题化了条件, 这很像 given:
with &amp;quot;abc&amp;quot;.index(&amp;quot;a&amp;quot;) { .say } # print 0  代替 elsif, orwith 用于把是否定义的测试链接起来:
# The below code says &amp;quot;Found a at 0&amp;quot; my $s = &amp;quot;abc&amp;quot;; with $s.index(&amp;quot;a&amp;quot;) { say &amp;quot;Found a at $_&amp;quot; } orwith $s.index(&amp;quot;b&amp;quot;) { say &amp;quot;Found b at $_&amp;quot; } orwith $s.index(&amp;quot;c&amp;quot;) { say &amp;quot;Found c at $_&amp;quot; } else { say &amp;quot;Didn&#39;t find a, b or c&amp;quot; }  你可以混合基于 if 的从句和基于 with 的从句：</description>
    </item>
    
    <item>
      <title>Raku 模块分析 - 并行查找文件</title>
      <link>https://ohmysummer.github.io/post/2016-10-19-raku%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90-%E5%B9%B6%E8%A1%8C%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 19 Oct 2016 19:12:22 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-19-raku%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90-%E5%B9%B6%E8%A1%8C%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/</guid>
      <description>并行查找文件 如果你没有使用 panda 或 zef 安装该模块, 你可以下载到本地：
use v6; use lib &amp;quot;C:\\Users\\Administrator\\raku-concurrent-file-find\\lib&amp;quot;; use Concurrent::File::Find;  下面来看具体代码：
class X::IO::NotADirectory does X::IO is export { has $.path; method message { &amp;quot;«$.path» is not a directory&amp;quot; } } class X::IO::CanNotAccess does X::IO is export { has $.path; method message { &amp;quot;Cannot access «$.path»: permission denied&amp;quot; } } class X::IO::StaleSymlink does X::IO is export { has $.path; method message { &amp;quot;Stale symlink «$.path»&amp;quot; } }  上面的代码自定义了 3 个与 IO 错误相关的类并导出, 每个类中有一个 $.</description>
    </item>
    
    <item>
      <title>Raku 中的 Block</title>
      <link>https://ohmysummer.github.io/post/2016-10-19-raku%E4%B8%AD%E7%9A%84block/</link>
      <pubDate>Wed, 19 Oct 2016 00:22:27 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-19-raku%E4%B8%AD%E7%9A%84block/</guid>
      <description>Raku 中的 Block class Block is Code { }  Block 是用于小规模代码复用的代码对象。 Block 由花括号括起来的一组语句创建。
如果没有显式的签名或占位符参数，那么 Block 会把 $_ 作为位置参数：
my $block = { uc $_; }; say $block.WHAT; # (Block) say $block(&#39;hello&#39;); # HELLO  Block 和 -&amp;gt; 或 &amp;lt;-&amp;gt; 之间还可以拥有签名:
my $add = -&amp;gt; $a, $b { $a + $b }; say $add(38, 4); # 42  如果用 &amp;lt;-&amp;gt; 引入签名, 那么参数默认标记为 rw:
my $swap = &amp;lt;-&amp;gt; $a, $b { ($a, $b) = ($b, $a) }; my ($a, $b) = (2, 4); $swap($a, $b); say $a; # 4  类型不是 Routine（它是 Block 的子类）的 Blocks 对于 return是透明的。</description>
    </item>
    
    <item>
      <title>Raku 中的函数</title>
      <link>https://ohmysummer.github.io/post/2016-10-17-raku%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 17 Oct 2016 21:13:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-17-raku%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</guid>
      <description>Raku 中的函数 例程（Routines）是 Raku 中代码重用的最小手段。它们有几种形式，最明显的是属于类和角色并与对象相关联的方法，还有函数, 也叫做子例程或短子程序，它们独立于对象而存在。
子例程默认是词法（my）作用域的，对它们的调用通常在编译时解析。
子例程可以具有签名，也称为*参数列表*，其指定签名期望的参数（如果有的话）。 它可以指定（或保持打开）参数的数量和类型，以及返回值。
子例程的内省通过例程提供。
定义/创建/使用 函数 子例程 创建子例程的基本方法是使用 sub 声明符，后跟可选标识符
sub my-func { say &amp;quot;Look ma, no args!&amp;quot; } my-func;  sub 声明符返回可以存储在任何容器中的 Sub 类型的值:
my &amp;amp;c = sub { say &amp;quot;Look ma, no name!&amp;quot; } c; # OUTPUT: «Look ma, no name!␤» my Any:D $f = sub { say &#39;Still nameless...&#39; } $f(); # OUTPUT: «Still nameless...␤» my Code \a = sub { say ‚raw containers don&#39;t implement postcircumfix:&amp;lt;( )&amp;gt;‘ }; a.</description>
    </item>
    
    <item>
      <title>Raku From Ruby - Nutshell</title>
      <link>https://ohmysummer.github.io/post/2016-10-17-rakufromruby/</link>
      <pubDate>Mon, 17 Oct 2016 17:55:34 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-17-rakufromruby/</guid>
      <description>Raku from Ruby - Nutshell
基本语法 语句结束分号 Ruby 使用换行(有几个例外)来探测大部分语句的结束, 只要表达式已经完成。通过把运算符挂在行的末尾以保证解析会继续而打断一个长的表达式的做法很常见:
foo + # 在 Ruby 中结尾的运算符意味着解析会继续 bar + baz  在 Raku 中你必须显式地使用 ; 来结束语句, 这允许更好的反馈和更灵活的断行。有两个例外不需要显式的 ;, 块儿中的最后一条语句, 在块自身的闭合花括号之后(如果那一行上没有任何其它东西):
if 5 &amp;lt; $x &amp;lt; 10 { say &amp;quot;Yep!&amp;quot;; $x = 17 # 在闭合花括号 } 之前不需要分号 ; } # 因为换行, 在闭合花括号 } 之后不需要分号 ; say &amp;quot;Done!&amp;quot;; # 如果后面什么也没有, 那么这儿的分号也不需要  空白 Ruby 中允许使用大量令人吃惊的灵活的空白, 即使在开启了严格模式和警告的情况下:
# 不符合习惯但是在 Ruby 中是合法的 puts&amp;quot;Hello &amp;quot;+ (people [ i] .</description>
    </item>
    
    <item>
      <title>stackoverflowWeekly1014</title>
      <link>https://ohmysummer.github.io/post/2016-10-14-stackoverflowweekly1014/</link>
      <pubDate>Fri, 14 Oct 2016 15:09:54 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-14-stackoverflowweekly1014/</guid>
      <description>Raku List Concatenation without Slip Raku List Concatenation without Slip 在 Perl 5 中 , 操作符用来连接列表; 然而在 Raku 中需要使用 | 操作符, 即 slip 操作符。
my @a = &amp;lt;a b c&amp;gt;; my @b = &amp;lt;d e f&amp;gt;; my @ab = |@a, |@b;  有比这短点的写法吗？
 答案  你可以使用 「flat」sub:
my @a = &amp;lt;a b c&amp;gt;; my @b = &amp;lt;d e f&amp;gt;; my @ab = flat @a, @b; say @ab.perl; #&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;] my @abf = (@a, @b).</description>
    </item>
    
    <item>
      <title>在手机中运行 Raku</title>
      <link>https://ohmysummer.github.io/post/2016-10-14-%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%AD%E8%BF%90%E8%A1%8Craku/</link>
      <pubDate>Fri, 14 Oct 2016 11:15:24 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-14-%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%AD%E8%BF%90%E8%A1%8Craku/</guid>
      <description>准备工作  一只 Root 过的安卓智能手机(例如 Smartisan T1) 下载并安装 busybox.apk 、 Linux Deploy.apk 和 JuiceSSH.apk  安装 Linux 下面以在我的锤子手机上安装 Debian 为例, 说明如何在手机上运行 Linux:
设置 Linux Deploy 打开手机上的 Linux Deploy.apk：
在下面工具栏「启动」-&amp;gt;「停止」-&amp;gt; 「下载」 tab 中找到那个类似下载图标的按钮点击, 进入属性设置, 其中属性设置如下所示:
其中,
   选项 值 说 明     发行版 Debian 根据自己需要的系统选择   发行版本 jsssie 选择稳定版   架构 armhf 软件会自省判断 CPU 架构类型   镜像地址 http://debian.bjtu.edu.cn/debian/ http://ftp.cn.debian.org/debian/   镜像大小 不用填写 默认就行   选择组件 只保留 SSH 服务器 手机上用什么桌面环境   图形界面 取消勾选 手机上不需要 GUI   自定义挂载 勾选 在挂载点那里选择 sdcard0    设置完成后回到最上面的 Intall(安装 GNU/Linux), 就会开始下载镜像文件了:</description>
    </item>
    
    <item>
      <title>Raku 中的 subst</title>
      <link>https://ohmysummer.github.io/post/2016-10-05-raku%E4%B8%AD%E7%9A%84subst/</link>
      <pubDate>Wed, 05 Oct 2016 23:32:51 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-05-raku%E4%B8%AD%E7%9A%84subst/</guid>
      <description>(Str) 方法 subst subst 取的是单词 substitution(替换)的前5个字符, 意为替换之意。
multi method subst(Str:D: $matcher, $replacement, *%opts)  返回被调用的那个字符串, 其中 $matcher 被 $replacement 给替换掉了(或者返回原来的字符串, 如果没有找到匹配的话)。
subst 有一个「就地」替换的句法变体, 它被拼写为 s/matcher/replacement/。
$matcher 可以是一个正则表达式, 或者一个字符串字面值。 Cool 类型的非字符串 matcher 会被强转为字符串以用于字面上的匹配。
my $some-string = &amp;quot;Some foo&amp;quot;; my $another-string = $some-string.subst(/foo/, &amp;quot;string&amp;quot;); # gives &#39;Some string&#39; $some-string.=subst(/foo/, &amp;quot;string&amp;quot;); # in-place substitution. $some-string is now &#39;Some string&#39;  replacement 可以是一个闭包:
my $i = 41; my $str = &amp;quot;The answer is secret.</description>
    </item>
    
    <item>
      <title>gather-take</title>
      <link>https://ohmysummer.github.io/post/2016-09-28-gather-take/</link>
      <pubDate>Wed, 28 Sep 2016 17:48:14 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-28-gather-take/</guid>
      <description>控制流 gather/take gather 是一个语句或者能返回一序列值的 block 前缀。该值来自于 gather 块中的动态作用域的 take 调用。
my $a = gather { take 1; take 5; take 42; } say join &#39;, &#39;, @$a; # 1, 5, 42  gather/take 能根据上下文按需(惰性地)生成值。如果你想强制惰性求值则使用 lazy 子例程或方法。绑定到一个标量或无符号的容器上也会强制惰性求值。 举个例子:
my @vals = lazy gather { take 1; say &amp;quot;Produced a value&amp;quot;; take 2; } say @vals[0]; say &#39;between consumption of two values&#39;; say @vals[1]; # OUTPUT: # 1 # between consumption of two values # Produced a value # 2  gather/take 是动态作用域的, 所以你可以从 gather 内部所调用的 subs 或方法中调用 take:</description>
    </item>
    
    <item>
      <title>解析命令行输出</title>
      <link>https://ohmysummer.github.io/post/2016-09-27-%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA/</link>
      <pubDate>Tue, 27 Sep 2016 07:51:05 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-27-%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA/</guid>
      <description>哦, 列, 你在哪里? 当 ramiroencinas 给 Raku 的生态系统增加 FileSystem::Capacity::VolumesInfo模块的时候, 我说他没有添加 macOS 支持。而当我尝试为这个模块贡献源代码时我才发现知道一丢丢 Raku 的特性就能节省很多时间。 FileSystem::Capacity::VolumesInfo 这个模块所做的就是解析 df 命令的输出, 它看起来长这样:
$ df -k -P Filesystem 1024-blocks Used Available Capacity Mounted on /dev/disk3 1219749248 341555644 877937604 29% / devfs 343 343 0 100% /dev /dev/disk1s4 133638140 101950628 31687512 77% /Volumes/Untitled map -hosts 0 0 0 100% /net map auto_home 0 0 0 100% /home map -fstab 0 0 0 100% /Network/Servers //Pawel%20Pabian@biala-skrzynka.</description>
    </item>
    
    <item>
      <title>I left my keys in a side-channel</title>
      <link>https://ohmysummer.github.io/post/2016-09-26-i-left-my-keys-in-a-side-channel/</link>
      <pubDate>Mon, 26 Sep 2016 12:17:59 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-26-i-left-my-keys-in-a-side-channel/</guid>
      <description>当我尝试把选项聚合到一个模块中时我无意中发现了一个常见问题的简洁解决办法。我想拥有一个子例程作为吞噬具名参数、做一些检查、并且要么返回 True 以满足那个 where 从句, 要么死掉并抛出一个合适的错误信息的 where 从句。 那很简单但是不彻底。那个 where 从句没有提供它所检查的参数的名字, 这需要拥有一个合适的错误信息。我们来简化下代码。
sub checker(*%colon-keys){ sub ($value-from-where-clause) { True } } sub f( *%h where checker(:a, :b, :c) ) {}  子例程 checker 在 where 从句真正检测任何东西之前被调用。在 Raku 中 where 从句是一种句法。如果提供一个表达式，它会调用该表达式，并保持它的返回值然后针对 %h 的值做实际检查。这并不在编译时发生，且返回值不进行缓存。在我们的例子中返回一个接受一个参数(where需要的)的匿名子例程，并且必须返回 True 以让 where 从句的检查通过。
如你所见 checker 接收一组冒号对(colon-pairs)。剩下的问题我们能提供给我们可能要输出的异常，特别的附加信息。如果我们希望该参数是可选的，避免奇怪的语法。我们可以有一个可选的位置，但我们就不能在checker中混合位置和具名参数。存储该值将是微不足道，因为返回的匿名子例程可以具有闭包变量。我们只需要填充它。幸运的是，子返回作为引用返回，然后由那个 where 从句调用。我们可以偷偷加进另一个呼叫，只要我们大家别忘了把代码引用返回给匿名子例程(sub)。
返回引用给同一个对象是通过链式方法调用完成的。通常情况下，当事情在 Raku 的领地上变得复杂时，我们就混入一个 role 好了。然后，我们有了一个可以返回自身的方法。
use v6; sub g($i){ my $closure-variable; sub ($value-from-where-clause) { say [$closure-variable, $value-from-where-clause]; $value-from-where-clause == $i or die &amp;quot;bad value $value-from-where-clause for $closure-variable&amp;quot; } but role :: { method side-channel($second-value){ $closure-variable = $second-value; self } } } sub f($a where g(42).</description>
    </item>
    
    <item>
      <title>These keys are LTA</title>
      <link>https://ohmysummer.github.io/post/2016-09-26-these-keys-are-lta/</link>
      <pubDate>Mon, 26 Sep 2016 12:15:14 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-26-these-keys-are-lta/</guid>
      <description>在折腾枚举作为子例程布尔选项的时候, 我发现默认的错误信息不够酷。
 Constraint type check failed for parameter &#39;@options&#39;  让错误信息变得更具体有点困难。我们来创建几个 exceptions 来告诉我们当东西出错时究竟发生了什么。
class X::Paramenter::Exclusive is Exception { has $.type; method message { &amp;quot;Parameters of {$.type.perl} are mutual exclusive&amp;quot; } }  现在我们能检查 Find::Type 的选项是否是独占的从而抛出异常。
&amp;amp;&amp;amp; ( exclusive-argument(@options, Find::Type) or fail X::Paramenter::Exclusive.new(type =&amp;gt; Find::Type) ) class X::Parameter::UnrecognisedOption is Exception { has $.type; has $.unrecognised; method message { &amp;quot;Option { $.unrecognised } not any of { $.type.map({ (.^name ~ &#39;::&#39;) xx * Z~ .</description>
    </item>
    
    <item>
      <title>键是可选的</title>
      <link>https://ohmysummer.github.io/post/2016-09-26-%E9%94%AE%E6%98%AF%E5%8F%AF%E9%80%89%E7%9A%84/</link>
      <pubDate>Mon, 26 Sep 2016 12:04:56 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-26-%E9%94%AE%E6%98%AF%E5%8F%AF%E9%80%89%E7%9A%84/</guid>
      <description>Keys are optional Keys are optional
在我探索一个并发的 File::Find 模块时我发现我需要一组排序用的参数(例如 Bool)和互相排斥的参数。枚举相当易于组合, 把好用的名字引入到作用域中(直接地或通过 export)并且应该让相互排斥变得容易。容易的那部分有点幼稚因为类型化的吞噬参数尚未支持(还没有)。如果没有容易的方式, 肯定会有一个可行的困难的方式。
首先, 我们定义两个枚举用作要查找的选项。
package Find { enum Type (&amp;lt;File Dir Symlink&amp;gt;); enum Options (&amp;lt;Recursive Keep-going&amp;gt;); }  现在我们可以让一个 where 从句首先检查吞噬数组的所有成员要么是 Find::Type 类型要么是 Find::Options 类型。然后我们可以检查 Find::Options 拥有多少个元素。因为如果有太多的话只有一个我们可以抱怨独占。
+@options where { @options.all (elem) (Find::Type::.values (|) Find::Options::.values) &amp;amp;&amp;amp; (+(@options.grep: * ~~ Find::Type) &amp;lt;= 1 or die &amp;quot;can only check for one type at a time&amp;quot;) }  在主体中我们可以使用 junctions 和智能匹配来检查选项是否出现。</description>
    </item>
    
    <item>
      <title>这些是你的键吗</title>
      <link>https://ohmysummer.github.io/post/2016-09-26-%E8%BF%99%E4%BA%9B%E6%98%AF%E4%BD%A0%E7%9A%84%E9%94%AE%E5%90%97/</link>
      <pubDate>Mon, 26 Sep 2016 12:01:22 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-26-%E8%BF%99%E4%BA%9B%E6%98%AF%E4%BD%A0%E7%9A%84%E9%94%AE%E5%90%97/</guid>
      <description>Are these your keys? are these your keys
在键是常量的散列中我经常打错键的名字。通过混合一个重载方法 AT-KEY 的 role 让键限制在一个给定的字符串列表中并不困难。但是那会是一个运行时错误并且用一个运行时错误代替另一个运行时错误。
枚举确实拥有一组常量值的键并提供散列能使用的同一性。Raku 的确允许枚举作为键的约束并且如果我们查询了一个没有定义为枚举的键的话会在编译时抛出异常。 然而, 如果我们把散列限制为一组给定的键, 我们可能想要输出所有可能的键, 而不仅仅是有关联值的那些键。我们可以通过混进一个 role 来解决它。
enum Noms(&amp;lt;Greenstuff Walkingstuff Syntetics&amp;gt;); (my %eaten{Noms} is default(0)) does role :: { method keys { Noms::.values } method kv { gather for self.keys -&amp;gt; \k { take k, self.{k} } } }; %eaten{Greenstuff}++; dd %eaten; # Hash[Any,Noms]+{&amp;lt;anon|75781152&amp;gt;} %eaten = (my Any %{Noms} = Noms::Greenstuff =&amp;gt; 1) dd %eaten.keyof; # Noms dd %eaten.</description>
    </item>
    
    <item>
      <title>Whatever Star</title>
      <link>https://ohmysummer.github.io/post/2016-09-25-whatever-star/</link>
      <pubDate>Sun, 25 Sep 2016 16:14:05 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-25-whatever-star/</guid>
      <description>Whatever 是什么?  Placeholder for unspecified value/parameter - 未指定的值/参数的占位符。
 * 字面量在 「term」 位置上创建 「Whatever」 对象。 * 的大部分魔法来自于 「Whatever 柯里化」. 当 * 作为 item 与很多操作符组合使用时, 编译器会把表达式转换为 「WhateverCode」 类型的闭包.
my $c = * + 2; # same as -&amp;gt; $x { $x + 2 }; say $c(4); # 6  如果一个表达式中有 N 个 *, 则会产生一个含有 N 个参数的闭包:
my $c = * + *; # same as -&amp;gt; $x, $y { $x + $y }  在复杂的表达式中使用 * 也会产生闭包:</description>
    </item>
    
    <item>
      <title>Raku 中的冒号</title>
      <link>https://ohmysummer.github.io/post/2016-09-24-raku%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</link>
      <pubDate>Sat, 24 Sep 2016 20:55:11 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-24-raku%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</guid>
      <description>Raku Colons 在 Raku 中到处都是冒号, 我搜集了你在 Raku 中使用冒号的所有方式。
Larry 语言再设计第一定律: 每个人都想要冒号 Larry 语言再设计第二定律: Larry 成为冒号
这些都是主题的变体，尤其是“冒号对”语法主题。如果冒号的两种用法看起来不同，或者在不同的用法上下文中不同，即使它们在技术上是相同的，我更愿意说明这两种用法。
命名空间 # namespace package A::B { ... } class A::B { ... } # Namespace separator my $x = A::B.new; # Dynamic namespace my $x = ::(&amp;quot;A::B&amp;quot;).new; # Pseudopackage representing null namespace say ::; # Anonymous class class :: is Int {...} # Current class in a compile-tiem var class Who { method myname { say ::?</description>
    </item>
    
    <item>
      <title>Learning Raku - sets</title>
      <link>https://ohmysummer.github.io/post/2016-09-19-learning-raku-sets/</link>
      <pubDate>Mon, 19 Sep 2016 22:56:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-19-learning-raku-sets/</guid>
      <description>Quick Tip #8: Raku sets Set – a collection of unique thingys Bag - a collection of unique thingys,but weighted for the count of the number of times something is put the bag Mix - a bag that allows fractional weights
这些是不可变类型。一旦生成就不可变了。每一个都有一个 Hash 版本以允许你更改成员, 但是我会忽略这些。
$ raku &amp;gt; my $set = set( 1, 2, 3, 4 ) set(4, 3, 1, 2) &amp;gt; 4 ∈ $set # member of True &amp;gt; 5 ∈ $set # member of False &amp;gt; 5 ∉ $set # not member of True &amp;gt; set( 2, 3 ) ⊆ $set # subset of True &amp;gt; set( 2, 6 ) ⊆ $set # subset of False  集合是一种更自然的查看一个值是否存在于一个值的列表中的方式。你可能每一个哈希和使用 :exists 来检查键，但集合会这样做（尽管那就是 Raku 集合现在在幕后为你所做的）：</description>
    </item>
    
    <item>
      <title>Python Vs Raku</title>
      <link>https://ohmysummer.github.io/post/2016-09-19-python-vs-raku/</link>
      <pubDate>Mon, 19 Sep 2016 09:15:54 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-19-python-vs-raku/</guid>
      <description>Python Vs Raku, 比较哪个写法更优雅简洁。
zip() # OUTPUT What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue.  Python
questions = [&#39;name&#39;, &#39;quest&#39;, &#39;favorite color&#39;] answers = [&#39;lancelot&#39;, &#39;the holy grail&#39;, &#39;blue&#39;] for q, a in zip(questions, answers): print &#39;What is your {0}? It is {1}.&#39;.format(q, a)  Raku
my @questions = (&#39;name&#39;, &#39; quest&#39;, &#39;favorite color&#39;); my @answers = (&amp;quot;lancelot&amp;quot;, &amp;quot;the holy grail&amp;quot;, &amp;quot;blue&amp;quot;); for zip(@questions, @answers) -&amp;gt; ($question, $answer) { say &amp;quot;What is you $question?</description>
    </item>
    
    <item>
      <title>feed 操作符</title>
      <link>https://ohmysummer.github.io/post/2016-09-18-feed%E6%93%8D%E4%BD%9C%E7%AC%A6/</link>
      <pubDate>Sun, 18 Sep 2016 22:56:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-18-feed%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid>
      <description>Sequencer Precedence
infix ==&amp;gt; 这个流操作符(feed operator)从它的左侧接收结果并把结果作为最后一个参数传递给下一个(右侧的)例程(routine)。
这个操作符的优先级很松散所以你需要使用圆括号把结果赋值给其它变量, 或者你甚至可以使用另外一个流操作符! 在接收单个参数或第一个参数为 block 的程序/方法的例子中, 你必须经常使用圆括号来调用(尽管这对于最后一个例程/方法不是必须的)。
# Traditional structure, read bottom-to-top my @result = sort # (4) Sort, result is &amp;lt;Earth People&amp;gt; grep { /&amp;lt;[PE]&amp;gt;/ }, # (3) Look for P or E map { .tc }, # (2) Capitalize the words &amp;lt;people of earth&amp;gt;; # (1) Start with the input # Feed (left-to-right) with parentheses, read top-to-bottom @result = ( &amp;lt;people of earth&amp;gt; # (1) Start with the input ==&amp;gt; map({ .</description>
    </item>
    
    <item>
      <title>对象哈希</title>
      <link>https://ohmysummer.github.io/post/2016-09-18-raku-calendar-2016-%E7%AC%AC%E4%B8%89%E5%A4%A9%E5%AF%B9%E8%B1%A1%E5%93%88%E5%B8%8C/</link>
      <pubDate>Sun, 18 Sep 2016 22:56:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-18-raku-calendar-2016-%E7%AC%AC%E4%B8%89%E5%A4%A9%E5%AF%B9%E8%B1%A1%E5%93%88%E5%B8%8C/</guid>
      <description>第三天　－　对象哈希
Raku 添加对象散列, 其键并不仅仅是字符串。这些键是值和类型的结合。这意味着对象可以被字符串化为同样的东西但是它们可以是不同的键。
普通的哈希构造：
use v6; my Int $int = 4; my Str $str = &amp;quot;4&amp;quot;; my IntStr $int_str = &amp;lt;4&amp;gt;; # Allomorph my %hash; %hash{$int} = &#39;Plain old number&#39;; %hash{$str} = &#39;String of digits&#39;; %hash{$int_str} = &#39;Dualvar&#39;; say &amp;quot;There are &amp;quot;, %hash.elems, &amp;quot; elements in the hash&amp;quot;; # this calls the .gist method, sorta like a dumper routine %hash.say;  结果显示该哈希中只有一个元素并且这个元素是我最后添加的那个：
There are 1 elements in the hash {4 =&amp;gt; Dualvar}  但是我也可以通过告诉哈希我想要它接受的对象来声明一个对象哈希（Object hash）。我可以使用　Any 对象来允许哈希接受任何东西：</description>
    </item>
    
    <item>
      <title>Data Dump</title>
      <link>https://ohmysummer.github.io/post/2016-09-10-data-dump/</link>
      <pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-09-10-data-dump/</guid>
      <description>for Raku 你们选对了, 这就是满足你们快速打印数据需要的. 如果你已经安装了 Term::ANSIColor的话,输出就会亮瞎你的狗眼!
选项 indent 默认缩进为 2
&amp;lt;...&amp;gt; say Dump({ some =&amp;gt; object }, :indent(4)); &amp;lt;...&amp;gt;  max-recursion 默认为 50
&amp;lt;...&amp;gt; say Dump({ some =&amp;gt; object }, :max-recursion(3)); &amp;lt;...&amp;gt;  :color( ) 默认为 :color(true), 安装了 Term::ANSIColor的情况下输出会带颜色. 当为 :color(False) 时关闭彩色.
用法 use Data::Dump; say Dump(%( key1 =&amp;gt; &#39;value1&#39;, key256 =&amp;gt; 1, ));  输出:
{ key1 =&amp;gt; &amp;quot;value1&amp;quot;.Str, key256 =&amp;gt; 1.Int, }  注意: 如果你已经安装了 Term::ANSIColor, 那么接下来就会让你吃惊了. 所以, 做好思想准备.</description>
    </item>
    
    <item>
      <title>Raku Shortcuts(第一部分)</title>
      <link>https://ohmysummer.github.io/post/2016-08-31-raku-shortcuts%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</link>
      <pubDate>Wed, 31 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-31-raku-shortcuts%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</guid>
      <description>查看原文
快捷(Shortcuts)是一个具有争议性的话题。有些人认为它让代码更快更易读。有些人认为它让代码变得更难度如果人们不熟悉那些快捷的话。这篇文章仅仅告诉你 Shortcuts 的东西, 用不用取决于你。让我们开始把。
类属性的公开 Getter/Setter &amp;ldquo;getter&amp;rdquo; 和 &amp;ldquo;setter&amp;rdquo; 的概念在很多语言中是共通的: 在你的类中有一个 &amp;ldquo;东西&amp;rdquo;, 并且你写了一个方法来设置或获取那个东西的值。以啰嗦的 Raku 方式来写, 这样的一个设置看起来像这样:
class Foo { has $!attr = 42; method attr is rw { $!attr } } my $obj = Foo.new; say $obj.attr; $obj.attr = 72; say $obj.attr; # 输出&amp;gt;&amp;gt; # 42 # 72  这就像它本来的那样简洁, 但公共属性通常足以使编写这点儿代码变得恼人。这就是为什么 $. twigil 存在的原因。单独使用它会创建一个 &amp;ldquo;getter&amp;rdquo;; 如果你还想要一个 &amp;ldquo;setter&amp;rdquo;, 需要使用 is rw 特性:
class Foo { has $.attr is rw = 42; } my $obj = Foo.</description>
    </item>
    
    <item>
      <title>哇, Raku!</title>
      <link>https://ohmysummer.github.io/post/2016-08-14-%E5%93%87raku/</link>
      <pubDate>Sun, 14 Aug 2016 13:14:00 +0100</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-14-%E5%93%87raku/</guid>
      <description>前言 Slides 地址 视频地址
答案地址
注意 Unicode  Raku 允许你使用 Unicode 的项和操作符。 这些 Unicode 都有对应的只使用 ASCII 字符的 Texas 变体, 如果你更喜欢使用它们, 到 http://docs.raku.org/language/unicode_texas 找到它们。
惰性列表和它们的使用 ## 惰性列表
我们来做点儿疯狂的事情吧&amp;hellip;例如创建一个无限列表(INIFINITE LIST)!
my @to-infinity-and-beyond = 0, 2 ... ∞; say @to-infinity-and-beyond[1008]; # 2016  来点更有用的东西: 处理大文件
for &#39;/tmp/4GB-file.txt&#39;.IO.words { .say; last if ++$ == 3; } say &amp;quot;Code took {now - INIT now} seconds to run&amp;quot;; # OUTPUT: # foo # bar # ber # Code took 0.</description>
    </item>
    
    <item>
      <title>大列表重构</title>
      <link>https://ohmysummer.github.io/post/2016-08-12-%E5%A4%A7%E5%88%97%E8%A1%A8%E9%87%8D%E6%9E%84/</link>
      <pubDate>Fri, 12 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-12-%E5%A4%A7%E5%88%97%E8%A1%A8%E9%87%8D%E6%9E%84/</guid>
      <description>Raku 最近(2015.9)经历的最大的变化就是 Great List Refactor(GLR), 俗称大列表重构。
它还很难解释！但是幸好有某些历史背景能帮助我们。 在 2014 年澳大利亚 Perl Workshop 会议上讨论了很多 GLR 的东西, Patrick Michaud 在它的博客上写了很多关于 GLR 的内容。
GLE 意图强调性能和列表和相关类型操作的一致性问题。改变这样的基本数据类型将会很痛苦。
通常 Perl 5 这样展开列表:
% perl -dE 1 -MData::Dumper [...snip...] DB&amp;lt;1&amp;gt; @foos=((1,2),3) DB&amp;lt;2&amp;gt; say Dumper \@foos $VAR1 = [ 1, 2, 3 ];  开始, 很多的 Raku 行为都模仿这种展平行为但是在去年年底的时候, 使用 non-flatterning(非展平)行为以保留原始数据结构的用法越来越多。
这样做和很多边界情况不一致并且 Rakudo 内部大量使用了一种叫做 Parcel 的数据类型, 之后 Parcel 被认为是一个 Bad Idea(糟糕的设计) — 主要是因为性能问题。
2015 年 7 月, Patrick 导入了一个涵盖 &amp;ldquo;Synopsis 7&amp;rdquo; 的孪生设计草案, 随后的月份中它变成官方的 S07。</description>
    </item>
    
    <item>
      <title>Abundant and Deficient Numbers</title>
      <link>https://ohmysummer.github.io/post/2016-08-11-abundant-and-deficient-numbers/</link>
      <pubDate>Thu, 11 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-11-abundant-and-deficient-numbers/</guid>
      <description>问题描述 abundant 数是其所有因子的和大于该数，而deficient数是其因子的和小于该数。
例如, 考虑数字 21。它的因子是 1, 3, 7 和 21, 这些因子的和是32。 因为 32 小于 2 x 21, 所以 21 是 deficient。它的差额是 2 x 21 - 32 = 10。
12 是第一个 abundant 数。它的因子是 1, 2, 3, 4, 6 和 12, 并且它们的和是 28。 因为 28 大于 2 x 12, 所以 12 是 abundant。它们的差额是 28 - 2 x 12 = 4。
输入描述 你会给定一个整数, 每行一个。例如:
18 21 9  输出描述 你的程序应该打印信息, 如果数字是 deficient, abundant(和它的abundance), 或者都不。例如:</description>
    </item>
    
    <item>
      <title>智能匹配</title>
      <link>https://ohmysummer.github.io/post/2016-08-03-%E6%99%BA%E8%83%BD%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-03-%E6%99%BA%E8%83%BD%E5%8C%B9%E9%85%8D/</guid>
      <description>智能匹配 智能匹配通常作用在当前”主题”(topic)上, 即作用在 $_ 变量上. 在下面的表格中, $_ 代表 ~~ 操作符的左侧, 或者作为 given 的参数, 或者作为其它主题化的参数. X 代表 ~~ 操作符右侧要匹配的模式, 或者在 when 后面的模式.(实际上, ~~ 操作符充当着一个小型的主题; 即, 为了右侧的计算, 它把 $_ 绑定到左侧的值上. 使用底层的 .ACCEPTS 形式来避免这种主题化.)
第一节包含了含有享有特权的语法; 如果匹配能通过那些条目之一完成, 那它就会那样做. 这些特别的语法是通过它们的形式而非它们的类型进行分派的. 否则就使用表格中的剩余部分,并且匹配会根据普通的方法分派规则进行分派. 允许优化器(optimizer)假定编译时之后没有定义额外的匹配操作符, 所以, 如果在编译时模式类型就显而易见的, 那么跳转表(jump table)可以被优化. 然而, 这部分表格的语法仍然有点特权的, 跟 ~~ 操作符一样, 是 Perl 中少有的几个不使用多重分派的操作符之一. 相反, 基于类型的智能匹配会被单个地分派给属于 X 模式对象的底层方法.
换句话说, 智能匹配首先根据模式(pattern)的形式或类型(下面的X)进行分派(dispatch), 然后那个模式自身决定是否和怎样注意主题($_)的类型. 所以, 下面表格中的第二列就是初始列. 第一列中的 Any 条目标示了模式要么不关心主题的类型, 要么把那个条目作为默认值, 因为上面列出的更具体的类型不匹配.
$_ X Type of Match Implied Match if (given $_) ====== ===== ===================== =================== Any True ~~ True (parsewarn on literal token) Any False ~~ False match (parsewarn on literal token) Any Match ~~ Successful match (parsewarn on literal token) Any Nil ~~ Benign failure (parsewarn on literal token) Any Failure Failure type check (okay, matches against type) Any * block signature match block successfully binds to |$_ Any Callable:($) item sub truth X($_) S03-smartmatch/any-callable.</description>
    </item>
    
    <item>
      <title>Raku Types--成人之美</title>
      <link>https://ohmysummer.github.io/post/2016-08-02-raku-types-%E6%88%90%E4%BA%BA%E4%B9%8B%E7%BE%8E/</link>
      <pubDate>Tue, 02 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-02-raku-types-%E6%88%90%E4%BA%BA%E4%B9%8B%E7%BE%8E/</guid>
      <description>Raku Types: 成人之美
在我的第一次大学编程语言课中， 我被告知 Pascal 语言在其它类型之外还拥有 Integer、Boolen 和 Stirng 类型。我知道了类型本来就该存在因为计算机很笨。当我在 C语言中涉猎的时候，我学到了更多有关 *int*、 char 和其它像在暖和的地方里地寄生虫， 还有我课桌底下嗡嗡的金属盒的声音。
Perl 5 没有类型，它给我的感觉就像骑着自行车无拘无束的追风少年，沿着斜坡而下。不久之后我一门心思钻到计算机硬件的缝隙中。我拥有数据并且我能用它做任何我想做的事， 只要我得到的不是错误的数据。当我搞定的时候，我从自行车上掉了下来并刮破了我的膝盖。
有了 Raku，鱼和熊掌可以兼得。你可以使用类型来避免它们。你可以拥有一个广域的类型来接收很多种类的值或窄类型。并且你可以享受代表机器智力的类型的速度， 或者你可以享受你自定义的代表你自己意志的类型的精度，类型为人类而生。
渐进类型 my $a = &amp;quot;whatever&amp;quot;; my Str $b = &amp;quot;strings only&amp;quot;; my Str:D $c = &amp;quot;defined strings only&amp;quot;; my int $d = 14; # native int sub foo ($x) { $x + 2 } sub bar (Int:D $x) returns Int { $x + 2 }  Raku 拥有渐进类型， 这意味着你要么可以使用它们，要么避免使用它们。所以究竟为什么要打扰它们呢？</description>
    </item>
    
    <item>
      <title>unspaces</title>
      <link>https://ohmysummer.github.io/post/2016-08-01-unspaces/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-01-unspaces/</guid>
      <description>有些语言例如 C 允许你转义一个换行符使行联合起来. 其它语言(例如正则表达式)因为各种各样的原因, 允许你使用反斜线转义一个空白符. Raku 把这种记法推广到任何种类的空白上. 通过在空白处前置一个 \, 任何相邻的空白(包括注释)都会在解析器面前隐身. 这就是鼎鼎大名的空白隐身( “unspace”).
在 Perl 中, 一个 unspace 能够抑制任意的几种空白附属物. 例如, 因为 Perl 要求名词和后缀操作符之间不能出现空白, 所以使用 unspace 让你可以把后缀操作符贴线对齐:
%hash\ {$key} @array\ [$ix] $subref\($arg)  上面的最后一种形式作为一种退化了的 unspace, 即反斜线后面直接跟着后缀. 注意, 反斜线前面不允许有空白, 所以:
$subref \($arg)  是语法错误(two terms in a row). 而
foo \($arg)  会被解析为带有 Capture 参数的列表操作:
foo(\($arg))  然而, 其它形式的 unspace 可能被有效地放在空白之前.
其它后缀操作符也可能使用 unspace:
$number\ ++; $number\ --; 1+3\ i; $object\ .say(); $object\#`{ your ad here }.</description>
    </item>
    
    <item>
      <title>学习Raku的一些网站</title>
      <link>https://ohmysummer.github.io/post/2016-07-25-%E5%AD%A6%E4%B9%A0raku%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/</link>
      <pubDate>Mon, 25 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-25-%E5%AD%A6%E4%B9%A0raku%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BD%91%E7%AB%99/</guid>
      <description> Blog  rakuintro raku.party Raku - Reddit Raku Tablet Rosetta Rosetta GitBook mfollett perlgeek Raku advent calendars RakuMaven Strangely Consistent Death by Raku jnthn 道  官方网站  raku.org Raku Documentation Raku Design Documents modules.raku.org pl6anet examples.raku.org Raku Features Raku 测试套件 Raku IRC  国内  sunnavy songzan 扶凯  </description>
    </item>
    
    <item>
      <title>HOW 方法</title>
      <link>https://ohmysummer.github.io/post/2016-07-22-how%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 22 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-22-how%E6%96%B9%E6%B3%95/</guid>
      <description>Why can&amp;rsquo;t I call the methods method on a Raku&amp;rsquo;s ClassHOW object?
我可以在某个对象身上调用 ^methods 方法, 以列出我能调用的方法的名字列表:
my $object = &#39;Camelia&#39; my @object_methods = $object.^methods; @object_methods.map( {.gist} ).sort.join(&amp;quot;\n&amp;quot;).say;  ^methods 返回一个列表, 通过对列表中的每个元素调用 .gist 方法, 得到一个人类友好的形式。
但是 ^methods 中的 ^ 暗含了 .HOW 方法:
我想下面这段代码本该有效的, 但是没有:
my $object = &#39;Camelia&#39;; my @object_objects = $object.HOW.methods;  但是我得到了一个错误:
Too few positionals passed; expected 2 arguments but got 1 in any methods at gen/moar/m-Metamodel.nqp line 490 in block &amp;lt;unit&amp;gt; at.</description>
    </item>
    
    <item>
      <title>The Awesome Errors of Raku</title>
      <link>https://ohmysummer.github.io/post/2016-07-20-the-awesome-errors-of-raku/</link>
      <pubDate>Wed, 20 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-20-the-awesome-errors-of-raku/</guid>
      <description>The Awesome Errors of Raku 如果你一直在读技术相关的东西，你现在可能知道 Rust 里面的令人惊喜的错误报告能力。 既然 Raku 也因它的绝妙的错误处理而闻名, mst 查询了一些例子来炫耀 rust 的错误处理能力, 但是不幸的是我没有发现。
我尽力避免错误并且我很少完整地读完它。所以我会搜寻一些很酷的关于令人惊叹的错误方面的例子并写出来。虽然我能够用头撞击键盘并把输出粘贴出来, 但是那将会惨不忍读, 所以我会谈论一些对初学者来说没那么明显的棘手的错误, 还有怎样修复那些错误。
让我们开始用头部猛击吧!
基础 下面是一段有错误的代码;
say &amp;quot;Hello world!; say &amp;quot;Local time is {DateTime.now}&amp;quot;; # ===SORRY!=== Error while compiling /home/zoffix/test.p6 # Two terms in a row (runaway multi-line &amp;quot;&amp;quot; quote starting at line 1 maybe?) # at /home/zoffix/test.p6:2 # ------&amp;gt; say &amp;quot;Local time is {DateTime.now}&amp;quot;; # expecting any of: # infix # infix stopper # postfix # statement end # statement modifier # statement modifier loop  第一行丢失了字符串上的闭合引号, 所以直到第二行的开括号之间的所有东西都会被认为是字符串的一部分。一旦推测的闭合引号被找到, Raku 就看到单词 &amp;ldquo;Local&amp;rdquo;, 这个单词被定义为一个项(item)。因为在 Raku 中一行中同时存在两个项(item)是不允许的, 所以编译器抛出了错误, 并对它所期望的提供了一些建议, 并且它探测到了我们正处在一个字符串中, 并且建议我们检测, 我们忘记在行 1 中闭合引号了。</description>
    </item>
    
    <item>
      <title>roundrobin</title>
      <link>https://ohmysummer.github.io/post/2016-07-18-roundrobin/</link>
      <pubDate>Mon, 18 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-18-roundrobin/</guid>
      <description>定义为
multi roundrobin(List:D: --&amp;gt; Seq)  用法
roundrobin LISTS  Round-Robin Merge Two Lists of Different Length roundrobin很像 zip。不同之处是, roundrobin不会在用光元素的列表上停止而是仅仅跳过任何未定义的值：
my @a = 1; my @b = 1..2; my @c = 1..3; for flat roundrobin(@a, @b, @c) -&amp;gt; $x { $x.say } # 1,1,1,2,2,3  它只是跳过了未定的值, 直到最长的那个列表的元素用完。
my @list1 = &#39;a&#39; .. &#39;h&#39;; my @list2 = &amp;lt;x y&amp;gt;; say flat roundrobin @list1, @list2; # a x b y c d e f g h  roundrobin 返回的是一列 Seq, 所以使用 flat 进行展开。</description>
    </item>
    
    <item>
      <title>副词的Pair形式</title>
      <link>https://ohmysummer.github.io/post/2016-07-16-%E5%89%AF%E8%AF%8D%E7%9A%84pair%E5%BD%A2%E5%BC%8F/</link>
      <pubDate>Sat, 16 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-16-%E5%89%AF%E8%AF%8D%E7%9A%84pair%E5%BD%A2%E5%BC%8F/</guid>
      <description>副词的 Pair 形式 S02-literals/adverbs.t lines 6–69
现在有一个普通的副词形式的 Pair 记号，也是人们所熟知的 &amp;ldquo;colon pair&amp;rdquo;（冒号对）形式。下面的表格展示了和胖箭头记号相一致的记号：
Fat arrow Adverbial pair Paren form ========= ============== ========== a =&amp;gt; True :a a =&amp;gt; False :!a a =&amp;gt; 0 :a(0) a =&amp;gt; $x :a($x) a =&amp;gt; &#39;foo&#39; :a&amp;lt;foo&amp;gt; :a(&amp;lt;foo&amp;gt;) a =&amp;gt; &amp;lt;foo bar&amp;gt; :a&amp;lt;foo bar&amp;gt; :a(&amp;lt;foo bar&amp;gt;) a =&amp;gt; «$foo @bar» :a«$foo @bar» :a(«$foo @bar») a =&amp;gt; {...} :a{...} :a({...}) a =&amp;gt; [...] :a[...] :a([...]) a =&amp;gt; $a :$a a =&amp;gt; @a :@a a =&amp;gt; %a :%a a =&amp;gt; &amp;amp;a :&amp;amp;a a =&amp;gt; %foo&amp;lt;a&amp;gt; %foo&amp;lt;a&amp;gt;:p  胖箭头结构应只用于项(term)所在位置因为它被认为是一个独立的表达式，因为胖箭头自身被解析为一个普通的中缀操作符（即使自动引起它左侧的标识符时）。因为左侧是一个普通的表达式，胖箭头形式会使用任何值作为键来创建 Pair。另一方面，当用上面的形式来生成 Pair 对象时，副词形式被约束为使用标识符作为键。在键不是标识符的地方，你必须使用胖箭头形式来生成 Pair。</description>
    </item>
    
    <item>
      <title>given when</title>
      <link>https://ohmysummer.github.io/post/2016-07-09-given-when/</link>
      <pubDate>Sat, 09 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-09-given-when/</guid>
      <description>given-when 有两个小的改变, 并且这俩改变都是开启新行为的, 而不是限制已存在的行为。
第一个小的改变: when 的开关行为不仅仅是用于 given 块儿中的, 而是可以用在任何&amp;rdquo;主题化&amp;rdquo;的块儿中的, 例如 for 循环中或接收 $_作为参数的子例程中。
given $answer { when &amp;quot;Atlantis&amp;quot; { say &amp;quot;那是对的&amp;quot; } default { say &amp;quot;BZZZZZZZZZZZZZ!&amp;quot; } } for 1..100 { when * %% 15 { say &amp;quot;Fizzbuzz&amp;quot; } when * %% 3 { say &amp;quot;Fizz&amp;quot; } when * %% 5 { say &amp;quot;Buzz&amp;quot; } default { say $_ } } sub expand($_) { when &amp;quot;R&amp;quot; { say &amp;quot;红警&amp;quot; } when &amp;quot;G&amp;quot; { say &amp;quot;绿警&amp;quot; } when &amp;quot;B&amp;quot; { say &amp;quot;蓝警&amp;quot; } default { say $_ } }  但是甚至不接受 $_作为参数的子例程也得到了它们自己的词法变量 $_供修改。所以规则就是&amp;rdquo;现在, 在 $_ 中有某些我能启动的好东西吗&amp;rdquo;。如果我们想要, 我们甚至能自己设置 $_。</description>
    </item>
    
    <item>
      <title>It&#39;s blocks all the way down</title>
      <link>https://ohmysummer.github.io/post/2016-07-07-its-blocks-all-the-way-down/</link>
      <pubDate>Thu, 07 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-07-its-blocks-all-the-way-down/</guid>
      <description>It’s blocks all the way down
当我在 glot.io 上玩 Raku 的时候我知道它们真的很像带有简单程序的 docker：
dir(&#39;/&#39;)&amp;gt;&amp;gt;.Str.say;  我想知道递归到目录里面是否还有更好的方法。 IO::Path.dir 会返回一个 IO::Path 对象的 Seq 序列。那就是为什么 &amp;gt;&amp;gt;. 超运算符会有效。它当然不会递归因为没有用来进行递归的子例程, 经过一段时间的冥思苦想我找到了我找了很久的东西。
在 Raku 中带有一个位置参数的 block 块是可调用的(Callable)。那个参数被绑定给主题变量 $_。 那是我们为什么能做:
for 1,2,3 {.say}  递归到目录中会很容易如果我们把 Str &#39;/&#39; 变成 IO::Path 对象并且检测我们是否得到了一个目录并且使用那个元素调用那个 block 块。那个 block 块需要一个名字, 这个我们可以通过使用 my &amp;amp;block = {Nil} 做到, 或者我们使用编译时变量 &amp;amp;?BLOCK。
for &#39;.&#39; { .Str.say when !.IO.d; .IO.dir()&amp;gt;&amp;gt;.&amp;amp;?BLOCK.IO.d }  .&amp;amp;?BLOCK 形式会把调用看作像方法调用一样, 这意味着 . 号左侧的对象会成为调用的第一个参数, 在调用者所属的地方。
我相信这是一个相当好的关于怎样使用 &amp;amp;?BLOCK 来避免嵌套循环和短变量的例子。这会在稍后被添加到文档中。</description>
    </item>
    
    <item>
      <title>Raku 中的梳子!</title>
      <link>https://ohmysummer.github.io/post/2016-07-07-raku%E4%B8%AD%E7%9A%84%E6%A2%B3%E5%AD%90/</link>
      <pubDate>Thu, 07 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-07-raku%E4%B8%AD%E7%9A%84%E6%A2%B3%E5%AD%90/</guid>
      <description>Raku 中的梳子! 在 Perl 5 中, 我很感激有这样两个便利的结构:
my @things = $text =~ /thing/g; my %things = $text =~ /(key)...(value)/g;  你拿出一小段可以预见的文本，并给它一个正则表达式，吼吼, 你得到了一个列表和散列，像变魔术一般！我们也可以在 Perl 6 中使用正则表达式，但是 comb 更适合做这个工作。
Plain &amp;lsquo;Ol Characters 你可以把 comb 用作子例程或方法。在它的最基本的形式中， comb 会把字符串分解为字符:
&#39;foobar moobar 駱駝道bar&#39;.comb.join(&#39;|&#39;).say; &#39;foobar moobar 駱駝道bar&#39;.comb(6).join(&#39;|&#39;).say; # OUTPUT: # f|o|o|b|a|r| |m|o|o|b|a|r| |駱|駝|道|b|a|r # foobar| mooba|r 駱駝道b|ar  不适用任何参数的 comb 你会得到各个单独的字符。给 comb 提供一个整数 $n, 那么你会得到长度至多为 $n 个字符的一个列表，并且如果没有剩下的字符不够的话，这个列表会接收较短的这个字符串。这个方法比使用正则表快了 30 倍。
Limits 你也可以为 comb 提供第二个整数参数，即 *limit*，来标示每个列表中最多含有 limit 个元素:</description>
    </item>
    
    <item>
      <title>Raku 中的正则表达式(二)</title>
      <link>https://ohmysummer.github.io/post/2016-06-29-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%8C/</link>
      <pubDate>Wed, 29 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-29-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%8C/</guid>
      <description>允许的修饰符 有些修饰符能在所有允许的地方出现, 但并非所有的都这样.
通常, 影响 regex 编译的修饰符( 像 :i ) 一定要在编译时被知道. 只影响行为而非 regex本身的修饰符(eg. :pos, :overlap, :x(4)) 可能只出现在引用某个调用的结构上(例如 m// 和s///), 并且不会出现在 rx// 上. 最后, 重叠在替换结构中是不被允许的, 而影响修改的副词只允许出现在替中.
这些准则导致了下面的 rules:
 :ignorecase, :ignoremark, :sigspace, :ratchet 和  :Perl5 修饰符和它们的便捷形式允许出现在 regex 中的任何地方, 还有 m//, rx// 和s/// 结构中. 一个 regex实现可能要求它们的值在编译时是被知晓的, 而如果不是这种情况则给出编译时错误信息.  rx:i/ hello / # OK rx:i(1) /hello/ # OK my $i = 1; rx:i($i) /hello/ # may error out at compile time   :samecase, :samespace 和 :same mark 修饰符(还有它们的便捷形式) 只允许出现在替换结构上 (s/// 和 s[] = .</description>
    </item>
    
    <item>
      <title>Raku 圣诞月历-(2011)</title>
      <link>https://ohmysummer.github.io/post/2016-06-28-raku%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2011/</link>
      <pubDate>Tue, 28 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-28-raku%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2011/</guid>
      <description>2011 The Flip-Flop operator Perl5有一个二元操作符叫做flip-flop,它为假直到它的第一个参数被计算为真，然后它保持真(反转)，直到第二个参数计算为真，然后在那里它又变成假(flop)。 这真是太有用了，以至于Raku也有flip-flop,只是它拼写为ff,并有一些变异：
ff ff^ ^ff ^ff^  音调符号^意味着在那个结尾跳过结尾。 …或许一些例子更能说明问题…
for 1..20 { .say if $_ == 9 ff $_ == 13; } # 9 10 11 12 13 for 1..20 { .say if $_ == 9 ff^ $_ == 13; } # 9 10 11 12 for 1..20 { .say if $_ == 9 ^ff $_ == 13; } # 10 11 12 13 for 1.</description>
    </item>
    
    <item>
      <title>S06-Subroutines</title>
      <link>https://ohmysummer.github.io/post/2016-06-27-s06-subroutines/</link>
      <pubDate>Mon, 27 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-27-s06-subroutines/</guid>
      <description>原文Subroutines
标题 概要 6: 子例程
版本 创建于: 2003 年 5 月 21
上一次更新: 2015 年 10 月 16
版本: 169
该文档总结了概要 6, 其中涵盖了子例程和新的类型系统。
子例程和其它 code 对象 Routine 是所有以关键字声明的 code blocks 的父类型。所有的 routines(程序)生来就带有未定义的 $_、$!和$/ 值, 除非该 routine 显式地声明了它们。一个编译单元, 例如模块文件或 EVAL 字符串, 也被看作是 routine, 要不然你就不能引用它们里面的 $! 或 $/。
使用 -&amp;gt; 声明或使用裸花括号的非-routine 的 code Blocks, 生来只有 $_, 它被别名到它的 OUTER::&amp;lt;$_&amp;gt; 上, 除非被绑定为参数。 block 通常使用由最里面的闭合 routine 所定义的 $! 和 $/, 除非在 block 中显式地声明了 $! 或 $/。</description>
    </item>
    
    <item>
      <title>给标题添加换行</title>
      <link>https://ohmysummer.github.io/post/2016-06-19-%E7%BB%99%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%8D%A2%E8%A1%8C/</link>
      <pubDate>Sun, 19 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-19-%E7%BB%99%E6%A0%87%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%8D%A2%E8%A1%8C/</guid>
      <description>简书太扯了, 不管是什么空格都替换掉了。 开门见山, 废话不多说。如果非标题行在标题行上面, 那么这俩行之间会有一段空白, 但是你肯定遇到过:
这个标题会和下面的非标题行贴在一块 即使我在这一行换行也于事无补, 它们被简书吃掉啦。这不能忍! 看起来很丑有没有？下面我们就来解决这个问题, 手动在这一行的上面加上一个全角的空格, 就 okay 了。
问题似乎已经解决了, 但是我不能够。必须写个程序来帮我们解决这烦人的问题。方法就是在标题行后面添加一个换行符和一个全角空格（测试后行不通, 还是被吃, 换成 &amp;lt;br&amp;gt; 吧）。
use v6; for dir(test =&amp;gt; /\. md|markdown $/) -&amp;gt; $file { my $out = open $file ~ &#39;.txt&#39;, :w; my @lines = $file.lines; for @lines -&amp;gt; $line is rw { if $line ~~ /^\s*$/ { $out.say($line); next; } $line ~~ s/^ (&#39;#&#39; ** 1..7 .*?) $/$0\n &amp;lt;br&amp;gt;/ unless $line ~~ /^\s*&#39;```&#39;\s*(\w+)?</description>
    </item>
    
    <item>
      <title>Raku FAQ</title>
      <link>https://ohmysummer.github.io/post/2016-06-06-raku-faq/</link>
      <pubDate>Mon, 06 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-06-raku-faq/</guid>
      <description>源文件可以在 github 或 raku.org上找到.
General Rakudo 和 Raku 的区别是什么？ Rakudo 是 Raku 的一个实现。目前它是完成度最好的但是过去也有其它的实现, 将来也可能会有其它实现。Raku 是语言的定义。很多场合
这两个名字可以宽松地使用并互相替换。
会有 Raku 版本 6.0.0 吗? 第一个稳定语言版本的版本称为 v6.c，而不是 6.0.0。 不同的命名方案使得不太可能发布具有精确版本 6.0.0 的语言。
您可以使用下面的代码检查您的 Rakudo 编译器是当前至少是什么版本（注意这可能不是真正的供应商二进制文件）：
raku -e &#39;say q[too old] if $*PERL.version before Version.new(q[6.c])&#39;  它首先由 Rakudo Raku 编译器版本的 2015.12 实现，并且可能通过使用 &amp;lsquo;use 6.c&amp;rsquo; 指令在可预见的未来支持后续版本。 下一个语言版本（无发布日期）为 v6.d.
作为一个 Raku 初学者我应该安装什么？ 如果你是一个 Linux 或 Mac 用户, 你可能需要下载 Rakudo Star 并通过编译 MoarVM 版本安装（一个简单的处理）
如果你是一个 Windows 32 或 64 位用户, 那么 Rakudo Star 二进制版本在 rakudo 网站也能获得。你需要 Windows Git 来使用 panda。</description>
    </item>
    
    <item>
      <title>如何在Raku中创建Grammar</title>
      <link>https://ohmysummer.github.io/post/2016-05-14-%E5%A6%82%E4%BD%95%E5%9C%A8raku%E4%B8%AD%E5%88%9B%E5%BB%BAgrammar/</link>
      <pubDate>Sat, 14 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-05-14-%E5%A6%82%E4%BD%95%E5%9C%A8raku%E4%B8%AD%E5%88%9B%E5%BB%BAgrammar/</guid>
      <description>检查 module 的名字是否 遵循 Raku 的命名规范。模块的名字可以是使用 2 个冒号分割的标识符, 例如 File::Compare 。标识符必须以字母字符 (a-z) 或下划线开头， 后面跟着 0 个 或多个字母数字字符。但是并没有那么简单, 有些模块的名字只有一个标识符而没有冒号，例如 Bailador ， 而其它模块可能有多个标识符和 :: 组成。这看起来正符合 grammar 的胃口！
定义 grammar Raku Grammars 是由 regexes 构建的。 我需要 2 个 regexes： 一个用于匹配标识符, 一个用于匹配双冒号分隔符。对于标识符 regex， 我使用：
&amp;lt;[A..Za..z_]&amp;gt; # begins with letter or underscore &amp;lt;[A..Za..z0..9]&amp;gt; ** 0..* # zero or more alpanumeric  Raku 中，字符类是使用 &amp;lt;[ ... ]&amp;gt; 来定义的， 范围是使用 范围操作符 .. 代替了短划线 -. 量词使用 ** 0.</description>
    </item>
    
    <item>
      <title>Actions 和抽象语法树</title>
      <link>https://ohmysummer.github.io/post/2016-05-12-actions%E5%92%8C%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/</link>
      <pubDate>Thu, 12 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-05-12-actions%E5%92%8C%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91/</guid>
      <description>有一段结构化的文本, 写一个 Grammar 来解析它：
name = Animal Facts author = jnthn [cat] desc = The smartest and cutest cuteness = 100000 [dugong] desc = The cow of the sea cuteness = -10 [magpie] desc = crow; raven; rook; jackdaw; chough; magpie; jay cuteness = 99  每一段都是一个章节, 有的章节没有[cat]这样的标题, 要求 grammar 生成一个散列, 散列的键是方括号中的单词, 如果没有就默认为 _ , 散列的值是一个散列的数组, 数组里面的每个散列的键为等号左边的单词, 键值为等号右边的字符。Grammar 如下:
use v6; #use Grammar::Debugger; grammar INIFile::Grammar { token TOP { ^ &amp;lt;entries&amp;gt; # 条目 &amp;lt;section&amp;gt;+ # 章节 $ } token section { &#39;[&#39; ~ &#39;]&#39; &amp;lt;key&amp;gt; \n &amp;lt;entries&amp;gt; # 每个章节含有多个条目 entry } token entries { [ | &amp;lt;entry&amp;gt; \n | \n # entry 可以为空 ]+ } token entry { &amp;lt;key&amp;gt; \h* &#39;=&#39; \h* &amp;lt;value&amp;gt; } token key { \w+ } token value { \N+ } } class INIFileActions { method entries($/) { my %entries; for $&amp;lt;entry&amp;gt; -&amp;gt; $e { %entries{$e&amp;lt;key&amp;gt;} := ~$e&amp;lt;value&amp;gt;; } make %entries; } method TOP($/) { my %result; %result&amp;lt;_&amp;gt; := $&amp;lt;entries&amp;gt;.</description>
    </item>
    
    <item>
      <title>列表解析</title>
      <link>https://ohmysummer.github.io/post/2016-05-11-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-05-11-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90/</guid>
      <description>列表解析 列表解析即 List Comprehensions。
生成 1x1, 2x2, 3x3, ..., 10x10 的列表：
($_**2 for 1..10);  for 语句前面还可以添加 if 修饰符，这样我们就可以仅筛选出偶数的平方：
($_**2 if !($_ % 2) for 1..10) ($_**2 if $_ % 2 == 1 for 1..10) # 同上  组合多个 if 条件:
my @list = ($_ if $_ %2 == 1 &amp;amp;&amp;amp; $_ &amp;gt; 2 for 1..6 ) # [3 5]  还可以生成全排列：
($_ for &amp;quot;ABC&amp;quot;.comb X~ &amp;quot;XYZ&amp;quot;.comb) # (&amp;quot;AX&amp;quot;, &amp;quot;AY&amp;quot;, &amp;quot;AZ&amp;quot;, &amp;quot;BX&amp;quot;, &amp;quot;BY&amp;quot;, &amp;quot;BZ&amp;quot;, &amp;quot;CX&amp;quot;, &amp;quot;CY&amp;quot;, &amp;quot;CZ&amp;quot;) my @a = (1,3,4) my @b = (2,4,6) my @list = (@a X @b) # 这儿也可以用圆括号, 也可以不用 # [(1 2) (1 4) (1 6) (3 2) (3 4) (3 6) (4 2) (4 4) (4 6)]  &amp;gt; ($_ when /7$/ for 1.</description>
    </item>
    
    <item>
      <title>输入Unicode字符</title>
      <link>https://ohmysummer.github.io/post/2016-05-11-%E8%BE%93%E5%85%A5unicode%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-05-11-%E8%BE%93%E5%85%A5unicode%E5%AD%97%E7%AC%A6/</guid>
      <description>输入 Unicode 字符 Raku 允许把 unicode 字符用作变量名. 很多操作符使用 unicode 符号(特别是在 set/bag 操作符中)还有一些引号结构. 因此, 知道如何把这些符号输入编辑器, Raku shell 和 命令行中是极好的, 特别是现实键盘中不存在那个符号的时候.
在各种操作系统和环境下关于输入 unicode 字符的通用信息可以在 Wikipedia unicode input page 中找到.
编辑器和 shell Vim 在 Vim 中, unicode 字符是通过先按 Ctrl-V(也表示为 ^V), 然后按下 u 和 要输入的 unicode 字符的十六进制值来输入的(在插入模式). 例如, 希腊字母 λ (lambda) 是通过组合键来输入的:
^Vu03BB  更多关于在 Vim 中输入特殊字符的信息可以在 Vim Wikia 页 entering special characters 中找到.
Emacs 在 Emacs 中, unicode 字符的输入是首先输入和弦 Ctrl-x 8 Enter , 然后再输入 unicode 代码点的十六进制数字, 然后回车.</description>
    </item>
    
    <item>
      <title>Raku 中的操作符(二)</title>
      <link>https://ohmysummer.github.io/post/2016-05-02-raku%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BA%8C/</link>
      <pubDate>Mon, 02 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-05-02-raku%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BA%8C/</guid>
      <description>infix:&amp;lt;&amp;hellip;&amp;gt;, 序列操作符.  作为一个中缀操作符， ... 操作符的左右两侧都有一个列表，并且为了产生想要的值的序列，序列操作符 ... 会尽可能地对序列进行惰性求值。列表被展平后求值。就像所有的中缀操作符一样， &amp;hellip; 序列操作符比逗号的优先级要低，所以你没必要在逗号列表的两侧加上圆括号。
序列操作符 ... 以右侧列表的第一个值开始。这只在右侧的列表中， &amp;hellip; 序列操作符唯一感兴趣的值；any additional list elements are treasured up lazily to be returned after the &amp;hellip; is done.
&amp;hellip; 右侧的第一个值是序列的端点或界限，这是序列操作符 &amp;hellip; 从左侧生成的。
一旦我们知道了序列的边界，左侧的列表会一项一项地被求值，并且普通数字或字符串值被无差异地传递（在右侧边界允许的程度内）如果序列中的任何值匹配到边界值，序列会终止，包括那个最后的边界值在内。要排除边界值，使用 &amp;hellip;^ 代替。
在内部，这两种形式用于检测匿名的循环是否会终止，而循环返回序列中的值。假设下一个候选的值存储在 $x 中，并且右侧序列中的第一个值存储在 $limit 中，这两个操作符各自实现为：
... last($x) if $x ~~ $limit; ...^ last if $x ~~ $limit;  如果边界是 * ,序列就没有界限。如果边界是一个闭包，它会在当前候选对象中进行布尔真值求值，并且序列会一直继续只要闭包返回false。如果边界是一个含有一个或无限参数的闭包，
my $lim = 0; 1,2,3 ...^ * &amp;gt; $lim # returns (), since 1 &amp;gt; 0  这个操作符如果只能把左边的值原样返回就太乏味了。它的强大来自于能从旧值生成新值。你可以，例如，使用一个存在的生成器产生一个无穷列表：</description>
    </item>
    
    <item>
      <title>Raku From Wikipedia</title>
      <link>https://ohmysummer.github.io/post/2016-04-26-raku-from-wikipedia/</link>
      <pubDate>Tue, 26 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-26-raku-from-wikipedia/</guid>
      <description>Raku 是 Perl 编程语言家族中的一员. 它仍旧在开发中, 几个解释器和编译器在同时进行. 它引入了很多现代和历史语言的元素. Raku 打算有很多实现. 和 Perl 5 兼容不是它的目标, 尽管兼容模式是它的计划书的一部分. Raku 的设计程序是从 2000 年开始的. 2015 年 9 月 预期会发布候选版, 并在 12 月 发布最终版.
Raku 第一个完成度最高的实现是 Pugs , 开始于 2005 年, 今天已经有多个 Raku 实现的工程了. Rakudo Perl 是基于 NQP (Not Quite Perl) 并使用 MoarVM 或 Java 虚拟机 作为运行时环境的一个 Raku 实现, 并且每个月会发布一个新版本; 在 2010 年 七月, 该项目发布了第一次 Rakudo Star 分发, 一个有用和可用的 Raku 实现和相关东西的集合. Larry Wall 维护了一个众所周知的叫做 STD.pm6 的引用文法, 它是用 Raku 写的, 并使用 Perl 5 驱动 (bootstrapped)</description>
    </item>
    
    <item>
      <title>Meta Operator</title>
      <link>https://ohmysummer.github.io/post/2016-04-25-meta-operator/</link>
      <pubDate>Mon, 25 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-25-meta-operator/</guid>
      <description>快速构造散列 &amp;gt; my %hash = @lowers Z=&amp;gt; @nums a =&amp;gt; 1, b =&amp;gt; 2, c =&amp;gt; 3  未完待续</description>
    </item>
    
    <item>
      <title>Raku 中的特性(一)</title>
      <link>https://ohmysummer.github.io/post/2016-04-22-raku%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%80/</link>
      <pubDate>Fri, 22 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-22-raku%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%80/</guid>
      <description>基础 数组 切片, 索引, Zen
use v6; my @primes = (2,3,5,7,11,13,17,19,23); # an array gets filled like in Perl 5 # my @primes = 2,3,5,7,11,13,17,19,23 ; # same thing, since unlike P5 round braces just do group # my @primes = &amp;lt;2 3 5 7 11 13 17 19 23&amp;gt;; # dito, &amp;lt;&amp;gt; is the new qw() say @primes[]; # 2 3 5 7 11 13 17 19 23 my $arrayref = [2,3,5,7,11,13,17,19,23]; # in scalar context you get automatically a reference say @$arrayref; # 2 3 5 7 11 13 17 19 23 my $arrayref = item @primes; # same thing, more explicit say $arrayref; my $arrayref = [13,]; # comma is the new array generator say $arrayref; my @primes = 2; # array with one element my @primes = [2,3,5,7,11,13,17,19,23]; # array with one element (arrayref) say @primes; # 2 3 5 7 11 13 17 19 23 my @dev = {&#39;dan&#39; =&amp;gt; &#39;parrot&#39;}; # array with one element (hashref) say @dev; # (&amp;quot;dan&amp;quot; =&amp;gt; &amp;quot;parrot&amp;quot;).</description>
    </item>
    
    <item>
      <title>reddit编程题-詹妮的水果篮</title>
      <link>https://ohmysummer.github.io/post/2016-04-12-reddit%E7%BC%96%E7%A8%8B%E9%A2%98-%E8%A9%B9%E5%A6%AE%E7%9A%84%E6%B0%B4%E6%9E%9C%E7%AF%AE/</link>
      <pubDate>Tue, 12 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-12-reddit%E7%BC%96%E7%A8%8B%E9%A2%98-%E8%A9%B9%E5%A6%AE%E7%9A%84%E6%B0%B4%E6%9E%9C%E7%AF%AE/</guid>
      <description>问题描述 小詹妮拿着 5 美元去超市买东西, 为新搬来的邻居买水果篮礼物。因为她是个勤奋并缺乏想象力的孩纸, 她打算正好花 5 美元, 不多也不少。
事实上超市里水果的价格并非整数, 正好花光 5 美元并不容易。 - 但是詹妮已经准备好了。她从背包里拿出上网本, 输入她看到过的水果的单价, 并且开启了一个程序为她收集 — 就是这样, 5 美元能买的水果的组合就出现在屏幕上。
挑战 : 用你选择的语言展示詹妮的程序是什么样子。
 目标就是 500 美分 (等于 5 美元) 解决方法可以包含多种同类型的水果 - 假设它们数量没有限制 解决方法没有必要包含所有水果类型 对给定的输入检测所有可能的方法  输入描述 每行一种水果 — 规定了水果的名字(不含空格的单词)和水果的单价(单位为美分, 整数)
输出描述 每个解决方法一行 — 用以逗号分割的数量+名字对儿, 描述了那种类型要买的水果数。
不要列出数量为 0 的水果。 如果为复数就给名字加 s。
输入样本 banana 32 kiwi 41 mango 97 papaya 254 pineapple 399  输出样本 6 kiwis, 1 papaya 7 bananas, 2 kiwis, 2 mangos  有挑战的输入 apple 59 banana 32 coconut 155 grapefruit 128 jackfruit 1100 kiwi 41 lemon 70 mango 97 orange 73 papaya 254 pear 37 pineapple 399 watermelon 500  注意, 这种输入有 180 种解决方法。</description>
    </item>
    
    <item>
      <title>正则替换</title>
      <link>https://ohmysummer.github.io/post/2016-04-07-%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2/</link>
      <pubDate>Thu, 07 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-04-07-%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2/</guid>
      <description>想把 Desgin Raku 中的 pod/html 转为 Markdown 格式, Raku 的 pod2markdown 不能用, 只能下载 html 格式的了, 然后用 pandoc test.html -o result.markdown 转换了, 但是也不理想, 里面还有很多 html 标签, 写个脚本批量替换下吧。 token 中的空白要显式地使用 \s、\h、\t 等表示, rule 中 :sigspace 是开启的。程序很丑, 仅仅是记录一下。
use v6; my rule r1 {&#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;line_\\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39; &#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;line_\\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;( &#39;&amp;lt;&#39;span)?$} my rule r2 {id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39; &#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;( &#39;&amp;lt;&#39;span)?$} my rule r3 {^id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;$} my rule r4 {&#39;&amp;lt;&#39;div class\=&#39;&amp;quot;&#39;smartlink&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;} my rule r5 {&#39;&amp;lt;&#39;&#39;/&#39;div&#39;&amp;gt;&#39;} my rule r6 {&#39;&amp;lt;&#39;div class\=&#39;&amp;quot;&#39;indexgroup&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;} my rule r7 {&#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;__top&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;} my token r8 {^ \s* &#39;&amp;lt;&#39;span$} my rule r9 {^id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39; &#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;$} my rule r10 {id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39; &#39;&amp;lt;&#39;span id\=&#39;&amp;quot;&#39;line_\d+&#39;&amp;quot;&#39;&#39;&amp;gt;&#39;&#39;&amp;lt;&#39;&#39;/&#39;span&#39;&amp;gt;&#39;(\s&#39;&amp;lt;&#39;span)?</description>
    </item>
    
    <item>
      <title>Raku 中的术语</title>
      <link>https://ohmysummer.github.io/post/2016-03-26-raku%E4%B8%AD%E7%9A%84%E6%9C%AF%E8%AF%AD/</link>
      <pubDate>Sat, 26 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-26-raku%E4%B8%AD%E7%9A%84%E6%9C%AF%E8%AF%AD/</guid>
      <description>匿名 子例程、方法或子方法，当它们不能通过名字调用时，就被称为匿名的
# named subroutine sub double($x) { 2 * $x }; # 匿名子例程,存储在一个具名的标量里 my $double = sub ($x) { 2 * $x };  注意，匿名子例程仍然可以有名字
# 使用 anon 关键字使子例程匿名 my $s = anon sub triple($x) { 3 * $x } say $s.name; # triple  副词 通常, 副词是函数的命名参数. 也有一些其它特殊语法形式允许副词出现在某些合适的地方:
q:w&amp;quot;foo bar&amp;quot; # &amp;quot;:w&amp;quot; is a Quotelike form modifier adverb m:g/a|b|c/ # &amp;quot;:g&amp;quot; is also 4 +&amp;gt; 5 :rotate # &amp;quot;:rotate&amp;quot; is an operator adverb @h{3}:exists # &amp;quot;:exists&amp;quot; is also, but is known as a subscript adverb  副词通常使用冒号对儿标记来表示, 因为这个原因, 冒号对儿标记法也以副词对儿形式著称:</description>
    </item>
    
    <item>
      <title>Raku 中的操作符(三)</title>
      <link>https://ohmysummer.github.io/post/2016-03-23-raku%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%89/</link>
      <pubDate>Wed, 23 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-23-raku%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%89/</guid>
      <description>范围和范围迭代器语法 .. 范围操作符有各种在两端带有 ^符号的变体以表明把那个端点排除在范围之外。 它总会产生一个 Range 对象。 Range 对象是不可变的， 主要用于匹配间隔。
1..2 是从1到2包含端点的间隔， 而 1^..^2 不包含端点但是匹配任何在它俩之间的实数。
对于不同类型的数字参数， 范围会被强制为更宽的类型，所以：
1 .. 1.5  被看作为：
1.0 .. 1.5  这些强制由 multi 签名定义。（其它类型可能有不同的强制策略。）特别要说明的是， 使用 Range 作为末端是非法的：
0 ..^ 10 # 0 .. 9 0 .. ^10 # ERROR  如果范围右侧是非数字类型， 那么右侧的参数被强转为数字， 然后按上面那样使用。
因此，第二个参数中的 Array 类型会被假定用作数字， 如果左侧的参数是数字的话：
0 ..^ @x # okay 0 ..^ +@x # same thing  对于字符串也类似：
0 .. &#39;1.5&#39; # okay 0 .</description>
    </item>
    
    <item>
      <title>Raku 中的 Bailador Web 框架(简介)</title>
      <link>https://ohmysummer.github.io/post/2016-03-20-raku%E4%B8%AD%E7%9A%84bailadorweb%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sun, 20 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-20-raku%E4%B8%AD%E7%9A%84bailadorweb%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B/</guid>
      <description>开始 Bailador Bailador 是对 Perl Dancer Web 开发框架的模仿。 安装方法：
panda install Bailador # or zef install Bailador  我们来创建一个脚本 first.pl，打印 &amp;ldquo;hello world&amp;rdquo;:
use v6; use Bailador; get &#39;/&#39; =&amp;gt; sub { &amp;quot;hello world&amp;quot; } baile;  运行：raku first.pl 它会启动一个小型的 Web 服务器，你可以在3000端口上访问它：
$ raku first.pl Entering the development dance floor: http://0.0.0.0:3000 [2016-05-05T12:57:31Z] Started HTTP server.  在 Bailador 中，我们需要把 HTTP 请求方法和服务器上的路径映射给一个匿名子例程, 这个子例程会返回它里面的内容。在这个例子中，我们把我们告诉它的网站根路径的 get HTTP 请求映射为返回字符串 hello world。如果你启动这个程序并用浏览器打开 http://0.0.0.0:3000/ 你就会看到这个文本。
我们还可以映射其它路径(path-es):</description>
    </item>
    
    <item>
      <title>用类来排序数组</title>
      <link>https://ohmysummer.github.io/post/2016-03-15-%E7%94%A8%E7%B1%BB%E6%9D%A5%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 15 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-15-%E7%94%A8%E7%B1%BB%E6%9D%A5%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>有多列数据, 序号, 学校, 课程 … 年份这几列。要如果学校和课程相同就根据年份倒序排列。
先按学校排序, 再按课程排序, 然后按年份倒序排序。
我定义一个类来进行多列数据的排序, 很方便：
class Course { has Int $.numb; has Str $.univ; has Str $.dis; has Int $.paper; has Int $.cited; has Int $.year; } my @headers = &amp;lt;numb univ dis paper cited year&amp;gt;; my @courses; for $=finish.lines -&amp;gt; $line { next if $line ~~ /^num/; my @words = $line.words; @words[0, 3,4,5] = @words[0,3,4,5]».Int; my %h = @headers Z=&amp;gt; @words; my $course = Course.</description>
    </item>
    
    <item>
      <title>Using Raku(二)</title>
      <link>https://ohmysummer.github.io/post/2016-03-14-using-raku%E4%BA%8C/</link>
      <pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-14-using-raku%E4%BA%8C/</guid>
      <description>捕获 签名不仅仅是语法，它们是含有一列参数对象的 first-class 对象 。同样地，有一种含有参数集的数据结构,叫捕获。捕获有位置和命名两个部分，表现的就像列表和散列。像列表的那部分含有位置参数，而像散列的那部分含有命名参数。
创建和使用捕获 无论你什么时间写下一个子例程调用，你就隐式地创建了一个捕获。然而，它随即被调用消耗了。有时，你想做一个捕获，存储它，然后将一个或多个子例程应用到它包含的一系列参数上。为了这，使用 n(&amp;hellip;) 语法。
my @tasks = n(39, 3, action =&amp;gt; { say $^a + $^b }), n(6, 7, action =&amp;gt; { say $^a * $^b });  这里，@tasks数组最后会包含两个捕获，每个捕获各含有两个位置参数和一个命名参数。捕获中的命名参数出现在哪并没有关系，因为他们是按名字传递，而非按位置。就像数组和散列，使用 | ，捕获也能被展平到参数列表中去:
sub act($left, $right, :$action) { $action($left, $right); } for @tasks -&amp;gt; $task-args { act(|$task-args); }  However, in this case it is specifying the full set of arguments for the call, including both named and positional arguments.</description>
    </item>
    
    <item>
      <title>匿名状态变量的工作原理</title>
      <link>https://ohmysummer.github.io/post/2016-03-12-%E5%8C%BF%E5%90%8D%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 12 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-12-%E5%8C%BF%E5%90%8D%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</guid>
      <description>Anonymous State Variables And How They Work 当调试代码的时候, 我经常添加一个计数变量以用于循环, 所以我能跟踪发生了什么, 或我能在代码片段中处理正迭代的部分数据集:
my $event-no = 0; for get_events() -&amp;gt; $event { $event-no++; process-event($event); last if $event-no &amp;gt;= 5; }  如果你正在调试, 或者你正尝试在单行中节省空间, Perl 6 实际上有一个匿名状态变量(anonymous state variables)标记, 用不含名字的 $符号来标示(你还可以在很多可迭代对象身上使用 kv 方法来完成类似的东西, 但是匿名的 $ 更普遍。)
for get_events() -&amp;gt; $event { process-event($event); last if ++$ &amp;gt;= 5; }  然而, 注意; 下面这样的用法是没有效果的:
for get_events() -&amp;gt; $event { process-event($event); $++; last if $ &amp;gt;= 5; }  好了, 为什么是那样的？</description>
    </item>
    
    <item>
      <title>Raku 圣诞月历-(2009)</title>
      <link>https://ohmysummer.github.io/post/2016-03-11-raku-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2009/</link>
      <pubDate>Fri, 11 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-11-raku-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2009/</guid>
      <description>2009 有用的和有意思的循环 让我们来看一个基本的例子.
for 1, 2, 3, 4 { .say }  这是一个最简单清晰的语法的例子.在这并没有使用括号来包起整个列表的语句,象这种写法可以贯穿整个 Raku. 通常比起 Perl 5 来你没有必要写那么多的括号了.
很象 Perl 5 , 这个循环中的值会默认存到 $_ .在这个方法调用的 say 其实就是 $_.say.注意在 Raku 中,你不能直接只打一个 say 而不加参数,它会默认使用 $_ 来传参.你需要使用 .say 。要么明确的指定是 $_.
下面这个语法块并不是一个普通的块.它能通过一个尖的指向,来告诉你的 循环变量传进去的参数的名字 .
for 1, 2, 3, 4 -&amp;gt; $i { $i .say }  如果你调用的 return 内部有这个,将返回闭合的子函数. 这个尖尖也能取 多个 参数.象下面这样.
1 2 3
for 1, 2, 3, 4 -&amp;gt; $i , $j { &amp;quot;$i, $j&amp;quot; .</description>
    </item>
    
    <item>
      <title>token 和 rule 的区别</title>
      <link>https://ohmysummer.github.io/post/2016-03-11-token%E5%92%8Crule%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 11 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-11-token%E5%92%8Crule%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>在 grammar 中, 有两个 regex 的变体, rule 和 token。rule 默认不会回溯. rule 与 token 的一个重要区别就是, rule 这样的正则采取了 :sigspace 修饰符。 rule 实际上是
 regex :ratchet :sigspace { ... }  的简写. ratchet 这个单词的意思是: (防倒转的)棘齿, 意思它是不能回溯的! 而 :sigspace 表明正则中的空白是有意义的, 而 token 实际上是
 regex :ratchet { ... }  的简写。 所以在 token 中, 若不是显式的写上 \s、\h、\n 等空白符号, 其它情况下就好像空白隐身了一样, 虽然你写了, 但是编译器却视而不见。
use v6; use Grammar::Debugger; grammar Token::Rule::Difference { # 下面三者等价 # rule TOP { [\w+]+ % &#39; &#39; | [\d+]+ % &#39; &#39; } 等价于 # rule TOP { | [\w+]+ % &#39; &#39; | [\d+]+ % &#39; &#39; } 等价于 rule TOP { | [\w+]+ % &#39; &#39; | [\d+]+ % &#39; &#39; } } # $=finish.</description>
    </item>
    
    <item>
      <title>Raku 中的模式匹配</title>
      <link>https://ohmysummer.github.io/post/2016-03-09-raku%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-09-raku%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>模式匹配 my $name = &amp;quot;twostraws&amp;quot;; given $name { when &amp;quot;bilbo&amp;quot; { say &amp;quot;Hello, Bilbo Baggins!&amp;quot;} when &amp;quot;twostraws&amp;quot; { say &amp;quot;Hello, Paul Hudson!&amp;quot; } default { say &amp;quot;身份验证失败&amp;quot; } }  同时检查名字和密码 my $name = &amp;quot;twostraws&amp;quot;; my $password = &amp;quot;fr0st1es&amp;quot;; given ($name, $password) { when (&amp;quot;bilbo&amp;quot;, &amp;quot;bagg1n5&amp;quot;) { say &amp;quot;Hello, Bilbo Baggins!&amp;quot; } when (&amp;quot;twostraws&amp;quot;, &amp;quot;fr0st1es&amp;quot;) { say &amp;quot;Hello, Paul Hudson!&amp;quot; } default { say &amp;quot;你是谁?&amp;quot; } }  使用单个元组 my $authentication = (&amp;quot;twostraws&amp;quot;, &amp;quot;fr0st1es&amp;quot;); given $authentication { when (&amp;quot;bilbo&amp;quot;, &amp;quot;bagg1n5&amp;quot;) { say &amp;quot;Hello, Bilbo Baggins!</description>
    </item>
    
    <item>
      <title>Raku 中的正则表达式(一)</title>
      <link>https://ohmysummer.github.io/post/2016-03-08-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80/</link>
      <pubDate>Tue, 08 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-08-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80/</guid>
      <description>标题 Synopsis 5: Regexes and Rules
版本 创建于: 2002/06/24 上次修改: 2015/05/12 版本: 180  不论何时, 在 grammar 中引用递归模式时, 通常更偏好使用 token 和 rule, 而不是 regex.
概览 作为常规表达式记法的扩展, Raku 原生地实现了 Parsing Expression Grammars(PEGs). PEGs 要求你为有歧义的那部分提供一个 主从秩序. Raku 的 主从秩序 由一个多级的平局择优法测试决定:
 1) Most-derived only/proto hides less-derived of the same name 2) 最长 token 匹配: food\s+ beats foo by 2 or more positions 3) 最长字面值前缀: food\w* beats foo\w* by 1 position 4) 对于一个给定的 proto, multis from a more-derived grammar win 5) 在一个给定的编译单元中, 出现较早的备选分支或 multi 胜出.</description>
    </item>
    
    <item>
      <title>Raku 中的动态变量</title>
      <link>https://ohmysummer.github.io/post/2016-02-29-raku%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 29 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-29-raku%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F/</guid>
      <description>Raku 中的动态变量
$*ARGFILES  $*ARGFILES Magic command-line input handle.
 argfiles.pl6
use v6; $*ARGFILES.perl.say; #=&amp;gt; IO::Handle.new(:path(Any),:chomp) # 按行读取 for $*ARGFILES.lines -&amp;gt; $line { say &amp;quot;$line&amp;quot;; } # 一次性读取 # say $*ARGFILES.slurp;  USAGE
$ raku argfiles.pl6 file1 file2 file3 ...   class IO::Handle - Raku Documentation Input/Output - Raku Documentation Raku文件操作 - Qiita  @*ARGS  @*ARGS - Arguments from the command line. 命令行中的参数。
 agrs.pl6
use v6; say @*ARGS.</description>
    </item>
    
    <item>
      <title>bless</title>
      <link>https://ohmysummer.github.io/post/2016-02-26-bless/</link>
      <pubDate>Fri, 26 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-26-bless/</guid>
      <description>bless 方法 method bless(*%attrinit) returns Mu:D  相比 new方法来说更低层级别的对象构造方法。
创建一个和调用者同类型的新对象, 使用具名参数来初始化属性, 并返回创建后的对象。
在自定义构造函数时可以使用该方法:
class Point { has $.x; has $.y; # multi 是可选的 multi method new($x, $y) { self.bless(:$x, :$y); } } # 重写构造函数后, 不需要传具名参数了 my $p = Point.new(-1, 1); say $p.x; # -1   虽然你可以自定义构造函数, 记得它会让子类继承变得更困难。
 use v6; # bless 的原理 class Dog { has $.name; my $.counter; # 类方法 # 重写 new 方法, 使用位置参数创建实例 method new ($newName) { $.</description>
    </item>
    
    <item>
      <title>Array language</title>
      <link>https://ohmysummer.github.io/post/2016-02-23-reddit-array-language/</link>
      <pubDate>Tue, 23 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-23-reddit-array-language/</guid>
      <description>[2015-12-09] Challenge #244 [Easy]er - Array language (part 3) - J Forks
Forks *fork 是一个接收三个函数作为参数的函数
给三个函数 f(y, x = defalut):, g(y, x = default):, h(y, x = default):, 其中函数 g 是含有两个参数的真实的函数。
然后调用 Fork(f, g, h)执行函数合成:
g(f(y, x), h(y, x)) (data1, data2)  1. 从字符串输入执行函数调用来产生字符串 sum divide count  (上面的输入是 Fork 函数的三个函数名)
2. 根据你喜欢的原生语言, 从上面的字符串输入中创建一个执行函数 3. 或创建一个接收三个函数作为输入的函数并返回一个函数 Fork(sum, divide, count) (array data)  应该返回数组的平均数。
4. 扩展上面的函数使函数参数接收基数 对于 5 个参数, Fork(a, b, c, d, e) 是:</description>
    </item>
    
    <item>
      <title>Raku 中的智能匹配</title>
      <link>https://ohmysummer.github.io/post/2016-02-19-raku%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-19-raku%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%B9%E9%85%8D/</guid>
      <description>智能匹配 这儿有一个标准 Raku（即在你的编译单元开始的时候所生效的 Perl 方言） 的智能匹配表格。智能匹配通常作用在当前「主题」(topic)上, 即作用在 $_ 变量上. 在下面的表格中, $_ 代表 ~~ 操作符的左侧, 或者代表 given 的参数, 或者代表其它主题化的参数。 X 代表 ~~ 操作符右侧要与之($_)相匹配的模式, 或者在 when 后面的模式。(并且, 实际上, ~~ 操作符充当着一个小型的主题(topicalizer); 即, 为了右侧的计算, 它把 $_ 绑定到左侧的值上。 使用底层的 .ACCEPTS 形式来避免这种主题化.)
第一节包含了特殊的(privileged)语法; 如果匹配能通过那些条目之一完成, 那它就会那样做。 这些特别的语法是通过它们的外形(form)而非它们的类型(type)进行分派的。 否则就使用表格中的剩余部分,并且匹配会根据正常的方法分派规则进行分派。 优化器(optimizer)被允许假定在编译时之后没有定义额外的匹配操作符, 所以, 如果在编译时模式类型就是显而易见的话, 那么跳转表(jump table)就可以被优化。 然而, 只要 ~~ 操作符是 Perl 中少有的几个不使用多重分派的操作符之一, 那么这部分表格的语法仍然有些特殊。 相反, 基于类型的智能匹配被直截了当地分派给了属于 X 模式对象的底层方法.
换句话说, 智能匹配首先根据模式(pattern)的外形/形式(form)或类型(下面的X)进行分派(dispatch), 然后那个模式自身决定是否关注和怎样关注主题($_)的类型。 所以, 下表中的第二列实际上是初始(primary)列。 第一列中的 Any 条目标示了模式要么不关心主题的类型, 要么挑选那个条目作为默认项, 因为上面列出的类型越具体，它越不匹配。
$_ X 所隐含的匹配类型 Match if (given $_) ====== ===== ===================== =================== Any True ~~ True (parsewarn on literal token) Any False ~~ False match (parsewarn on literal token) Any Match ~~ Successful match (parsewarn on literal token) Any Nil ~~ Benign failure (parsewarn on literal token) Any Failure Failure type check (okay, 与类型相匹配) Any * block 签名匹配 block 成功绑定到 |$_ Any Callable:($) item sub truth X($_)  S03-smartmatch/any-callable.</description>
    </item>
    
    <item>
      <title>Raku 圣诞月历-(2013)</title>
      <link>https://ohmysummer.github.io/post/2016-02-15-raku%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2013/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-15-raku%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2013/</guid>
      <description>2013 Heredocs, Theredocs, Everywheredocs docs So let’s say you’ve got a bit of documentation to print out, a help statement perhaps. You could use an ordinary string, but it always looks like something you really shouldn’t be doing.
sub USAGE { say &amp;quot;foobar Usage: ./foobar &amp;lt;args&amp;gt; &amp;lt;file&amp;gt; Options: ... &amp;quot;; }  Raku has a much better idea for you, fortunately: heredocs! They work a bit differently from Perl 5, and are now invoked using the adverb :heredoc on quoting constructs:</description>
    </item>
    
    <item>
      <title>Raku Examples</title>
      <link>https://ohmysummer.github.io/post/2016-02-14-raku-examples/</link>
      <pubDate>Sun, 14 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-14-raku-examples/</guid>
      <description>斐波拉契数列（Fibonacci Sequence）  analytic  use v6; sub fibonacci (Int $n where 0..* --&amp;gt; Int) { constant phi = (1 + sqrt 5) / 2; return round( phi**($n+1) / sqrt 5); } for 0..1000 -&amp;gt; $i { say $i.fmt(&#39;%3d&#39;), &#39;: &#39;, fibonacci($i); }  这种方法计算前1000个斐波拉契数大约为0.746s（2015.7.Rakudo, 以下都是）。
 迭代  use v6; sub fibonacci (Int $n) { state @sequence = 1,1; while @sequence.elems &amp;lt;= $n { @sequence.push( @sequence[*-2] + @sequence[*-1] ); } return @sequence[$n]; } for 0.</description>
    </item>
    
    <item>
      <title>S07-Lists</title>
      <link>https://ohmysummer.github.io/post/2016-02-12-s07-lists/</link>
      <pubDate>Fri, 12 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-12-s07-lists/</guid>
      <description>push 和 append 的表现不同, push 一次只添加单个参数到列表末端, append 一次可以添加多个参数。
use v6; my @d = ( [ 1 .. 3 ] ); @d.push( [ 4 .. 6 ] ); @d.push( [ 7 .. 9 ] ); for @d -&amp;gt; $r { say &amp;quot;$r[]&amp;quot;; } # 1 # 2 # 3 # 4 5 6 # 7 8 9 for @d -&amp;gt; $r { say $r.WHAT() } # (Int) # (Int) # (Int) # (Array) 整个数组作为单个参数 # (Array) say @d.</description>
    </item>
    
    <item>
      <title>适当的使用proto</title>
      <link>https://ohmysummer.github.io/post/2016-02-11-%E6%81%B0%E5%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8proto/</link>
      <pubDate>Thu, 11 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-11-%E6%81%B0%E5%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8proto/</guid>
      <description>原文在此Apropos proto: Raku.c multi thoughts
Multi 程序相当整洁, 但对于我来说是不彻底的。一些背景 — 有人可能这样计算阶乘:
multi fac(0) { 1 } multi fac(Int $n where 1..Inf) { $n * fac( $n-1 ) } say fac(4); # 24  现在假设我们要把我们的递归 multi-sub 作为一个回调传递会怎样呢？
given &amp;amp;fac -&amp;gt; $some_fun { say &amp;quot;some_fun(4)=&amp;quot;, $some_fun(4) }  现在&amp;hellip; 定义一个匿名的 multi-sub 怎么样？
my $anon_fac = do { multi hidden_fac(0) { 1 } multi hidden_fac(Int $n where 1..Inf) { $n * fac( $n - 1 ) } &amp;amp;hidden_fac }; say $anon_fac(4); # 24  这也会有作用, 但是有点 hack 的味道, 并且我们的 multi-sub 并不是真正的匿名。它仅仅是被隐藏了。真正匿名的对象不会在任何作用域中安装, 而在这个例子中, &amp;ldquo;hidden_fac&amp;rdquo; 被安装在 &amp;ldquo;do&amp;rdquo; block 中的本地作用域中。</description>
    </item>
    
    <item>
      <title>given when和模式匹配</title>
      <link>https://ohmysummer.github.io/post/2016-02-06-given-when%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 06 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-06-given-when%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>Raku 中的模式匹配
use v6; my $bool1 = 1; my $bool2 = 0; given ($bool1, $bool2) { when (0, 0) {say &amp;quot;0, 0&amp;quot;} when (0, 1) {say &amp;quot;0, 1&amp;quot;} when (1, 0) {say &amp;quot;1, 0&amp;quot;} when (1, 1) {say &amp;quot;1, 1&amp;quot;} } given (&amp;quot;15&amp;quot;, &amp;quot;example&amp;quot;, &amp;quot;3.14&amp;quot;) { say $_.WHAT; # (&amp;quot;15&amp;quot;, &amp;quot;example&amp;quot;, &amp;quot;3.14&amp;quot;) =&amp;gt; List when ($, $, Str) { say &amp;quot;I got a String of $_[2]&amp;quot; } # $ 代表一个匿名变量, 表示元组的前两个不参与智能匹配?</description>
    </item>
    
    <item>
      <title>comb - 操作字符串的利器</title>
      <link>https://ohmysummer.github.io/post/2016-02-03-comb-%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A9%E5%99%A8/</link>
      <pubDate>Wed, 03 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-03-comb-%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A9%E5%99%A8/</guid>
      <description>comb - 操作字符串的利器
comb 子例程 comb 子例程的定义为：
multi sub comb(Regex $matcher, Str(Cool) $input, $limit = *) returns List:D multi method comb(Regex $matcher, $limit = *) returns List:D  用法：
comb /PATTERN/, STRING, LIMIT? # 子例程形式 STRING.comb(/PATTERN/, LIMIT?) # 方法形式  返回调用者（方法形式）的所有（或者至多 $limit 个，如果提供了的话）匹配，或者返回第二个参数（sub 形式）与 Regex 相匹配的字符串列表。
say &amp;quot;6 or 12&amp;quot;.comb(/\d+/).join(&amp;quot;, &amp;quot;); # 6, 12  Str 类中的 comb multi sub comb(Str:D $matcher, Str:D $input, $limit = Inf) multi sub comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match) multi sub comb(Int:D $size, Str:D $input, $limit = Inf) multi method comb(Str:D $input:) multi method comb(Str:D $input: Str:D $matcher, $limit = Inf) multi method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match) multi method comb(Str:D $input: Int:D $size, $limit = Inf)  在 $input 中搜索 $matcher 并返回所有匹配（默认是 Str，或者是 Match 对象，如果 $match 为真的话）的一个列表。$limit 表示至多返回 $limit 个匹配。</description>
    </item>
    
    <item>
      <title>Raku 中的 S/// 操作符</title>
      <link>https://ohmysummer.github.io/post/2016-01-28-raku%E4%B8%AD%E7%9A%84s%E6%93%8D%E4%BD%9C%E7%AC%A6/</link>
      <pubDate>Thu, 28 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-28-raku%E4%B8%AD%E7%9A%84s%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid>
      <description>Raku: S/// 操作符 By Zoffix Znet
来自 Perl 5 背景的我， 第一次使用 Raku 的非破坏性替换操作符 S/// 的经历就像下面这样:
进展会更好的。我不但会改善错误信息，而且会解释当前的所有事情。
智能匹配 我有问题的原因是因为，看到外形相似的操作符，我就简单地把 Perl 5 中的绑定操作符(=~)转换为 Raku 中的智能匹配操作符(~~) 还期望它能正常工作。事实上我是异想天开。S/// 操作符没有文档，并且结合令人困惑的(那个时候)警告信息，这就是我痛苦的根源：
my $orig = &#39;meowmix&#39;; my $new = $orig ~~ S/me/c/; say $new; # OUTPUT warning: # Smartmatch with S/// can never succeed  这个丑陋的警告说这儿的 ~~ 操作符是个错误的选择并且确实如此。~~ 操作符不是 Perl 5 的 =~ 操作符的等价物。~~ 智能操作符把它左边的东西起了个叫做 $_ 的别名，然后 ~~ 计算它右侧的东西，然后在右侧这个东西身上调用 .ACCEPTS($_) 方法。这就是所有的魔法。
所以上面的例子实际上发生了:
 我们到达 S/// 的时候， $orig 被起了个叫做 $_ 的别名。 S/// 非破坏性地在 $_ 身上执行了替换并返回那个结果字符串。这是智能匹配将要操作的东西。 智能匹配，按照 Str 与 Str 相匹配的规则，会根据替换是否发生来给出 True 或 False（令人困惑的是，True 意味着没发生）  结果一路下来，我们并没有得到我们想要的：替换过的字符串。</description>
    </item>
    
    <item>
      <title>Roles</title>
      <link>https://ohmysummer.github.io/post/2016-01-21-roles/</link>
      <pubDate>Thu, 21 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-21-roles/</guid>
      <description>Protocol 在 Swift 中是一组方法和属性的集合, 可用于代码复用。 Raku 中有与之类似的结构, 叫做 Role, 下面转换一个 Swift 的 Protocol 为 Raku 的 Role, 把部门人员的相关信息打印为一个表格:
Protocol in Swift 　import UIKit func padding(amount: Int) -&amp;gt; String { var paddingString = &amp;quot;&amp;quot; for _ in 0..&amp;lt;amount { paddingString += &amp;quot; &amp;quot; } return paddingString } // 协议 protocol TabularDataSource { var numberOfRows: Int { get } var numberOfColumns: Int { get } func labelForRow(row: Int) -&amp;gt; String // 行标签 func labelForColumn(column: Int) -&amp;gt; String // 列标签 func itemForRow(row: Int, column: Int) -&amp;gt; Int // 表格中的单元格 } struct Person { let name: String let age: Int let yearsOfExperience: Int } // 让 **Department** 遵守 **TabularDataSource**协议 struct Department: TabularDataSource { let name: String var people = [Person]() init(name: String) { self.</description>
    </item>
    
    <item>
      <title>Fallout Hacking Game</title>
      <link>https://ohmysummer.github.io/post/2016-01-12-fallout-hacking-game/</link>
      <pubDate>Tue, 12 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-12-fallout-hacking-game/</guid>
      <description>流行游戏辐射3: New Vegas 有一台计算机, 玩家必须正确地从同样长度的单词列表中猜出正确的密码。你的挑战是你自己实现这个游戏。
玩家有只 4 次机会, 每一次不正确的猜测计算机会提示有多少个字母位置是正确的。
例如, 如果密码是 MIND , 玩家猜测为 MEND, 游戏会提示4个位置中的3个是正确的(M_ND)。如果密码是 COMPUT, 玩家猜测为 PLAYFUL, 游戏会报告 0/7。虽然某些字符是匹配的, 但是位置不匹配。
询问玩家难度设置为几（非常简单, 简单, 中等, 困难, 非常困难）, 然后给玩家展示5到15的同样长度的单词。长度可以是 4到15个字符。
这儿有一个游戏例子:
Difficulty (1-5)? 3 SCORPION FLOGGING CROPPERS MIGRAINE FOOTNOTE REFINERY VAULTING VICARAGE PROTRACT DESCENTS Guess (4 left)? migraine 0/8 correct Guess (3 left)? protract 2/8 correct Guess (2 left)? croppers 8/8 correct You win!  你可以从我们的字典文件中获取单词：enable1.txt 。 你的程序应该在做位置检查时完全忽略大小写。
能增加游戏的难度, 或许甚至不能保证有解决方法, 根据你特别挑选的单词。例如, 你的程序能提供某些位置重叠的字符以至于暴露给玩家的信息越少越好。</description>
    </item>
    
    <item>
      <title>从正则表达式到Grammars - Part 2</title>
      <link>https://ohmysummer.github.io/post/2016-01-04-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammars-part-2/</link>
      <pubDate>Mon, 04 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-04-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammars-part-2/</guid>
      <description>省略啰嗦的一堆。
使用量词匹配前面的东西至少 min 次, 至多 max 次, item ** min .. max
my regex Date { \d ** 4 &#39;-&#39; \d ** 2 &#39;-&#39; \d ** 2 }  还能精确地匹配 N 次。
 /literal string here/ 匹配一个字母数字序列。任何不是字母数字(顺便说一下, 这里的字母数字不一定严格地限制为 USe ASCII, 任何带有 &amp;lsquo;Letter&amp;rsquo; 或 &amp;lsquo;Number&amp;rsquo; Unicode 属性的字符都符合要求)的东西都需要用引号引起来或者以某种形式转义。
如果你想让某个东西是可选的, 使用 ?：
&amp;quot;Skyfall&amp;quot; ~~ /Sky &#39;fall&#39;?/;  这会匹配 &amp;lsquo;Sky&amp;rsquo; 或 &amp;lsquo;Skyfall&amp;rsquo;。
Raku 的正则表达式, 就像大多数 RE 引擎一样, 当它们找到了一个匹配后会停止匹配。从左到右, 以 &amp;lsquo;Skyfalling&amp;rsquo; 为例：
&amp;quot;Skyfalling&amp;quot; ~~ /Sky &#39;fall&#39;?</description>
    </item>
    
    <item>
      <title>使用Raku的subsets和multiple辨别年龄</title>
      <link>https://ohmysummer.github.io/post/2016-01-04-%E4%BD%BF%E7%94%A8raku%E7%9A%84subsets%E5%92%8Cmultiple%E8%BE%A8%E5%88%AB%E5%B9%B4%E9%BE%84/</link>
      <pubDate>Mon, 04 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-04-%E4%BD%BF%E7%94%A8raku%E7%9A%84subsets%E5%92%8Cmultiple%E8%BE%A8%E5%88%AB%E5%B9%B4%E9%BE%84/</guid>
      <description>举个例子, 假设 person 有一个 age 属性. 我能写一个 multimethod, 让它接收一个 person 作为参数, 并返回这样的结果吗:
return &amp;quot;child&amp;quot; if age &amp;lt; 16; return &amp;quot;adult&amp;quot; if 16 &amp;lt;= age &amp;lt; 66; return &amp;quot;senior&amp;quot; if age &amp;gt;= 66;  class Person { has Int $.age; has Str $.name; }  这仅仅定义了一个拥有两个属性, 叫做 Person 的类. age 必须是 Int 型, name 必须是 Str 型. . 语法会生成一个只读访问器, 以使我们能从类的外部访问 getter 方法.
现在我们来定义一个 age-group multi 来告诉一个 person 属于哪个 age-group:
multi age-group ($person where (*.</description>
    </item>
    
    <item>
      <title>Raku 博文收集</title>
      <link>https://ohmysummer.github.io/post/2016-01-02-raku-%E5%8D%9A%E6%96%87%E6%94%B6%E9%9B%86/</link>
      <pubDate>Sat, 02 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-02-raku-%E5%8D%9A%E6%96%87%E6%94%B6%E9%9B%86/</guid>
      <description>本文意在收集 Raku 方面的博文, 如有侵权请告知删除。
Raku 的 Grammar 学习总结 Raku 的正则表达式 Raku 的正则表达式 Perl 6 的列表 Raku 的字符串 Raku URB 解析 Raku 格式化帮助信息 Raku 解决 24 Game Raku 神的90亿名字整数版 Raku 计算矩阵占比 Raku 24游戏 Raku temporary Raku 括号匹配 Raku 上传文件 译 Raku Object Orientation [译 Raku] Native Calling Interface](https://segmentfault.com/a/1190000004864391) 译 Raku 5to6-nutshell c++ Raku 括号的匹配 [c++ Raku] 神的90亿名字整数版](https://segmentfault.com/n/1330000004493136) Raku 正则替换 c++|Raku 累加器工厂 Raku IEEE754 Raku usbip 自动 bind Raku 5to6-perlfunc Raku GetOption Raku Search Binary-Tree node Raku Getopt::Kinoko</description>
    </item>
    
    <item>
      <title>Raku 核心骇客--词法的胡言乱语</title>
      <link>https://ohmysummer.github.io/post/2016-01-01-raku-%E6%A0%B8%E5%BF%83%E9%AA%87%E5%AE%A2-%E8%AF%8D%E6%B3%95%E7%9A%84%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/</link>
      <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-01-raku-%E6%A0%B8%E5%BF%83%E9%AA%87%E5%AE%A2-%E8%AF%8D%E6%B3%95%E7%9A%84%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/</guid>
      <description>Raku 核心骇客: 词法的胡言乱语
喜欢修复 Raku 编译器中的 bug? 这儿有一个great grammar bugglet: 当 „” 引号用在引起的用空白分割的单词列表构造器中时看起来好像不能工作:
say „hello world”; .say for qww&amp;lt;„hello world”&amp;gt;; .say for qww&amp;lt;&amp;quot;hello world&amp;quot;&amp;gt;; # OUTPUT: # hello world # „hello # world” # hello world  ” 引号不应该出现在输出中并且在输出中我们应该只有 3 行输出; 这 3 行输出都是 hello world。看起来像是一个待修复的有趣的 bug! 我们进去看看。
你怎样拼写它? 事实上这段代码没能正确解析表明这是一个 grammar bug。大部分的 grammar 住在 src/Raku/Grammar.nqp中, 但是在我们的手变脏之前, 让我们来解决我们应该查看什么。
二进制 raku 有一个 --target 命令行参数来接收其中之一的编译步骤并且会导致那个步骤的输出被产生出来。那儿有哪些步骤? 根据你正使用的后端它们也会有所不同, 但是你可以仅仅运行 raku --stagestats -e &#39;&#39; 把它们都打印出来:</description>
    </item>
    
    <item>
      <title>rakuintro 翻译</title>
      <link>https://ohmysummer.github.io/post/2015-12-21-raku-intro-%E7%BF%BB%E8%AF%91/</link>
      <pubDate>Mon, 21 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-12-21-raku-intro-%E7%BF%BB%E8%AF%91/</guid>
      <description>第八章 函数式编程 在本章中，我们将看看一些有利于函数式编程的功能。
函数是一等公民 　函数/子例程是一等公民:
 它们能作为参数传递 它们能从另外一个函数中返回 它们能被赋值给变量  map 函数是用来说明这个概念的极好例子。map 是高阶函数, 它接收另外一个函数作为参数。
脚本
my @array = &amp;lt;1 2 3 4 5&amp;gt;; sub squared($x) { $x ** 2 } say map(&amp;amp;squared, @array);  输出
(1 4 9 16 25)  解释
我们定义了一个叫做 squared 的子例程, 它接收一个数字并返回该数字的二次幂。下一步, 我们使用 map 这个高阶函数并传递给它两个参数, 一个子例程和一个数组。结果是所有数组元素的平方组成的列表。
注意当传递子例程作为参数时, 我们需要在子例程的名字前添加一个 &amp;amp; 符号。
闭包 　在 Raku 中所有的代码对象都是闭包, 这意味着它们能从外部作用域(outer scope)引用词法变量(lexical variables)。
匿名函数 　匿名函数也叫做拉姆达(lambda)。
匿名函数没有绑定到标识符(匿名函数没有名字)。
让我们使用匿名函数重写 map 那个例子。</description>
    </item>
    
    <item>
      <title>stackoverflow0902</title>
      <link>https://ohmysummer.github.io/post/2015-12-18-stackoverflow0902/</link>
      <pubDate>Fri, 18 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-12-18-stackoverflow0902/</guid>
      <description>How do I chain to an inline block in Raku?
我想修改一个数组(我在这个例子中使用了 splice, 但是它也可能是修改数组的任何操作)并返回修改后的数组 - 和 slice 不一样, slice 返回的是从数组中抠出的项。我可以很容易地通过在数组中存储一个 block 来做到, 就像下面这样:
my $1 = -&amp;gt; $a { splice($a,1,3,[1,2,3]); $a }; say (^6).map( { $_ &amp;lt; 4 ?? 0 !! $_ } ).Array; # [0 0 0 0 4 5] say (^6).map( { $_ &amp;lt; 4 ?? 0 !! $_ } ).Array.$1; # [0 1 2 3 4 5]  我怎么把由 $1 代表的 block 内联到单个表达式中呢？ 下面的解决方法不正确:</description>
    </item>
    
    <item>
      <title>给数字添加千分位分割符</title>
      <link>https://ohmysummer.github.io/post/2015-12-14-%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E5%88%86%E5%89%B2%E7%AC%A6/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-12-14-%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E5%88%86%E5%89%B2%E7%AC%A6/</guid>
      <description>使用链式函数调用 考虑最简单的一种情况, 不带小数点的数字:
&amp;quot;1234567890&amp;quot;.comb.reverse.rotor(3,:partial).map(*.join(&#39;&#39;)).join(&#39;,&#39;).comb.reverse.join(&#39;&#39;) # 1,234,567,890  使用 \\ 转义空白, 使代码对齐:
&amp;quot;1234567890&amp;quot;.comb\ .reverse\ .rotor(3,:partial)\ .map(*.join(‘’))\ .join(‘,’)\ .comb\ .reverse\ .join(‘’)\ .say;  使用正则表达式 comming soon!
使用 Grammar comming soon!</description>
    </item>
    
    <item>
      <title>类中的twigils</title>
      <link>https://ohmysummer.github.io/post/2015-12-11-%E7%B1%BB%E4%B8%AD%E7%9A%84twigils/</link>
      <pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-12-11-%E7%B1%BB%E4%B8%AD%E7%9A%84twigils/</guid>
      <description>Raku中的 . 和 ! twigil 是什么？ . twigil 的意思是&amp;rdquo;这是类公用的&amp;rdquo;, ! twigil 的意思是“这是类私有的”, 只能用在类的内部。
class ScoreKeeper { has @.options; has %!player-points; }  普通的符号表明了词法作用域或包作用域, 但是 twigils 就像是 sigils 的兄弟, 表明了不同的作用域, 它影响了变量的作用域。. 和 ! 是二级 sigils。
属性存在于每个类的实例中, 在类的内部, 可以直接使用 !访问到实例的属性:
class Point { has $.x; has $.y; method Str() { &amp;quot;($!x, $!y)&amp;quot; } }  那么 . twigil 和 ! twigil 之间有什么关系呢？下面看一个例子:
use v6; class Point { has $.x; has $.y; method Str() { # 注意这次我们使用 .</description>
    </item>
    
    <item>
      <title>扩展 Raku 中的类型</title>
      <link>https://ohmysummer.github.io/post/2015-11-25-%E6%89%A9%E5%B1%95raku%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 25 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-25-%E6%89%A9%E5%B1%95raku%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B/</guid>
      <description>扩展 Raku 中的类型 使用继承 class BetterInt is Int { method even { self %% 2 } } my BetterInt $x .= new: 42; say $x.even; $x .= new: 71; say $x.even; say $x + 42; # OUTPUT: # True # False # 113  my BetterInt $x 约束 $x 只能包含 BetterInt 或它的子类这种类型的对象。.= new: 42 等价于 = BetterInt.new: 42。 下面的子例程期望接收一个 Int 型的参数，但是你给它传递一个 BetterInt 类型的参数它会很高兴:
sub foo(Int $x) { say &amp;quot;\$x is $x&amp;quot;} my BetterInt $x .</description>
    </item>
    
    <item>
      <title>简单字符串解析</title>
      <link>https://ohmysummer.github.io/post/2015-11-25-%E7%AE%80%E5%8D%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 25 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-25-%E7%AE%80%E5%8D%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90/</guid>
      <description>简单字符串解析 我已经以好几种方式使用 Raku 解析用引号引起的字符串了。 但是我想知道有没有更好更干净的方法。下面有一个为引起的字符串准备的小型 grammar 而且还有一些测试:
grammar String::Simple::Grammar { our $quote; rule TOP {^ &amp;lt;string&amp;gt; $} # Note for now, {} gets around a rakudo binding issue token string { &amp;lt;quote&amp;gt; {} :temp $quote = $&amp;lt;quote&amp;gt;; &amp;lt;quotebody&amp;gt; $&amp;lt;quote&amp;gt; } token quote { &#39;&amp;quot;&#39; | &amp;quot;&#39;&amp;quot; } token quotebody { ( &amp;lt;escaped&amp;gt; | &amp;lt;!before $quote&amp;gt; . )* } token escaped { &#39;\\&#39; ( $quote | &#39;\\&#39; ) } } class String::Simple::Actions { method TOP($/) { make $&amp;lt;string&amp;gt;.</description>
    </item>
    
    <item>
      <title>项</title>
      <link>https://ohmysummer.github.io/post/2015-11-21-%E9%A1%B9/</link>
      <pubDate>Sat, 21 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-21-%E9%A1%B9/</guid>
      <description>Raku 中的大部分句法结构能归类为项和操作符. 这儿你能找到各种不同类型的项的概览.
Literals Int 42 12_300_00 :16&amp;lt;DEAD_BEEF&amp;gt; #十六进制  Int 字面量由数字组成, 并且能在数字之间包含下划线. 使用 :radix&amp;lt;number&amp;gt; 冒号对儿形式能指定 10 进制外的其它进制.
Rat 有理数 12.34 1_200.345_678  Rat(有理数)字面量由一个点号分割的两部分整数组成. 注意尾部的点号是不允许的, 所以你必须写成 1.0 而非 1. ( 这个规则很重要, 因为有一个以点号开头的中缀操作符, 例如 .. 范围操作符 ).
Num 浮点数 12.3e-32 3e8  Num(浮点数)字面量由 Rat 或 Int 字面量后面再跟着一个字母 e 和 一个指数(可能为负)组成. 3e8 使用 值 3* 10**8 构建了一个 Num.
Str &#39;a string&#39;&#39;I\&#39;m escaped!&#39; &amp;quot;I don&#39;t need to be&amp;quot; &amp;quot;\&amp;quot;But I still can be,\&amp;quot; he said.</description>
    </item>
    
    <item>
      <title>Guess Who</title>
      <link>https://ohmysummer.github.io/post/2015-11-20-reddit-guess-who/</link>
      <pubDate>Fri, 20 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-20-reddit-guess-who/</guid>
      <description>你是一个刚成立的小公司里的一名软件工程师, 有天晚上你收到了一封来自CEO 的电子邮件:
 亲爱的工程师,
​ 好新闻！看起来我们的网站越来越受欢迎。我们要变的有钱了! 每秒钟有成千上万的人在同时访问我们的网站, 而且还在快速增长。
我们必须立即识别出谁的通信量最大。幸运的是我的朋友给我发送了一份巨大的 IP 地址和名字的列表。很酷不是吗？你能写一段程序接收我们大量的访问者, 把它和地址/ 名字列表相比, 并创建一些统计吗？我的意思是, 生成一个国家的名字列表, 每个
做好了的话我给你们开个披萨聚会。
 邮件的附件文件包含了一个 IP 地址和名字的列表。写一个程序来统计下有多少 IP 访问了你的网站。
输入描述 输入来自两部分。第一个是一个文本文件, 包含 IP 地址范围。每行一项,使用两个空格分割 IP 和名字。
第二个文件是一个 IP 地址的列表, 每行一个, 它们是必须被查询的IP。
IP 输入样本 输入是有包含两个 IP 地址和一个跟 IP 范围关联的名字的大量行组成。
123.45.17.8 123.45.123.45 University of Vestige 123.50.1.1 123.50.10.1 National Center for Pointlessness 188.0.0.3 200.0.0.250 Mayo Tarkington 200.0.0.251 200.0.0.255 Daubs Haywire Committee 200.0.1.1 200.255.255.255 Geopolitical Encyclopedia 222.222.222.222 233.233.233.233 SAP Rostov 250.</description>
    </item>
    
    <item>
      <title>Raku 中的可变 Grammar</title>
      <link>https://ohmysummer.github.io/post/2015-11-16-raku%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98grammar/</link>
      <pubDate>Mon, 16 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-16-raku%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98grammar/</guid>
      <description>## A Mutable Grammar For Raku Rules Rules 就像 perl5的 regexes，并且更好。它们像子例程和方法那样申明，并且还能调用其它 rules
下面是一个解析 Raku 基本变量名的例子：
grammar Raku { # among other stuff: # token alpha 是一个预定义好的 rule token identifier { &amp;lt;alpha&amp;gt; \w+ } # 匹配一个全限定名标识符 # [ ... ] 是非捕获组 token name { &amp;lt;identifier&amp;gt; [ &#39;::&#39; &amp;lt;identifier&amp;gt; ] * } # .. | .. 是分支. 最长匹配胜出. token sigil { &#39;$&#39; | &#39;@&#39; | &#39;&amp;amp;&#39; | &#39;%&#39; | &#39;::&#39; } # &amp;lt;rule&amp;gt; 调用命名 rule, 隐式地锚定在当前位置 token variable { &amp;lt;sigil&amp;gt; &amp;lt;name&amp;gt; } }  Grammars Grammar 跟类很像，含有 rules 而不是 methods。 grammars 是 rules 的集合并支持继承。</description>
    </item>
    
    <item>
      <title>roles冲突</title>
      <link>https://ohmysummer.github.io/post/2015-11-16-roles%E5%86%B2%E7%AA%81/</link>
      <pubDate>Mon, 16 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-16-roles%E5%86%B2%E7%AA%81/</guid>
      <description>学会了怎么创建类, 我们继续用它来构建我们的中心内容:
class Hammer { method hammer($stuff) { say &amp;quot;You hammer on $stuff. BAM BAM BAM!&amp;quot;; } } class Gavel { method hammer($stuff) { say &amp;quot;You hammer on $stuff. BAM BAM BAM!&amp;quot;; } } class Mallet { method hammer($stuff) { say &amp;quot;You hammer on $stuff. BAM BAM BAM!&amp;quot;; } }  但是注意到了吗？ 这三个方法包含了同样的方法, 在类中重复了。我们必须那样做如果我们想让每个 Hammar、Gavel 和 Mallet 有能力击打的话。（并且那是合理的）。 但是遗憾的是我们不得不把那个方法一式三份。
为什么遗憾？ 因为一方面在真实世界中, 方法并不是很彼此相似, 有一天你决定在 hammer 方法中更改某些东西, 并没有意识到这个方法在三个不同的地方&amp;hellip; 这导致了一堆痛苦和难受。
所以我们的新玩具, 类, 展现出了一个问题。我们想在每个类中重用 hammer 方法。一个新的概念, role 来拯救我们来了:</description>
    </item>
    
    <item>
      <title>圆括号和方括号在创建数组时的区别</title>
      <link>https://ohmysummer.github.io/post/2015-11-14-%E5%9C%86%E6%8B%AC%E5%8F%B7%E5%92%8C%E6%96%B9%E6%8B%AC%E5%8F%B7%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 14 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-14-%E5%9C%86%E6%8B%AC%E5%8F%B7%E5%92%8C%E6%96%B9%E6%8B%AC%E5%8F%B7%E5%9C%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>[ ] 和 ( ) 的区别 # 无法正常排序 my @s = [2443,5,33, 90, -9, 2, 764]; say @s.sort; # 2443 5 33 90 -9 2 764 say @s.WHAT; # (Array) say @s.perl; # [[2443, 5, 33, 90, -9, 2, 764]]&amp;lt;&amp;gt; # 正常排序 my $array = [2443,5,33, 90, -9, 2, 764]; say $array.sort; # -9 2 5 33 90 764 2443 say $array.WHAT; # (Array) say $array.perl; # [2443, 5, 33, 90, -9, 2, 764] my @s = (2443,5,33,90,-9,2,764); say @s.</description>
    </item>
    
    <item>
      <title>在 Raku 中怎么为已存在的类添加方法</title>
      <link>https://ohmysummer.github.io/post/2015-11-11-%E5%9C%A8raku%E4%B8%AD%E6%80%8E%E4%B9%88%E4%B8%BA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 11 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-11-%E5%9C%A8raku%E4%B8%AD%E6%80%8E%E4%B9%88%E4%B8%BA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95/</guid>
      <description>How do you add a method to an existing class in Raku? Raku 中怎么为已存在的类添加方法?
Int 类有一个方法叫做 is-prime, 我想为 Int类型添加其它的方法。
class MyInt is Int { method is-even () returns Bool:D { return False if self % 2; return True; } } my $n = MyInt.new(138); say $n.is-even;  通过类的继承也是一种方法, 但是不是我想要的。Swift 中可以通过扩展来实现, Raku 中有一个 add_method方法:
method add_method(Metamodel::MethodContainer: $obj, $name, $code)  这会给元类(meta class)添加一个方法, 使用 $name 作为调用的方法名。这只会在类型被组合前使用。
Int.^add_method( &#39;is-even&#39;, method () returns Bool:D { return False if self % 2; return True; } ); say 137.</description>
    </item>
    
    <item>
      <title>D 在 Raku 中是什么意思</title>
      <link>https://ohmysummer.github.io/post/2015-11-05-d%E5%9C%A8raku%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</link>
      <pubDate>Thu, 05 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-05-d%E5%9C%A8raku%E4%B8%AD%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</guid>
      <description>一个裸的 :D、:U、:T 或 :_ 是限制默认类型为定义、未定义、类型对象或任何对象的类型约束。所以
class Con { method man(:U: :D $x) }  其签名等价于 (Con:U: Any:D $x)。
Con:U 是调用者, 在调用者后面加上一个冒号。要标记一个显式的调用者, 在它后面放上一个冒号就好了:
method doit ($x: $a, $b, $c) { ... }  Abstract vs Concrete types 　对于任何有名字的类型, 某些其它子集类型可以自动地通过在类型的名字后面追加一个合适的状语来派生出来：
Int:_ 允许定义或未定的 Int 值 Int:D 只允许有定义的(强制的)Int 值 Int:U 只允许未定义值(抽象或失败)Int 值 Int:T 允许Int只作为类型对象  即, 它们的意思有点像:
Int:D Int:_ where DEFINITE($_) Int:U Int:_ where not(DEFINITE($_)) Int:T Int:U where none(Failure)  where DEFINITE 是一个布尔宏, 它说正处理的对象是否有一个合法的强制表示。(查看下面的自省) .</description>
    </item>
    
    <item>
      <title>Raku 中的正则表达式(三)</title>
      <link>https://ohmysummer.github.io/post/2015-11-05-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%89/</link>
      <pubDate>Thu, 05 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-05-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%89/</guid>
      <description>预定义 Subrules 下面这些是为任意 grammar 或 regex 预定义好的 subrules:
 ident   匹配一个标识符.
 upper   匹配单个大写字符.
 lower   匹配单个小写字符.
 alpha   匹配单个字母字符, 或者是一个下划线.
要匹配不带下划线的 Unicode 字母字符, 使用 &amp;lt;:alpha&amp;gt;.
 digit   匹配单个数字.
 xdigit   匹配单个十六进制数字.
 print   匹配单个可打印字符.
 graph   匹配单个图形字符.
 cntrl   匹配单个控制字符. (等价于 &amp;lt;:Cc&amp;gt; 属性). 控制字符通常不产生输出, 相反, 它们以某种方式控制末端:例如换行符和退格符都是控制字符. 所有使用 ord() 之后小于 32 的字符通常归类为控制字符.</description>
    </item>
    
    <item>
      <title>从正则表达式到 Grammar</title>
      <link>https://ohmysummer.github.io/post/2015-10-29-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammar/</link>
      <pubDate>Thu, 29 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-10-29-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammar/</guid>
      <description>「原文链接」
如果你是正则表达式新人(至少当它们用于 Raku 中时), 那我建议你从这个系列的第一部分开始。那些掌握了一定正则表达式的人可以跳过上周的文章。现在, 继续演示!
上周轶事 我们开始开发一个接收诸如
var a = 3; console.log(&amp;quot;Hey, did you konw a = &amp;quot; + a + &amp;quot;?&amp;quot;);  Javascript 表达式的 Raku 编译器, 并把这段代码转换为 Rakudo Perl 那样的编译器能运行的 Raku 代码。在我们开始之前, 想想转换后的 Raku 代码看起来是什么样的可能会是个好主意。如果你已经知道了 Perl 5, 那么你应该熟悉这样的代码。
my $a = 3; say &amp;quot;Hey, did you konw a = &amp;quot; ~ $a ~ &amp;quot;?&amp;quot;;  我们将需要确保我们的正则表达式捕获到了 Javascript 的要素。如果你还记得上一次, 我们使用这样一组正则表达式来捕获我们的文本:
my rule Number { \d+ }; my rule Variable { \w+ }; my rule String { &#39;&amp;quot;&#39; &amp;lt;-[&amp;quot; ]&amp;gt;+ &#39;&amp;quot;&#39; }; my rule Assignment-Expression { var &amp;lt;Variable&amp;gt; &#39;=&#39; &amp;lt;Number&amp;gt; }; my rule Function-Call { console &#39;.</description>
    </item>
    
    <item>
      <title>IO 操作</title>
      <link>https://ohmysummer.github.io/post/2015-10-11-io%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 11 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-10-11-io%E6%93%8D%E4%BD%9C/</guid>
      <description>文件存在、文件的时间戳、文件的修改时间等等
批量插入文本 use v6; my @filenames = dir &#39;.&#39;, test =&amp;gt; any(/\.md$/, /\.markdown/); for @filenames -&amp;gt; $filePath { my $path = $filePath.path(); $path ~~ s/.md//; $path ~~ s/.markdown//; my $date = DateTime.new(now); my $head = qq:heredoc &#39;EOT&#39;; title: $path.IO.basename() date: $date tags: Raku categories: Raku --- &amp;lt;blockquote class=&amp;quot;blockquote-center&amp;quot;&amp;gt;这城市有太多风景都在提醒那过去！&amp;lt;/blockquote&amp;gt; [TOC] EOT my @content = slurp $filePath; spurt($filePath.path, &amp;quot;$head\n@content[]&amp;quot;); }  在当前目录中查找所有以 .md (.markdown)结尾的文件（即markdown文件）, 并在文件最前面插入一段文本， 形如：
title: Raku date: 2015-08-20T23:19:13Z tags: Raku categories: Raku --- &amp;lt;blockquote class=&amp;quot;blockquote-center&amp;quot;&amp;gt;我站在天桥上念你, 有点狼狈&amp;lt;/blockquote&amp;gt;  类 IO::Path 提供了 basename, path, parts, 等方法供使用, 具体用法请看文档:</description>
    </item>
    
    <item>
      <title>proto</title>
      <link>https://ohmysummer.github.io/post/2015-10-06-proto/</link>
      <pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-10-06-proto/</guid>
      <description>proto proto 意思为原型。proto 从形式上声明了 multi 候选者之间的共性。 proto 充当作能检查但不会修改参数的包裹。看看这个基本的例子:
proto congratulate(Str $reason, Str $name, |) {*} multi congratulate($reason, $name) { say &amp;quot;Hooray for your $reason, $name&amp;quot;; } multi congratulate($reason, $name, Int $rank) { say &amp;quot;Hooray for your $reason, $name -- you got rank $rank!&amp;quot;; } congratulate(&#39;being a cool number&#39;, &#39;Fred&#39;); # OK congratulate(&#39;being a cool number&#39;, &#39;Fred&#39;, 42); # OK congratulate(&#39;being a cool number&#39;, 42); # Proto match error  所有的 multi congratulate 会遵守基本的签名, 这个签名中有两个字符串参数, 后面跟着可选的更多的参数。 | 是一个未命名的 Capture 形参, 这允许 multi 接收额外的参数。第三个 congratulate 调用在编译时失败, 因为第一行的 proto 的签名变成了所有三个 multi congratulate 的共同签名, 而 42 不匹配 Str。</description>
    </item>
    
    <item>
      <title>Raku 圣诞月历-(2010)</title>
      <link>https://ohmysummer.github.io/post/2015-10-05-raku-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2010/</link>
      <pubDate>Mon, 05 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-10-05-raku-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2010/</guid>
      <description>2010 第二天:用main函数控制命令行交互 2010 年 Raku 圣诞月历(二)用 main 函数控制命令行交互
在 UNIX 环境下，很多脚本都是要从命令行里获取运行参数的。Raku 上，实现这个相当简单~比如下面这样：
$ cat add.pl sub MAIN ($x, $y) { say $x + $y } $ raku add.pl 3 4 7 $ raku add.pl too many arguments Usage: add.pl x y  只要定义一个带命名变量的 MAIN 函数，你就可以获得一个命令行分析器。然后命令行参数就被自动绑定到 $x 和 $y 上了。如果不匹配，还有温馨的 Usage 提示~~
当然，你可能更喜欢自己定制 Usage 信息。那么自己动手，编写 USAGE 函数好了：
$ cat add2.pl sub MAIN($x, $y) { say $x + $y } sub USAGE () { say &amp;quot;Usage: add.</description>
    </item>
    
    <item>
      <title>空白格</title>
      <link>https://ohmysummer.github.io/post/2015-09-18-%E7%A9%BA%E7%99%BD%E6%A0%BC/</link>
      <pubDate>Fri, 18 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-18-%E7%A9%BA%E7%99%BD%E6%A0%BC/</guid>
      <description> 空格最少化 在数组或散列的开括号(即下标左边的那个括号)之前不允许有空格, 参数列表的圆开括号前面也是不能有空格的. 即:
@deadbeef[$x] # okay %monsters{&#39;cookie&#39;} # okay saymewant(&#39;cookie&#39;) # okay @a [$b] # WRONG %people {&#39;john&#39;} # WRONG mewant (&#39;cookie&#39;) # WRONG  这种限制的的几个副作用之一就是条件控制结构的周围不再需要圆括号了:
if $value eq $target { print &amp;quot;Bullseye!&amp;quot;; } while $i &amp;lt; 10 { $i++ }  然而, 显式的使用 unspace 语法仍然能够让你对齐下标和后缀操作符:
%squirrels{&#39;fluffy&#39;} = Squirrel.new; %monsters.{&#39;cookie&#39;} = Monster.new; %beatles\.{&#39;ringo&#39;} = Beatle.new; %people\ .{&#39;john&#39;} = Person.new;  </description>
    </item>
    
    <item>
      <title>Raku 中的 polymod 方法</title>
      <link>https://ohmysummer.github.io/post/2015-09-17-raku%E4%B8%AD%E7%9A%84polymod%E6%96%B9%E6%B3%95/</link>
      <pubDate>Thu, 17 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-17-raku%E4%B8%AD%E7%9A%84polymod%E6%96%B9%E6%B3%95/</guid>
      <description>Raku 中的 .polymod 方法 - 把数字分解成分母
 命名 .polymod 方法接受几个除数并把它的调用者分解成一份一份的:
my $seconds = 1 * 60*60*24 # days + 3 * 60*60 # hours + 4 * 60 # minutes + 5; # seconds say $seconds.polymod: 60, 60; say $seconds.polymod: 60, 60, 24; # OUTPUT: # (5 4 27) # (5 4 3 1)  这种情况下我们作为参数传递的除数是和时间相关的: 60(每分钟有多少秒)， 60(每小时有多少分钟)，和24(每天有多少小时)。从最小的单位开始， 我们一直前进到最大的单位。
输出和输入的除数是相匹配的 - 从最小的单位到最大的单位： 5 秒，4 分钟，3 小时和 1 天。</description>
    </item>
    
    <item>
      <title>日期难题</title>
      <link>https://ohmysummer.github.io/post/2015-09-15-%E6%97%A5%E6%9C%9F%E9%9A%BE%E9%A2%98/</link>
      <pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-15-%E6%97%A5%E6%9C%9F%E9%9A%BE%E9%A2%98/</guid>
      <description>reddit 上使用 Raku 处理日期
描述 下面的日期, 有些使用了 M D Y 格式, 有些使用了 Y M D 格式, 还使用了任意分隔符! 请把这些散乱的文本解析成合适的 ISO 8601 (YYYY-MM-DD) 格式化日期。
假设只有以 4 个数字开头的日期使用 Y M D 格式, 其它的使用 M D Y 格式。
输入样本 2/13/15 1-31-10 5 10 2015 2012 3 17 2001-01-01 2008/01/07  输出样本 2015-02-13 2010-01-31 2015-05-10 2012-03-17 2001-01-01 2008-01-07  扩展挑战 [中级] 使用 2014-12-24 作为相对日期的基准。
当添加 days(天数) 时, 要考虑到每月会有不同的天数, 忽略闰年。
当添加月和年时, 使用整个 units, 以至于:
one month before october 10 is september 10</description>
    </item>
    
    <item>
      <title>Raku Weekly(一)</title>
      <link>https://ohmysummer.github.io/post/2015-09-11-raku-weekly%E4%B8%80/</link>
      <pubDate>Fri, 11 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-11-raku-weekly%E4%B8%80/</guid>
      <description>1、在 Raku 中怎样检查文件的时间戳属性？
在 Raku 中怎样检查文件的时间戳属性？ 在 Perl 5 中是使用文件测试操作符 file test operators , 在 Raku 中是使用来自于 IO::FileTestable role 的方法 (e.g. .modified, .accessed and .changed) 。
例如:
my $filename = &amp;quot;sample.txt&amp;quot;; my $seconds_since_epoch = $filename.IO.accessed; my $readable_timestamp = DateTime.new($filename.IO.accessed); say &amp;quot;File &#39;$filename&#39; was last accessed at &#39;$readable_timestamp&#39;, which is {$seconds_since_epoch.Num} seconds since the epoch&amp;quot;;  2、我正尝试生成包含 10 个随机随机序列的 FASTQ 文件， 序列由随机品质分数构成。我原来是使用下面的代码，它工作良好:
my @seq = (rand_fa_seq() for ^10); my @qual = (rand_qual() for ^10); @seq.</description>
    </item>
    
    <item>
      <title>Raku 中的正则表达式(四)</title>
      <link>https://ohmysummer.github.io/post/2015-09-11-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%9B/</link>
      <pubDate>Fri, 11 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-11-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%9B/</guid>
      <description>最长 token 匹配 注意，下面进入糟糕区域，如果看不懂请查看英文原文!
S05-metasyntax/longest-alternative.t lines 53–460
因为 &amp;rdquo;longest-token matching&amp;rdquo; 是一个很长的短语, 我们会经常将这个概念叫做 LTM. 这个基本的概念就是人们在头脑中倾向于怎么去解析文本, 所以计算机应该像人一样尝试做同样的事情. 而使用 LTM 解析文本就是关于计算机怎样决定匹配一组备选分支中的哪一个备选分支的.
在 Raku 中, | 代表使用声明性的 longest-token 语义的逻辑备选分支.(你现在能使用 || 来标示旧的暂存的备选分支. 就是, | 和 || 现在在正则语法内的运作方式和在正则语法外的运作方式很像, 在正则语法外部, | 和 || 代表 junctional 和 短路的 OR. 这也包括事实上 | 的优先级比 || 的优先级高.)
在过去, Perl 中正则表达式是通过一个能回溯的 NFA 算法来处理的. 这很强大, 但是很多解析器通过并行地处理 rules , 而不是一个接着一个地处理, 工作起来更高效, 至少达到某种程度. 如果你看一下像 yacc grammar 这样的东西, 你会发现很多 pattern/action 声明, 其中的 patterns 被认为是并行的, 并且最终由 grammar 决定触发哪个 action.</description>
    </item>
    
    <item>
      <title>Raku 中的操作符(一)</title>
      <link>https://ohmysummer.github.io/post/2015-08-31-raku%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%80/</link>
      <pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-31-raku%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%80/</guid>
      <description>操作符优先级 S03-operators/arith.t lines 46–342
S03-operators/precedence.t lines 5–200
Raku 拥有和 Perl 5 同等数量的优先级级别，但是它们散布在不同的地方。这儿，我们列出了从最紧凑到最松散的级别，每一级别还有几个例子：
最高优先级到最低优先级：
A Level Examples = ===== ======== N Terms 42 3.14 &amp;quot;eek&amp;quot; qq[&amp;quot;foo&amp;quot;] $x :!verbose @$array L Method postfix .meth .+ .? .* .() .[] .{} .&amp;lt;&amp;gt; .«» .:: .= .^ .: N Autoincrement ++ -- R Exponentiation ** L Symbolic unary ! + - ~ ? | || +^ ~^ ?^ ^ L Multiplicative * / % %% +&amp;amp; +&amp;lt; +&amp;gt; ~&amp;amp; ~&amp;lt; ~&amp;gt; ?</description>
    </item>
    
    <item>
      <title>探索Raku的Signatures,第二部分</title>
      <link>https://ohmysummer.github.io/post/2015-08-29-%E6%8E%A2%E7%B4%A2raku%E7%9A%84signatures%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</link>
      <pubDate>Sat, 29 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-29-%E6%8E%A2%E7%B4%A2raku%E7%9A%84signatures%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</guid>
      <description>在我们探索 Raku 签名的第一部分中, 我们了解了怎么使用 Raku 强大而灵活的类型系统来约束具名参数和位置参数是如何被传递给子例程和方法的。我们还涉及了怎么使用 slurp 签名来创建能接收任意具名和位置参数列表的可变函数。
Raku 的签名系统提供了更多。在这篇文章中我们将验证其中更高级的特性, 它们让 Raku 的调用语义更强大。
Class 约束 你可以使用签名来指定传递进函数中的参数的类型约束。你使用的类型可以是任意类名。
sub foo( Numeric $foo, Str $bar) { say &amp;quot;my string is $bar and my number is $foo&amp;quot; }  这个签名要求我们传递 Numeric 和 Str 类型的参数。但是因为 Raku 的内置类型实际上就是类(classes), 并且因为 Numeric 拥有几个子类型, 我们可以传递进任何数字类型, 它都能工作:
foo(42, &amp;quot;blah&amp;quot;); foo(42.99, &amp;quot;yoohoo&amp;quot;); foo(3+9i, &amp;quot;hellooooooo&amp;quot;); # etc  我们自己定义的类中签名的工作原理也一样。
class Foo { has $.prop is rw; } sub inspect-a-foo( Foo $my-foo ) { say &amp;quot;this foo&#39;s property is &amp;quot; ~ $my-foo.</description>
    </item>
    
    <item>
      <title>Raku 中的变量</title>
      <link>https://ohmysummer.github.io/post/2015-08-25-raku%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</link>
      <pubDate>Tue, 25 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-25-raku%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</guid>
      <description>变量名以一个叫做魔符 sigil 的特殊字符开头, 后面跟着一个可选的第二个叫做 twigil 的特殊字符, 然后是一个标识符.
Sigils    符号 类型约束 默认类型 Flattens Assignment     $ Mu (no type constraint) Any No item   &amp;amp; Callable Callable No item   @ Positional Array Yes list   % Associative Hash Yes list    例子:
my $square = 9 ** 2; my @array = 1, 2, 3; # Array variable with three elements my %hash = London =&amp;gt; &#39;UK&#39;, Berlin =&amp;gt; &#39;Germany&#39;;  默认类型可以使用 is 关键字设置。</description>
    </item>
    
    <item>
      <title>Raku 单行程序</title>
      <link>https://ohmysummer.github.io/post/2015-08-25-raku-%E5%8D%95%E8%A1%8C%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 25 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-25-raku-%E5%8D%95%E8%A1%8C%E7%A8%8B%E5%BA%8F/</guid>
      <description>Raku 单行程序 这本书在进行之中。我希望你能觉得它有趣，甚至可能有用！如果你想贡献反馈的话，那么很欢迎提问题还有新的或有提升的正则表达式。
作者 戴维法瑞尔 PerlTricks.com
版本 版本 0.01
许可 FreeBSD
贡献者  Alexander Moquin Bruce Gray Carl Mäsak David H. Adler FROGGS Helmut Wollmersdorfer japhb Larry Wall Matt Oates Moritz Lenz Mouq Salve J Nilsen Sam S Skids timotimo  致谢 启发于 Peteris Krumins 的 Perl 5 example 文件。他逐字逐句地写了一本关于 Perl 5 单行 的书。
irc上有很好地 folks。
内容  介绍 教程 文件间距 行号 计算 创建字符串和创建数组 文本转换和替换 文本分析 选择性的行打印 使用管道转换数据(进行中) WWW(进行中) 转换到 Windows  介绍 把 Perl 和其它语言区别开的一件事情是在单行代码中写小程序的能力，即人们所熟知的&amp;rdquo;单行&amp;rdquo;。在终端里直接键入一个程序比写一个废弃的脚本往往更快。并且单行程序也很强大；它们是羽翼丰满的程序，能够加载外部库，但是也能集成到终端中。你可以在单行程序中输入或输出数据。</description>
    </item>
    
    <item>
      <title>cookbook</title>
      <link>https://ohmysummer.github.io/post/2015-08-25-cookbook/</link>
      <pubDate>Tue, 25 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-25-cookbook/</guid>
      <description>字符串处理  将每行从第二列到最后一列数值为0的且数目多于6个的行删除
 数据：
OG004240: 1 3 1 1 9 0 4 5 1 1 6 1 2 OG004241: 1 2 1 4 7 2 1 3 1 2 9 1 1 OG004242: 1 2 1 2 4 1 3 9 2 2 4 2 2 OG004243: 0 4 1 2 9 2 4 5 1 2 3 1 1 OG004244: 0 2 1 3 8 3 3 2 2 3 4 2 2 OG004245: 0 3 1 2 7 3 3 0 3 2 7 2 2 OG004246: 0 0 2 0 1 15 0 15 0 0 1 0 1  use v6; my @lines = &amp;quot;a.</description>
    </item>
    
    <item>
      <title>Raku 中的引号</title>
      <link>https://ohmysummer.github.io/post/2015-08-24-raku%E4%B8%AD%E7%9A%84%E5%BC%95%E5%8F%B7/</link>
      <pubDate>Mon, 24 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-24-raku%E4%B8%AD%E7%9A%84%E5%BC%95%E5%8F%B7/</guid>
      <description>除了 q 和 qq 之外，现在还有一种基本形式的 Q，它不会进行插值，除非显式地修改它那样做。所以，q 实际上是 Q:q 的简称，qq 实际上是 Q:qq 的简称。实际上所有的 quote-like 形式都派生自带有副词的 Q 形式：
S02-literals/quoting.t lines 95–116 S02-literals/quoting.t lines 132–139
q// Q :q // qq// Q :qq // rx// Q :regex // s/// Q :subst /// tr/// Q :trans ///  诸如 :regex 的副词通过转换到不同的解析器改变了语言的解析。这能完全改变任何之后的副词还有所引起的东西自身的解释。
q:s// Q :q :scalar // rx:s// Q :regex :scalar //  就像 q[...] 拥有简写形式的 &amp;lsquo;&amp;hellip;&amp;rsquo;, 并且 qq[...] 拥有简写形式的 &amp;ldquo;&amp;hellip;&amp;rdquo; 一样，完整的 Q[...] 引用也有一种使用半角括号 ｢&amp;hellip;｣ 的短形式。</description>
    </item>
    
    <item>
      <title>Raku Weekly(二)</title>
      <link>https://ohmysummer.github.io/post/2015-08-22-rakuweekly%E7%AC%AC%E4%BA%8C%E6%9C%9F/</link>
      <pubDate>Sat, 22 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-22-rakuweekly%E7%AC%AC%E4%BA%8C%E6%9C%9F/</guid>
      <description>:my $foo 的作用域和用途 在 *regex*、token 或 rule 中, 定义像下面这样的变量是可能的:
token directive { :my $foo = &amp;quot;in command&amp;quot;; &amp;lt;command&amp;gt; &amp;lt;subject&amp;gt; &amp;lt;value&amp;gt;? }  在中提到了一点有关该变量的东西, 我引用过来:
 任何 grammar regex 实际上是一种方法, 并且你可以在这样一个子例程中使用一个冒号跟着任何作用域声明符来声明一个变量, 这些声明符包括 my, our, state 和 constant (作为类似的声明符, temp 和 let 也能被识别). 单个语句(直到结尾的分号或行末尾的闭括号为止) 被解析为普通的 Raku 代码:
 token prove-nondeterministic-parsing { :my $threshold = rand; &#39;maybe&#39; \s+ &amp;lt;it($threshold)&amp;gt; }  有谁能解释下这段代码的应用场景吗？
what scope does :my $foo; have? :my $foo 在它所出现的 rule/token/regex 中拥有词法作用域(lexical scope)。你所得到的作用域要么很大要么很小:</description>
    </item>
    
    <item>
      <title>在 Raku 中为自定义的类添加下标(subscripts)</title>
      <link>https://ohmysummer.github.io/post/2015-08-18-%E5%9C%A8raku%E4%B8%AD%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%A0%87subscripts/</link>
      <pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-18-%E5%9C%A8raku%E4%B8%AD%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%A0%87subscripts/</guid>
      <description>为自定义的类添加下标(subscripts) 假如你定义了一个类，你想把类的实例用作散列那样，可以索引其中的元素， 那么你需要让你得自定义遵守 Associative 接口，并重写 AT-KEY 、EXISTS-KEY 、DELETE-KEY 、push 等跟散列有关的方法:
use v6; class HTTPHeader { ... } class HTTPHeader does Associative { has %!fields handles &amp;lt;self.AT-KEY self.EXISTS-KEY self.DELETE-KEY self.push list kv keys values&amp;gt;; method Str { say self.hash.fmt; } multi method EXISTS-KEY ($key) { %!fields{normalize-key $key}:exists } multi method DELETE-KEY ($key) { %!fields{normalize-key $key}:delete } multi method push (*@_) { %!fields.push: @_ } sub normalize-key ($key) { $key.subst(/\w+/, *.tc, :g) } # titileCase 驼峰式的键 method AT-KEY (::?</description>
    </item>
    
    <item>
      <title>S12-Objects</title>
      <link>https://ohmysummer.github.io/post/2015-08-09-s12-objects/</link>
      <pubDate>Sun, 09 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-09-s12-objects/</guid>
      <description>标题 大纲 12： 对象(Objects)
版本 创建于： 2004-08-27
上次修改时间： 2014-8-26
版本：134
概述 这个大纲总结了第12个启示录, 它探讨关于面向对象的编程。
类 (Classes) S12-class/lexical.t lines 12–61
S12-class/basic.t lines 13–50
S14-roles/lexical.t lines 12–47
类是使用关键字 class 声明的模块。 至于模块, 即公共存储, 接口, 并且类的名字通过包和它的名字来表示, 这总是(但不必须)一个全局的名字。 类是一个模块, 因此能导出东西, 但是类添加了更多的行为来支持 Raku 的标准的基于类的 OO。
作为类型对象(type object), 类名代表了它的类型的所有可能值, 因此在计算那种类型的普通对象能做什么时, 类型对象能用作任何属于该类型的&amp;rdquo;真实&amp;rdquo;对象的代理。 类对象是一个对象, 但是它不是一个类(Class), 因为 Raku 中没有强制性的 Class 类, 还因为在Raku 中类型对象被认为是未定义的。 我们想基于类的和基于原型的 OO 编程这两个都支持。所以, 所有的元编程是通过当前对象的 HOW 对象来完成的, 这可以把元编程代理给任何它喜欢的元模型上。 然而, 默认地, 从 Mu 派生的对象支持相当标准的基于类的模型。
有两种基本的类声明语法:
unit class Foo; # 文件的剩余部分是类的定义 has $.</description>
    </item>
    
    <item>
      <title>rotor</title>
      <link>https://ohmysummer.github.io/post/2015-08-08-rotor/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-08-rotor/</guid>
      <description>method rotor(*@cycle, Bool() :$partial)  rotor 返回一个 list, 这个 list 的元素也是 list, 其中每个子列表由调用者中的元素组成. 在最简单的情况下, @cycle 只包含一个整数, 这时调用者列表被分割为多个子列表, 每个子列表中的元素尽可能多的为那个整数指定的个数. 如果 :$partial 为 True, 不够分的最后那部分也会被包括进去, 即使它不满足长度的要求:
say (&#39;a&#39;..&#39;h&#39;).rotor(3).join(&#39;|&#39;); # a b c|d e f say (&#39;a&#39;..&#39;h&#39;).rotor(3, :partial).join(&#39;|&#39;); # a b c|d e f|g h  如果 @cycle 的元素是一个 /type/Pair, 则 pair 的键指定了所返回子列表的长度(即每个子列表中含有的元素数), pair 的键值指定两个列表之间的间隙; 负的间隙会产生重叠:
say (&#39;a&#39;..&#39;h&#39;).rotor(2 =&amp;gt; 1).join(&#39;|&#39;); # a b|d e|g h say (&#39;a&#39;..&#39;h&#39;).rotor(3 =&amp;gt; -1).join(&#39;|&#39;); # a b c|c d e|e f g &amp;gt; my $pair = 2 =&amp;gt; 1;&amp;gt; my $key = $pair.</description>
    </item>
    
    <item>
      <title>Raku 圣诞月历-(2015)</title>
      <link>https://ohmysummer.github.io/post/2015-08-05-raku%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2015/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-05-raku%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2015/</guid>
      <description>Comming Soon!</description>
    </item>
    
    <item>
      <title>Introspection</title>
      <link>https://ohmysummer.github.io/post/2015-07-25-introspection/</link>
      <pubDate>Sat, 25 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-25-introspection/</guid>
      <description>Raku 支持&amp;rdquo;泛型, roles 和 多重分发&amp;rdquo;, 它们都是很好的特点, 并且已经在其它 advent calendar 中发布过了。
但是今天我们要看的是 MOP。 &amp;ldquo;MOP&amp;rdquo;代表着元对象协议(&amp;ldquo;Meta-Object Protocol&amp;rdquo;)。那意味着, 它们实际上是你能从用户那边改变的一部分, 而不是对象、类等定义语言的东西。
实际上, 在 Raku中, 你可以为类型添加方法, 移除某个方法, 包裹方法, 使用更多能力增强类(OO::Actors 和 OO::Monitors 就是两个这样的例子), 或者你可以完全重定义它(并且, 例如, 使用 Ruby-like 的对象系统。这儿有个例子)。
但是今天, 我们首先看一下第一部分: 自省。在类型创建完之后查看它的类型, 了解它, 并使用这些信息。
我们将要创建的模块是基于 Sixcheck 模块(一个 QuickCheck-like 模块)的需求: 为某个类型生成一些随机数据, 然后把数据喂给我们正测试的函数, 并检查某些后置条件(post-condition)。
所以, 我们先写出第一个版本:
my %special-cases{Mu} = (Int) =&amp;gt; -&amp;gt; { (1..50).pick }, (Str) =&amp;gt; -&amp;gt; { (&#39;a&#39;..&#39;z&#39;).pick(50).join(&#39;&#39;) }, ; sub generate-data(Mu:U \t) { %special-cases{t} ?? %special-cases{t}() !! t.</description>
    </item>
    
    <item>
      <title>元对象协议</title>
      <link>https://ohmysummer.github.io/post/2015-07-16-%E5%85%83%E5%AF%B9%E8%B1%A1%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Thu, 16 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-16-%E5%85%83%E5%AF%B9%E8%B1%A1%E5%8D%8F%E8%AE%AE/</guid>
      <description>自省和 Raku 的对象系统 Raku 是构建在元对象层上面的。那意味着有些对象(元对象)控制着各种面向对象结构(例如类、roles、方法、属性、枚举,…)怎样去表现。
要感受类的元对象, 这儿有一个同样的例子出现2次: 一次一种 Raku中的普通声明, 一次通过元模型来表达:
class A { method x() { say 42 } } A.x(); # 42  对应于:
constant A := Metamodel::ClassHOW.new_type( name =&amp;gt; &#39;A&#39; ); # class A { A.^add_method(&#39;x&#39;, my method x(A:) { say 42 }); # method x() .. . A.^compose; # } A.x(); # 42  (除了声明形式的运行在编译时, 后面这种形式不是)
对象后面的元对象能使用 $obj.HOW获取, 这儿的 HOW 代表着 Higher Order Workings(或者 HOW the *%@$ does this work?</description>
    </item>
    
    <item>
      <title>Raku 中的 Role</title>
      <link>https://ohmysummer.github.io/post/2015-07-15-raku%E4%B8%AD%E7%9A%84role/</link>
      <pubDate>Wed, 15 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-15-raku%E4%B8%AD%E7%9A%84role/</guid>
      <description>Composition and mix-ins Sigils Typed data structures Traits  所以到底什么是 role 呢？ role 是零个或多个方法和属性的集合。
role 不像 class，它不能被实例化（如果你尝试了，会生成一个 class）。Raku 中 Classes 是可变的，而 roles 是不可变的。
申明 Roles 就像申明 Class 一样： 使用关键字 role来引入 role, 在 role 中声明属性和方法就像在 Raku 的类中声明属性和方法那样。
role DebugLog { has @.log_lines; has $.log_size is rw = 100; method log_message($message) { @!log_lines.shift if @!log_lines.elems &amp;gt;= $!log_size; @!log_lines.push($message); } }  Role Composition  使用 does trait 将 role 组合到 Class 中：  class WebCrawler does DebugLog { .</description>
    </item>
    
    <item>
      <title>Raku rotor--列表操作之王</title>
      <link>https://ohmysummer.github.io/post/2015-07-14-raku-rotor-%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%8E%8B/</link>
      <pubDate>Tue, 14 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-14-raku-rotor-%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%8E%8B/</guid>
      <description>Raku .rotor - The King of List Manipulation
对于 Raku 程序员, .rotor是一个强大的列表操作工具。
分段 最简单的, .rotor接收一个整数$number并把列表分成多个子列表, 每个子列表含有 $number 个元素:
say &amp;lt;a b c d e f g h&amp;gt;.rotor: 3 # ((a b c) (d e f))  我们有一个含有 8 个元素的列表, 我们在该列表上调用接收参数 3 的 .rotor方法, 它返回 2 个列表, 每个列表中含有 3 个元素。不包括原列表中的最后 2 个元素, 因为它们没有组成一个完整的3个元素的列表。然而它们可以被包含进来, 使用 :partial具名参数设置为 True:
say &amp;lt;a b c d e f g h&amp;gt;.rotor: 3, :partial # ((a b c) (d e f) (g h)) say &amp;lt;a b c d e f g h&amp;gt;.</description>
    </item>
    
    <item>
      <title>Grammar 笔记</title>
      <link>https://ohmysummer.github.io/post/2015-07-11-grammar%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 11 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-11-grammar%E7%AC%94%E8%AE%B0/</guid>
      <description>一个 Grammar 解析复杂文本的例子。
一个 Grammar 调了很久, 先分解下：
 解析[ ] 里面的数据：  use v6; use Grammar::Debugger; grammar Lines { token TOP { ^ &amp;lt;line&amp;gt;+ $ } token line { \[ &amp;lt;student&amp;gt;+ % &amp;lt;semicolon&amp;gt; \] \n # 换行 \n 是最容易被忽略的地方, 坑了很多次了！ } token student { &amp;lt;myname&amp;gt;+ % &amp;lt;comma&amp;gt; # 分隔符也可以是一个 subrule } token myname { &amp;lt;[A..Za..z-]&amp;gt;+ # 字符类的写法 &amp;lt;[...]&amp;gt; } token comma { &#39;,&#39; \s+ # 逗号, 分号 不能裸露出现在 token 中 } token semicolon { &#39;;&#39; \s+ } } my $parse = Lines.</description>
    </item>
    
    <item>
      <title>MAIN 中的冒号</title>
      <link>https://ohmysummer.github.io/post/2015-07-05-main-%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</link>
      <pubDate>Sun, 05 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-05-main-%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</guid>
      <description>假如我有多个文本文件, 我要写一段脚本来进行替换操作。在命令行中提供一些列选项供配置。文本格式如下:
Raku 很灵活 Raku 很强大 Raku 很复杂 I 123 Love Perl Six 尽管它456还很稚嫩789 对了, 它的 logo 是一个可爱的456花蝴蝶。  我想把每行中第一次出现的 3 位数字替换为 &amp;ldquo;在木星&amp;rdquo;。
@蘑菇 的脚本:
use v6; use MONKEY-SEE-NO-EVAL; sub MAIN(Str :$regex, Str :$substr, Str :$ext = &#39;.out&#39;, Int :$ignore-line = 0, *@files) { for @files -&amp;gt; $file { my $out = open $file ~ &amp;quot;.out&amp;quot;, :w; # 写入文件 for $file.IO.lines.kv -&amp;gt; $index, $line is copy { next if $index &amp;lt;= $ignore-line; # 忽略前 $ignore-line几行 $line ~~ EVAL &amp;quot;s/&amp;quot; ~ $regex ~ &amp;quot;/&amp;quot; ~ $substr ~ &amp;quot;/&amp;quot;; # 根据正则表达式进行替换 say $/; $out.</description>
    </item>
    
    <item>
      <title>散列也是容器</title>
      <link>https://ohmysummer.github.io/post/2015-06-28-%E6%95%A3%E5%88%97%E4%B9%9F%E6%98%AF%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sun, 28 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-06-28-%E6%95%A3%E5%88%97%E4%B9%9F%E6%98%AF%E5%AE%B9%E5%99%A8/</guid>
      <description>散列也是容器 假设我们想计算某个东西的出现次数, 我们通常的做法是弄一个 &amp;ldquo;seen-hash&amp;rdquo; 散列。有时候我们有一组待查询的键, 其中有些键可能不在我们所扫描的数据中。那是一种特殊情况, 但是 Raku 能够完美地解决, 因为散列也是容器, 因此我们能够拥有默认值。
my $words = &amp;lt;Hashes are containers too&amp;gt;.lc; constant alphabet = &#39;a&#39; .. &#39;z&#39;; my %seen of Int is default(0); %seen{$_}++ for $words.comb; put &amp;quot;$_: %seen{$_}&amp;quot; for alphabet;  输出结果:
a: 3 b: 0 c: 1 d: 0 e: 3 f: 0 g: 0 h: 2 i: 1 j: 0 k: 0 l: 0 m: 0 n: 2 o: 3 p: 0 q: 0 r: 2 s: 3 t: 2 u: 0 v: 0 w: 0 x: 0 y: 0 z: 0  $words 中没有出现的特殊字符由 is default(0) 处理了。 默认值可以被精心设计。我们来弄一个在数值上下文中为默认值为 0 但是在字符串上下文中为默认值为 NULL 并且总是被定义的一个散列。</description>
    </item>
    
    <item>
      <title>找到两个文件中共有的行</title>
      <link>https://ohmysummer.github.io/post/2015-06-18-%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E5%85%B1%E6%9C%89%E7%9A%84%E8%A1%8C/</link>
      <pubDate>Thu, 18 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-06-18-%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E5%85%B1%E6%9C%89%E7%9A%84%E8%A1%8C/</guid>
      <description>找出两个文件中共有的行, 顺序无关紧要 在 Perl 5 里, 你可以这样:
#!/usr/bin/env perl use 5.010; use warnings; use strict; my %filea = map { $_ =&amp;gt; 1 } do { open my $fa, &#39;&amp;lt;&#39;, &#39;filea&#39; or die $!; &amp;lt;$fa&amp;gt; }; my %fileb = map { $_ =&amp;gt; 1 } do { open my $fb, &#39;&amp;lt;&#39;, &#39;fileb&#39; or die $!; &amp;lt;$fb&amp;gt; }; for( keys %filea ){ print if $fileb{$_}; }  在 Raku 中就长这样:</description>
    </item>
    
    <item>
      <title>正则表达式一例</title>
      <link>https://ohmysummer.github.io/post/2015-06-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%E4%BE%8B/</link>
      <pubDate>Sun, 14 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-06-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%E4%BE%8B/</guid>
      <description>以指定音量随机播放音频文件：
#!/usr/bin/env raku use v6; my %v; # hash to hold data my token filename { .+? \.\S\S\S }; # filenames end in .??? my token volume { \d+ }; # any digits for volume my regex extra { .+ \S }; # anything following that my $mixer = &#39;mixer&#39;; my $player = &#39;mplayer -vf dsize=600:-2 -geometry +200-10 &#39;; my $lockfile = &#39;/tmp/myplayer&#39;; $lockfile.IO.spurt( $*PID ); # store the process ID so other process can kill this one END { $lockfile.</description>
    </item>
    
    <item>
      <title>class-List</title>
      <link>https://ohmysummer.github.io/post/2015-06-10-class-list/</link>
      <pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-06-10-class-list/</guid>
      <description>my class List is Iterable does Positional { .. }  List 以序列化的方式存储 items并且潜在是惰性的。
默认列表和数组的索引从 0 开始。
你可以给列表中的元素赋值如果它们是容器的话。使用数组以使列表中的每个元素存储在容器中。
Items, Flattening and Sigils 在 Raku 中, 把 List 赋值给一个标量变量不会丢死信息。不同之处在于迭代通常会把标量中的列表(或其它任何像列表的东西, 例如 Parcel 和 数组)当作单个元素。
my @a = 1, 2, 3; for @a { } # 三次迭代  my $s = @a; for $s { } # 一次迭代 for @a.item { } # 一次迭代 for $s.list { } # 三次迭代  Lists 通常会插值(展开)除非它们通过一个 item(scalar)容器访问:(GLR 的影响？)</description>
    </item>
    
    <item>
      <title>Slip一例</title>
      <link>https://ohmysummer.github.io/post/2015-05-19-slip%E4%B8%80%E4%BE%8B/</link>
      <pubDate>Tue, 19 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-19-slip%E4%B8%80%E4%BE%8B/</guid>
      <description> 描述 有 7 块板子放在一个&amp;rdquo;袋子&amp;rdquo;中, 随机从袋子中移除一个板子展示到玩家面前直到袋子变空。当袋子变空时, 它会被重新装填, 如果需要额外的板子, 则重复前面那个过程。
输出 使用随机 bag 系统随机输出 50 块板子。
板子如下:
 O I S Z L J T  输出样本  LJOZISTTLOSZIJOSTJZILLTZISJOOJSIZLTZISOJTLIOJLTSZO OTJZSILILTZJOSOSIZTJLITZOJLSLZISTOJZTSIOJLZOSILJTS ITJLZOSILJZSOTTJLOSIZIOLTZSJOLSJZITOZTLJISTLSZOIJO  在 Raku 中我会这样写 (smls):
say (|&amp;lt;O I S Z L J T&amp;gt;.pick(*) xx *).[^50].join;  注意:
 | 操作符把每次迭代的项展开进外部的列表中, 以使你不必在结果上显式地调用 .flat 方法 使用 &amp;lt; &amp;gt; 字符串列表字面量看起来比在字符串字面量上使用 .comb 方法更合适 xx 操作符每次都会重新计算它左侧的表达式  </description>
    </item>
    
    <item>
      <title>怎么在 Raku 中自定义存取器</title>
      <link>https://ohmysummer.github.io/post/2015-05-19-%E6%80%8E%E4%B9%88%E5%9C%A8raku%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%8F%96%E5%99%A8/</link>
      <pubDate>Tue, 19 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-19-%E6%80%8E%E4%B9%88%E5%9C%A8raku%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%8F%96%E5%99%A8/</guid>
      <description>How does one write custom accessor methods in Raku? 我有一个类:
class Wizard { has Int $.mana is rw; }  我可以这样做:
my Wizard $gandalf .= new; $gandalf.mana = 150;  我想在不放弃使用$gandalf.mana = 150; 的情况下, 在 setter里面做一些检查。换句话说, 我不想这样写: $gandalf.setMana(150)。 如果程序尝试设置一个负值的话, 就退出。
class Wizard { has Int $!mana; method mana() is rw { return Proxy.new: FETCH =&amp;gt; sub ($) { return $!mana }, STORE =&amp;gt; sub ($, $mana) { die &amp;quot;It&#39;s over 9000!</description>
    </item>
    
    <item>
      <title>下标副词</title>
      <link>https://ohmysummer.github.io/post/2015-05-18-%E4%B8%8B%E6%A0%87%E5%89%AF%E8%AF%8D/</link>
      <pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-18-%E4%B8%8B%E6%A0%87%E5%89%AF%E8%AF%8D/</guid>
      <description>下标副词 为了使切片下标返回除了值以外的其它东西，那么给下标(subscript)添加合适的副词。
@array = &amp;lt;A B&amp;gt;; @array[0,1,2]; # returns &#39;A&#39;, &#39;B&#39;, (Any) @array[0,1,2] :p; # returns 0 =&amp;gt; &#39;A&#39;, 1 =&amp;gt; &#39;B&#39; @array[0,1,2] :kv; # returns 0, &#39;A&#39;, 1, &#39;B&#39; @array[0,1,2] :k; # returns 0, 1 @array[0,1,2] :v; # returns &#39;A&#39;, &#39;B&#39; %hash = (:a&amp;lt;A&amp;gt;, :b&amp;lt;B&amp;gt;); %hash&amp;lt;a b c&amp;gt;; # returns &#39;A&#39;, &#39;B&#39;, (Any) %hash&amp;lt;a b c&amp;gt; :p; # returns a =&amp;gt; &#39;A&#39;, b =&amp;gt; &#39;B&#39; %hash&amp;lt;a b c&amp;gt; :kv; # returns &#39;a&#39;, &#39;A&#39;, &#39;b&#39;, &#39;B&#39; %hash&amp;lt;a b c&amp;gt; :k; # returns &#39;a&#39;, &#39;b&#39; %hash&amp;lt;a b c&amp;gt; :v; # returns &#39;A&#39;, &#39;B&#39;  如果副词为真，那么这些副词形式都会清除不存在的条目；如果为假的话，就会留下不存在的项，就像普通的切片那样。所以：</description>
    </item>
    
    <item>
      <title>在 Raku 中异步地执行外部程序</title>
      <link>https://ohmysummer.github.io/post/2015-05-14-%E5%9C%A8raku%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%9C%B0%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Thu, 14 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-14-%E5%9C%A8raku%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%9C%B0%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>Execute an external program with timeout in Raku
Proc::Async 允许我们异步地执行外部程序。
my $proc = Proc::Async.new(&amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;-o&amp;quot;, &amp;quot;index.html&amp;quot;, &amp;quot;http://www.cpan.org&amp;quot;); my $res = await $proc.start;  我们可以在 Proc::Async 中使用超时吗? Proc::Async 没有正式支持该功能，但是我们可以很容易地实现它。看一下这个：
class Proc::Async::Timeout is Proc::Async { has $.timeout is rw; method start($self: |) { return callsame unless $.timeout; my $killer = Promise.in($.timeout).then: { $self.kill }; my $promise = callsame; Promise.anyof($promise, $killer).then: { $promise.result }; } } my $proc = Proc::Async::Timeout.new(&amp;quot;perl&amp;quot;, &amp;quot;-E&amp;quot;, &amp;quot;sleep 5; warn &#39;end&#39;&amp;quot;); $proc.</description>
    </item>
    
    <item>
      <title>Raku 入门指南</title>
      <link>https://ohmysummer.github.io/post/2015-05-08-raku%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 08 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-08-raku%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</guid>
      <description>exit，warn，die exit
#!/usr/bin/env raku use v6; say &amp;quot;hello&amp;quot;; exit; say &amp;quot;world&amp;quot;; # 这句不会执行了  #!/usr/bin/env raku use v6; warn &amp;quot;This is a warning&amp;quot;; # 打印警告，带行号 say &amp;quot;Hello World&amp;quot;;  die
#!/usr/bin/env raku use v6; say &amp;quot;Before calling die&amp;quot;; die &amp;quot;This will kill the script&amp;quot;; say &amp;quot;This will not show up&amp;quot;;  Hello World Hello World
使用关键字 say打印出字符串，并在字符串结尾自动添加一个换行符。字符串被双引号包裹住。Raku 中语句以分号结束。 examples/intro/hello_world.p6
#!/usr/bin/env raku use v6; say &amp;quot;Hello Raku World&amp;quot;;  同样地， OOP 风格: examples/intro/hello_world_oop.</description>
    </item>
    
    <item>
      <title>Sneaky methods</title>
      <link>https://ohmysummer.github.io/post/2015-05-01-sneaky-methods/</link>
      <pubDate>Fri, 01 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-05-01-sneaky-methods/</guid>
      <description>Sneaky methods
就像你想的那样, 在类的定义中可以声明和定义方法。你期望不高的甚至文档中都很少提及是用 my 关键字声明的免费浮点方法。现在为什么你想要:
my method foo(SomeClass:D:) { self }  明显的答案是元对象协议中的 add_method 方法, 在 Rakudo 里你能找到它：
src/core/Bool.pm 32: Bool.^add_method(&#39;pred&#39;, my method pred() { Bool::False }); 33: Bool.^add_method(&#39;succ&#39;, my method succ() { Bool::True }); 35: Bool.^add_method(&#39;enums&#39;, my method enums() { self.^enum_values });  这种方法还有另外一种更诡异的用法。你可能很想知道在链式方法调用中究竟发生了什么。我们可以扯开最上面的那个表达式并插入一个短的变量, 输出我们的调试, 并且继续链式调用。好的名字很重要并且把它们浪费在一个短变量上没有必要。
&amp;lt;a b c&amp;gt;.&amp;amp;(my method ::(List:D) { dd self; self } ).say; # output # (&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;) # (a b c)  没有显式调用我们就不能没有名字, 因为 Raku 不允许我们这样做, 所以我们使用了空的作用域 :: 以使解析器高兴。使用一个合适的调用, 我们就不需要它了。还有, 那个匿名方法不是 List 中的一员。我们需要使用后缀 .</description>
    </item>
    
    <item>
      <title>Raku 中的正则表达式(五)</title>
      <link>https://ohmysummer.github.io/post/2015-04-28-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%94/</link>
      <pubDate>Tue, 28 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-28-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%94/</guid>
      <description>从匹配中返回值 Match 对象  成功的匹配总是返回一个 Match 对象, 这个对象通常也被放进 $/ 中, (具名 regex, token, 或 rule 是一个子例程, 因此会声明它们自己的本地 $/ 变量, 它通常指 rule 中最近一次的 submatch, 如果有的话)。当前的匹配状态被保存到 regex 的 $¢ 变量中, 当匹配结束时它最终会被绑定到用户的 $/变量中  不成功的匹配会返回 Nil (并把 $/ 设置为 Nil, 如果匹配已经设置了 $/的话)
 名义上, Match 对象包含一个布尔的成功值, 一个有序的子匹配对象(submatch objects)数组, 一个具名的子匹配对象(submatch objects)散列.(它也可选地包含一个用于创建抽象语法树(AST)的抽象对象) 为了提供访问这些各种各样值的便捷方法, Match 对象在不同上下文中求值也不同:
 在布尔上下文中 Match 对象被求值为真或假
  if /pattern/ {...} # 或: /pattern/; if $/ {...}  如果模式使用 :global 或 :overlap 或 :exhaustive 修饰符, 会在第一个匹配处返回布尔真值.</description>
    </item>
    
    <item>
      <title>从正则表达式到Grammars - Part 1</title>
      <link>https://ohmysummer.github.io/post/2015-04-27-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammars-part-1/</link>
      <pubDate>Mon, 27 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-27-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammars-part-1/</guid>
      <description>原文
略去啰嗦的前半部分。
Into the Breach 假设我们 的日志文件中有一个时间戳 2016-02-06T14:36+02:00, 我们使用智能匹配:
say $logfile ~~ /2016-02-06T14:36+02:00/;  这会报错:
 Unrecognized regex metacharacter - (must be quoted to match literally)
 在 Raku 的正则表达式中任何非字母数字字符(&amp;lsquo;a&amp;rsquo;..&amp;lsquo;z&amp;rsquo;, &amp;lsquo;A&amp;rsquo;..&amp;lsquo;Z&amp;rsquo;, 0..9)都必须用引号引起来:
say $logfile ~~ /2016 &#39;-&#39; 02 &#39;-&#39; 06T14 &#39;:&#39; 36 &#39;+&#39; 02 &#39;:&#39; 00/;  现在我们得到等价的奇怪的表达式:
｢2016-01-29T13:25+01:00｣  这仅仅告诉我们, ~~智能匹配操作符匹配了一些文本, 这就是它匹配到的文本。｢｣ 是日语引文标记, 故意和剩余的文本区分开来。
在 Raku 中, 默认打印出带有明确标记的匹配对象, 它准确地告诉你匹配从哪里开始, 到哪里结束。
归纳 我们想让该正则表达式更具普遍性, 例如匹配 2016 年的日志:
say $logfile ~~ /2015 | 2016 &#39;-&#39; 02 &#39;-&#39; 06T14 &#39;:&#39; 36 &#39;+&#39; 02 &#39;:&#39; 00/;  但是这还会匹配到我们不想要的东西, 例如 &amp;rsquo;/post/2015/02&amp;rsquo; 或者甚至 &amp;lsquo;/number/120153&amp;rsquo;。因为 |的优先级没有字符间的连接优先级高。所以:</description>
    </item>
    
    <item>
      <title>Grammars generating grammars</title>
      <link>https://ohmysummer.github.io/post/2015-04-15-grammars-generating-grammars/</link>
      <pubDate>Wed, 15 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-15-grammars-generating-grammars/</guid>
      <description>现在你可能已经习惯了 Raku 中到处出现的前缀&amp;rdquo;meta&amp;rdquo;。Metaclasses, Metaobjects, Metaoperators, 还有迷一般的 Meta-Object 协议。听起来一点也不可怕, 你都见过了不是吗？今天, 在 Raku Advent Calendar 上, 我们将进行完全的 meta 化(full meta)。我们将拥有能解析 grammars 的 grammars, 然后生成将用于解析 grammars 的 grammars。
Grammars 无疑是 Raku 的杀手级功能。我们拥有了正则表达式曾经没有的东西: 可读性、可组合性当然还有解析 Raku 自身的能力。— 如果这不能展示它的强大, 那我不知道什么能够!
为预定义好的 grammars(例如以 Bachus-Naur 形式)写解析器总是有点无趣, 几乎和复制粘贴一样。如果你曾经坐下来重头开始写一个解析器(或者期间温习一遍那本优秀的&amp;rdquo;让我们构建一个编译器&amp;rdquo;图书), 你可能会意识到模式是如此相似:从你的 grammar 中拿出单个 rule, 为它写一个子例程, 让它调用(可能是递归的)其它类似的为其它 grmmars rules 定义的子例程, 清洗, 重复。现在我们有了Raku Grammars! 在这个新世界中, 我们不必为每个 token 写上子例程来完成工作了。 现在我们写 grammar 类, 里面放上 *tokens*、*rules*、regexes 标志。在标志里写正则表达式(或代码)并引用(可能是递归的) Raku gramamr 中的其它标志。如果你曾经使用过这些东西, 你肯定会意识到 Raku 中的 gramamrs 是多么的方便。</description>
    </item>
    
    <item>
      <title>Raku圣诞月历-(2012)</title>
      <link>https://ohmysummer.github.io/post/2015-04-15-raku%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2012/</link>
      <pubDate>Wed, 15 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-15-raku%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2012/</guid>
      <description>2012 一个日历 #!/usr/bin/env raku constant @months = &amp;lt;January February March April May June July August September October November December&amp;gt;; constant @days = &amp;lt;Su Mo Tu We Th Fr Sa&amp;gt;; sub center(Str $text, Int $width) { my $prefix = &#39; &#39; x ($width - $text.chars) div 2; my $suffix = &#39; &#39; x $width - $text.chars - $prefix.chars; return $prefix ~ $text ~ $suffix; } sub MAIN(:$year = Date.today.year, :$month = Date.</description>
    </item>
    
    <item>
      <title>Capture</title>
      <link>https://ohmysummer.github.io/post/2015-04-01-capture/</link>
      <pubDate>Wed, 01 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-01-capture/</guid>
      <description>Capture 的定义:
class Capture does Positional does Associative { }  Capture 是一个用于给 code 对象传递参数的容器。Captures 是签名的另一面 — Captures 在调用方定义实参, 而签名(Signatures) 在被调用方定义形式参数。
当你调用 print $a, $b 时, $a, $b 这部分就是一个 Capture。$a, $b 在这儿是实参。
Captures 包含一个 list-like 部分的位置参数和一个 hash-like 部分的具名参数。对于具名参数, Captures 使用一种略微不同的语法而不是普通的 List。有两种简单的方法生成一个具名参数：
 使用一个未引起的键命名一个形参, 后面跟着 =&amp;gt;, 然后跟着参数 使用以形参命名的冒号对儿字面量  say unique 1, -2, 2, 3, as =&amp;gt; { abs $_ }; # 1, -2, 3 # ... is the same thing as: say unique 1, -2, 2, 3, :as({ abs $_ }); # 1, -2, 3 # Be careful not to quote the name of a named parameter: say unique 1, -2, 2, 3, &#39;as&#39; =&amp;gt; { abs $_ }; # 1, -2, 2, 3, &amp;quot;as&amp;quot; =&amp;gt; { .</description>
    </item>
    
    <item>
      <title>Raku 中的模块</title>
      <link>https://ohmysummer.github.io/post/2015-03-23-raku%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 23 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-23-raku%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/</guid>
      <description>Modules Exporting and Selective Importing is export packages(包), subroutines(子例程), variables(变量), constants(常量) 和 enums(枚举) , 通过在它们的名字后面添加 is export 特性来导出。
unit module MyModule; our $var is export = 3; sub foo is export { ... }; constant $FOO is export = &amp;quot;foobar&amp;quot;; enum FooBar is export &amp;lt;one two three&amp;gt;; # Packages like classes can be exported too class MyClass is export {}; # If a subpackage is in the namespace of the current package # it doesn&#39;t need to be explicitly exported class MyModule::MyClass {};  就像所有的 traits 一样, 如果应用到子例程(routine)上, &amp;ldquo;is export&amp;rdquo; 应该出现在参数列表的后面:</description>
    </item>
    
    <item>
      <title>Sneaking into a loop</title>
      <link>https://ohmysummer.github.io/post/2015-03-23-sneaking-into-a-loop/</link>
      <pubDate>Mon, 23 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-23-sneaking-into-a-loop/</guid>
      <description>Sneaking into a loop [Sneaking into a loop]https://gfldex.wordpress.com/2016/08/10/sneaking-into-a-loop/
Zoffix 回答了一个关于 Perl 5s &amp;lt;&amp;gt; 操作符的问题。
slurp.words.Bag.sort(-*.value).fmt(&amp;quot;%10s3d\n&amp;quot;).say;  slurp 会从 STDIN 中读取整个 &amp;ldquo;file&amp;rdquo; 并返回一个 Str。方法 Str::words 会按照某种 Unicode 意义的单词把该字符串分割成一个列表。把列表强转为 Bag 则创建一个计数 Hash, 它是如下表述的快捷方式。
my %h; %h{$_}++ for &amp;lt;peter paul marry&amp;gt;; dd %h; # # OUTPUT«Hash %h = {:marry(1), :paul(1), :peter(1)}␤»  在关联数组上调用 .sort(-*.value) 会按照值的降序排序并返回一个排序后的 Pairs 列表。List::fmt 会调用 Pair::fmt, 它调用 fmt 方法, .key 作为其第二个参数, .value 也作为参数。say 会会使用一个空格连接各个元素并输出到标准输出。最后一步有一点错误因为除了第一行之外的每一行前面都会有一个额外的空格。
slurp.words.Bag.sort(-*.value).fmt(&amp;quot;%10s =&amp;gt; %3d&amp;quot;).join(&amp;quot;\n&amp;quot;).say;  手动连接字符串更好。这对于简短的单行程序来说有点多了。我们需要找到最长的单词并使用 .</description>
    </item>
    
    <item>
      <title>Raku 的薛定谔的猫--Junctions</title>
      <link>https://ohmysummer.github.io/post/2015-03-22-raku%E7%9A%84%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E7%8C%AB-junctions/</link>
      <pubDate>Sun, 22 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-22-raku%E7%9A%84%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E7%8C%AB-junctions/</guid>
      <description>薛定谔欧文应该是喜欢 Raku 的, 因为他的著名的薛定谔的猫可以用 Raku 的 Junction表达:
my $cat = &#39;dead&#39; | &#39;alive&#39;; say &amp;quot;cat is both dead and alive&amp;quot; if $cat eq &#39;dead&#39; and $cat eq &#39;alive&#39;; # OUTPUT: # cat is both dead and alive  这里面发生了什么事情? 我会告诉你全部的!
Anyone 游戏? 拿最简单的来说, Junctions 允许你把一堆值当作单个值。例如, 你可以使用 any Junction 来测试一个变量是否等于所给定值中的任意一个:
say &#39;it matches!&#39; if &#39;foo&#39; eq &#39;foo&#39; | &#39;bar&#39; | &#39;ber&#39;; say &#39;single-digit prime&#39; if 5 == any ^9.grep: *.is-prime; my @values = ^100; say &amp;quot;it&#39;s in there!</description>
    </item>
    
    <item>
      <title>Subset</title>
      <link>https://ohmysummer.github.io/post/2015-03-19-subset/</link>
      <pubDate>Thu, 19 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-19-subset/</guid>
      <description>Subset 子集 Subset 可用于声明某一类型的子集。
输入一个密码， 要求密码必须满足如下条件：
1、 至少 8 位 2、 必须包含大写字母、小写字母 和 数字
use v6; subset Length8 of Str where *.chars &amp;lt; 8; subset UpCase of Str where none(&#39;A&#39;..&#39;Z&#39;) ∈ *.comb.Set; subset LowerCase of Str where none(&#39;a&#39;..&#39;z&#39;) ∈ *.comb.Set; subset IntNumber of Str where none(&#39;0&#39;..&#39;9&#39;) ∈ *.comb.Set; my $guess = prompt(&#39;Enter your password:&#39;); given $guess { when Length8 { say &#39;密码长度必须为 8 位 以上&#39;; proceed } when UpCase { say &#39;密码必须包括大写字母&#39;; proceed } when LowerCase { say &#39;密码必须包含小写字母&#39;; proceed } when IntNumber { say &#39;密码必须包含数字&#39;; } }  该程序具有可扩展性， 要增加一种密码验证， 只有添加一个 subset 就好了，然后在 given/When 里面增加一个处理。</description>
    </item>
    
    <item>
      <title>操作符</title>
      <link>https://ohmysummer.github.io/post/2015-03-16-%E6%93%8D%E4%BD%9C%E7%AC%A6/</link>
      <pubDate>Mon, 16 Mar 2015 13:16:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-16-%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid>
      <description>操作符 操作符优先级 在像 1 + 2 * 3 这样的表达式中， 2 * 3 被首先计算， 因为中缀操作符 * 的优先级比 + 的优先级高。下面的表中总结了 Perl 6 中 的优先级级别， 从最牢固到最松散：
A Level Examples N Terms 42 3.14 &amp;quot;eek&amp;quot; qq[&amp;quot;foo&amp;quot;] $x :!verbose @$array L 方法后缀 .meth .+ .? .* .() .[] .{} .&amp;lt;&amp;gt; .«» .:: .= .^ .: N 自增 ++ -- R 求幂 ** L Symbolic unary ! + - ~ ? | || +^ ~^ ?</description>
    </item>
    
    <item>
      <title>Raku 中的特性(二)</title>
      <link>https://ohmysummer.github.io/post/2015-03-16-raku%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%BA%8C/</link>
      <pubDate>Mon, 16 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-16-raku%E4%B8%AD%E7%9A%84%E7%89%B9%E6%80%A7%E4%BA%8C/</guid>
      <description>Set my $keywords = set &amp;lt;if for unless while&amp;gt;; # create a set sub has-keyword(*@words) { for @words -&amp;gt; $word { return True if $word (elem) $keywords; # 依次检查数组中的元素是否属于集合 $keywords } False; } say has-keyword &#39;not&#39;, &#39;one&#39;, &#39;here&#39;; # False say has-keyword &#39;but&#39;, &#39;here&#39;, &#39;for&#39;; # True  Series Operator my @a=&amp;lt;A G C T&amp;gt;; my $x=@a; for 1 ... * -&amp;gt; $a { (( [X~] $x xx $a )).</description>
    </item>
    
    <item>
      <title>When and Where</title>
      <link>https://ohmysummer.github.io/post/2015-03-15-when%E5%92%8Cwhere/</link>
      <pubDate>Sun, 15 Mar 2015 13:15:00 +0300</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-15-when%E5%92%8Cwhere/</guid>
      <description>When 可以用在主题化($_)的语句中 Perl 里面有个特殊的变量叫 $_, 即主题化变量, the variable in question.
&amp;gt; for (&#39;Swift&#39;, &#39;PHP&#39;, &#39;Python&#39;, &#39;Perl&#39;) -&amp;gt; $item { say $item when $item ~~ /^P/ } PHP Python Perl  &amp;gt; for (12, 24, 56, 42) {.say when *&amp;gt;40 } 56 42  而 where 用于对类型进行约束.
&amp;gt; for (&#39;Swift&#39;, &#39;PHP&#39;, &#39;Python&#39;, &#39;Perl&#39;, 42) -&amp;gt; $item where $item ~~ Str {say $item} Swift PHP Python Perl Constraint type check failed for parameter &#39;$item&#39;  未完待续.</description>
    </item>
    
    <item>
      <title>Using Raku(一)</title>
      <link>https://ohmysummer.github.io/post/2015-03-14-using-raku%E4%B8%80/</link>
      <pubDate>Sat, 14 Mar 2015 13:14:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-14-using-raku%E4%B8%80/</guid>
      <description>第一章 概要 Comming soon!
第二章 基础 假设有一场乒乓球比赛，比赛结果以这种格式记录： Player1 Player2 | 3:2 这意味着选手1与选手2的比分为3:2, 你需要一个脚本算出每位选手赢了几场比赛并且胜了几局。 输入数据（存储在一个叫做scores的文件中）像下面这样：
Beth Ana Charlie Dave Ana Dave | 3:0 Charlie Beth | 3:1 Ana Beth | 2:3 Dave Charlie | 3:0 Ana Charlie | 3:1 Beth Dave | 0:3  第一行是选手清单。随后每一行记录着比赛结果。
这里使用Raku给出一种解决方案：
use v6; my $file = open &#39;scores&#39;; my @names = $file.get.words ; #get方法读入一行，每调用一次get，读取一行 # &amp;gt; @names.perl # Array.new(&amp;quot;1&amp;quot;, &amp;quot;Beth&amp;quot;, &amp;quot;Ana&amp;quot;, &amp;quot;Charlie&amp;quot;, &amp;quot;Dave&amp;quot;) my %matches; # 赢得比赛次数 my %sets; # 赢得比赛局数 for $file.</description>
    </item>
    
    <item>
      <title>Raku 圣诞月历-(2014)</title>
      <link>https://ohmysummer.github.io/post/2014-12-19-raku%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2014/</link>
      <pubDate>Fri, 19 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2014-12-19-raku%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2014/</guid>
      <description>2014 Data munging in Raku vs Perl 5 案例学习: 生成成绩报告单
example.txt STDOUT Peter B Celine A- Zsófia B+ João F Maryam B+ 秀英 B- Finn D+ Aarav A Emma F Omar B  输出报告单：
Zsófia&#39;s grade: B+ List of students with a failing grade: João, Emma Distribution of grades by letter: A: 2 students B: 5 students D: 1 student F: 2 students  example.txt 是一个文本文件， 每行一个学生姓名和分数，中间用空格分割。 我们希望我们的脚本能解析这样的文件并打印含有如下信息的报告：
学生名为 “Zsófia”的成绩 所有不及格学生的名字 (i.</description>
    </item>
    
    <item>
      <title>Raku from Haskell - Nutshell</title>
      <link>https://ohmysummer.github.io/post/2017-04-29-raku-from-haskell-nutshell/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-04-29-raku-from-haskell-nutshell/</guid>
      <description>Haskell 和 Raku 是非常不同的语言。这很明显。 但是，这并不意味着没有相似之处或共同的想法！ 此页面尝试让一个 Haskell 用户启动并运行 Raku。Haskell 用户可能会发现，在用 Raku 编写脚本时，他们不需要放弃所有 Haskelly 的想法。
请注意，这不应该被误认为是初学者教程或 Raku 概述; 它旨在作为具有强大 Haskell 背景的 Raku 学习者的技术参考。
类型 类型 vs 值 在 Haskell 中, 您有类型级编程, 然后进行值级编程。
plusTwo :: Integer -&amp;gt; Integer -- Types plusTwo x = x + 2 -- Values  您不要像下面那样在 Haskell 中混合类型和值。
plusTwo 2 -- This is valid plusTwo Integer -- This is not valid  在 Raku 中, 类型(亦称为类型对象)和值处于同样的级别
sub plus-two(Int $x --&amp;gt; Int) { $x + 2 } plus-two(2); # This is valid plus-two(Int); # This is valid  我将再用一个例子来说明 Raku 这个独特之处:</description>
    </item>
    
  </channel>
</rss>