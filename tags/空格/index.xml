<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>空格 on Raku Programming</title>
    <link>https://ohmysummer.github.io/tags/%E7%A9%BA%E6%A0%BC/</link>
    <description>Recent content in 空格 on Raku Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 01 Aug 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/%E7%A9%BA%E6%A0%BC/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>unspaces</title>
      <link>https://ohmysummer.github.io/post/2016-08-01-unspaces/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-01-unspaces/</guid>
      <description>有些语言例如 C 允许你转义一个换行符使行联合起来. 其它语言(例如正则表达式)因为各种各样的原因, 允许你使用反斜线转义一个空白符. Raku 把这种记法推广到任何种类的空白上. 通过在空白处前置一个 \, 任何相邻的空白(包括注释)都会在解析器面前隐身. 这就是鼎鼎大名的空白隐身( “unspace”).
在 Perl 中, 一个 unspace 能够抑制任意的几种空白附属物. 例如, 因为 Perl 要求名词和后缀操作符之间不能出现空白, 所以使用 unspace 让你可以把后缀操作符贴线对齐:
%hash\ {$key} @array\ [$ix] $subref\($arg)  上面的最后一种形式作为一种退化了的 unspace, 即反斜线后面直接跟着后缀. 注意, 反斜线前面不允许有空白, 所以:
$subref \($arg)  是语法错误(two terms in a row). 而
foo \($arg)  会被解析为带有 Capture 参数的列表操作:
foo(\($arg))  然而, 其它形式的 unspace 可能被有效地放在空白之前.
其它后缀操作符也可能使用 unspace:
$number\ ++; $number\ --; 1+3\ i; $object\ .say(); $object\#`{ your ad here }.</description>
    </item>
    
  </channel>
</rss>