<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>given when on Raku Programming</title>
    <link>https://ohmysummer.github.io/tags/given-when/</link>
    <description>Recent content in given when on Raku Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 11 Aug 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/given-when/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Abundant and Deficient Numbers</title>
      <link>https://ohmysummer.github.io/post/2016-08-11-abundant-and-deficient-numbers/</link>
      <pubDate>Thu, 11 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-11-abundant-and-deficient-numbers/</guid>
      <description>问题描述 abundant 数是其所有因子的和大于该数，而deficient数是其因子的和小于该数。
例如, 考虑数字 21。它的因子是 1, 3, 7 和 21, 这些因子的和是32。 因为 32 小于 2 x 21, 所以 21 是 deficient。它的差额是 2 x 21 - 32 = 10。
12 是第一个 abundant 数。它的因子是 1, 2, 3, 4, 6 和 12, 并且它们的和是 28。 因为 28 大于 2 x 12, 所以 12 是 abundant。它们的差额是 28 - 2 x 12 = 4。
输入描述  你会给定一个整数, 每行一个。例如:
18219输出描述  你的程序应该打印信息, 如果数字是 deficient, abundant(和它的abundance), 或者都不。例如:</description>
    </item>
    
    <item>
      <title>given when</title>
      <link>https://ohmysummer.github.io/post/2016-07-09-given-when/</link>
      <pubDate>Sat, 09 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-07-09-given-when/</guid>
      <description>given-when 有两个小的改变, 并且这俩改变都是开启新行为的, 而不是限制已存在的行为。
第一个小的改变: when 的开关行为不仅仅是用于 given 块儿中的, 而是可以用在任何&amp;quot;主题化&amp;quot;的块儿中的, 例如 for 循环中或接收 $_作为参数的子例程中。
given $answer {when &amp;quot;Atlantis&amp;quot; { say &amp;quot;那是对的&amp;quot; }default { say &amp;quot;BZZZZZZZZZZZZZ!&amp;quot; }}for 1..100 {when * %% 15 { say &amp;quot;Fizzbuzz&amp;quot; }when * %% 3 { say &amp;quot;Fizz&amp;quot; }when * %% 5 { say &amp;quot;Buzz&amp;quot; }default { say $_ }}sub expand($_) {when &amp;quot;R&amp;quot; { say &amp;quot;红警&amp;quot; }when &amp;quot;G&amp;quot; { say &amp;quot;绿警&amp;quot; }when &amp;quot;B&amp;quot; { say &amp;quot;蓝警&amp;quot; }default { say $_ }}但是甚至不接受 $_作为参数的子例程也得到了它们自己的词法变量 $_供修改。所以规则就是&amp;quot;现在, 在 $_ 中有某些我能启动的好东西吗&amp;rdquo;。如果我们想要, 我们甚至能自己设置 $_。</description>
    </item>
    
    <item>
      <title>Raku 中的模式匹配</title>
      <link>https://ohmysummer.github.io/post/2016-03-09-raku%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Wed, 09 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-09-raku%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>模式匹配 my $name = &amp;quot;twostraws&amp;quot;;given $name {when &amp;quot;bilbo&amp;quot; { say &amp;quot;Hello, Bilbo Baggins!&amp;quot;}when &amp;quot;twostraws&amp;quot; { say &amp;quot;Hello, Paul Hudson!&amp;quot; }default { say &amp;quot;身份验证失败&amp;quot; }}同时检查名字和密码 my $name = &amp;quot;twostraws&amp;quot;;my $password = &amp;quot;fr0st1es&amp;quot;;given ($name, $password) {when (&amp;quot;bilbo&amp;quot;, &amp;quot;bagg1n5&amp;quot;) { say &amp;quot;Hello, Bilbo Baggins!&amp;quot; }when (&amp;quot;twostraws&amp;quot;, &amp;quot;fr0st1es&amp;quot;) { say &amp;quot;Hello, Paul Hudson!&amp;quot; }default { say &amp;quot;你是谁?&amp;quot; }}使用单个元组 my $authentication = (&amp;quot;twostraws&amp;quot;, &amp;quot;fr0st1es&amp;quot;);given $authentication {when (&amp;quot;bilbo&amp;quot;, &amp;quot;bagg1n5&amp;quot;) { say &amp;quot;Hello, Bilbo Baggins!</description>
    </item>
    
    <item>
      <title>given when和模式匹配</title>
      <link>https://ohmysummer.github.io/post/2016-02-06-given-when%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 06 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-06-given-when%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description>Raku 中的模式匹配
use v6;my $bool1 = 1;my $bool2 = 0;given ($bool1, $bool2) {when (0, 0) {say &amp;quot;0, 0&amp;quot;}when (0, 1) {say &amp;quot;0, 1&amp;quot;}when (1, 0) {say &amp;quot;1, 0&amp;quot;}when (1, 1) {say &amp;quot;1, 1&amp;quot;}}given (&amp;quot;15&amp;quot;, &amp;quot;example&amp;quot;, &amp;quot;3.14&amp;quot;) {say $_.WHAT; # (&amp;quot;15&amp;quot;, &amp;quot;example&amp;quot;, &amp;quot;3.14&amp;quot;) =&amp;gt; Listwhen ($, $, Str) { say &amp;quot;I got a String of $_[2]&amp;quot; } # $ 代表一个匿名变量, 表示元组的前两个不参与智能匹配?</description>
    </item>
    
    <item>
      <title>Subset</title>
      <link>https://ohmysummer.github.io/post/2015-03-19-subset/</link>
      <pubDate>Thu, 19 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-19-subset/</guid>
      <description>Subset 子集 Subset 可用于声明某一类型的子集。
输入一个密码， 要求密码必须满足如下条件：
1、 至少 8 位 2、 必须包含大写字母、小写字母 和 数字
use v6;subset Length8 of Str where *.chars &amp;lt; 8;subset UpCase of Str where none(&#39;A&#39;..&#39;Z&#39;) ∈ *.comb.Set;subset LowerCase of Str where none(&#39;a&#39;..&#39;z&#39;) ∈ *.comb.Set;subset IntNumber of Str where none(&#39;0&#39;..&#39;9&#39;) ∈ *.comb.Set;my $guess = prompt(&#39;Enter your password:&#39;);given $guess {when Length8 { say &#39;密码长度必须为 8 位 以上&#39;; proceed }when UpCase { say &#39;密码必须包括大写字母&#39;; proceed }when LowerCase { say &#39;密码必须包含小写字母&#39;; proceed }when IntNumber { say &#39;密码必须包含数字&#39;; } }该程序具有可扩展性， 要增加一种密码验证， 只有添加一个 subset 就好了，然后在 given/When 里面增加一个处理。</description>
    </item>
    
  </channel>
</rss>