<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Raku on Raku Programming</title>
    <link>https://ohmysummer.github.io/tags/raku/</link>
    <description>Recent content in Raku on Raku Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 31 Jul 2019 20:22:08 +0800</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/raku/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Parse with Raku Regexes and Grammars</title>
      <link>https://ohmysummer.github.io/post/2019-07-31-parse-with-raku-regexes-and-grammars/</link>
      <pubDate>Wed, 31 Jul 2019 20:22:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-07-31-parse-with-raku-regexes-and-grammars/</guid>
      <description>启动翻译。</description>
    </item>
    
    <item>
      <title>Encode-Decode</title>
      <link>https://ohmysummer.github.io/post/2019-07-16-encode-decode/</link>
      <pubDate>Tue, 16 Jul 2019 18:56:48 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-07-16-encode-decode/</guid>
      <description>http://blogs.perl.org/users/damian_conway/2019/07/vigenere-vs-vigenere.html
第15 届 Perl 每周挑战赛的第二项任务是为 Vigenère Cipher 实现编码器和解码器。但这比看起来要复杂得多，因为以 Blaisede Vigenère 命名的密码实际上并不是由他发明的，而 Vigenère 实际发明的密码并不是以他的名字命名的。
那么我们应该实现 Vigenère Cipher 加密&amp;hellip;还是 Vigenère 加密？为什么不两个都要呢！
Vigenère Cipher 是由吉奥万·巴蒂斯塔·贝拉索于 1553 年制定的，然后错误归因到约三百年后的 Vigenère 身上。它使用tabularēcta 把消息文本转换为密文，然后再转回去。
给定用户提供的密钥（例如 &amp;ldquo;BELLASO&amp;rdquo;），我们通过匹配密钥和消息的相应字母来加密消息（例如 &amp;quot;VIGENEREDIDNOTINVENTTHIS&amp;quot;），然后将它们用作两个索引以在 rēcta 表的适当列和行中查找对应的密码字符。如果密钥短于消息，我们只需根据需要多次循环密钥。
例如：
 Key: B E L L A S O B E L L A S O B E L L A S O B E L L A... Text: V I G E N E R E D I D N O T I N V E N T T H I S Table: ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓↓ ↓ ↓ Cipher: W M R P N W F F H T O N G H J R G P N L H I M D 换句话说，tabularēcta 的每一列是单独的Caesar Cipher （或ROT-N转录），其中每个连续的密钥字母选择在消息中的相应字母上执行哪个替换。</description>
    </item>
    
    <item>
      <title>Raku 中的 奇偶排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-29-odd-even-sort-in-raku/</link>
      <pubDate>Sat, 29 Jun 2019 19:37:39 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-29-odd-even-sort-in-raku/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Raku 中的煎饼排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-27-pancake-sort-in-raku/</link>
      <pubDate>Sat, 29 Jun 2019 19:36:02 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-27-pancake-sort-in-raku/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Raku 中的 Gnome sort</title>
      <link>https://ohmysummer.github.io/post/2019-06-28-gnome-sort-in-raku/</link>
      <pubDate>Fri, 28 Jun 2019 19:37:18 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-28-gnome-sort-in-raku/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Raku 中的 Stooge Sort</title>
      <link>https://ohmysummer.github.io/post/2019-06-26-stooge-sort-in-raku/</link>
      <pubDate>Wed, 26 Jun 2019 19:35:43 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-26-stooge-sort-in-raku/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Raku 中的合并排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-25-merge-sort-in-raku/</link>
      <pubDate>Tue, 25 Jun 2019 19:35:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-25-merge-sort-in-raku/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Raku 中的插入排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-24-insertion-sort-in-raku/</link>
      <pubDate>Mon, 24 Jun 2019 19:19:06 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-24-insertion-sort-in-raku/</guid>
      <description>今天，我们研究插入排序算法及其在 Raku 中的可能实现。算法的复杂性是 O(n2)，但它是练习 Raku 的一个很好的选择。
这个想法很简单。您可以在数组中找到最小值并将其放在第一个位置。然后从第二个位置开始扫描数据（因为第一个位置已经被最低元素占用）。然后你向右走，找到最小值并将它们放到当前位置直到你到达终点。
它类似于选择排序，但不是交换两个元素，而是插入一个（因此，移动其他元素）。让我们从简单的方法和两个嵌套循环开始：
sub insertion-sort(@data) { for ^@data -&amp;gt; $i { for ^$i -&amp;gt; $j { if @data[$i] &amp;lt; @data[$j] { @data.splice($j, 0, @data[$i]); @data.splice($i + 1, 1); } } } } my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10; insertion-sort @data; say @data; 在Raku中，数组的拼接方法可以完成两个任务：用另一个元素列表替换数组的一部分，或者只是删除元素或一行中的一些元素。
在上面的代码中，使用了该方法的两个应用程序。首先，将新找到的元素插入当前位置。其次，它从之前的位置删除（数组刚刚增长，因此索引变为$ i + 1）。
由于splice方法也返回已删除的元素，我们可以将第二个调用放到正在读取元素的位置：@data [$ i]。因此，可以使用以下嵌套调用替换这两行
@data.splice($j, 0, @data.splice($i, 1)) 请注意，索引现在只是$ i，因为数组尚未修改。
您应该已经熟悉了第二个可能的技巧：如果出现以下情况，请使用 if 后缀：</description>
    </item>
    
    <item>
      <title>Raku 中的快速排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-23-quick-sort-in-raku/</link>
      <pubDate>Sun, 23 Jun 2019 19:16:15 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-23-quick-sort-in-raku/</guid>
      <description>今天，我们来看看另一个，也许是最着名的数据排序方法，快速排序。
该算法要求您选择所谓的枢轴，其中一个元素来自数据，并将其余部分分成两部分：小于枢轴的元素，以及大于或等于枢轴的元素。然后再次递归地对每个部分进行排序。在每次迭代中，部件变得越来越小，直到子列表是一个或甚至零个元素的平凡数据集。
一个单独的理论是如何选择正确的枢轴。有几种方法，例如，从列表中间取值，或取第一项，或最后一项，或随机项。还有更复杂的方法，您可以调整它以在您的数据集类型上实现最佳性能。
为简单起见，让我们选择第一个元素作为轴点，这是代码
sub quick-sort(@data) { return @data if @data.elems &amp;lt;= 1; my $pivot = @data[0]; my @left; my @right; for @data[1..*] -&amp;gt; $x { if $x &amp;lt; $pivot { push @left, $x; } else { push @right, $x; } } return flat(quick-sort(@left), $pivot, quick-sort(@right)); } my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10; @data = quick-sort @data; say @data; 与之前的冒泡排序示例不同，此程序不会就地排序，而是返回新列表。
现在是时候将代码转换为更具 Raku 风格代码的时候了。</description>
    </item>
    
    <item>
      <title>Raku 中的冒泡排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-22-bubble-sort-in-raku/</link>
      <pubDate>Sat, 22 Jun 2019 10:59:47 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-22-bubble-sort-in-raku/</guid>
      <description>嘿大家好，让我们在 Raku 中实现一些算法。
第一个将是经典的冒泡排序。实质上，您从左到右扫描数据并交换两个相邻的项（如果它们尚未正确排序）。重复这个过程，直到整个数据列表被排序。
这是最初的直接实现：
sub bubble-sort(@data) { my Bool $done = False; while !$done { $done = True; for 1 .. @data.elems - 1 -&amp;gt; $n { if @data[$n - 1] &amp;gt; @data[$n] { (@data[$n - 1], @data[$n]) = (@data[$n], @data[$n - 1]); $done = False; } } } } my @data = 4, 5, 7, 1, 46, 78, 2, 2, 1, 9, 10; bubble-sort @data; say @data; 此实现执行就地排序，但您不需要将函数参数声明为 is rw。实际上，编译器会告诉您这是多余的，并将停止进一步编译:</description>
    </item>
    
    <item>
      <title>Raku 中的选择排序</title>
      <link>https://ohmysummer.github.io/post/2019-06-21-selection-sort-in-raku/</link>
      <pubDate>Fri, 21 Jun 2019 16:26:46 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-21-selection-sort-in-raku/</guid>
      <description>sub find-smallest(@arr) { my $smallest = @arr[0]; my $smallest_index = 0; for @arr.kv -&amp;gt; $k, $v { if $v &amp;lt; $smallest { $smallest = $v; # 存储最小的值 $smallest_index = $k; # 存储最小元素的索引 } } return $smallest_index } sub selection-sort(@arr) { my @new-arr = []; for @arr.clone.kv -&amp;gt; $k, $v { # 对数组进行排序 my $smallest_index = find-smallest(@arr); @new-arr.append(@arr.splice($smallest_index,1).head); # 找出数组中最小的元素,并将其加入到新数组中 } return @new-arr } say selection-sort([5, 3, 6, 2, 10]); </description>
    </item>
    
    <item>
      <title>Raku 实现二分查找</title>
      <link>https://ohmysummer.github.io/post/2019-06-01-binary-search-in-raku/</link>
      <pubDate>Sat, 01 Jun 2019 14:09:49 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-06-01-binary-search-in-raku/</guid>
      <description>sub binary_search(@list, $item) { my $low = 0; # low 和 high 用于跟踪要在其中查找的列表部分 my $high = @list.elems -1; # while $low &amp;lt;= $high { # 只要范围没有缩小到只包含一个元素 my $mid = ($low + $high) / 2; # 就检查中间的元素 my $guess = @list[$mid]; return $mid if $guess == $item; # 找到了就返回 if $guess &amp;gt; $item { # 猜的数字大了 $high = $mid -1 } else { # 才的数字小了 $low = $mid + 1 } } } my @list = [1, 3, 5, 7, 9]; say binary_search(@list, 3); say binary_search(@list, -1); </description>
    </item>
    
    <item>
      <title>Raku Colonoscopy</title>
      <link>https://ohmysummer.github.io/post/2019-03-26-perl6-colonoscopy/</link>
      <pubDate>Tue, 26 Mar 2019 09:33:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-03-26-perl6-colonoscopy/</guid>
      <description>Raku Colonoscopy I promise, this will not hurt. Much&amp;hellip;
In this article we&amp;rsquo;ll look into colons in Raku, where to place them, and what they mean. 我保证，这不会受到伤害。许多&amp;hellip;
在本文中，我们将研究Raku中的冒号，放置它们的位置以及它们的含义。
Sigils But first a short detour. A newcomer to the Raku universe cannot miss the significance of sigils when dealing with variables. They are:
 $ (Anything) @ (Array) % (Hash) &amp;amp; (Callable)  The sigil is part of the variable name, and is not changed depending on the context (as in Perl 5):</description>
    </item>
    
    <item>
      <title>Perl 5 to Raku guide - special variables</title>
      <link>https://ohmysummer.github.io/post/2019-02-24-special-variables/</link>
      <pubDate>Mon, 25 Feb 2019 13:33:26 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-02-24-special-variables/</guid>
      <description>描述 一个（希望）全面的 Perl 5 特殊变量列表及其 Raku 等价物，并在必要时记录它们之间的变化。
注意 本文档试图引导读者从 Perl 5 中的特殊变量到 Raku 中的等效变量。有关 Raku 特殊变量的完整文档，请参阅每个变量的 Raku 文档。
特殊变量 通用变量  $ARG $_  值得庆幸的是， $_ 是 Perl 5 中的常规默认变量。Raku 的主要区别在于现在你可以在它身上调用方法。 例如，Perl 5 的 say $_ 可以在 Raku 中以 $_.say 表示。 此外，因为它是默认变量，您甚至不需要使用变量名称。 前面的例子也可以 通过使用 .say 实现。
 @ARG @_  由于 Raku 现在具有函数签名，您的参数可以去那里，而不是依赖于 @_。 事实上，如果你使用函数签名，使用 @_ 会吐出你告诉它不能覆盖一个现有签名。
但是，如果您不使用函数签名，则 @_ 将包含您传递给函数的参数, 就像它在Perl 5中那样。再次，与 $_ 一样 ，您可以在其上调用方法。 与 $_ 不同，你不能假设 @_ 为 这些方法的默认变量（即 @_.</description>
    </item>
    
    <item>
      <title>Python to Raku - nutshell</title>
      <link>https://ohmysummer.github.io/post/2019-02-25-python-to-raku-nutshell/</link>
      <pubDate>Mon, 25 Feb 2019 09:41:35 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-02-25-python-to-raku-nutshell/</guid>
      <description>此页面试图为来自 Python 背景的人们提供学习 Raku 的方法。我们在 Raku 中讨论了许多 Python 构造和惯用法的等价语法。
基本语法 Hello, world 让我们从打印 &amp;ldquo;Hello, world!&amp;rdquo; 开始吧。 Raku 中的 put 关键字相当于 Python 中的 print。与 Python 2 一样，括号是可选的。换行符添加到行尾。
 Python 2  print &amp;#34;Hello, world!&amp;#34;  Python 3  print(&amp;#34;Hello, world!&amp;#34;)  Raku  put &amp;quot;Hello, world!&amp;quot; 还有 say 关键字，其行为类似，但会调用其参数的 gist 方法。
 Raku  my $hello = &amp;quot;Hello, world!&amp;quot;; say $hello; # also prints &amp;quot;Hello, world!&amp;quot; # same as: put $hello.gist 在 Python 中 &#39; 和 &amp;quot; 是可互换的。在 Raku 中两者都可用于引用, 但双引号(&amp;quot;)表示应该进行插值。例如, 以 $ 开头的变量和包含在花括号中的表达式会被插值。</description>
    </item>
    
    <item>
      <title>How Naming of Variables Works in Raku</title>
      <link>https://ohmysummer.github.io/post/2018-09-28-how-naming-of-variables-works-in-raku/</link>
      <pubDate>Fri, 28 Sep 2018 20:18:30 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-09-28-how-naming-of-variables-works-in-raku/</guid>
      <description>在本系列的第 5 篇文章中，比较 Perl 5 和 Raku，了解在 Raku 中使用 sigils。
在本系列的前 4 篇文章中，我们比较了 Perl 5 和 Raku，讨论了迁移代码时可能遇到的一些问题，垃圾收集是如何工作的，为什么容器替换了引用，以及在 Raku 中使用(子例程)签名，以及这些与 Perl 5 的区别。
在第 5 篇文章中，我们将查看 Perl 5 和 Raku 之间 sigils(变量名开头的符号)的细微差别。
概览 让我们从 Perl 5 和 Raku 中的 sigils 的概述开始:
   Sigil Perl 5 Raku     @ Array Positional   % Hash Associative   &amp;amp; Subroutine Callable   $ Scalar Item   * Typeglob n/a    @ (Array vs.</description>
    </item>
    
    <item>
      <title>Command Line Arguments in Raku</title>
      <link>https://ohmysummer.github.io/post/2018-08-07-command-line-arguments-in-raku/</link>
      <pubDate>Tue, 07 Aug 2018 19:54:26 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-08-07-command-line-arguments-in-raku/</guid>
      <description>MAIN 子例程 命名参数和位置参数  命名参数 位置参数 Multi dispatch 组合命名参数和位置参数   可选参数和必选参数 别名或备用命名参数 USAGE 子例程  Sub MAIN 在 Raku 中，命令行参数的解析是使用 MAIN 子例程完成的，MAIN 子例程是一个特殊的子例程，它根据签名解析命令行参数。与其他子程序一样，您可以使用命名参数和位置参数，可选（和必需）参数，multiple dispatch 等。 通过定义 MAIN 子例程，编译器会自动生成 USAGE 子例程。可以修改此子例程以返回自定义的 usage 信息。所有的命令行参数也可以在特殊变量 @*ARGS 中使用，它可以在 MAIN 处理之前进行更改。
命名参数和位置参数 命名参数
我们从一个简单的程序开始（保存为 prog.p6）:
use v6; sub MAIN( Str :$name = &#39;John&#39;, Str :$last-name = &#39;Doe&#39;, ) { my $formatted-name = &amp;quot;$name.tc() $last-name.tc()&amp;quot;; say $formatted-name; } 在这个 MAIN 子程序中，我们创建了两个命名参数，$name 和 $last-name，带有类型约束（Str），方法是在子例程的签名给每个变量添加 :。这些参数还具有默认值，这是通过为参数赋值来实现的。在这种情况下，我们将 $name 设置为默认值 &amp;lsquo;John&amp;rsquo;，将 $last-name 设置为 &amp;lsquo;Doe&amp;rsquo;。如果执行 prog.</description>
    </item>
    
    <item>
      <title>我为什么学习Raku</title>
      <link>https://ohmysummer.github.io/post/2018-07-07-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0raku/</link>
      <pubDate>Fri, 06 Jul 2018 00:27:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-07-%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%A6%E4%B9%A0raku/</guid>
      <description>http://www.evanmiller.org/why-im-learning-perl-6.html
想听一个编程笑话吗？
Raku。
想知道我最喜欢的编程语言吗？
Raku。
嘘，克隆 master 分支并运行这个：
use v6.d.PREVIEW; my $channel = Channel.new; my @ten_tasks = (^10).map: { start { my $thread = $*THREAD.id; await $channel; say &amp;quot;HOLY MOLEY SOMEONE STOLE MY THREAD&amp;quot; if $thread != $*THREAD.id; } } $channel.send(&amp;quot;Ring ring&amp;quot;) for ^10; $channel.close; await @ten_tasks; 猜猜它输出了什么？
没有！开个玩笑，你会看到很多来自任务的烦恼消息，等待电话响起，然后穿着别人的操作系统线程醒来。
为什么这很重要？并发很难，如果你想要M：N线程多路复用（即WEB SCALE CODE，其中应用程序线程没有固定到pthread）你今天的选择正是Erlang，Go，.NET和Raku。
如果你对Erlang感到困惑，被Go推迟，对.NET无动于衷，请看看Raku.认真的。当然，它的发展时间比男孩时期要长 - 从2000年开始，比电影早两年，并在2015年发布，两年之后 - 但也许如果有人在某事上工作了15年，他们实际上可能会做出一些好事。我不是说这种情况是真的（可能不是少年时代），但至少它是可能的，对吗？
有趣的是，十五年前，每个人都在说Perl是如何通过大规模的语言重新设计而自拔的，因为世界显然将转向Python和Ruby。好吧每个人都切换到Python和Ruby，但现在每个人都有了再次切换的痒，因为事实证明Python和Ruby并不是为并发代码执行而设计的。如果你需要的是仿生robo-feet，也许拍摄自己的脚并不是一个糟糕的策略。
我不会在这里回顾 Raku 作为一种语言，因为它是一个包含大量黑暗角落和奇怪边缘情况的大规模规范，但我确实希望分享一些关于语言运行时发现的事情。 Raku虚拟机MoarVM是一项出色的技术。
事件循环感知调度程序？检查。延续？你得到了他们。将两者混合后会发生什么？好吧，你可以启动数百个工作程序并让它们等待消息（比如网络），而不会占用任何操作系统线程。当例程获得消息时，它会继续执行任何可用的OS线程。因此在开场示例中所有的“圣洁的MOLEY”。这就像Go或Erlang有更多的美元符号，或者没有回调cacciatore的Nginx或Node.js。
MoarVM是用漂亮干净的C编写的，如果你喜欢挖掘，它会充满惊喜。没有GIL，因此与其他语言不同，Raku字节码可以同时执行。 Unicode很棒，让“Straße”.uc正确并使用一个聪明的恒定时间算法来解决代码点组合的字形。对象模型和垃圾收集器与FFI很好地配合，因此与C的接口很简单。代码库编写得很好，组织良好，文档齐全，经过充分测试;小东西，比如具有正确尺寸的函数和具有良好名称的变量，使得阅读愉快。
判断语言实现的快速方法是检查其字符串连接函数。如果将concat实现为realloc和memcpy，那么楼上的灯可能没有设置为全亮度。看哪，在MoarVM中，字符串被分成多个字符串，并且可以重复链而不占用更多内存。所以这个表达式：
&amp;quot;All work and no play makes Jack a dull boy&amp;quot; x 1000 不会生成一千个字符串的副本，甚至可以指向同一个字符串的一千个指针。它存储为短字符串和重复计数，并且VM字符串函数知道如何在具有重复子字符串的字符串上有效地操作。很聪明，对吧？制作一亿份; RAM的使用率几乎没有变化</description>
    </item>
    
    <item>
      <title>Raku 概览</title>
      <link>https://ohmysummer.github.io/post/2018-07-06-raku%E6%A6%82%E8%A7%88/</link>
      <pubDate>Fri, 06 Jul 2018 00:23:57 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-07-06-raku%E6%A6%82%E8%A7%88/</guid>
      <description>http://www.evanmiller.org/a-review-of-perl-6.html
Raku 让我想起了我叔叔的博士学位论文。在前五年, 我们会问（圣诞节前）他什么时候完成; 时间久了我们就越来越不相信他的答案了, 并且没有任何证据表明论文确实存在过, 我们使完成日期成为一种流行的笑话, 就像波士顿 Big Dig 或纽约的第二大道地铁线。但是, 经过多次自我强加的最后期限后, 我们已经不再拿它开玩笑了。过了那么多年, 我们不再问了。
如果你错过了, 我认为每个人都错过了, Raku 在一年半前 - 在 2015 年的圣诞节 - 碰巧发布了 - 在名义上跨越了近 16 年之后被发布了。 （我想, 但我不确定, 我的叔叔的论文也在某个时候完成了。）我在 2017 年写这篇文章的新编程语言市场虽然具有竞争力, 但并不是难以理解的 - 但就像一位新博士生, 似乎没有人确定 Raku 的市场前景, 就像一篇刚刚开始的论文, 似乎没有人知道多年的劳动成果是否真的值得一试。
除了你想要的任何简单答案之外, Raku 的提供者几乎没有提供关于你应该用这个语言做什么的一些提示。 Raku 是多范式的, 也许是全范式的; 它声称支持面向对象的编程, 函数式编程, 面向标记的编程, 数组编程和（旧的）过程式编程。这是一种新语言, 而不仅仅是 Perl 5 的清理版本, 只不过英语是德语减去变音符号。了解以前的版本, 唉, 不会让你走得太远。出于同样的原因, 对前面化身的偏见并不一定适用于今天的水。
接下来是我试图向世界提供一个对编程世界中最白的大象Raku的一个诚实的, 如果不完整的评估。我受到以下思想的激励：每个系统管理员至少知道一点 Perl, 但我不认识任何人我知道任何 Raku, 也不认识任何知道 Raku 的人。我从来没有读过任何关于 Raku 的信息。我同样可以想象一个 Raku 是一堆垃圾的世界, 还有一个语言设计的 Hope Diamond。似乎没有人知道;没有人会知道。 Raku 是一个已写入的寄存器, 仍在等待读取。</description>
    </item>
    
    <item>
      <title>饭否客户端</title>
      <link>https://ohmysummer.github.io/post/2018-05-10-%E9%A5%AD%E5%90%A6%E5%AE%A2%E6%88%B7%E7%AB%AF/</link>
      <pubDate>Thu, 10 May 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-10-%E9%A5%AD%E5%90%A6%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid>
      <description>Inspired by fanfou-py
use Digest::HMAC;use Digest;use Digest::SHA;use MIME::Base64;use URI::Encode;use URI;use Cro::HTTP::Client;# URL 编码sub oauth_escape($s){return uri_encode_component($s.Str);}# 返回当前时间戳sub oauth_timestamp() {return time;}# 单次值, 返回一个8位的随机字符串, 防止重复请求sub oauth_nonce($size=8) {return ((1..9).pick for 1..$size).join(&amp;quot;&amp;quot;);}# 返回按一定顺序拼接好的字符串sub oauth_query(%args) {return (sprintf &amp;quot;%s=%s&amp;quot;, $_, oauth_escape(~%args{$_}) for %args.keys.sort).join(&#39;&amp;amp;&#39;);}# URL 正规化sub oauth_normalized_url($url){my URI $u .= new($url);return sprintf(&#39;%s://%s%s&#39;, $u.</description>
    </item>
    
    <item>
      <title>Awesome Async Interfaces with Raku</title>
      <link>https://ohmysummer.github.io/post/2018-04-27-raku%E4%B8%AD%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 26 Apr 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-04-27-raku%E4%B8%AD%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3/</guid>
      <description>2015 年圣诞节前后, 我写了我的第一个 Raku 程序 - 新年 IRC 派对机器人。这项工作包括发布了 IRC::Client 模块。我从这个语言中找到了童年的乐趣并且在假期喝了不少酒, 结果就是这个模块最终足够疯狂。
最近, 我需要一个工具来完成一些 Raku 的 bug 队列工作, 因此我决定把自己关上一个周末, 从头开始重新设计和重写这个模块。在过去的几个月里, 有好几个人请求我这么做, 所以我想我也应该写一篇关于如何使用这个模块的教程 - 作为对我这个拖延症大师的道歉。如果你对 IRC 没有兴趣的话, 我希望这篇教程可以作为 Raku 中的异步、非阻塞接口的一个一般示例。
基础 要创建一个 IRC 机器人, 请实例化一个 IRC::Client 对象, 给它一些基本信息, 然后调用 .run 方法。将所有你需要的功能实现为类, 并通过方法名匹配你想要监听的事件, 然后通过 .plugins 属性将其传递给所有的插件。当发生 IRC 事件时, 它会按照你指定的顺序传递给所有的插件, 如果有插件宣称处理了该事件就停止。
这里有一个简单的 IRC 机器人, 它可以响应在频道中找人、通知和发送给它的私人消息。下面这个响应是机器人收到的大写后的原始消息：
use IRC::Client;.run with IRC::Client.new::nick&amp;lt;MahBot&amp;gt;:host&amp;lt;irc.freenode.net&amp;gt;:channels&amp;lt;#raku&amp;gt;:debug:plugins(class { method irc-to-me ($_) { .text.uc } })这就是机器人运行时的样子：</description>
    </item>
    
    <item>
      <title> More on the proto keyword in Raku</title>
      <link>https://ohmysummer.github.io/post/2018-02-21-more-on-the-proto-keyword-in-raku/</link>
      <pubDate>Wed, 21 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-21-more-on-the-proto-keyword-in-raku/</guid>
      <description>在深入研究 EVAL 子例程的细节之前，我们必须揭示一些关于 protos 原型和多重分派的更多信息。检查以下程序：
proto sub f($x) {say &amp;quot;proto f($x)&amp;quot;;}multi sub f($x) {say &amp;quot;f($x)&amp;quot;}multi sub f(Int $x) {say &amp;quot;f(Int $x)&amp;quot;}multi sub f(Str $x) {say &amp;quot;f(Str $x)&amp;quot;}f(2);f(&#39;2&#39;);f(3);f(&#39;3&#39;);这里有三个 multi 函数和一个用 proto 关键字声明的函数。早些时候，我们只看到了函数体为空的原型函数，如:
proto sub f($x) {*}但这不是必需的。正如我们在示例中所看到的，该函数可以承载正常的函数体：
proto sub f($x) {say &amp;quot;proto f($x)&amp;quot;;}运行这个程序：
proto f(2)proto f(2)proto f(3)proto f(3)所有的调用都被 proto-候选者抓住了。现在，更新它并返回一些专用值的 {*} 块;</description>
    </item>
    
    <item>
      <title>Examining the Real role of Raku, part 2</title>
      <link>https://ohmysummer.github.io/post/2018-02-18-examining-the-real-role-of-raku-part-2/</link>
      <pubDate>Sun, 18 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-18-examining-the-real-role-of-raku-part-2/</guid>
      <description>今天，我们继续对几天前开始的 Real 角色进行初步探索。
与其方法一起，角色包含许多子例程（放置在角色之外），它们使用 Real 类型的对象定义中缀运算符。名单不长，所以让我把它复制在这里：
multi sub infix:&amp;lt;+&amp;gt;(Real \a, Real \b) { a.Bridge + b.Bridge }multi sub infix:&amp;lt;-&amp;gt;(Real \a, Real \b) { a.Bridge - b.Bridge }multi sub infix:&amp;lt;*&amp;gt;(Real \a, Real \b) { a.Bridge * b.Bridge }multi sub infix:&amp;lt;/&amp;gt;(Real \a, Real \b) { a.Bridge / b.Bridge }multi sub infix:&amp;lt;%&amp;gt;(Real \a, Real \b) { a.Bridge % b.Bridge }multi sub infix:&amp;lt;**&amp;gt;(Real \a, Real \b) { a.Bridge ** b.</description>
    </item>
    
    <item>
      <title>Everyone Loves Porgs</title>
      <link>https://ohmysummer.github.io/post/2018-02-17-everyone-loves-porgs/</link>
      <pubDate>Sat, 17 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-17-everyone-loves-porgs/</guid>
      <description>这个想法有一阵子了。我在完成的各个阶段都有几个发文的想法，有时候很难优先考虑这个问题。所以我想我要开始发布我一直在玩的更短的想法和事情，以免这个博客变成那些永不更新的博客之一。所以，我们开始吧。
类在 Raku 中很容易定义。它们非常容易，我发现自己使用它们来封装小型的 Hash-like 那样的东西，其中我也可能会使用一两种方法。
class Contact {has $.name;has $.phone;has $.bday;method age {(Date.new($.bday), *.later(:1year) ...^ * &amp;gt; Date.today).end}}是的，这是一种低效率的计算年龄的方法&amp;hellip;&amp;hellip;就像生活中的很多事情一样，你越老，这种方法变得越慢。
无论如何，现在我已经定义了一个简单的小类来保存一些数据，但要实际实例化一个我不得不 bust out 一些命名参数。
my @contacts;@contacts.push: Contact.new(:name&amp;lt;John&amp;gt;, :phone&amp;lt;555-1111&amp;gt;, :bday&amp;lt;1940-10-09&amp;gt;);谁有时间为所有这些角色？有时候我只是想用位置参数来构建它们，但这意味着要编写一个新的自定义 multi method new 来处理这些情况&amp;hellip;&amp;hellip;但我只是将一个快速肮脏的类放在一起，真的值得我花时间来构建自定义构造函数吗？
于是我开始四处游玩，并创建了一个让我用 Positional 参数的角色&amp;hellip;&amp;hellip;或一个 Array ..或 List &amp;hellip;构建我的类，嘿，I threw in a Hash for free!！
@contacts.push: Contact.new(&#39;James&#39;, &#39;555-1112&#39;, &#39;1942-06-18&#39;);@contacts.push: Contact.new(&amp;lt; George 555-1113 1943-02-25 &amp;gt;)my %hash = name =&amp;gt; &#39;Richard&#39;, phone =&amp;gt; &#39;555-1114&#39;, bday =&amp;gt; &#39;1940-07-07&#39;;@contacts.</description>
    </item>
    
    <item>
      <title>A word on polymod in Raku</title>
      <link>https://ohmysummer.github.io/post/2018-02-16-a-word-on-polymod-in-raku/</link>
      <pubDate>Fri, 16 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-16-a-word-on-polymod-in-raku/</guid>
      <description>在转到 Real 角色的第二部分之前，让我们停下来研究一下 Int 类的中的 polymod 方法。
该方法接收一个数字和任意数字（单位）的列表并返回相应的乘数。所以，你可以很容易地说，例如 550 秒，是 9分 10 秒：
&amp;gt; 550.polymod(60)(10 9)在方法调用中，60 的值是一分钟内的秒数。结果中，9 是分钟数，10 是余数，其为秒数。所以，550 秒= 10 秒 + 9 分钟。
如果你想了解更多细节，请添加更多单位。例如，什么是 32768 秒？
&amp;gt; 32768.polymod(60, 60, 24)(8 6 9 0)这是 8 秒，6 分钟，9 小时和 0 天。
类似地，132768 秒是 1 天，12 小时，52 分钟和 48 秒：
&amp;gt; 132768.polymod(60, 60, 24)(48 52 12 1)老实说，我很难理解它是如何工作的，以及如何读取结果。
文档中的另一个例子更加难以理解：
&amp;gt; 120.polymod(1, 10, 100)(0 0 12 0)12 是什么意思？这显然是12倍10.</description>
    </item>
    
    <item>
      <title>如何在 Raku 中对散列进行排序</title>
      <link>https://ohmysummer.github.io/post/2018-02-16-%E5%A6%82%E4%BD%95%E5%9C%A8raku%E4%B8%AD%E5%AF%B9%E6%95%A3%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 16 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-16-%E5%A6%82%E4%BD%95%E5%9C%A8raku%E4%B8%AD%E5%AF%B9%E6%95%A3%E5%88%97%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F/</guid>
      <description>要在 Raku 中对散列进行排序，首先你要知道什么是占位符变量。一旦这个概念变得清晰，对散列排序就变得非常简单。
例如，创建一个不同城市距离莫斯科远近的散列：
my %distance =Владимир =&amp;gt; 185,Волгоград =&amp;gt; 1000,Калининград =&amp;gt; 1227,Мурманск =&amp;gt; 1895,Новосибирск =&amp;gt; 3550;现在的任务是通过比较距离来对散列进行排序。
say %distance.sort({$^a.value &amp;lt;=&amp;gt; $^b.value});一般来说，它已经准备好了。该程序打印你需要的东西：
(Владимир =&amp;gt; 185 Волгоград =&amp;gt; 1000 Калининград =&amp;gt; 1227 Архангельск =&amp;gt; 1261 Астрахань =&amp;gt; 1411 Мурманск =&amp;gt; 1895 Новосибирск =&amp;gt; 3550)让我们看看传递给排序方法的块内发生了什么。
首先，变量 $^a 和 $^b 是占位符，它是匿名块的参数并按字母顺序排序。也就是说，以相同的方式，他们可以被称为 $^x 和 $^y 或 $^var1 和 $^var2。
其次，这些占位符变量内部是 Pair 类型的对象，它包含键和值：
say %distance.sort({say $^a.key ~ &#39;, &#39; ~ $^a.</description>
    </item>
    
    <item>
      <title>Examining the Real role of Raku, part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-15-examining-the-real-role-of-perl-6-part-1/</link>
      <pubDate>Thu, 15 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-15-examining-the-real-role-of-perl-6-part-1/</guid>
      <description>在过去的几天里，我们谈了很多关于 Real 这个角色。让我们更仔细地看看它。该代码位于 src/core/Real.pm 文件中。
它包含角色本身和一些实现不同中缀的子例程。Real 角色又实现了 Numeric 角色：
my role Real does Numeric {. . .}有趣的是，类定义还需要关于 Complex 类的一些知识，这就是为什么在文件的第一行有一个前向类声明：
my class Complex { ... }Real 角色将许多三角函数定义为方法，正如我们已经看到的，他们正在使用 Bridge 方法：
method sqrt() { self.Bridge.sqrt }method rand() { self.Bridge.rand }method sin() { self.Bridge.sin }method asin() { self.Bridge.asin }method cos() { self.Bridge.cos }method acos() { self.Bridge.acos }method tan() { self.Bridge.tan }method atan() { self.</description>
    </item>
    
    <item>
      <title>FatRat vs Rat in Raku</title>
      <link>https://ohmysummer.github.io/post/2018-02-15-fatrat-vs-rat-in-raku/</link>
      <pubDate>Thu, 15 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-15-fatrat-vs-rat-in-raku/</guid>
      <description>昨天，Solomon Foster 在 Facebook 的 Raku 小组上发布了一个例子:
my @x = FatRat.new(1, 1), -&amp;gt; $x { $x - ($x ** 2 - $N) / (2 * $x) } ... *这段代码实现了牛顿找到 $N 平方根近似值的方法。重要的是它使用 FatRat 值来获得更高的准确性。
让我们运行 9 的平方根：
my $N = 9;my @x = Rat.new(1, 1), -&amp;gt; $x { $x - ($x ** 2 - $N) / (2 * $x) } ... *;.say for @x[0..7];很快，它收敛到正确的值：
153.43.</description>
    </item>
    
    <item>
      <title>A bit more on Rat vs FatRat in Raku</title>
      <link>https://ohmysummer.github.io/post/2018-02-14-a-bit-more-on-rat-vs-fatrat-in-perl-6/</link>
      <pubDate>Wed, 14 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-14-a-bit-more-on-rat-vs-fatrat-in-perl-6/</guid>
      <description>昨天，我们正在深入研究 Rakudo Raku，以了解Rat值成为Num值的时间。事实证明，如果该值变得太小，这意味着它的分母变得越来越大，Rakudo开始使用Num值而不是Rat。
我们找到了它发生的地方。今天，让我们进行一个练习，看看Raku的行为是否可能不同，即扩展数据类型而不是将其切换为浮点数并且失去准确性。
改变很简单。所有你需要的是更新DIVIDE_N例程中的ifs：
--- a/src/core/Rat.pm+++ b/src/core/Rat.pm@@ -48,16 +48,14 @@ sub DIVIDE_NUMBERS(Int:D \nu, Int:D \de, \t1, \t2) {($numerator := -$numerator),($denominator := -$denominator))),nqp::if(- nqp::istype(t1, FatRat) || nqp::istype(t2, FatRat),+ nqp::istype(t1, FatRat) || nqp::istype(t2, FatRat) || $denominator &amp;gt;= UINT64_UPPER,nqp::p6bindattrinvres(nqp::p6bindattrinvres(nqp::create(FatRat),FatRat,&#39;$!numerator&#39;,$numerator),FatRat,&#39;$!denominator&#39;,$denominator),- nqp::if(- $denominator &amp;lt; UINT64_UPPER,nqp::p6bindattrinvres(nqp::p6bindattrinvres(nqp::create(Rat),Rat,&#39;$!numerator&#39;,$numerator),- Rat,&#39;$!denominator&#39;,$denominator),- nqp::p6box_n(nqp::div_In($numerator, $denominator)))))+ Rat,&#39;$!denominator&#39;,$denominator)+ ))}现在有两种结果：例程产生一个Rat值或一个FatRat。当子参数已经是FatRats或当前Rat太接近于零时，后者发生。
从昨天的帖子中用牛顿算法编译并测试我们修改过的raku可执行文件：
my $N = 25;my @x = Rat.</description>
    </item>
    
    <item>
      <title>Going over the Bridge, part 2. Let’s get rid of it</title>
      <link>https://ohmysummer.github.io/post/2018-02-12-going-over-the-bridge-part-2/</link>
      <pubDate>Mon, 12 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-12-going-over-the-bridge-part-2/</guid>
      <description>今天，我们继续在 Rakudo Raku 中使用 Bridge 方法。昨天，我们在几个预定义的数据类型中看到了方法的定义。现在是时候看看如何使用该方法。
里面有什么? 该方法的主要用途在 Real 角色中，该角色包含以下一组方法：
method sqrt() { self.Bridge.sqrt }method rand() { self.Bridge.rand }method sin() { self.Bridge.sin }method asin() { self.Bridge.asin }method cos() { self.Bridge.cos }method acos() { self.Bridge.acos }method tan() { self.Bridge.tan }method atan() { self.Bridge.atan }. . .method sec() { self.Bridge.sec }method asec() { self.Bridge.asec }method cosec() { self.Bridge.cosec }method acosec() { self.</description>
    </item>
    
    <item>
      <title>Going over the Bridge, part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-11-going-over-the-bridge-part-1/</link>
      <pubDate>Sun, 11 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-11-going-over-the-bridge-part-1/</guid>
      <description>在处理 Raku 中的数字的类中，我们看到了 Bridge 方法，该方法以多态方式使用。让我们花一些时间，并试图了解 1）它是如何工作的，2）是否有必要。
类和角色 我们的第一步是查看方法定义在哪里。以下是我们需要的类和角色列表：
 Duration Instant Int Num Rational Real  为了预测下一步，让我们添加一些关于他们关系的更多细节：
 class Duration is Cool does Real class Instant is Cool does Real class Int is Cool does Real class Num is Cool does Real role Rational does Real role Real does Numeric  在斜体字体中，我添加了伪声明，这些伪声明没有在 src/core 的相应文件中明确拼写，而是通过 src/Raku/Metamodel/BOOTSTRAP.nqp 设置:
Int.HOW.add_parent(Int, Cool);. . .Num.HOW.add_parent(Num, Cool);对于完整的图片，我们可以查看其他类的位置，例如 Rat 或 Complex，但让我们先关注上面的列表。
Bridge 方法 现在，让我们看看这些类和角色中 Bridge 方法的定义。</description>
    </item>
    
    <item>
      <title>Raku 中的命名参数</title>
      <link>https://ohmysummer.github.io/post/2018-02-10-raku%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 10 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-10-raku%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0/</guid>
      <description>Raku 中的函数（和类方法）能够接受命名参数。最简单的方法是用箭头分隔名称和值：
sub f(:$a, :$b) {$a ** $b}say f(a =&amp;gt; 2, b =&amp;gt; 3); # 8但另一种语法是可能的，在冒号的帮助下。有几个主要品种。
:key(value) 所有内容都以冒号开头，数值在括号内：
say f(:a(2), :b(3));例如，不用圆括号，尖角括号也是允许的：
say f(:a&amp;lt;2&amp;gt;, :b&amp;lt;3&amp;gt;);：Nkey 对于整数值，仍然有这样一个奇怪的语法：
say f(:2a, :3b);:key 和 :!key 如果命名参数用作标记，则不需要指定值。在这种情况下，您可以传递 True 和 False，如下所示：
sub g(:$key) {$key}say g(:key); # Truesay g(:!key); # False实际上，所有冒号对儿都会创建键值对，因此您可以在创建散列时执行相同的操作
my %data = :alpha(10), :beta(20), :gamma(30);say %data&amp;lt;beta&amp;gt;; # 20</description>
    </item>
    
    <item>
      <title>Raku Grammar 中的冒号对儿</title>
      <link>https://ohmysummer.github.io/post/2018-02-08-raku-grammar%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7%E5%AF%B9%E5%84%BF/</link>
      <pubDate>Thu, 08 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-08-raku-grammar%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7%E5%AF%B9%E5%84%BF/</guid>
      <description>欢迎来到这个系列的第 50 篇文章!
今天, 我们将讨论一个小的语法结构, 然而就 Grammar 来说这是非常复杂的。首先让我们看看整个 colonpair token:
token colonpair {:my $*key;:my $*value;&#39;:&#39;:dba(&#39;colon pair&#39;)[| &#39;!&#39; [ &amp;lt;identifier&amp;gt; || &amp;lt;.panic: &amp;quot;Malformed False pair; expected identifier&amp;quot;&amp;gt; ][ &amp;lt;[ \[ \( \&amp;lt; \{ ]&amp;gt; {$/.typed_panic(&#39;X::Syntax::NegatedPair&#39;, key =&amp;gt; ~$&amp;lt;identifier&amp;gt;) } ]?{ $*key := $&amp;lt;identifier&amp;gt;.Str; $*value := 0 }| $&amp;lt;num&amp;gt; = [\d+] &amp;lt;identifier&amp;gt; [ &amp;lt;?before &amp;lt;.[ \[ \( \&amp;lt; \{ ]&amp;gt;&amp;gt; {} &amp;lt;.sorry(&amp;quot;Extra argument not allowed; pair already has argument of &amp;quot; ~ $&amp;lt;num&amp;gt;.</description>
    </item>
    
    <item>
      <title>Raku 中的数据类型 Bag</title>
      <link>https://ohmysummer.github.io/post/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/</link>
      <pubDate>Wed, 07 Feb 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-07-raku%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bbag/</guid>
      <description>数据类型 Bag 是一种 Perl 5 中没有的新的数据类型。
它可以被认为是一个容器，它一方面知道它里面有多少个单独的元素，另一方面可以说有多少种不同类型的商品。您可以用不同的方式描述此类型：Bag 是一个哈希，默认情况下，您添加的键的值为1。我们来看看例子。
把一个 1 放进 bag 里，看看 perl 的输出：
my $b1 = bag(1);say $b1.perl;该程序打印以下输出：
(1=&amp;gt;1).Bag也就是说，我们有一个 1。
如果你把另一个数字也放进 bag 里面：
my $b2 = bag(1, 2);say $b2.perl;现在有一个 1 和一个 2：
(1=&amp;gt;1,2=&amp;gt;1).Bag好的，如果你添加另一个 1 呢?
my $b3 = bag(1, 2, 1);say $b3.perl;现在有两个 1：
(1=&amp;gt;2,2=&amp;gt;1).Bag让我们稍微离题一下：所有显示的例子都可以把括号去掉：
my $b1 = bag 1;my $b2 = bag 1, 2;my $b3 = bag 1, 2, 1;比较典型的是，bag 不止能存储数字，还可以存储字符串，例如：</description>
    </item>
    
    <item>
      <title>Raku Core Hacking: QASTalicious</title>
      <link>https://ohmysummer.github.io/post/2018-01-28-raku-core-hacking-qastalicious/</link>
      <pubDate>Sun, 28 Jan 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-01-28-raku-core-hacking-qastalicious/</guid>
      <description>在过去的一个月中，我在 Rakudo 的 QAST 地区花了一些时间写了一些优化，修复了包含警告的错误，并且用一个单一的提交压缩了一个10个thunk范围的bug的怪物蜂巢。 在今天的文章中，我们将详细介绍最后一个专长，以及了解QAST是什么以及如何使用它。
第一部分: QAST &amp;ldquo;QAST&amp;rdquo; 代表 &amp;ldquo;Q&amp;rdquo; Abstract Syntax Tree.(&amp;ldquo;Q&amp;rdquo; 抽象语法树.) 为什么会有个字母 &amp;ldquo;Q&amp;rdquo; 在那里呢, 因为 Q 是 P 的下一个字母, 而 &amp;ldquo;P&amp;rdquo; 过去是在 &amp;ldquo;PAST&amp;rdquo; 里面的, 代表 &amp;ldquo;Parrot&amp;rdquo;(鹦鹉), 是很早之前的一个实验性的 Raku 实现(或者说, 它的虚拟机). 我们来看看什么是 QAST!
Dumping QAST 每个 Rakudo Raku 程序都编译到 QAST 节点树上，如果在编译程序或模块时给 raku 指定 --target=ast 或 --target=optimize 命令行选项，则可以转储该树:
$ raku --target=ast -e &#39;say &amp;quot;Hello, World!&amp;quot;&#39;[...]- QAST::Op(call &amp;amp;say) &amp;lt;sunk&amp;gt; :statement_id&amp;lt;?&amp;gt; say \&amp;quot;Hello, World!\&amp;quot;- QAST::Want &amp;lt;wanted&amp;gt; Hello, World!</description>
    </item>
    
    <item>
      <title>Raku logo</title>
      <link>https://ohmysummer.github.io/post/2018-01-28-perl-6-logo/</link>
      <pubDate>Sun, 28 Jan 2018 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-01-28-perl-6-logo/</guid>
      <description></description>
    </item>
    
    <item>
      <title>第二十五天-圣诞奖金 - 并发HTTP服务器实施和scripter的方法</title>
      <link>https://ohmysummer.github.io/post/2017-12-25-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E5%A4%A9-%E5%B9%B6%E5%8F%91http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 25 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-25-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E5%A4%A9-%E5%B9%B6%E5%8F%91http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0/</guid>
      <description>Bonus Xmas – Concurrent HTTP Server implementation and the scripter’s approach 首先，我想强调 Jonathan Worthington 在 Rakudo Raku 和 IO::Socket::Async 中的工作。谢谢 Jon！
我喜欢制作脚本;编写组织良好的动作序列，获得结果并对它们进行处理。
当我从 Raku 开始时，我发现了一个壮观的生态系统，我可以按照自己喜欢的方式实践我的想法：脚本方式。其中一个想法是实现一个小型的 HTTP 服务器来玩玩。查看与 Raku，HTTP 和套接字相关的其他项目和模块，我发现背后的作者是具有面向对象编程经验的程序员。
Raku 范式 Raku 支持三种最流行的编程范式:
 面向对象 函数式 过程式  我认为，当你设计一个将会增长的应用程序或服务时，面向对象的范式是很好的，它会做许多不同的事情并且会有很多变化。但我不喜欢那些变化太大，会有很多变化的东西;这就是为什么我喜欢使用原生过程式方法的脚本，因为它能够快速提升简单性和有效性。我喜欢小（一步一步）但能快速完成伟大东西的事物。
函数式范式在我看来非常棒;你可以使用一个函数，并像 var 一样使用它，以及其他令人惊讶的事情。
Raku Supplies 就像一个 V12 引擎 在我开始将 rakuintro.com 翻译成西班牙语后不久，我开始使用 Raku。看看 Raku 的文档，我发现了 Raku 巨大的并发潜力。 Raku在并发方面比我想象的更加强大。
我使用 Raku 的 HTTP 服务器的思想始于 Raku Supplies（具有多个订阅者的异步数据流），具体来说就是 IO::Socket::Async类。所有的套接字管理，数据传输和并发性实际上都是自动且易于理解的。制作并玩一玩小并发但强大的服务是极好的。
基于 IO::Socket::Async 文档的示例，我开始在 mini-http-cgi-server 项目中实现一个支持 pseudoCGI 的小型 HTTP 服务器，并且按照我的预期工作。当我得到我想要的东西时，我很满意，我离开了这个项目一段时间。我不喜欢事情发展太多。</description>
    </item>
    
    <item>
      <title>第二十四天-解魔方</title>
      <link>https://ohmysummer.github.io/post/2017-12-24-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%A4%A9-%E8%A7%A3%E9%AD%94%E6%96%B9/</link>
      <pubDate>Sun, 24 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-24-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%A4%A9-%E8%A7%A3%E9%AD%94%E6%96%B9/</guid>
      <description>Day 24 – Solving a Rubik’s Cube 介绍 我在圣诞节的愿望清单上有一个速度魔方，我真的很兴奋。 :)我想分享一些Raku代码的热情。
我在89年从高中毕业，所以我恰好是在青少年时期拥有魔方的合适年龄。我记得试图在巴士上炫耀，让我的时间缩短到不到一分钟。我在80年代从当地的一家玩具店拿到了一本小册子，其中展示了一个关于如何解决我记忆的立方体的算法。我再也没有这本小册子了。多年来我一直坚持，但从来没有达到竞争水平。
在过去的几个月里，YouTube根据我对立体声频道的兴趣，向我推荐了一些立方体视频;看到世界纪录在5秒以内，使我一分钟的旧时间看起来很慢。
我所讲过的每个人都可以解决魔方问题，他们使用的算法与我所学的算法不同，而在立体魔法中讨论的方法却与众不同。不过，这种先进的版本似乎被定期制定世界记录的人们普遍使用。
拾取这个算法并不难，我找到了几个视频，尤其是描述如何解决最后一层的视频。这样做了几天之后，我将步骤转录为几个笔记，其中列出了步骤列表，以及每个步骤的关键部分：所需的方向，然后是该步骤的各个转弯。然后，我可以参考我的笔记本的一个页面，而不是一个30分钟的视频，并且在几天后，记住了以下步骤：能够从记谱法移动到仅仅做这些移动是一个很大的加速。
一周后，我能够在两分钟内使用新方法可靠地解决问题;退后一步，但在休息时间里一周的努力并不坏。从那以后（几个星期后），我一直下到1:20以下。再次，这是初学者的方法，没有任何先进的技术，而且我可以在不查看立方体的情况下完成各个算法步骤。 （尽管如此，我仍然有很长的路要走。）
符号 关于移动符号的快速注释 - 考虑到您将立方体的一边保持在顶部，一边朝向您，相对边是：
L (Left) R (Right) U (Up) D (Down) F (Front) B (Back) 如果在步骤中看到一个单独的字母，如B，则表示顺时针转动该面（相对于立方体的中心，而不是您）。如果你在信里加了一个&amp;rsquo;&#39;，那就意味着逆时针方向，所以R&#39;会让最上面的部分下来，而R会让底部的部分出现。
此外，您可能必须翻转两次，写成U2; （顺时针或逆时针无关紧要，因为它从起点开始为180º。）
算法 我正在使用的初学者算法有以下基本步骤：
1.白色十字架2.白色拐角3.第二层4.黄色十字架5.黄色边缘6.黄色拐角7.定位黄色拐角
如果您对每个步骤的具体内容感到好奇，您可以浏览Rubik的wiki或上面链接的YouTube视频。该算法的更高级版本（由Jessica Fridrich提供的CFOP）允许您合并步骤，具有处理特定立方体状态的特定“快捷方式”，或者解决任何颜色作为第一面，而不仅仅是白色。
设计一个模块 当我开始研究这个模块时，我知道我希望能够以某种熟悉算法的人熟悉的方式展示每一步所需的位置，并且让各个步骤也是自然的，就像是：
F.R.U.Rʼ.Uʼ.Fʼ  我也希望能够转储立方体的现有状态;现在作为文本，但最终也能够将其与视觉表示相结合，
我们需要能够判断立方体是否已解决;我们需要能够检查相对于当前方向的棋子，并且能够改变我们的方向。
由于我要开始渲染立方体状态的能力，然后快速添加转向两侧的能力，我选择了一个内部结构，使其变得相当容易。
代码 github上提供了该模块的最新版本。这里介绍的代码来自最初的版本。
Raku允许您创建Enumerations，因此您可以在代码中使用实际的单词而不是查找值，所以让我们从一些我们需要的内容开始：
enum Side «:Up(&#39;U&#39;) :Down(&#39;D&#39;) :Front(&#39;F&#39;) :Back(&#39;B&#39;) :Left(&#39;L&#39;) :Right(&#39;R&#39;)»;enum Colors «:Red(&#39;R&#39;) :Green(&#39;G&#39;) :Blue(&#39;B&#39;) :Yellow(&#39;Y&#39;) :White(&#39;W&#39;) :Orange(&#39;O&#39;)»;有了这个语法，我们可以直接在我们的代码中使用Up，并且它的关联值是U.
我们需要一个类，以便我们可以存储属性并拥有方法，所以我们的类定义具有：
class Cube::Three {has %!</description>
    </item>
    
    <item>
      <title>Playing with the code of Rakudo Raku</title>
      <link>https://ohmysummer.github.io/post/2017-12-23-playing-with-the-code-of-raku/</link>
      <pubDate>Sat, 23 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-23-playing-with-the-code-of-raku/</guid>
      <description>昨天，我们查看了返回字符串的 Bool 类的两个方法。函数产生的字符串表示在源代码中被硬编码。
让我们使用这个观察并尝试改变文本。
所以，这里是我们要修改的片段：
Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) {self ?? &#39;True&#39; !! &#39;False&#39;});该 gist 方法用于对已定义的变量进行字符串化。
要做到这一点，你需要在计算机上安装 Rakudo 的源代码，以便编译它们。首先从 GitHub 克隆项目：
$ git clone https://github.com/rakudo/rakudo.git编译 MoarVM：
$ cd rakudo$ perl Configure.pl --gen-moar --gen-nqp --backends=moar$ make完成之后，你会在 rakudo 目录下获得 raku 可执行文件。
现在，打开 src/core/Bool.pm 文件，并将 gist 方法的字符串更改为使用 Unicode 大拇指代替纯文本：
Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) {self ?? &#39;👍&#39; !! &#39;👎&#39;});保存文件后，您需要重新编译 Rakudo。 Bool.pm 位于要在 Makefile 中编译的文件列表中：</description>
    </item>
    
    <item>
      <title>第二十三天-Raku 高尔夫</title>
      <link>https://ohmysummer.github.io/post/2017-12-23-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E5%A4%A9-raku-6%E9%AB%98%E5%B0%94%E5%A4%AB/</link>
      <pubDate>Sat, 23 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-23-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E5%A4%A9-raku-6%E9%AB%98%E5%B0%94%E5%A4%AB/</guid>
      <description>Day 23 – The Wonders of Raku Golf 啊，圣诞节！还有什么比和你的朋友与家人一起坐在桌子旁边玩高尔夫球代码还好呢！ &amp;hellip;等等，什么？
哦，对，这还不是圣诞节。但是你可能想要为它做好准备！
如果你还没有注意到，有一个不错的网站可以玩高尔夫球代码：https://code-golf.io/。这个网站很酷的地方是，它不仅仅只支持 perl 6！在撰写本文时，它还支持其他 6 种语言。嗯&amp;hellip;
无论如何，因为我在那个网站的成绩还不错，我会分享一些我觉得最好的解决方案。所有的 trickety-hackety，unicode-cheatery 和 mind-blowety。在我们看来，也许我们甚至会看到即使在代码高尔夫中，perl 6 也非常简洁易读。也就是说，如果你很难将你的圣诞愿望放在一张卡片上，那么可能会放得下一行 perl 6 代码。
我不会提供完整的解决方案，不会破坏你的圣诞乐趣，但我会给你足够的提示，以提出有竞争力的解决方案。
这个圣诞节我就是想让你得到一些乐趣。所以你先下载一份 rakudo，以确保你可以跟随。稍后我们会有一些南瓜派，我们会做一些颂歌。如果您在运行 perl 6 时遇到任何问题，可以在 freenode 上加入 ＃raku 频道以获得一些帮助。这就是说，https://code-golf.io/ 本身为你提供了一个很好的编辑器来编写和评估你的代码，所以应该没有问题。
一些基本的例子 让我们以帕斯卡三角形任务为例。我听到了，我听到了！圣诞节前的数学，这太残酷了。残忍，但很有必要。
只有一个你必须知道的基本技巧。如果从 Pascal 三角形中取出任何一行，将它移动一个元素，然后用原始行对结果进行 zip-sum，就会得到下一行！
所以如果你有一行数字：
1 3 3 1你所做的只是把它移到右边：
0 1 3 3 1并将其与原始行相加：
1 3 3 1+ + + +0 1 3 3 1=1 4 6 4 1就是如此容易！所以我们还是写代码吧：</description>
    </item>
    
    <item>
      <title>Exploring the Bool type in Raku, part 1</title>
      <link>https://ohmysummer.github.io/post/2017-12-22-exploring-the-bool-type-in-raku-part-1/</link>
      <pubDate>Fri, 22 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-22-exploring-the-bool-type-in-raku-part-1/</guid>
      <description>今天，我们将使用 GitHub 上提供的 Rakudo 源代码挖掘 Bool 类型的内部。
Raku 是用 Raku 和 NQP（Not Quite Raku）语言编写的，这使得阅读源代码变得相对容易。当然，有很多东西不容易理解，或者没有反映在 Raku 语言的公开文档中。到目前为止，您都无法在 Raku 书籍中找到深入的细节。无论如何，对 Raku 有一些中级的理解，这仍然是可能的。
好的，回到 src/core/Bool.pm 文件。它以一些 BEGIN phasers 开始，它为 Bool 类添加了一些方法和 multi 方法。下一次我们将讨论元模型和类构造的细节。今天，对我们来说更有趣的是 Bool 类的方法在做什么。
gist 和 perl gist 和 perl 方法返回对象的字符串表示形式：当变量被字符串化时隐式调用 gist，perl 应该直接调用。它适用于 Raku 中的任何对象，但这种行为当然应该定义在某处。他们在这里：
Bool.^add_method(&#39;gist&#39;, my proto method gist(|) {*});Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:D:) { self ?? &#39;True&#39; !! &#39;False&#39;});Bool.^add_multi_method(&#39;gist&#39;, my multi method gist(Bool:U:) {&#39;(Bool)&#39;});Bool.^add_method(&#39;perl&#39;, my proto method perl(|) {*});Bool.</description>
    </item>
    
    <item>
      <title>第二十二天-Raku.d 的特性</title>
      <link>https://ohmysummer.github.io/post/2017-12-22-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%A4%A9-raku-6.d%E7%9A%84%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 22 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-22-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%A4%A9-raku-6.d%E7%9A%84%E7%89%B9%E6%80%A7/</guid>
      <description>Day 22 – Features of Raku.d 所以我们就是这样。 Rakudo Raku第一次正式发布两年后，或者更准确的说是6.c。自从马特奥茨从那时起就开始关注性能的提升之后，圣诞老人认为要对此进行对比，描述自那时起实施的6.d的新功能。因为有很多，圣诞老人不得不做出选择。
在创建时调整对象 您创建的任何课程现在都可以使用TWEAK方法。在新的类的新实例的所有其他初始化完成之前，这个方法将被调用。一个简单的，有点人为的例子，其中一个类A有一个属性，默认值是42，但如果在创建对象时指定了默认值，它应该更改该值：
class A {has $.value = 42;method TWEAK(:$value = 0) { # default prevents warning# change the attribute if the default value is specified$!value = 666 if $value == $!value;}}# no value specified, it gets the default attribute valuedd A.new; # A.new(value =&amp;gt; 42)# value specified, but it is not the defaultdd A.</description>
    </item>
    
    <item>
      <title>Raku 中的 proto 关键字</title>
      <link>https://ohmysummer.github.io/post/2017-12-21-raku-%E4%B8%AD%E7%9A%84-proto-%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Thu, 21 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-21-raku-%E4%B8%AD%E7%9A%84-proto-%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>今天，我们正在关注 proto 关键字。它向编译器提供了关于你打算创建 multi-subs 的提示。
例子 1 考虑一个翻转字符串或使整数变成负数的函数示例。
multi sub f(Int $x) {return -$x;}multi sub f(Str $x) {return $x.flip;}say f(42); # -42say f(&#39;Hello&#39;); # olleH如果我们创建另一个接收两个参数的函数的变体，会怎么样？
multi sub f($a, $b) {return $a + $b;}say f(1, 2); # 3这个代码完美的工作，但它看起来像它的和谐是破碎的。即使函数的名称没有提及它的作用，我们也打算设置一个函数，以某种方式返回它的参数的“反射”版本。将两个数字相加的函数不适合这个想法。
所以，现在是在 proto 关键字的帮助下清楚地宣布意图的时候了。
proto sub f($x) {*}现在，尝试调用双参数函数将无法编译：
===SORRY!=== Error while compiling proto.plCalling f(Int, Int) will never work with proto signature ($x)at proto.</description>
    </item>
    
    <item>
      <title>第二十天-宏的进阶</title>
      <link>https://ohmysummer.github.io/post/2017-12-20-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%A4%A9-%E5%AE%8F%E7%9A%84%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Wed, 20 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-20-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%A4%A9-%E5%AE%8F%E7%9A%84%E8%BF%9B%E9%98%B6/</guid>
      <description>Day 20: Advancements in Macrotechnologies 你好！
请允许我，在出现日历的这一天，一个小切线。我不会直接谈论一个很酷的熟练的Raku特性。相反，我会打开一个小窗口，讨论可能会发生什么 - 希望在某些时候！
如果你像我一样，在Rakudo上继续了几年的进步，你在版本中经常看到这一点：&amp;gt;一些不太有效的功能包括：&amp;gt; - 高级宏
那么，这究竟意味着什么？ Raku确实有宏，但它们目前的限制超出了人们通常想要做的。这并不是说它们目前是无用的，它们仍然是有用的，从前几年出现的其他帖子到OO :: Monitor使用宏来提前报告拼写错误。
输入007. 007是“具有宏观许可的小型实验语言”。这是什么意思？！这是一种用于对宏进行调试和实验的语言，因此当他们被集成到Raku中时，他们的设计就已经准备好并经过战斗测试。
那么，它有什么？ 007试图模仿Raku的“强大”部分，因此我们不会为完全不同的语言设计宏。这意味着阶段，中缀操作员，（MOP和正则表达式的要点）。
它是什么样子的？ 007的核心就是喜欢Raku.然而，它的确存在一些问题。让我们来看看你想写的最重要的片段：FizzBu​​zz。注意：此博客帖子中的所有代码片段都是可执行的007代码，而不是Raku代码。
my n = 1;while n &amp;lt;= 100 {if n %% 15 {say(&amp;quot;FizzBuzz&amp;quot;);}else if n %% 3 {say(&amp;quot;Fizz&amp;quot;);}else if n %% 5 {say(&amp;quot;Buzz&amp;quot;);}else {say(n);}n = n + 1;}什么？你不在乎吗？很明显，我确实答应过你的宏。我们将看看一个简单的宏“name”，它返回最后一个索引对象的名称。
macro name(expr) {if expr ~~ Q::Postfix::Property {expr = expr.</description>
    </item>
    
    <item>
      <title>第十八天-Raku 支持的工作流</title>
      <link>https://ohmysummer.github.io/post/2017-12-18-%E7%AC%AC%E5%8D%81%E5%85%AB%E5%A4%A9-raku%E6%94%AF%E6%8C%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81/</link>
      <pubDate>Mon, 18 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-18-%E7%AC%AC%E5%8D%81%E5%85%AB%E5%A4%A9-raku%E6%94%AF%E6%8C%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81/</guid>
      <description>Day 18: Raku powered work flow 保持流畅的编码可能是一个挑战。分心和讨厌的句法错误是潜在的流量瓶颈。
然后是7 +/- 2短期内存限制，我们都必须耍弄。与计算机不同，我们不能仅仅增加更多的硬件来增加大脑工作内存缓冲区的大小 - 至少目前还没有。保持流量需要管理这个缓冲区以避免井喷。幸运的是，我们有电脑帮助。
自计算开始以来，使用计算机扩展记忆的想法一直存在。早在1945年，Vannevar Bush就设想了一种Memex（MEMory EXtender），这是一种“扩大了对个人记忆的贴心补充”。
在2017年，卑微的文本文件可以像一个穷人的memex。该文本文件包含三个部分的时间轴：过去，现在和下一个。这有点像改变日志，但也有未来。过去的部分会随着时间的推移填满，包含完成的任务和信息供以后召回。现在部分可帮助您专注于手头的任务，而下一部分将排队完成将来要完成的任务。
任务通过三种状态：do（+ next），done（！now）和done（-past）。
为了保持畅通，你有时需要快速回忆一些事情，记下将来要做的事情，并专注于现在的进步。保留一个123.do文件可以帮助您减轻编码时的认知负担。
123.do文件的格式很简单，因此您可以直接使用文本编辑器对其进行破解，并使用此Raku语法进行描述。
这是驱动它的Raku命令行模块。
安装它只需:
shell&amp;gt; zef install Do123shell&amp;gt; 123 +7 Merry Christmasshell&amp;gt; 123 +13 Happy New Year</description>
    </item>
    
    <item>
      <title>第十七天-关于消息传递</title>
      <link>https://ohmysummer.github.io/post/2017-12-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E5%A4%A9-%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/</link>
      <pubDate>Sun, 17 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-17-%E7%AC%AC%E5%8D%81%E4%B8%83%E5%A4%A9-%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92/</guid>
      <description>Day 17: Something about messaging (but I couldn’t think of a snappier title.) 为什么要传递消息 当我第一次开始考虑写今年的 Advent 文章时，我反思我在过去的十二个月里并没有真正写过大量的 Raku，与往年相比，我似乎写了大量的模块。我一直在做的事情（至少在我的日常工作中）正在考虑和实施大量使用某些消息传递系统的应用程序。所以我认为将这些想法引入 Raku 会很有趣。
作为一种“胶水语言”，Perl一直享有盛誉，Raku 具有与之竞争的功能，最显着的是响应式和并发功能，因此非常适合创建基于消息的集成服务。
传递什么信息 现在我的脚下就是优秀的企业集成模式，尽管它现在已经有近15年的历史了，但我仍然建议任何有兴趣（或工作于）该领域的人。然而，它是一个重量级的书（字面上，它在硬书中的重量接近一点五公斤），所以我用它来提醒自己不要试图在这个主题上详尽无遗，以免这会变成一本书本身。
有相当多的自由和商业管理消息系统，使用一系列开放和专有的协议，但我将限制自己到我熟悉的 RabbitMQ，并且在 Raku 中由 Net::AMQP 支持。
如果你想亲自尝试一下这些例子，你将需要访问一个 RabbitMQ 代理（它可以作为大多数操作系统发行版的包），但是你可以使用 Docker Image，它看起来工作得很好。
您还需要安装 Net::AMQP，这可以通过以下方式完成：
zef install Net::AMQP在示例中，我将使用 RabbitMQ 服务器的默认连接详细信息（即代理正在本地主机上运行，​​并且默认 guest 处于活动状态），如果您需要提供不同的详细信息，则可以更改 Net::AMQP 的构造函数以反映适当的值：
my $n = Net::AMQP.new(host =&amp;gt; &#39;localhost&#39;,port =&amp;gt; 5672,login =&amp;gt; &#39;guest&#39;,password =&amp;gt; &#39;guest&#39;,vhost =&amp;gt; &#39;/&#39;);一些示例可能需要其他模块，但我会在介绍时介绍它们。
强制性的你好，世界 RabbitMQ实现了由AMQP v0.</description>
    </item>
    
    <item>
      <title>第十六天-Raku 性能改进</title>
      <link>https://ohmysummer.github.io/post/2017-12-16-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%A4%A9-raku%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B/</link>
      <pubDate>Sat, 16 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-16-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%A4%A9-raku%E6%80%A7%E8%83%BD%E6%94%B9%E8%BF%9B/</guid>
      <description>Day 16 – 🎶 Deck The Halls With Perf Improvements 🎶 在英国，我们缺乏感恩节给圣诞节带来了新的一年，感谢和反思。为此，我想围绕Raku性能的状态放置一些我已经坐了一段时间的零碎片断，这些片断强调了这个过程需要付出多少努力。我不确定更广泛的编程社区对正在发生的努力的速度和数量表示赞赏。
我不是核心开发人员，但自2010年推出Rakudo *之后，我一直是Raku的低级用户。通常情况下，已经进入Rakudo的努力被未知的努力所掩盖。人们重新审视Rakudo Raku时尤其如此，他可能会想象下一个圣诞节将会如何。但是Raku在历史上证明，在下一个圣诞节之前，事情总会有所改善，无论您选择哪个圣诞节，
回到2014年的圣诞节，我写了一篇关于为什么我认为Raku能够完成生物信息学工作的出色文章。那篇文章中没有提到的是，为什么在Rakudo上实现Raku根本没有准备好去做任何严肃的生物信息学。表演真的没有！我在Raku中的第一次尝试（当Parrot虚拟机完全使用时）让我执行了几十分钟的简单操作，我期望它是毫秒级的性能。这很遗憾，因为我没有跟踪时间。但这当然不是一个好起点。
然而，快速转发到2014年和MoarVM，我觉得自己写这篇来临邮件感觉很舒服，因为我知道在作为用户的4年中有多少改进。而且，所有的发展都是在完成语言定义和正确的实施。然而，我是一直在等待perf到达那里的用户。我认为大部分时间到了。为此，我要感谢所有核心开发者所付出的巨大的日常努力。观看它展现出令人难以置信的动力。对我来说，这个圣诞节是圣诞节的目标，它已经到来。 👏🏻🎊
我一直在为我的BioInfo模块运行和计时测试，这些模块对生物序列数据进行了多年的基本操作。它以非常糟糕的方式做到了这一点。在紧密循环中分配和丢弃哈希时出现了很多错误等等。但是我已经将这些代码留给了现在 - 在五年多的时间里。悄悄地进行私人基准测试，偶尔鼓励在IRC频道看到大幅飞跃的努力。 Sub 10s是一个很大的！它从30/40秒突然发生。在我暗示IRC一个地方，我的代码在分析时特别慢，这是一次跳跃！
这是一个长期观点，如果我放大去年的这一年，可以看到，如果时间不是很长，整个系数的性能仍然在提高。
请记住，所有这些配置文件都不是来自Rakudo编译器的发布版本，而是来自当天的HEAD。所以偶尔会有一些奇怪的表现回归，正如你上面看到的，通常不会留下来发布。
发生什么了？情况如何变好？有几个原因。 Raku中的许多算法选择和核心功能都已经在源代码级别（更晚些时候）逐步和积极地进行了优化。但支持Rakudo的MoarVM虚拟机的优化能力也得到了提高，并且可以降低到原生代码和内联专用版本的代码。这部分得益于2014年以来Rakudo Raku提供的-profile选项，它提供了所有这些信息。
在上面关于MoarVM如何处理我编译过的Raku测试的代码框的情节中，应该很清楚的是，自从今年夏天以来，有相当多的框架被JIT编译，解释较少，并且几乎所有专用框架（橙色）结束原生JIT（绿色）。如果您想了解更多有关“spesh”MoarVM代码专门工具的最新工作，您可以在他的博客上阅读Jonathan Worthington的4篇文章。 Baart Weigmans还有一篇博客概述了他在JIT编译器方面的工作，最近还谈到了许多尚未登陆的新功能，希望能让许多新开发人员加入并帮助改进JIT。所以如果这对你来说是一件有趣的事情，我建议你查看一下上面的链接。
所以这是我的基准和我的目标，其中大部分是围绕数据结构创建和解析。但是，数字作品等其他内容呢？那也保持了吗？没有任何人推动，就像我推动我对事情可以改进的地方的看法。答案是肯定的！
曾几何时，早在2013年，一位名叫Tim King的绅士就开始对Raku中的素数感兴趣.Tim对他发现的性能颇为不满。正确如此。他从以下漂亮的代码开始：
通过定义一个素数的交叉点找到任何素数，真是一个不错的优雅解决方案！但是蒂姆惊讶地发现联赛很慢，上面的代码让他看到了前1000个素数。今天，超级高级代码需要0.96s。
对于基于联结的代码的缓慢程度，蒂姆继续做更标准的迭代方法感到不满。 Tim在这些帖子后不久就从网上消失。但他留下了我继续留下的遗产。他的主要基准测试代码和我对时间结果的适应性可以在这个要点中找到。以下是另一张图表，其中显示了每个超过100次试验找到前1000个素数所需的平均时间。 2015年的垂直线是较高的标准偏差。
再次以最近的放大视图（最新的数据点让我担心一点，我以某种方式搞砸了&amp;hellip;&amp;hellip;）
上面的收敛到一个点，是启动和停止Rakudo运行时和MoarVM的开销。发现素数并不是它曾经的努力，它比Rakudo的开始稍微慢一些。无论您选择的代码解决方案的级别和优雅程度如何，至少要快一个数量级。
好吧，我们已经看到MoarVM获得了一些闪亮的新运动部件。但是像Liz，jnthn，Zoffix以及最近在字符串Samcv世界中开发人员已经付出了巨大的努力，以改进MoarVM和Rakudo在算法上实际上正在做的事情。
旁注：我相信我根本不会做大多数其他开发人员的正义，特别是在这篇文章中忽略了JVM的努力。我建议每个人都去，并检查提交日志，看看有多少人现在参与使Rakudo更快，更好，更强大。我确定他们想在本文的底部看到您的感谢！ 因此，节省你一份查看提交日志的工作我已经做了一些挖掘，看看自上个圣诞节以来与提高性能有关的提交。 N％或Nx更快的东西。如下所示：
3c6277c77 Have .codes use nqp::codes op. 350% faster for short stringsee4593601 Make Baggy (^) Baggy about 150x faster 这两项承诺将以一年的核心发展时间表推动编程项目的发展。但是，今年，它们仅仅是数百次提交中的两次。
下面是一些提交数量的直方图以及他们提到的性能的百分比和x乘数的增加。你可以用上面的代码自己grep日志。在2016年有一些更令人兴奋的收益值得检查。
这仅仅是2017年的性能提升承诺，几乎每天都会有更多的降落。这甚至不包括许多来自Zoffix授予的I / O性能收益，因为它们在之前/之后并不总是基准。 2016年同样密集，一些疯狂的&amp;gt; 1000倍的改进。今年只有十个左右提交，提高40倍！看到这真是令人印象深刻。至少对我来说。我认为这对项目的许多人来说并不明显，他们正在完成多少。记住这些是单数提交。有些甚至在一年中复合改进！</description>
    </item>
    
    <item>
      <title>第十五天-带有 Promise 的简单网络爬虫</title>
      <link>https://ohmysummer.github.io/post/2017-12-15-%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9-%E5%B8%A6%E6%9C%89promise%E7%9A%84%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</link>
      <pubDate>Fri, 15 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-15-%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A4%A9-%E5%B8%A6%E6%9C%89promise%E7%9A%84%E7%AE%80%E5%8D%95%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/</guid>
      <description>Day 15 – A Simple Web Spider With Promises 承诺，承诺 去年夏天，我申请了一项编程工作，面试官要求我编写一个程序来抓取给定的域，只在该域中的链接之后，找到它引用的所有页面。我被允许以任何语言编写程序，但我选择使用Go语言执行任务，因为这是该公司使用的主要语言。这对于并发编程来说是一个理想的任务，并且Go具有非常好的现代化功能，即使有些低级别的并发支持。网络蜘蛛中的主要工作是执行与在域中发现的唯一锚链接相同的次数，即在每个页面上执行HTTP GET并解析页面文本以获取新链接。这个任务可以并行安全地完成，因为没有可能（除非你做得很糟糕），任何调用爬取代码都会干扰其他任何调用。
Go和Raku的创造者受到安东尼霍尔爵士1978年的开创性工作“沟通顺序过程”的启发，但值得注意的是，Raku代码更加简洁，因此更容易隐藏到博客文章中。事实上，Go设计者总是将他们的结构称为“并发原语”。 Go为我的作业应用程序编写的并发spider代码大约有200行，而在Raku中大小不到这个大小的一半。
下面我们来看看如何在Raku中实现一个简单的Web爬虫。内置的Promise类允许您启动，调度和检查异步计算的结果。所有你需要做的就是给Promise.start方法一个代码引用，然后调用await方法，这会阻塞，直到promise完成执行。然后您可以测试结果方法以确定承诺是否已被保留或中断。
您可以通过将其保存到本地文件中来运行本文中的代码，例如网络spider.p6。如果您希望抓取https网站，请使用zef安装HTML :: Parser :: XML和HTTP :: UserAgent以及IO :: Socket :: SSL。我会提醒你，SSL支持目前看起来有点狼狈，所以最好坚持http站点。 Raku程序中的MAIN子程序存在时表示一个独立程序，这就是执行开始的地方。 MAIN的参数表示命令行参数。我编写了这个程序，以便默认情况下它会抓取Perlmonks站点，但是您可以覆盖它，如下所示：
$ raku web-spider.p6 [–domain=http://example.com] 简单的Raku域蜘蛛
use HTML::Parser::XML;use XML::Document;use HTTP::UserAgent;sub MAIN(:$domain=&amp;quot;http://www.perlmonks.org&amp;quot;) {my $ua = HTTP::UserAgent.new;my %url_seen;my @urls=($domain);loop {my @promises;while ( @urls ) {my $url = @urls.shift;my $p = Promise.start({crawl($ua, $domain, $url)});@promises.</description>
    </item>
    
    <item>
      <title>第十四天-在 Raku 中构建和测试 Big Grammars</title>
      <link>https://ohmysummer.github.io/post/2017-12-14-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9-%E5%9C%A8raku%E4%B8%AD%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95%E5%A4%A7grammars/</link>
      <pubDate>Thu, 14 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-14-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%A4%A9-%E5%9C%A8raku%E4%B8%AD%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B5%8B%E8%AF%95%E5%A4%A7grammars/</guid>
      <description>The Little Match Girl: Building and Testing Big Grammars in Raku Raku Grammars 很棒，但在项目中使用它们会是什么样呢？在圣诞节前和圣诞节后，我的经历是一个令人心酸的故事。你可以在这里找到版本库。我不是来自计算机科学背景，所以也许它看起来很简陋，但是当我学习 Raku Grammars 时，这是我的困难和胜利。
第一根火柴 就像卖火柴的小女孩一样，我们的故事发生在圣诞节前。卖火柴的小女孩的任务是在圣诞节前夕销售一捆火柴棍（实际上是新年，我确实回去读了那个故事。圣诞节更适合 Raku），而我的任务是从 Modelica 模型中提取注释渲染为矢量图形。现在，Modelica 是一个非常棒的面向对象的建模语言，除了提及其附录中包含一个具体语法部分的非常好的规范文档（pdf）之外，我将完全理解它。仔细阅读本节，我意识到“语法元符号”和“词法单位”看起来像我最近读过的一篇博客文章中的 Raku Grammars，并且急于尝试。
来自 Modelica 的示例具体语法：
class-definition :[ encapsulated ] class-prefixesclass-specifierRaku rule 的示例:
rule class_definition {[&amp;lt;|w&amp;gt;&#39;encapsulated&#39;&amp;lt;|w&amp;gt;]? &amp;lt;class_prefixes&amp;gt;&amp;lt;class_specifier&amp;gt;}这就像卖火柴的小女孩划第一颗火柴一样，第一次看到了一个超越她现实的奇妙世界。一个温暖的小炉子。然后它熄灭了。
它非常接近，我把它放到了一个文本编辑器中，并且用一些 Raku 的东西替换了不是 Raku 的部分，以查看它是否会运行。它没有运行。我砍掉了它，我指出了不同的位来解决更小的块。无处不在的空白符号，正则表达式，标记，规则。我能够解析某些部分，其他部分神秘地没有起效。回顾过去，这一定很糟糕。与此同时，我们一起破解传统的正则表达式来提取注释，并将我的 Grammar 放在架子上。
第二根火柴 不久之后，发布了 Grammar::Profiler 和 Grammar::Debugger，并且我受到启发，决定再试一试。我被授予了对我的规则出乎意料表现的很好的见解。我能够比以前更深入地理解 grammar。第二支火柴一直亮着，我有一场盛宴。然后它熄灭了。
在调试器中，我陷入了回溯的深渊。分析器一直运行，因为它一次又一次地陷入泥潭。我能够走得更远，但最终遇到了一堵墙。成功似乎非常接近，但我自己的经历中有太多缺失的部分，并且有文档让我度过难关。
第三根火柴 时间流逝，圣诞节来了。我有了新的职位，有时间做个人项目。我有不断改进的 Grammar 文档来指导我。我已经阅读了使用遗留代码高效工作的书。这足以让我再次迎难而上。
面向对象 这对我来说是最大的突破。当我从文档中了解到 Tokens，rules 和 regex 都是有趣的外观方法时，我突然发现了所有的东西。当我回到家时，我立即检查我是否可以重写 TOP，并检查是否可以将 Grammar 方法变为 role。两人都很愉快地工作，而且我在做生意。我可以把它分成块，而不是一个单一的，全有或全无的 grammar。这极大地改进了代码的组织和可测试性。</description>
    </item>
    
    <item>
      <title>第十三天 - 使用 Raku 挖掘维基百科</title>
      <link>https://ohmysummer.github.io/post/2017-12-13-%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9-%E4%BD%BF%E7%94%A8-raku-%E6%8C%96%E6%8E%98%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91/</link>
      <pubDate>Wed, 13 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-13-%E7%AC%AC%E5%8D%81%E4%B8%89%E5%A4%A9-%E4%BD%BF%E7%94%A8-raku-%E6%8C%96%E6%8E%98%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91/</guid>
      <description>介绍 大家好!
今天，让我介绍一下如何用 Raku 挖掘维基百科的 Infobox。
维基百科信息框在自然语言处理中扮演着非常重要的角色，并且有许多应用程序可以利用维基百科信息框：
 构建知识库（例如 DBpedia[0]） 排名属性的重要性[1] 问答[2]  其中，我将重点讨论信息框提取问题，并演示如何使用 Grammars 和 Actions 解析信息框的复杂结构。
Grammar 和 Actions 难学吗? 不，他们不是！
你只需要知道五件事情：
  Grammar
  token 是最基础的一个。你通常使用它。
  rule 让空白符有意义。
  regex 让匹配引擎回溯。
  Actions
  make 准备一个对象用于返回当 made calls on it。
  made 在它的调用者身上调用并返回准备好的对象。
  欲了解更多信息, 请查看: https://docs.raku.org/language/grammars
什么是 Infobox? 你有没有听过 &amp;ldquo;Infobox&amp;rdquo; 这个词?
对于那些没听说过的人，我会简单地解释一下。
理解信息框的一个简单方法是使用一个真实的例子：
你可以看到，信息框会在页面的右上方显示页面主题的属性-值对儿。例如, 在这个例子中, 它说 Raku 的设计者 (ja: 設計者)是 Larry Wall(ja: ラリー・ウォール)。</description>
    </item>
    
    <item>
      <title>第十二天 – The Year of Raku Books</title>
      <link>https://ohmysummer.github.io/post/2017-12-12-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9the-year-of-raku-books/</link>
      <pubDate>Tue, 12 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-12-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9the-year-of-raku-books/</guid>
      <description>https://rakuadvent.wordpress.com/2017/12/12/day-12-the-year-of-perl-6-books/</description>
    </item>
    
    <item>
      <title>第十天 – Wrapping Rats</title>
      <link>https://ohmysummer.github.io/post/2017-12-10-%E7%AC%AC%E5%8D%81%E5%A4%A9wrapping-rats/</link>
      <pubDate>Sun, 10 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-10-%E7%AC%AC%E5%8D%81%E5%A4%A9wrapping-rats/</guid>
      <description>Day 10 – Wrapping Rats 沿着烟囱向下是一件危险的事情。
烟囱可能很窄，很高，有时候建造得不够好。
今年，圣诞老人想要做好准备。因此，他正在将烟囱检查与交付礼物结合起来。
烟囱检查涉及确保每层砖都处于正确的高度; 即砂浆层的高度是一致的，并且砖的高度也是一致的。
例如，对于 2¼” 高的砖和厚度为 ⅜” 的砂浆，测量序列应该如下所示：
 🎅 ─██─||layer total░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░2¼ ░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░░░░░░░░░░░ ░░░░░░░░░░░░░░░ ░░░░░░░░░░⅜ ‾‾???░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░2¼ ░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░⅜ ‾‾5⅝░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░2¼ ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░░░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░⅜ ‾‾3░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░2¼ ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░ ░░░░░░ ░░░░░░░░░░░░░ ░░░░░░░░░░░░ ░░░⅜ _____________________________________‾‾⅜ 这个计划是让精灵们下降到烟囱的底部，手中拿着卷尺，然后回来，确保每个砖块的顶部恰好位于卷尺上的正确位置。</description>
    </item>
    
    <item>
      <title>第九天 – HTTP and Web Sockets with Cro</title>
      <link>https://ohmysummer.github.io/post/2017-12-09-%E7%AC%AC%E4%B9%9D%E5%A4%A9http-and-web-sockets-with-cro/</link>
      <pubDate>Sat, 09 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-09-%E7%AC%AC%E4%B9%9D%E5%A4%A9http-and-web-sockets-with-cro/</guid>
      <description>Day 9 – HTTP and Web Sockets with Cro 礼物不仅仅是圣诞节的时候才有。今年夏天，在瑞士 Perl 工作室 - 精美地坐落在阿尔卑斯山 - 我有幸透露了 Cro。 Cro 是一组用于在 Raku 中构建服务的库，以及一些用于 stub，run 和跟踪服务的开发工具。 Cro 主要关注使用 HTTP（包括HTTP/2.0）和 Web 套接字构建服务，但可以提供对 ZeroMQ 的早期支持，并计划在未来推出一系列其他选项。
响应式管道 Cro 遵循 Perl 的设计原则，使简单的事情变得简单，并且让困难的事情变得可能。就像 Git 一样，Cro 可以被认为是具有瓷器（使简单的事情变得简单）和管道（使困难的事情成为可能）。管道水平由组成管道的组件组成。这些组件具有不同的形状，例如源，传输和下沉。这是一个将 HTTP 请求转换为 HTTP 响应的转换：
use Cro;use Cro::HTTP::Request;use Cro::HTTP::Response;class MuskoxApp does Cro::Transform {method consumes() { Cro::HTTP::Request }method produces() { Cro::HTTP::Response }method transformer(Supply $pipeline --&amp;gt; Supply) {supply whenever $pipeline -&amp;gt; $request {given Cro::HTTP::Response.</description>
    </item>
    
    <item>
      <title>第八天 – Adventures in NQP Land: Hacking the Rakudo Compiler</title>
      <link>https://ohmysummer.github.io/post/2017-12-08-%E7%AC%AC%E5%85%AB%E5%A4%A9adventures-in-nqp-land-hacking-the-rakudo-compiler/</link>
      <pubDate>Fri, 08 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-08-%E7%AC%AC%E5%85%AB%E5%A4%A9adventures-in-nqp-land-hacking-the-rakudo-compiler/</guid>
      <description>Day 8 – Adventures in NQP Land: Hacking the Rakudo Compiler/ 对旧圣诞节经典“圣诞节十二天”的道歉，我给你一个 Raku 版本的第一行：
在圣诞节的第一天，我真正的爱给了 pod 树上的 Perl 表格&amp;hellip;&amp;hellip;
但是我得到的表格不是很漂亮！
背景 我与 Raku 的第一次真正联系是在 2015 年春天，当时我决定检查它的状态，发现它已经准备好迎接黄金时段。在获得了该语言的一些经验之后，我开始在我可以提供帮助的地方贡献文档。我对文档的第一个贡献是清理其中没有很好呈现的表格。在我对本地主机上的 pod 表进行实验期间，我尝试了下表格：
=begin table-r0c0 r0c1=end table这导致 Raku 抛出一个丑陋的, LTA（非常搓）的异常消息：
&amp;quot;===SORRY!=== Cannot iterate object with P6opaque representation&amp;quot;我解决了这个问题，但它让我感觉不爽，所以我开始调查 pod 和 tables 的内部。这导致我在 github.com/rakudo/src/Raku/Pod.nqp 中发现了问题的根源。
事实上，许多 pod 表格问题的真正问题最终都出现在该文件中。
Not Quite Perl (NQP) nqp 是用于构建 Rakudo Raku 编译器的中间语言。它的 git 仓库在这里。本文的其余部分是关于修改 rakudo 编译器中的 nqp 代码，其仓库地址在这里。 Rakudo 在这里也有一个网站。</description>
    </item>
    
    <item>
      <title>第七天 – Test All The Things</title>
      <link>https://ohmysummer.github.io/post/2017-12-07-%E7%AC%AC%E4%B8%83%E5%A4%A9test-all-the-things/</link>
      <pubDate>Thu, 07 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-07-%E7%AC%AC%E4%B8%83%E5%A4%A9test-all-the-things/</guid>
      <description>https://rakuadvent.wordpress.com/2017/12/07/day-7-test-all-the-things/
Raku 与其大姐姐 Perl 5一样，具有很悠久的测试传统。当您安装任何 Perl 模块时，安装程​​序通常会运行该模块的测试套件。当然，作为新兴的 Raku 模块作者，您需要创建自己的测试套件。或者，也许你会在创建模块之前勇于创建测试套件。这实际上有几个好处，其中最主要的是你的第一个用户，甚至在它被写之前。
但在实际代码之前，我想提一下我经常使用的两个 shell 别名 -
alias 6=&amp;#39;raku -Ilib&amp;#39;alias 6p=&amp;#34;prove -e&amp;#39;raku -Ilib&amp;#39;&amp;#34;这些别名使我可以快速运行测试文件，而不必去安装我的代码。如果我在项目目录中，我可以运行
$ 6 t/01-core.tok 1 - call with numberok 2 - call with textok 3 - call with formatted string1..3它会告诉我我运行了哪些测试以及它们是否全部通过。就像它的大姐姐Perl 5一样，Raku使用&amp;rsquo;t /&amp;lsquo;目录作为测试文件，并按照惯例使用后缀&amp;rsquo;.t&#39;来区分测试文件和软件包或脚本。它还有一个内置的单元测试模块，我们在上面使用。如果我们正在测试sprintf（）内部，它可能看起来像
use Test;ok sprintf(1), &#39;call with number&#39;;ok sprintf(&amp;quot;text&amp;quot;), &#39;call with text&#39;;ok sprintf(&amp;quot;%d&amp;quot;,1), &#39;call with formatted string&#39;;done-testing;ok和done-testing功能会自动导出给我们。我在这里使用规范的Raku风格，而不是太依赖括号。在这种情况下，我确实需要使用圆括号来确保sprintf（）不会“认为”“空调用”是它的参数。
OK只需要两个参数，你想要测试的真实性，以及一个可选的消息。如果第一个参数是任何评估为True的东西，则测试通过。否则&amp;hellip;&amp;hellip;你知道。该消息只是描述测试的文本。它纯粹是可选的，但当测试失败时它可以很方便，因为您可以在测试文件中搜索该字符串并快速找到问题。不过，如果你像作者一样，行号更有价值，所以当你看到的时候
not ok 1 - call with number# Failed test &#39;call with number&#39;# at test.</description>
    </item>
    
    <item>
      <title>第六天-Raku 书评</title>
      <link>https://ohmysummer.github.io/post/2017-12-06-%E7%AC%AC%E5%85%AD%E5%A4%A9-raku-%E4%B9%A6%E8%AF%84/</link>
      <pubDate>Wed, 06 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-06-%E7%AC%AC%E5%85%AD%E5%A4%A9-raku-%E4%B9%A6%E8%AF%84/</guid>
      <description>https://rakuadvent.wordpress.com/2017/12/06/</description>
    </item>
    
    <item>
      <title>第三天 – LetterOps with Raku</title>
      <link>https://ohmysummer.github.io/post/2017-12-03-%E7%AC%AC%E4%B8%89%E5%A4%A9letterops-with-raku/</link>
      <pubDate>Sun, 03 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-03-%E7%AC%AC%E4%B8%89%E5%A4%A9letterops-with-raku/</guid>
      <description>Day 3 – LetterOps with Raku 规模 “规模！规模就是一切！“。
当圣诞老人的声音传到他们身上时，精灵散落在四面八方。
“这个 operation 是为三十四个孩子准备的？现在我们有无数的！大人也送信！“
小精灵 Buzzius 站了出来，喷出“但现在我们有电脑！”，又回到他精灵的追求。
“他们有什么好处？请告诉我，如果我仍然需要阅读每一封信，我该怎么办？“。
小精灵 Diodius 短暂地从藏身处抬起头，说：“告诉孩子们发一封文字信”。
圣诞老人停止了叫喊，并抓住了他有胡子的下巴。 “我可以做到这一点”。早期的儿童采用者就像这样发了一封信。
Dear Santa: I have been a good boy so I want you to bring me a collection of scythes and an ocean liner with a captain and a purser and a time travel machine and instructions to operate it and I know I haven&#39;t been so good at times but that is why I&#39;m asking the time machine so that I can make it good and well and also find out what happened on July 13th which I completely forgot.</description>
    </item>
    
    <item>
      <title>第二天-Raku: 符号, 变量和容器</title>
      <link>https://ohmysummer.github.io/post/2017-12-02-%E7%AC%AC%E4%BA%8C%E5%A4%A9-raku%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Sat, 02 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-02-%E7%AC%AC%E4%BA%8C%E5%A4%A9-raku%E4%B8%AD%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%B9%E5%99%A8/</guid>
      <description>第二天-Raku: 符号, 变量和容器 对容器的基本理解对于在 Raku 中进行愉快的编程是至关重要的。它们无处不在，不仅影响你获得的变量类型，还决定了 List 和 Map 在迭代时的行为方式。
今天，我们将学习什么是容器，以及如何使用它们，但是首先，我希望你暂时忘记你对 Raku 的符号和变量的所有知识或怀疑，特别是如果你来自 Perl 5 的背景。 忘记一切。
把钱拿出来 在 Raku 中，变量以 $ 符号为前缀，用绑定运算符（:=）赋值。 像这样：
my $foo := 42; say &amp;#34;The value is $foo&amp;#34;; # OUTPUT: «The value is 42␤» 如果你已经按照我的建议来忘记你所知道的一切，那么学习 List 和 Hash 类型也是一样：
my $ordered-things := &amp;lt;foo bar ber&amp;gt;; my $named-things := %(:42foo, :bar&amp;lt;ber&amp;gt;); say &amp;#34;$named-things&amp;lt;foo&amp;gt; bottles of $ordered-things[2] on the wall&amp;#34;; # OUTPUT: «42 bottles of ber on the wall␤» .</description>
    </item>
    
    <item>
      <title>第一天 – Raku 鬼精灵: 圣诞节实用指南</title>
      <link>https://ohmysummer.github.io/post/2017-12-01-%E7%AC%AC%E4%B8%80%E5%A4%A9-raku%E9%AC%BC%E7%B2%BE%E7%81%B5-%E5%9C%A3%E8%AF%9E%E8%8A%82%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 01 Dec 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-01-%E7%AC%AC%E4%B8%80%E5%A4%A9-raku%E9%AC%BC%E7%B2%BE%E7%81%B5-%E5%9C%A3%E8%AF%9E%E8%8A%82%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>第一天 – Raku 鬼精灵: 圣诞节实用指南 看看他们！同事、朋友和亲近的家人都在开心地笑着。他们都在享受着使用 Raku 的 6.c “圣诞”版编程的乐趣。给力的并发原语, 核心文法, 还有非常棒的对象模型。它让我印象深刻！
但是等一下&amp;hellip; 就一秒。我有个想法。一个可怕的想法。我想到了一个鬼主意! 我们可以在他们的&amp;quot;圣诞&amp;quot;上捣乱。需要的只有一点花招。哈哈哈哈哈哈！！
欢迎来到 2017 年的 Raku 圣诞日历！每天，从今天直到圣诞节，我们都会有一篇很赞的关于 Raku 的博客推送到你面前。
今天，我们会展示我们淘气的一面并且故意地做些淘气的事情。确实，这有点用，但是淘气点更快乐。我们开始吧！
But True does False 你听过 but 操作符吗？一个好玩的东西：
say True but False ?? &amp;#39;Tis true&amp;#39; !! &amp;#39;Tis false&amp;#39;; # OUTPUT: «Tis false␤» my $n = 42 but &amp;#39;forty two&amp;#39;; say $n; # OUTPUT: «forty two␤» say $n + 7; # OUTPUT: «49␤» 它是一个中缀操作符，它首先拷贝它左边的对象，然后把它右边提供的 role 混进这个拷贝中：
my $n = 42 but role Evener { method is-even { self %% 2 } } say $n.</description>
    </item>
    
    <item>
      <title>根据select结果生成insert语句</title>
      <link>https://ohmysummer.github.io/post/2017-09-16-%E6%A0%B9%E6%8D%AEselect%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90insert%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sat, 16 Sep 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-09-16-%E6%A0%B9%E6%8D%AEselect%E7%BB%93%E6%9E%9C%E7%94%9F%E6%88%90insert%E8%AF%AD%E5%8F%A5/</guid>
      <description>想根据 MySQL select 语句的结果生成 insert 语句。
use v6;for $=finish.lines -&amp;gt; $line {next if $++ &amp;lt; 3 || $line ~~ / &#39;-&#39; /;say &#39;insert into convert_path (id, path_name, events, app_key, create_at, update_at) values (&#39; ~ ($line.split: /&amp;lt;[\s+ |]&amp;gt;/, :skip-empty)&amp;gt;&amp;gt;.&amp;amp;quote.join(&amp;quot;,&amp;quot;) ~ &amp;quot;);&amp;quot;;}sub quote(Str $ele) {return &#39;&amp;quot;&#39; ~ $ele ~ &#39;&amp;quot;&#39;;}=finish+-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+| id | path_name | events | app_key | create_at | update_at |+-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+| 308 | 新增打听流程1 | 新增打听,提交打听 | 10c29cf8bd6e61f9ae4a0212eed803c8 | 1505098067 | 1505098067 || 309 | 用户购买流程 | 浏览商品,加入购物车,结算购物车中的商品,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505283224 | 1505283224 || 311 | 用户购买流程2 | 浏览商品,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505284039 | 1505284039 || 312 | 朗读模板付费转化流程 | 访问朗读首页,访问朗读模板,输入或导入文本,开始朗读,进入下载支付页,微信支付 | 54117664fad164a634c57571ba7c5aa7 | 1505284047 | 1505284047 || 313 | 用户购买流程3 | 浏览商品,填写配送地址,点击付款,完成付款 | c10606f35c85bac58625c95006fba769 | 1505284110 | 1505284110 || 315 | 用户购买流程4 | 浏览商品,填写配送地址,完成配送地址,点击立即购买,付款,付款完成 | c10606f35c85bac58625c95006fba769 | 1505284303 | 1505284303 || 316 | 新建朗读付费转化流程 | 访问朗读首页,访问新建朗读,输入或导入文本,开始朗读,进入下载支付页,微信支付 | 54117664fad164a634c57571ba7c5aa7 | 1505284351 | 1505284351 || 321 | goodsDetail | onLoad,onShow | c10606f35c85bac58625c95006fba769 | 1505451421 | 1505451421 |+-----+--------------------------------+-------------------------------------------------------------------------------------------------------------+----------------------------------+------------+------------+最后生成的结果如下：</description>
    </item>
    
    <item>
      <title>开启 Disqus 评论</title>
      <link>https://ohmysummer.github.io/post/2017-09-15-%E5%BC%80%E5%90%AFdisqus%E8%AF%84%E8%AE%BA/</link>
      <pubDate>Fri, 15 Sep 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-09-15-%E5%BC%80%E5%90%AFdisqus%E8%AF%84%E8%AE%BA/</guid>
      <description>要开启 Disqus 评论, 需要先在 Disqus 官网注册账号, 获得 disqusShortname。
#use Grammar::Tracer;#use Grammar::Debugger;my $scene = q:to/END/;★ 二维码1011 扫描二维码1047 扫描小程序码1012 长按图片识别二维码1013 手机相册选取二维码1031 长按图片识别一维码1032 手机相册选取一维码1048 长按图片识别小程序码1049 手机相册选取小程序码1025 扫描一维码1072 二维码收款页面★ 搜索1005 顶部搜索框的搜索结果页1006 发现栏小程序主入口搜索框的搜索结果页1042 添加好友搜索框的搜索结果页1053 搜一搜的结果页1027 顶部搜索框搜索结果页“使用过的小程序”列表★ 公众号1043 公众号模板消息1020 公众号 profile 页相关小程序列表1035 公众号自定义菜单1058 公众号文章1074 公众号会话下发的小程序消息卡片★ 分享1036 App 分享消息卡片1007 单人聊天会话中的小程序消息卡片1008 群聊会话中的小程序消息卡片1044 带 shareTicket 的小程序消息卡片★ 模板消息1014 小程序模版消息1034 微信支付完成页★ 测试1059 体验版小程序绑定邀请页1017 前往体验版的入口页★ 卡券1028 我的卡包1029 卡券详情页1052 卡券的适用门店列表★ 小程序之间跳转1037 小程序打开小程序1038 从另一个小程序返回★ 快捷入口1001 发现栏小程序主入口1022 聊天顶部置顶小程序入口1023 安卓系统桌面图标1024 小程序 profile 页★ 广告投放1068 附近小程序列表广告1067 公众号文章广告★ 其他1039 摇电视1056 音乐播放器菜单1019 微信钱包1026 附近小程序列表1064 微信连Wifi状态栏1073 客服消息列表下发的小程序消息卡片ENDgrammar Scene {token TOP { ^ &amp;lt;entry&amp;gt;+ $ } # 一个或多个块token entry {&amp;lt;head&amp;gt; \s* # 每个块都有一个标题&amp;lt;line&amp;gt;+ \s* # 每个标题下面有很多非标题行}token head { &#39;★&#39; \s+ &amp;lt;title&amp;gt; }token line {[&amp;lt;!</description>
    </item>
    
    <item>
      <title>Raku Sheet</title>
      <link>https://ohmysummer.github.io/post/2017-05-19-sheet/</link>
      <pubDate>Fri, 19 May 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-05-19-sheet/</guid>
      <description>正则表达式 Raku 的正则表达式允许你为你自定义的字符类混进 Unicode 属性！
constant string = &#39;The Quick 🐼 Jumped Over 57 Dogs&#39;; say string ~~ m:g/ &amp;lt;:upper-[TQ]&amp;gt; /; # (「J」 「O」 「P」) say string ~~ m:g/ &amp;lt;-[\x0..\x255]+[\x35..\x37]&amp;gt; /; # (「🐼」 「5」 「7」) say string ~~ m:g/ &amp;lt;-:digit -:Ll -:Zs&amp;gt; /; # (「T」 「Q」 「🐼」 「J」 「O」 「D」) say string ~~ m:g/ &amp;lt;[\w]-[TQJ\d]-:lower+[5]&amp;gt; /; # (「O」 「5」 「D」) Wow! #Raku #Regex is so awesome, you can just shove an array into it and it&amp;rsquo;ll know to treat it as alternatives to match!</description>
    </item>
    
    <item>
      <title>4 种风格的模板引擎</title>
      <link>https://ohmysummer.github.io/post/2017-03-04-4%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</link>
      <pubDate>Sat, 04 Mar 2017 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-03-04-4%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</guid>
      <description>4 种风格的模板引擎. 带基准测试！ 这一次在博客上，我将告诉你如何编写自己的模板引擎 - 根据需要为你量身定制语法和行为。 我们将以四种不同的方式来分析每种方法的优缺点，以及代码速度和复杂性。 我们今天的示例任务是为用户撰写密码提醒文本，然后可以通过电子邮件发送。
use v6; my $template = q{ Hi [VARIABLE person]! You can change your password by visiting [VARIABLE link] . Best regards. }; my %fields = ( &#39;person&#39; =&amp;gt; &#39;John&#39;, &#39;link&#39; =&amp;gt; &#39;http://example.com&#39; ); 所以由我们决定我们的模板语法应该是什么样子的，对于初学者，我们会有一些小的变量（虽然这不是很精确的名称，因为模板中的变量几乎总是不变的）。 我们还有用于填充模板字段的数据。 让我们开始吧！
Substitutions sub substitutions ( $template is copy, %fields ) { for %fields.kv -&amp;gt; $key, $value { $template ~~ s:g/&#39;[VARIABLE &#39; $key &#39;]&#39;/$value/; } return $template; } say substitutions($template, %fields); 输出:</description>
    </item>
    
    <item>
      <title>Raku From Ruby - Nutshell</title>
      <link>https://ohmysummer.github.io/post/2016-10-17-rakufromruby/</link>
      <pubDate>Mon, 17 Oct 2016 17:55:34 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-17-rakufromruby/</guid>
      <description>Raku from Ruby - Nutshell
基本语法 语句结束分号 Ruby 使用换行(有几个例外)来探测大部分语句的结束, 只要表达式已经完成。通过把运算符挂在行的末尾以保证解析会继续而打断一个长的表达式的做法很常见:
foo + # 在 Ruby 中结尾的运算符意味着解析会继续 bar + baz 在 Raku 中你必须显式地使用 ; 来结束语句, 这允许更好的反馈和更灵活的断行。有两个例外不需要显式的 ;, 块儿中的最后一条语句, 在块自身的闭合花括号之后(如果那一行上没有任何其它东西):
if 5 &amp;lt; $x &amp;lt; 10 { say &amp;quot;Yep!&amp;quot;; $x = 17 # 在闭合花括号 } 之前不需要分号 ; } # 因为换行, 在闭合花括号 } 之后不需要分号 ; say &amp;quot;Done!&amp;quot;; # 如果后面什么也没有, 那么这儿的分号也不需要 空白 Ruby 中允许使用大量令人吃惊的灵活的空白, 即使在开启了严格模式和警告的情况下:
# 不符合习惯但是在 Ruby 中是合法的 puts&amp;#34;Hello &amp;#34;+ (people [ i] .</description>
    </item>
    
    <item>
      <title>在手机中运行 Raku</title>
      <link>https://ohmysummer.github.io/post/2016-10-14-%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%AD%E8%BF%90%E8%A1%8Craku/</link>
      <pubDate>Fri, 14 Oct 2016 11:15:24 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-14-%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%AD%E8%BF%90%E8%A1%8Craku/</guid>
      <description>准备工作  一只 Root 过的安卓智能手机(例如 Smartisan T1) 下载并安装 busybox.apk 、 Linux Deploy.apk 和 JuiceSSH.apk  安装 Linux 下面以在我的锤子手机上安装 Debian 为例, 说明如何在手机上运行 Linux:
设置 Linux Deploy 打开手机上的 Linux Deploy.apk：
在下面工具栏「启动」-&amp;gt;「停止」-&amp;gt; 「下载」 tab 中找到那个类似下载图标的按钮点击, 进入属性设置, 其中属性设置如下所示:
其中,
   选项 值 说 明     发行版 Debian 根据自己需要的系统选择   发行版本 jsssie 选择稳定版   架构 armhf 软件会自省判断 CPU 架构类型   镜像地址 http://debian.bjtu.edu.cn/debian/ http://ftp.cn.debian.org/debian/   镜像大小 不用填写 默认就行   选择组件 只保留 SSH 服务器 手机上用什么桌面环境   图形界面 取消勾选 手机上不需要 GUI   自定义挂载 勾选 在挂载点那里选择 sdcard0    设置完成后回到最上面的 Intall(安装 GNU/Linux), 就会开始下载镜像文件了:</description>
    </item>
    
    <item>
      <title>Raku from Haskell - Nutshell</title>
      <link>https://ohmysummer.github.io/post/2017-04-29-raku-from-haskell-nutshell/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-04-29-raku-from-haskell-nutshell/</guid>
      <description>Haskell 和 Raku 是非常不同的语言。这很明显。 但是，这并不意味着没有相似之处或共同的想法！ 此页面尝试让一个 Haskell 用户启动并运行 Raku。Haskell 用户可能会发现，在用 Raku 编写脚本时，他们不需要放弃所有 Haskelly 的想法。
请注意，这不应该被误认为是初学者教程或 Raku 概述; 它旨在作为具有强大 Haskell 背景的 Raku 学习者的技术参考。
类型 类型 vs 值 在 Haskell 中, 您有类型级编程, 然后进行值级编程。
plusTwo :: Integer -&amp;gt; Integer -- Types plusTwo x = x + 2 -- Values 您不要像下面那样在 Haskell 中混合类型和值。
plusTwo 2 -- This is valid plusTwo Integer -- This is not valid 在 Raku 中, 类型(亦称为类型对象)和值处于同样的级别
sub plus-two(Int $x --&amp;gt; Int) { $x + 2 } plus-two(2); # This is valid plus-two(Int); # This is valid 我将再用一个例子来说明 Raku 这个独特之处:</description>
    </item>
    
    <item>
      <title>Raku Grammars, Part 1</title>
      <link>https://ohmysummer.github.io/post/2018-02-13-raku-grammers-part-1/</link>
      <pubDate>Fri, 11 Jul 2014 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-02-13-raku-grammers-part-1/</guid>
      <description>Raku Grammars, Part 1 Raku 语言内置了对 grammar 的支持。您可以将 grammars 视为众所周知的正则表达式和诸如 yacc 或 bison 等实用程序或更复杂的 grammar 工具（如ANTLR）的组合。所有这些 - 词法分析器，语法分析器和语义处理 - 通常是编译器的独立部分，在 Raku 中它们都是内置的，并且可以通过全新的 Raku 安装 进行开箱即用。
要感受 grammar 的力量，Raku 自己的 grammar 就是用 Raku 庞大的 grammar 类 Raku::Grammar写成的就足以说明了。
在本文中，我将通过几个例子来说明 grammar 的基础知识。所有必需的语言结构将在我们进行的时候进行解释。
解析数字 在你开始思考用户可以使用不同格式的数字,包括负数，浮点数，科学记数法中的数字，特殊形式的数字（如C的长整数）之前，解析数字似乎是一项简单的任务。
让我们从最简单的形式开始：一个数字作为数字序列。例如，1,42,123 或 1000. Raku 中的 grammar 是一种特殊的类，它有自己的关键字。grammar 的第一个 rule 必须（默认情况下）称为 TOP，以下是解析第一组数字的完整程序：
grammar N {token TOP {&amp;lt;digit&amp;gt;+}}for &amp;lt;1 42 123 1000&amp;gt; -&amp;gt; $n {say N.</description>
    </item>
    
  </channel>
</rss>