<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>正则表达式 on Raku Programming</title>
    <link>https://ohmysummer.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
    <description>Recent content in 正则表达式 on Raku Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 29 Jun 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Raku 中的正则表达式(二)</title>
      <link>https://ohmysummer.github.io/post/2016-06-29-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%8C/</link>
      <pubDate>Wed, 29 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-29-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%8C/</guid>
      <description>允许的修饰符 有些修饰符能在所有允许的地方出现, 但并非所有的都这样.
通常, 影响 regex 编译的修饰符( 像 :i ) 一定要在编译时被知道. 只影响行为而非 regex本身的修饰符(eg. :pos, :overlap, :x(4)) 可能只出现在引用某个调用的结构上(例如 m// 和s///), 并且不会出现在 rx// 上. 最后, 重叠在替换结构中是不被允许的, 而影响修改的副词只允许出现在替中.
这些准则导致了下面的 rules:
 :ignorecase, :ignoremark, :sigspace, :ratchet 和  :Perl5 修饰符和它们的便捷形式允许出现在 regex 中的任何地方, 还有 m//, rx// 和s/// 结构中. 一个 regex实现可能要求它们的值在编译时是被知晓的, 而如果不是这种情况则给出编译时错误信息.  rx:i/ hello / # OK rx:i(1) /hello/ # OK my $i = 1; rx:i($i) /hello/ # may error out at compile time   :samecase, :samespace 和 :same mark 修饰符(还有它们的便捷形式) 只允许出现在替换结构上 (s/// 和 s[] = .</description>
    </item>
    
    <item>
      <title>Raku 中的正则表达式(一)</title>
      <link>https://ohmysummer.github.io/post/2016-03-08-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80/</link>
      <pubDate>Tue, 08 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-08-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80/</guid>
      <description>标题 Synopsis 5: Regexes and Rules
版本 创建于: 2002/06/24 上次修改: 2015/05/12 版本: 180  不论何时, 在 grammar 中引用递归模式时, 通常更偏好使用 token 和 rule, 而不是 regex.
概览 作为常规表达式记法的扩展, Raku 原生地实现了 Parsing Expression Grammars(PEGs). PEGs 要求你为有歧义的那部分提供一个 主从秩序. Raku 的 主从秩序 由一个多级的平局择优法测试决定:
 1) Most-derived only/proto hides less-derived of the same name 2) 最长 token 匹配: food\s+ beats foo by 2 or more positions 3) 最长字面值前缀: food\w* beats foo\w* by 1 position 4) 对于一个给定的 proto, multis from a more-derived grammar win 5) 在一个给定的编译单元中, 出现较早的备选分支或 multi 胜出.</description>
    </item>
    
    <item>
      <title>Raku 中的正则表达式(三)</title>
      <link>https://ohmysummer.github.io/post/2015-11-05-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%89/</link>
      <pubDate>Thu, 05 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-11-05-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%89/</guid>
      <description>预定义 Subrules 下面这些是为任意 grammar 或 regex 预定义好的 subrules:
 ident   匹配一个标识符.
 upper   匹配单个大写字符.
 lower   匹配单个小写字符.
 alpha   匹配单个字母字符, 或者是一个下划线.
要匹配不带下划线的 Unicode 字母字符, 使用 &amp;lt;:alpha&amp;gt;.
 digit   匹配单个数字.
 xdigit   匹配单个十六进制数字.
 print   匹配单个可打印字符.
 graph   匹配单个图形字符.
 cntrl   匹配单个控制字符. (等价于 &amp;lt;:Cc&amp;gt; 属性). 控制字符通常不产生输出, 相反, 它们以某种方式控制末端:例如换行符和退格符都是控制字符. 所有使用 ord() 之后小于 32 的字符通常归类为控制字符.</description>
    </item>
    
    <item>
      <title>Raku 中的正则表达式(四)</title>
      <link>https://ohmysummer.github.io/post/2015-09-11-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%9B/</link>
      <pubDate>Fri, 11 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-09-11-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%9B/</guid>
      <description>最长 token 匹配 注意，下面进入糟糕区域，如果看不懂请查看英文原文!
S05-metasyntax/longest-alternative.t lines 53–460
因为 &amp;rdquo;longest-token matching&amp;rdquo; 是一个很长的短语, 我们会经常将这个概念叫做 LTM. 这个基本的概念就是人们在头脑中倾向于怎么去解析文本, 所以计算机应该像人一样尝试做同样的事情. 而使用 LTM 解析文本就是关于计算机怎样决定匹配一组备选分支中的哪一个备选分支的.
在 Raku 中, | 代表使用声明性的 longest-token 语义的逻辑备选分支.(你现在能使用 || 来标示旧的暂存的备选分支. 就是, | 和 || 现在在正则语法内的运作方式和在正则语法外的运作方式很像, 在正则语法外部, | 和 || 代表 junctional 和 短路的 OR. 这也包括事实上 | 的优先级比 || 的优先级高.)
在过去, Perl 中正则表达式是通过一个能回溯的 NFA 算法来处理的. 这很强大, 但是很多解析器通过并行地处理 rules , 而不是一个接着一个地处理, 工作起来更高效, 至少达到某种程度. 如果你看一下像 yacc grammar 这样的东西, 你会发现很多 pattern/action 声明, 其中的 patterns 被认为是并行的, 并且最终由 grammar 决定触发哪个 action.</description>
    </item>
    
    <item>
      <title>正则表达式一例</title>
      <link>https://ohmysummer.github.io/post/2015-06-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%E4%BE%8B/</link>
      <pubDate>Sun, 14 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-06-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%E4%BE%8B/</guid>
      <description>以指定音量随机播放音频文件：
#!/usr/bin/env raku use v6; my %v; # hash to hold data my token filename { .+? \.\S\S\S }; # filenames end in .??? my token volume { \d+ }; # any digits for volume my regex extra { .+ \S }; # anything following that my $mixer = &#39;mixer&#39;; my $player = &#39;mplayer -vf dsize=600:-2 -geometry +200-10 &#39;; my $lockfile = &#39;/tmp/myplayer&#39;; $lockfile.IO.spurt( $*PID ); # store the process ID so other process can kill this one END { $lockfile.</description>
    </item>
    
    <item>
      <title>Raku 中的正则表达式(五)</title>
      <link>https://ohmysummer.github.io/post/2015-04-28-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%94/</link>
      <pubDate>Tue, 28 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-28-raku%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BA%94/</guid>
      <description>从匹配中返回值 Match 对象  成功的匹配总是返回一个 Match 对象, 这个对象通常也被放进 $/ 中, (具名 regex, token, 或 rule 是一个子例程, 因此会声明它们自己的本地 $/ 变量, 它通常指 rule 中最近一次的 submatch, 如果有的话)。当前的匹配状态被保存到 regex 的 $¢ 变量中, 当匹配结束时它最终会被绑定到用户的 $/变量中  不成功的匹配会返回 Nil (并把 $/ 设置为 Nil, 如果匹配已经设置了 $/的话)
 名义上, Match 对象包含一个布尔的成功值, 一个有序的子匹配对象(submatch objects)数组, 一个具名的子匹配对象(submatch objects)散列.(它也可选地包含一个用于创建抽象语法树(AST)的抽象对象) 为了提供访问这些各种各样值的便捷方法, Match 对象在不同上下文中求值也不同:
 在布尔上下文中 Match 对象被求值为真或假
  if /pattern/ {...} # 或: /pattern/; if $/ {...}  如果模式使用 :global 或 :overlap 或 :exhaustive 修饰符, 会在第一个匹配处返回布尔真值.</description>
    </item>
    
    <item>
      <title>从正则表达式到Grammars - Part 1</title>
      <link>https://ohmysummer.github.io/post/2015-04-27-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammars-part-1/</link>
      <pubDate>Mon, 27 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-27-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0grammars-part-1/</guid>
      <description>原文
略去啰嗦的前半部分。
Into the Breach 假设我们 的日志文件中有一个时间戳 2016-02-06T14:36+02:00, 我们使用智能匹配:
say $logfile ~~ /2016-02-06T14:36+02:00/;  这会报错:
 Unrecognized regex metacharacter - (must be quoted to match literally)
 在 Raku 的正则表达式中任何非字母数字字符(&amp;lsquo;a&amp;rsquo;..&amp;lsquo;z&amp;rsquo;, &amp;lsquo;A&amp;rsquo;..&amp;lsquo;Z&amp;rsquo;, 0..9)都必须用引号引起来:
say $logfile ~~ /2016 &#39;-&#39; 02 &#39;-&#39; 06T14 &#39;:&#39; 36 &#39;+&#39; 02 &#39;:&#39; 00/;  现在我们得到等价的奇怪的表达式:
｢2016-01-29T13:25+01:00｣  这仅仅告诉我们, ~~智能匹配操作符匹配了一些文本, 这就是它匹配到的文本。｢｣ 是日语引文标记, 故意和剩余的文本区分开来。
在 Raku 中, 默认打印出带有明确标记的匹配对象, 它准确地告诉你匹配从哪里开始, 到哪里结束。
归纳 我们想让该正则表达式更具普遍性, 例如匹配 2016 年的日志:
say $logfile ~~ /2015 | 2016 &#39;-&#39; 02 &#39;-&#39; 06T14 &#39;:&#39; 36 &#39;+&#39; 02 &#39;:&#39; 00/;  但是这还会匹配到我们不想要的东西, 例如 &amp;rsquo;/post/2015/02&amp;rsquo; 或者甚至 &amp;lsquo;/number/120153&amp;rsquo;。因为 |的优先级没有字符间的连接优先级高。所以:</description>
    </item>
    
  </channel>
</rss>