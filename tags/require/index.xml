<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>require on Raku Programming</title>
    <link>https://ohmysummer.github.io/tags/require/</link>
    <description>Recent content in require on Raku Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 26 Oct 2016 16:37:31 +0000</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/require/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Raku 中的 require</title>
      <link>https://ohmysummer.github.io/post/2016-10-26-raku%E4%B8%AD%E7%9A%84require/</link>
      <pubDate>Wed, 26 Oct 2016 16:37:31 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-10-26-raku%E4%B8%AD%E7%9A%84require/</guid>
      <description>有时你必须不择手段地得到一个东西。 如果它是一个文件，你可以使用 Jonathan Stowes 的 URI::FetchFile。 所述模块检查四个模块中的任何一个是否可用，并且采用第一个将 URI 保存为磁盘上的文件。 在他的代码中有一个有趣的触发了 ENODOC 的行。
$type = try require :: ($class-name); 这里 require 返回一个类型对象，该类型对象由模块声明，并且具有与该模块相同的名字。
检查 roast 这个巧妙的花招并把玩整个动态模块的魔法让我意识到，我们没有真正地在文档中覆盖这一点。 当我尝试处理一个 ENODOC 时我喜欢从一个可编译的例子开始。 这一次，我们需要两个文件。
# M.pm6 unit module M; class C is export { method m { &#39;method C::m&#39; } }; class D is export { method m { &#39;method D::m&#39; } }; # dynamic-modules.p6 use v6; use lib &#39;.&#39;; subset C where ::(&#39;M::C&#39;); my C $context = try { CATCH { default { .</description>
    </item>
    
  </channel>
</rss>