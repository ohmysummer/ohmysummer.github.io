<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Subset on Young For Perl 6</title>
    <link>https://ohmysummer.github.io/tags/subset/</link>
    <description>Recent content in Subset on Young For Perl 6</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 02 Aug 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/subset/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Perl 6 Types--成人之美</title>
      <link>https://ohmysummer.github.io/post/2016-08-02-perl-6-types--%E6%88%90%E4%BA%BA%E4%B9%8B%E7%BE%8E/</link>
      <pubDate>Tue, 02 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-08-02-perl-6-types--%E6%88%90%E4%BA%BA%E4%B9%8B%E7%BE%8E/</guid>
      <description>Perl 6 Types: 成人之美
在我的第一次大学编程语言课中， 我被告知 Pascal 语言在其它类型之外还拥有 Integer、Boolen 和 Stirng 类型。我知道了类型本来就该存在因为计算机很笨。当我在 C语言中涉猎的时候，我学到了更多有关 *int*、 char 和其它像在暖和的地方里地寄生虫， 还有我课桌底下嗡嗡的金属盒的声音。
Perl 5 没有类型，它给我的感觉就像骑着自行车无拘无束的追风少年，沿着斜坡而下。不久之后我一门心思钻到计算机硬件的缝隙中。我拥有数据并且我能用它做任何我想做的事， 只要我得到的不是错误的数据。当我搞定的时候，我从自行车上掉了下来并刮破了我的膝盖。
有了 Perl 6，鱼和熊掌可以兼得。你可以使用类型来避免它们。你可以拥有一个广域的类型来接收很多种类的值或窄类型。并且你可以享受代表机器智力的类型的速度， 或者你可以享受你自定义的代表你自己意志的类型的精度，类型为人类而生。
渐进类型 my $a = &amp;quot;whatever&amp;quot;; my Str $b = &amp;quot;strings only&amp;quot;; my Str:D $c = &amp;quot;defined strings only&amp;quot;; my int $d = 14; # native int sub foo ($x) { $x + 2 } sub bar (Int:D $x) returns Int { $x + 2 }  Perl 6 拥有渐进类型， 这意味着你要么可以使用它们，要么避免使用它们。所以究竟为什么要打扰它们呢？</description>
    </item>
    
    <item>
      <title>使用Perl6的subsets和multiple辨别年龄</title>
      <link>https://ohmysummer.github.io/post/2016-01-04-%E4%BD%BF%E7%94%A8perl6%E7%9A%84subsets%E5%92%8Cmultiple%E8%BE%A8%E5%88%AB%E5%B9%B4%E9%BE%84/</link>
      <pubDate>Mon, 04 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-01-04-%E4%BD%BF%E7%94%A8perl6%E7%9A%84subsets%E5%92%8Cmultiple%E8%BE%A8%E5%88%AB%E5%B9%B4%E9%BE%84/</guid>
      <description>举个例子, 假设 person 有一个 age 属性. 我能写一个 multimethod, 让它接收一个 person 作为参数, 并返回这样的结果吗:
return &amp;quot;child&amp;quot; if age &amp;lt; 16; return &amp;quot;adult&amp;quot; if 16 &amp;lt;= age &amp;lt; 66; return &amp;quot;senior&amp;quot; if age &amp;gt;= 66;  class Person { has Int $.age; has Str $.name; }  这仅仅定义了一个拥有两个属性, 叫做 Person 的类. age 必须是 Int 型, name 必须是 Str 型. . 语法会生成一个只读访问器, 以使我们能从类的外部访问 getter 方法.
现在我们来定义一个 age-group multi 来告诉一个 person 属于哪个 age-group:
multi age-group ($person where (*.</description>
    </item>
    
    <item>
      <title>Subset</title>
      <link>https://ohmysummer.github.io/post/2015-03-19-subset/</link>
      <pubDate>Thu, 19 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-19-subset/</guid>
      <description>Subset 子集 Subset 可用于声明某一类型的子集。
输入一个密码， 要求密码必须满足如下条件：
1、 至少 8 位 2、 必须包含大写字母、小写字母 和 数字
use v6; subset Length8 of Str where *.chars &amp;lt; 8; subset UpCase of Str where none(&#39;A&#39;..&#39;Z&#39;) ∈ *.comb.Set; subset LowerCase of Str where none(&#39;a&#39;..&#39;z&#39;) ∈ *.comb.Set; subset IntNumber of Str where none(&#39;0&#39;..&#39;9&#39;) ∈ *.comb.Set; my $guess = prompt(&#39;Enter your password:&#39;); given $guess { when Length8 { say &#39;密码长度必须为 8 位 以上&#39;; proceed } when UpCase { say &#39;密码必须包括大写字母&#39;; proceed } when LowerCase { say &#39;密码必须包含小写字母&#39;; proceed } when IntNumber { say &#39;密码必须包含数字&#39;; } }  该程序具有可扩展性， 要增加一种密码验证， 只有添加一个 subset 就好了，然后在 given/When 里面增加一个处理。</description>
    </item>
    
  </channel>
</rss>