<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Subscripts on Rakudo Perl 6</title>
    <link>https://ohmysummer.github.io/tags/subscripts/</link>
    <description>Recent content in Subscripts on Rakudo Perl 6</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 01 Jun 2016 10:54:24 +0200</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/subscripts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Perl 6 中的 Subscripts</title>
      <link>https://ohmysummer.github.io/post/2016-06-01-perl6%E4%B8%AD%E7%9A%84subscripts/</link>
      <pubDate>Wed, 01 Jun 2016 10:54:24 +0200</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-01-perl6%E4%B8%AD%E7%9A%84subscripts/</guid>
      <description>Subscripts 通过索引或键访问数据结构中的元素。
通常，人们需要引用集合或数据结构中的一个特定的元素（或特定的元素切片）。从数学标记法中偷学到的，向量 v 的组成部分用 v₁, v₂, v₃ 来引用，在 Perl 6 中这个概念叫做 “下标” （或“索引”）。
Basics Perl 6 提供了两个通用的下标接口：
elements are identified by interface name supported by [ ] zero-based indices Positional Array, List, Buf, Match, ... { } string or object keys Associative Hash, Bag, Mix, Match, ...   Positional 下标 (通过 postcircumfix [ ] 通过元素在有序集合中的位置来寻址元素。)索引 0 引用第一个元素， 索引 1 引用第二个元素， 以此类推：  my @chores = &amp;quot;buy groceries&amp;quot;, &amp;quot;feed dog&amp;quot;, &amp;quot;wash car&amp;quot;; say @chores[0]; #-&amp;gt; buy groceries say @chores[1]; #-&amp;gt; feed dog say @chores[2]; #-&amp;gt; wash car   Associative 下标 (通过 postcircumfix { }), 不要求集合以任何特定的顺序保存元素 - 相反，它使用一个唯一的键来寻址每个值。键的种类取决于使用的集合： 举个例子， 一个标准的散列 使用字符串作为键， 而一个 Mix 能使用任意的对象作为键， 等等:  my %grade = Zoe =&amp;gt; &amp;quot;C&amp;quot;, Ben =&amp;gt; &amp;quot;B+&amp;quot;; say %grade{&amp;quot;Zoe&amp;quot;}; #-&amp;gt; C say %grade{&amp;quot;Ben&amp;quot;}; #-&amp;gt; B+ my $stats = ( Date.</description>
    </item>
    
    <item>
      <title>在 Perl 6 中为自定义的类添加下标(subscripts)</title>
      <link>https://ohmysummer.github.io/post/2015-08-18-%E5%9C%A8perl6%E4%B8%AD%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%A0%87subscripts/</link>
      <pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-18-%E5%9C%A8perl6%E4%B8%AD%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0%E4%B8%8B%E6%A0%87subscripts/</guid>
      <description>为自定义的类添加下标(subscripts) 假如你定义了一个类，你想把类的实例用作散列那样，可以索引其中的元素， 那么你需要让你得自定义遵守 Associative 接口，并重写 AT-KEY 、EXISTS-KEY 、DELETE-KEY 、push 等跟散列有关的方法:
use v6; class HTTPHeader { ... } class HTTPHeader does Associative { has %!fields handles &amp;lt;self.AT-KEY self.EXISTS-KEY self.DELETE-KEY self.push list kv keys values&amp;gt;; method Str { say self.hash.fmt; } multi method EXISTS-KEY ($key) { %!fields{normalize-key $key}:exists } multi method DELETE-KEY ($key) { %!fields{normalize-key $key}:delete } multi method push (*@_) { %!fields.push: @_ } sub normalize-key ($key) { $key.subst(/\w+/, *.tc, :g) } # titileCase 驼峰式的键 method AT-KEY (::?</description>
    </item>
    
  </channel>
</rss>