<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>圣诞 on Rakudo Perl 6</title>
    <link>https://ohmysummer.github.io/tags/%E5%9C%A3%E8%AF%9E/</link>
    <description>Recent content in 圣诞 on Rakudo Perl 6</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 28 Jun 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/%E5%9C%A3%E8%AF%9E/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Perl 6 圣诞月历-(2011)</title>
      <link>https://ohmysummer.github.io/post/2016-06-28-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2011/</link>
      <pubDate>Tue, 28 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-06-28-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2011/</guid>
      <description>2011 The Flip-Flop operator Perl5有一个二元操作符叫做flip-flop,它为假直到它的第一个参数被计算为真，然后它保持真(反转)，直到第二个参数计算为真，然后在那里它又变成假(flop)。 这真是太有用了，以至于Perl6也有flip-flop,只是它拼写为ff,并有一些变异：
ff ff^ ^ff ^ff^  音调符号^意味着在那个结尾跳过结尾。 …或许一些例子更能说明问题…
for 1..20 { .say if $_ == 9 ff $_ == 13; } # 9 10 11 12 13 for 1..20 { .say if $_ == 9 ff^ $_ == 13; } # 9 10 11 12 for 1..20 { .say if $_ == 9 ^ff $_ == 13; } # 10 11 12 13 for 1.</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2009)</title>
      <link>https://ohmysummer.github.io/post/2016-03-11-perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2009/</link>
      <pubDate>Fri, 11 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-03-11-perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2009/</guid>
      <description>2009 有用的和有意思的循环 让我们来看一个基本的例子.
for 1, 2, 3, 4 { .say }  这是一个最简单清晰的语法的例子.在这并没有使用括号来包起整个列表的语句,象这种写法可以贯穿整个 Perl 6. 通常比起 Perl 5 来你没有必要写那么多的括号了.
很象 Perl 5 , 这个循环中的值会默认存到 $_ .在这个方法调用的 say 其实就是 $_.say.注意在 Perl 6 中,你不能直接只打一个 say 而不加参数,它会默认使用 $_ 来传参.你需要使用 .say 。要么明确的指定是 $_.
下面这个语法块并不是一个普通的块.它能通过一个尖的指向,来告诉你的 循环变量传进去的参数的名字 .
for 1, 2, 3, 4 -&amp;gt; $i { $i .say }  如果你调用的 return 内部有这个,将返回闭合的子函数. 这个尖尖也能取 多个 参数.象下面这样.
1 2 3
for 1, 2, 3, 4 -&amp;gt; $i , $j { &amp;quot;$i, $j&amp;quot; .</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2013)</title>
      <link>https://ohmysummer.github.io/post/2016-02-15-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2013/</link>
      <pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-02-15-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2013/</guid>
      <description>2013 Heredocs, Theredocs, Everywheredocs docs So let’s say you’ve got a bit of documentation to print out, a help statement perhaps. You could use an ordinary string, but it always looks like something you really shouldn’t be doing.
sub USAGE { say &amp;quot;foobar Usage: ./foobar &amp;lt;args&amp;gt; &amp;lt;file&amp;gt; Options: ... &amp;quot;; }  Perl 6 has a much better idea for you, fortunately: heredocs! They work a bit differently from Perl 5, and are now invoked using the adverb :heredoc on quoting constructs:</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2010)</title>
      <link>https://ohmysummer.github.io/post/2015-10-05-perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2010/</link>
      <pubDate>Mon, 05 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-10-05-perl-6-%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2010/</guid>
      <description>2010 第二天:用main函数控制命令行交互 2010 年 Perl6 圣诞月历(二)用 main 函数控制命令行交互
在 UNIX 环境下，很多脚本都是要从命令行里获取运行参数的。Perl6 上，实现这个相当简单~比如下面这样：
$ cat add.pl sub MAIN ($x, $y) { say $x + $y } $ perl6 add.pl 3 4 7 $ perl6 add.pl too many arguments Usage: add.pl x y  只要定义一个带命名变量的 MAIN 函数，你就可以获得一个命令行分析器。然后命令行参数就被自动绑定到 $x 和 $y 上了。如果不匹配，还有温馨的 Usage 提示~~
当然，你可能更喜欢自己定制 Usage 信息。那么自己动手，编写 USAGE 函数好了：
$ cat add2.pl sub MAIN($x, $y) { say $x + $y } sub USAGE () { say &amp;quot;Usage: add.</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2015)</title>
      <link>https://ohmysummer.github.io/post/2015-08-05-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2015/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-05-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2015/</guid>
      <description>Comming Soon!</description>
    </item>
    
    <item>
      <title>Perl 6圣诞月历-(2012)</title>
      <link>https://ohmysummer.github.io/post/2015-04-15-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2012/</link>
      <pubDate>Wed, 15 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-04-15-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2012/</guid>
      <description>2012 一个日历 #!/usr/bin/env perl6 constant @months = &amp;lt;January February March April May June July August September October November December&amp;gt;; constant @days = &amp;lt;Su Mo Tu We Th Fr Sa&amp;gt;; sub center(Str $text, Int $width) { my $prefix = &#39; &#39; x ($width - $text.chars) div 2; my $suffix = &#39; &#39; x $width - $text.chars - $prefix.chars; return $prefix ~ $text ~ $suffix; } sub MAIN(:$year = Date.today.year, :$month = Date.</description>
    </item>
    
    <item>
      <title>Perl 6 圣诞月历-(2014)</title>
      <link>https://ohmysummer.github.io/post/2014-12-19-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2014/</link>
      <pubDate>Fri, 19 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2014-12-19-perl-6%E5%9C%A3%E8%AF%9E%E6%9C%88%E5%8E%86-2014/</guid>
      <description>2014 Data munging in Perl 6 vs Perl 5 案例学习: 生成成绩报告单
example.txt STDOUT Peter B Celine A- Zsófia B+ João F Maryam B+ 秀英 B- Finn D+ Aarav A Emma F Omar B  输出报告单：
Zsófia&#39;s grade: B+ List of students with a failing grade: João, Emma Distribution of grades by letter: A: 2 students B: 5 students D: 1 student F: 2 students  example.txt 是一个文本文件， 每行一个学生姓名和分数，中间用空格分割。 我们希望我们的脚本能解析这样的文件并打印含有如下信息的报告：</description>
    </item>
    
  </channel>
</rss>