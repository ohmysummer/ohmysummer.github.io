<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Roles on 焉知非鱼</title>
    <link>http://ohmysummer.github.io/tags/roles/</link>
    <description>Recent content in Roles on 焉知非鱼</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Jan 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://ohmysummer.github.io/tags/roles/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Roles</title>
      <link>http://ohmysummer.github.io/post/2016-01-21-roles/</link>
      <pubDate>Thu, 21 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ohmysummer.github.io/post/2016-01-21-roles/</guid>
      <description>Protocol 在 Swift 中是一组方法和属性的集合, 可用于代码复用。 Perl 6 中有与之类似的结构, 叫做 Role, 下面转换一个 Swift 的 Protocol 为 Perl 6 的 Role, 把部门人员的相关信息打印为一个表格:
Protocol in Swift 　import UIKit func padding(amount: Int) -&amp;gt; String { var paddingString = &amp;quot;&amp;quot; for _ in 0..&amp;lt;amount { paddingString += &amp;quot; &amp;quot; } return paddingString } // 协议 protocol TabularDataSource { var numberOfRows: Int { get } var numberOfColumns: Int { get } func labelForRow(row: Int) -&amp;gt; String // 行标签 func labelForColumn(column: Int) -&amp;gt; String // 列标签 func itemForRow(row: Int, column: Int) -&amp;gt; Int // 表格中的单元格 } struct Person { let name: String let age: Int let yearsOfExperience: Int } // 让 **Department** 遵守 **TabularDataSource**协议 struct Department: TabularDataSource { let name: String var people = [Person]() init(name: String) { self.</description>
    </item>
    
    <item>
      <title>roles冲突</title>
      <link>http://ohmysummer.github.io/post/2015-11-16-roles%E5%86%B2%E7%AA%81/</link>
      <pubDate>Mon, 16 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ohmysummer.github.io/post/2015-11-16-roles%E5%86%B2%E7%AA%81/</guid>
      <description>学会了怎么创建类, 我们继续用它来构建我们的中心内容:
class Hammer { method hammer($stuff) { say &amp;quot;You hammer on $stuff. BAM BAM BAM!&amp;quot;; } } class Gavel { method hammer($stuff) { say &amp;quot;You hammer on $stuff. BAM BAM BAM!&amp;quot;; } } class Mallet { method hammer($stuff) { say &amp;quot;You hammer on $stuff. BAM BAM BAM!&amp;quot;; } }  但是注意到了吗？ 这三个方法包含了同样的方法, 在类中重复了。我们必须那样做如果我们想让每个 Hammar、Gavel 和 Mallet 有能力击打的话。（并且那是合理的）。 但是遗憾的是我们不得不把那个方法一式三份。
为什么遗憾？ 因为一方面在真实世界中, 方法并不是很彼此相似, 有一天你决定在 hammer 方法中更改某些东西, 并没有意识到这个方法在三个不同的地方&amp;hellip; 这导致了一堆痛苦和难受。
所以我们的新玩具, 类, 展现出了一个问题。我们想在每个类中重用 hammer 方法。一个新的概念, role 来拯救我们来了:</description>
    </item>
    
  </channel>
</rss>