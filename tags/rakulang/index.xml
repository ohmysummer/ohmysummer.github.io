<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rakulang on Raku Programming</title>
    <link>https://ohmysummer.github.io/tags/rakulang/</link>
    <description>Recent content in rakulang on Raku Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 27 Oct 2020 22:28:41 +0800</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/rakulang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>剖析一个 Raku 片段</title>
      <link>https://ohmysummer.github.io/post/2020-10-27-dissecting-a-raku-snippet/</link>
      <pubDate>Tue, 27 Oct 2020 22:28:41 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-10-27-dissecting-a-raku-snippet/</guid>
      <description>几天前，我在为一个问题的解决方案做原型时，写了一段代码，给我带来了巨大的喜悦。那是一种让你每次看到它运行时都会傻笑的代码，只因为这个解决方案看起来是多么的聪明和优雅，也因为证明了，与你的期望相反，它确实是可行的，而感到兴奋。</description>
    </item>
    
    <item>
      <title>列表断链</title>
      <link>https://ohmysummer.github.io/post/2020-09-25-list-breaks-the-chain/</link>
      <pubDate>Tue, 27 Oct 2020 21:48:29 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-09-25-list-breaks-the-chain/</guid>
      <description>在看 RaycatWhoDat 喜欢 Raku 的时候，我才发现，List of Matches 不是 MatchList。</description>
    </item>
    
    <item>
      <title>鬼鬼祟祟的参数</title>
      <link>https://ohmysummer.github.io/post/2020-10-10-sneaky-arguments/</link>
      <pubDate>Tue, 27 Oct 2020 21:22:31 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-10-10-sneaky-arguments/</guid>
      <description>在玩 .</description>
    </item>
    
    <item>
      <title>计划淘汰</title>
      <link>https://ohmysummer.github.io/post/2020-10-27-planned-obsolescence/</link>
      <pubDate>Tue, 27 Oct 2020 21:02:20 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-10-27-planned-obsolescence/</guid>
      <description>12年前¹，拉里策划了我的一个模块的报废。他的狡猾计划在两周前被 lizmat 执行了。如果你是从源码开始构建 Rakudo，你现在可以走另一条捷径。</description>
    </item>
    
    <item>
      <title>Raku 中的实例属性</title>
      <link>https://ohmysummer.github.io/post/2020-08-26-instance-attributes-in-raku/</link>
      <pubDate>Wed, 26 Aug 2020 22:45:42 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-08-26-instance-attributes-in-raku/</guid>
      <description>Raku 中的实例属性 在 Raku 中, 默认情况下, 一个对象的方法是完全可以访问的, 但它的数据（作为属性）不能在类外直接访问, 除非明确指定。为了从外部读取、写入或两者都能访问数据, 你必须以某种方式将其公开。你允许对一个对象的数据进行何种级别的访问, 主要取决于你声明它的属性的方式。</description>
    </item>
    
    <item>
      <title>要作为子程序调用还是作为方法调用</title>
      <link>https://ohmysummer.github.io/post/2020-08-26-to-be-called-as-a-sub-or-method/</link>
      <pubDate>Wed, 26 Aug 2020 22:42:51 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-08-26-to-be-called-as-a-sub-or-method/</guid>
      <description>要作为子程序调用还是作为方法调用？这就是问题所在 在 Raku 中，具有自己的词法范围和返回处理的代码对象的总称是例程。虽然不是所有的例程都是子程序和/或方法，但所有的子程序和/或方法都是例程。一个例程既可以是子程序，也可以是方法，在这种情况下，你可以分别使用子程序调用语法和方法调用语法来调用它。例如</description>
    </item>
    
    <item>
      <title>Containers in Raku</title>
      <link>https://ohmysummer.github.io/post/2020-08-26-containers-in-raku/</link>
      <pubDate>Wed, 26 Aug 2020 21:49:02 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-08-26-containers-in-raku/</guid>
      <description>Containers in Raku 在编程语言中，变量是将一个特定的值与编译器已知的名称关联起来的一种方式。例如，以变量声明及其赋值为例，my $x = &amp;quot;Hello&amp;quot;。这就把值 42 和名字 $x 联系起来了，虽然这对大多数意图和目的来说是正确的，但在 Raku 中这并不是整个故事。</description>
    </item>
    
    <item>
      <title>tailgrep</title>
      <link>https://ohmysummer.github.io/post/2020-08-25-tailgrep/</link>
      <pubDate>Wed, 26 Aug 2020 10:02:52 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-08-25-tailgrep/</guid>
      <description>tailgrep 跟随一个文件, 过滤行, 观察 spinner.</description>
    </item>
    
    <item>
      <title>一个更好的终端自动装置</title>
      <link>https://ohmysummer.github.io/post/2020-08-25-a-bettter-terminal-automator/</link>
      <pubDate>Tue, 25 Aug 2020 23:57:35 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-08-25-a-bettter-terminal-automator/</guid>
      <description>A Better Terminal Automator 不久前，我有了一个改善终端体验的想法&amp;ndash;在这里有描述&amp;ndash;这个想法是这样的:</description>
    </item>
    
    <item>
      <title>Defined or Dynvar</title>
      <link>https://ohmysummer.github.io/post/2020-08-17-defined-or-dynvar/</link>
      <pubDate>Mon, 17 Aug 2020 21:41:41 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-08-17-defined-or-dynvar/</guid>
      <description>在为 Shell::Piping 添加 dynvars 以减少手指受伤的风险时，我犯了一个错，lizmat 好心地纠正了这个错误。她建议使用 defined-or 操作符来测试一个给定的动态变量是否被声明。</description>
    </item>
    
    <item>
      <title>Guarding Dynamics</title>
      <link>https://ohmysummer.github.io/post/2020-08-17-guarding-dynamics/</link>
      <pubDate>Mon, 17 Aug 2020 21:35:27 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-08-17-guarding-dynamics/</guid>
      <description>动态变量是一种很好的方式，它可以获得全局变量的好处，但又不存在缺点。它们在调用树上传递信息，而不强制调用者进行声明。然而，动态变量与异常共享一个负担。被调用者知道如何做调用者可能想不到的事情。</description>
    </item>
    
    <item>
      <title>Whereceptions</title>
      <link>https://ohmysummer.github.io/post/2020-08-17-whereceptions/</link>
      <pubDate>Mon, 17 Aug 2020 21:23:44 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-08-17-whereceptions/</guid>
      <description>我有一个 sub，它接收一个文件，并试图防范自己遇到不存在的文件。where 子句没有做好错误信息。</description>
    </item>
    
    <item>
      <title>Dropin Replacement</title>
      <link>https://ohmysummer.github.io/post/2020-08-01-dropin-replacement/</link>
      <pubDate>Sun, 02 Aug 2020 20:02:05 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-08-01-dropin-replacement/</guid>
      <description>今天我知道了 whereis 可以接收多个命令在 $PATH 中查找。</description>
    </item>
    
    <item>
      <title>包裹异常</title>
      <link>https://ohmysummer.github.io/post/2020-08-01-wrapping-exceptions/</link>
      <pubDate>Sun, 02 Aug 2020 19:55:39 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-08-01-wrapping-exceptions/</guid>
      <description>如前所述，我希望减少 Shell::Piping 中简单的错误处理。下面的内容太长了，不适合放在终端的单行中。</description>
    </item>
    
    <item>
      <title>并发的狗粮</title>
      <link>https://ohmysummer.github.io/post/2020-07-31-concurrent-dogfood/</link>
      <pubDate>Sun, 02 Aug 2020 19:44:55 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-31-concurrent-dogfood/</guid>
      <description>我在 Raku 项目中使用 zef --verbose test .</description>
    </item>
    
    <item>
      <title>狗粮时间</title>
      <link>https://ohmysummer.github.io/post/2020-07-31-dogfood-time/</link>
      <pubDate>Sun, 02 Aug 2020 19:39:37 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-31-dogfood-time/</guid>
      <description>Shell::Piping 现在已经拥有了我列表中的所有功能。所以是时候使用它了。我还需要以 README.</description>
    </item>
    
    <item>
      <title>带退出码的增强</title>
      <link>https://ohmysummer.github.io/post/2020-07-29-augmenting-with-exitcode/</link>
      <pubDate>Sun, 02 Aug 2020 19:23:37 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-29-augmenting-with-exitcode/</guid>
      <description>在我的上一篇文章中，我找到了一个很好的方法来匹配 exitcode。我想把它扩展到与 STDERR 匹配，如果 exitcode 是非零。我已经有了一种方法来捕获一个管道的所有错误流。</description>
    </item>
    
    <item>
      <title>处理异常</title>
      <link>https://ohmysummer.github.io/post/2020-07-27-handling-failure/</link>
      <pubDate>Sun, 02 Aug 2020 19:15:43 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-27-handling-failure/</guid>
      <description>经过一番反反复复，我找到了一个实用的方法来处理 Shell::Piping 中的错误条件。这个实用的方法是有多个方法。一个进程确实有一个 exitinteger(称为代码，因为它可能很神秘)和文本输出到 STDERR 来表示出了问题。有时我们需要粗心的错误处理，有时我们需要研究文本输出并对其做出反应。</description>
    </item>
    
    <item>
      <title>模仿引号</title>
      <link>https://ohmysummer.github.io/post/2020-07-24-mimicing-quotes/</link>
      <pubDate>Sun, 02 Aug 2020 19:01:20 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-24-mimicing-quotes/</guid>
      <description>我对缩短代码的追求进展顺利。有一件事还是挺啰嗦的，那就是对象创建。为了让管道充满生命，我们需要 Proc::Async 的实例。</description>
    </item>
    
    <item>
      <title>摆脱模板</title>
      <link>https://ohmysummer.github.io/post/2020-07-18-deboilerplating/</link>
      <pubDate>Sun, 19 Jul 2020 06:11:18 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-18-deboilerplating/</guid>
      <description>我同意 Damian 的观点，link:https://youtu.</description>
    </item>
    
    <item>
      <title>无论何时何地</title>
      <link>https://ohmysummer.github.io/post/2019-05-31-whatever-whenever-does/</link>
      <pubDate>Tue, 07 Jul 2020 10:09:19 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-05-31-whatever-whenever-does/</guid>
      <description>Jnthn 回答了为什么 $*IN.</description>
    </item>
    
    <item>
      <title>显示缺席</title>
      <link>https://ohmysummer.github.io/post/2020-07-06-indicating-absence/</link>
      <pubDate>Tue, 07 Jul 2020 09:35:35 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-06-indicating-absence/</guid>
      <description>我不能在 Stackoverflow 上自作聪明，因为我和他们使用的许可证不兼容。但这并不能阻止我阅读 uzlxxxx 提出的问题。在他最后的知识收获中，他试图用 Nil 来表示链接列表末尾没有值。Nil 是这个博客的老朋友了，我花了很长时间才喜欢上它。</description>
    </item>
    
    <item>
      <title>非递归</title>
      <link>https://ohmysummer.github.io/post/2020-07-06-unrecursing/</link>
      <pubDate>Mon, 06 Jul 2020 19:40:45 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-06-unrecursing/</guid>
      <description>Moritz 不满意 Raku 给他的权力，让他与名单搏斗。他说的没错。如果简单的事情很容易，就不需要摔跤了。这让我想到了我在上一篇博文中构建的数据结构。它是一个列表和一个 Proc::Async 的对。</description>
    </item>
    
    <item>
      <title>Wat Freeness</title>
      <link>https://ohmysummer.github.io/post/2020-06-22-wat-freeness/</link>
      <pubDate>Mon, 06 Jul 2020 18:59:57 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-06-22-wat-freeness/</guid>
      <description>遗憾的是，我不能参加云端会议，因为我把翅膀借给了一个天使，而那个吸盘没有把翅膀带回来。但没有什么&amp;ndash;哪怕是瘟疫&amp;ndash;可以阻止我写一篇博文。</description>
    </item>
    
    <item>
      <title>感觉像一个 bug</title>
      <link>https://ohmysummer.github.io/post/2020-06-20-it-felt-like-a-bug/</link>
      <pubDate>Mon, 06 Jul 2020 18:51:56 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-06-20-it-felt-like-a-bug/</guid>
      <description>IO::Path 提供了不少关于文件的信息。缺少的是它的真实类型。文件的结尾是有欺骗性的。在文件的操作系统上，我们可以得到一个清晰的图像。Shelling 用 file -b -i 获取 mimetype 有点慢，所以我试着在文件名列表上添加一个 .</description>
    </item>
    
    <item>
      <title>监控新访客</title>
      <link>https://ohmysummer.github.io/post/2020-05-26-watching-new-arrivals/</link>
      <pubDate>Mon, 06 Jul 2020 17:29:03 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-05-26-watching-new-arrivals/</guid>
      <description>任何枯燥的重复性工作都必须尽可能地简单，否则就会被忽视。我很确定这就是我们发明电脑的原因。备份是挺无聊的。事实上，当涉及到备份时，你要避免任何形式的刺激。所以它们必须尽可能的简单。我有一个脚本，当一个新设备被添加时，由 udev 规则触发。当插入一个磁盘时，这个脚本工作得很好。(这很好用。)我有一个 USB 集线器，里面有几个U盘，形成了一个 btrfs raid5，每当我打开U盘集线器的时候，就可以对我的 $home 进行快速备份。在某些情况下，这并不能正常工作。找一个 bash 脚本来检查是否有一个硬盘丢失了，这可不好玩。主要是因为只有合适的语言才会有 Set。我们确实有一种合适的语言。</description>
    </item>
    
    <item>
      <title>Spinning Up Sort</title>
      <link>https://ohmysummer.github.io/post/2020-07-06-spinning-up-sort/</link>
      <pubDate>Mon, 06 Jul 2020 09:23:16 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-06-spinning-up-sort/</guid>
      <description>我的 Linux 盒子正在从 mp4 转码 到 av1 像一个老板。我想，缩小空间的霸主减半是便宜，然后一倍的磁盘空间。用20.</description>
    </item>
    
    <item>
      <title>管道变得简单</title>
      <link>https://ohmysummer.github.io/post/2020-07-04-piping-made-easy/</link>
      <pubDate>Sat, 04 Jul 2020 19:32:53 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-04-piping-made-easy/</guid>
      <description>哈梅林的魔笛手是有史以来最强大的超级英雄之一。他可以通过在烟斗上吹奏一首曲子来带领一大群孩子离开。大多数父母都很难带领一个孩子离开电视。我很确定这就是为什么在 *nix 上被称为烟斗的原因。这也意味着，超级英雄电影只是童话故事。</description>
    </item>
    
    <item>
      <title>REPL</title>
      <link>https://ohmysummer.github.io/post/2020-07-01-repl/</link>
      <pubDate>Wed, 01 Jul 2020 10:19:09 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-07-01-repl/</guid>
      <description>Raku 中的 REPL 现在有一些令人迷惑的行为, 和直接使用 raku filename.</description>
    </item>
    
    <item>
      <title>我们可以做得更多</title>
      <link>https://ohmysummer.github.io/post/2020-06-26-we-can-do-more/</link>
      <pubDate>Fri, 26 Jun 2020 19:25:49 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-06-26-we-can-do-more/</guid>
      <description>DataKinds 继续着他对 Python 之道的教育翻译，以蝴蝶的方式。他的追求是展示如何在 Raku 中做一些在 Python 中完成的事情。一如既往，TIMTOWTDI 适用。</description>
    </item>
    
    <item>
      <title>Raku 谜语</title>
      <link>https://ohmysummer.github.io/post/2020-06-24-a-raku-riddle/</link>
      <pubDate>Wed, 24 Jun 2020 19:20:57 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-06-24-a-raku-riddle/</guid>
      <description>在思考 DataKinds 博文的时候，我想到了一个最奇特的谜语。它的内容如下。</description>
    </item>
    
    <item>
      <title>成群的异常</title>
      <link>https://ohmysummer.github.io/post/2020-06-14-swarms-of-exceptions/</link>
      <pubDate>Sun, 14 Jun 2020 18:41:31 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-06-14-swarms-of-exceptions/</guid>
      <description>在拉里看来，懒惰是一种美德。让我们看看 Rakudo 是否同意。</description>
    </item>
    
    <item>
      <title>主题就是主题</title>
      <link>https://ohmysummer.github.io/post/2020-06-12-the-topic-is-the-topic/</link>
      <pubDate>Fri, 12 Jun 2020 18:15:49 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-06-12-the-topic-is-the-topic/</guid>
      <description>我在上一篇文章中感叹，我们缺少初学者的资料。我给出的理由是，写这种指南很难。这就有一个问题，为什么会那么难。在堵住文档的漏洞时，我发现很多地方都出现了很多语言的特点。Raku 和自己是交织在一起的。对于初学者来说，你会希望从一些简单的东西开始，然后在此基础上建立，直到你达到最大的复杂性。有什么能比谦逊的 if 语句更简单呢？事实上，有很多。原因是主题。这将是这篇文章的主题。</description>
    </item>
    
    <item>
      <title>替换的相似性</title>
      <link>https://ohmysummer.github.io/post/2020-06-08-replacement-similarities/</link>
      <pubDate>Mon, 08 Jun 2020 18:06:04 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-06-08-replacement-similarities/</guid>
      <description>我在上一篇文章中说，我博客的文章点击率比去年上升了20%。我查的原因显然是虚荣心作祟。那天我查的原因是一篇关于 Rust 越来越受欢迎的文章。作为一种精神上的练习，我把那些抛弃他们所使用的语言的程序员所给出的不同理由变成了一个检查清单。</description>
    </item>
    
    <item>
      <title>掉入错误的兔子洞</title>
      <link>https://ohmysummer.github.io/post/2020-06-06-down-the-error-rabbit-hole/</link>
      <pubDate>Sat, 06 Jun 2020 17:29:03 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-06-06-down-the-error-rabbit-hole/</guid>
      <description>好的错误信息是有用的，因为它们告诉我们，当出错时，我们不必检查什么。(见：LTA)我通过尝试用 Raku 替换 Bash 得出了这个结论。让我们来看看一些无辜的代码。</description>
    </item>
    
    <item>
      <title>沉默不语</title>
      <link>https://ohmysummer.github.io/post/2020-05-27-ungolden-silence/</link>
      <pubDate>Wed, 27 May 2020 17:29:03 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-05-27-ungolden-silence/</guid>
      <description>在我寻求用 Raku 替换 Bash 的过程中，我尝试使用 qx，但失败了。对我来说，它没有工作，因为 qx 失败的方式是错误的。在底层，Rakudo 通过一些语法魔法来实现它，在 core.</description>
    </item>
    
    <item>
      <title>归还正确的数量</title>
      <link>https://ohmysummer.github.io/post/2020-05-25-returning-the-right-amount/</link>
      <pubDate>Mon, 25 May 2020 17:19:51 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-05-25-returning-the-right-amount/</guid>
      <description>你知道当你带着买错的东西回来时，你的另一半的表情吗？告诉你吧，我们会为此写一个脚本！</description>
    </item>
    
    <item>
      <title>神秘的中缀运算符</title>
      <link>https://ohmysummer.github.io/post/2020-05-24-the-mysterious-infix/</link>
      <pubDate>Sun, 24 May 2020 17:06:08 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-05-24-the-mysterious-infix/</guid>
      <description>瓦迪姆-贝尔曼告诉我们，他开始了一个在控制台中编写图形用户界面(GUI)应用程序的模块。这让我一下子回到了九十年代。看着示例代码，我又有了下一次的回想。如果你需要一个按钮，你需要子类。事实上，如果你需要任何东西，你都需要子类。在一个有词法作用域的动态语言中，这可能真的有用。</description>
    </item>
    
    <item>
      <title>自动切割日志</title>
      <link>https://ohmysummer.github.io/post/2020-05-14-autorotating-logs/</link>
      <pubDate>Thu, 14 May 2020 16:48:27 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2020-05-14-autorotating-logs/</guid>
      <description>当我把我的备份脚本从 bash 翻译到 Raku 的时候，我偷看了一下 /var/log/，震惊地发现有 650MB 的东西我从来没有看过。不出所料，/var/log/journal 是最大的犯罪者。遗憾的是，我必须说 systemd 一贯不太好用。2008 年我就出过糗。我之所以还在继续用它完全是因为 Debian 系统。尽管它没有 xrdp.</description>
    </item>
    
    <item>
      <title>Nil Shall Warn or Fail but Not Both</title>
      <link>https://ohmysummer.github.io/post/2019-05-14-nil-shall-warn-or-fail-but-not-both/</link>
      <pubDate>Thu, 14 May 2020 10:45:27 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-05-14-nil-shall-warn-or-fail-but-not-both/</guid>
      <description>正如之前宣布的那样，我去写了一个模块，让 Nil.</description>
    </item>
    
    <item>
      <title>追踪缺失的东西</title>
      <link>https://ohmysummer.github.io/post/2019-07-07-tracing-whats-missing/</link>
      <pubDate>Sun, 07 Jul 2019 10:05:30 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-07-07-tracing-whats-missing/</guid>
      <description>我有一个如下形式的日志文件，我想分析一下。</description>
    </item>
    
    <item>
      <title>Monkey See No Nil</title>
      <link>https://ohmysummer.github.io/post/2019-05-04-monkey-see-no-nil/</link>
      <pubDate>Sat, 04 May 2019 10:50:27 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-05-04-monkey-see-no-nil/</guid>
      <description>在 for 循环中，Nil 变成了一个 List，其中有一个元素恰好是 Any。这让我很不爽，所以我去找原因。结果发现罪魁祸首就是 Nil 的定义是 Cool。为了能够把任何一个值变成一个 List，Cool 实现了方法 list()。它接受一个单一的值，并将这个值变成一个有这一个值的 List。Nil 表示不存在一个值，把它变成一个值是没有意义的。幸运的是我们可以改变这一点。</description>
    </item>
    
    <item>
      <title>Parallel Permutations</title>
      <link>https://ohmysummer.github.io/post/2019-04-27-parallel-permutations/</link>
      <pubDate>Sat, 27 Apr 2019 10:53:52 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-04-27-parallel-permutations/</guid>
      <description>Jo Christian Oterhals 要求为挑战2提供一个并行的解决方案。我相信他自己也有问题，因为他的代码中有不少 for 循环。通过将这些循环改为方法调用链，我们可以使用 .</description>
    </item>
    
    <item>
      <title>Nil Is a Pessimist</title>
      <link>https://ohmysummer.github.io/post/2019-04-24-nil-is-a-pessimist/</link>
      <pubDate>Wed, 24 Apr 2019 10:56:39 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-04-24-nil-is-a-pessimist/</guid>
      <description>Guifa 对 $xml.</description>
    </item>
    
    <item>
      <title>Wrapping a Scope</title>
      <link>https://ohmysummer.github.io/post/2019-04-21-wrapping-a-scope/</link>
      <pubDate>Sun, 21 Apr 2019 11:00:16 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-04-21-wrapping-a-scope/</guid>
      <description>像 *望远镜 这样复杂的仪器对温度敏感。把它们包在一些舒适的绝缘体中会有帮助。在 Perl 6 中，情况恰恰相反。当我们封装一个 Callable 时，我们需要添加绝缘体来保护在不同作用域中的任何东西。</description>
    </item>
    
    <item>
      <title>I Like Rakudo 100x</title>
      <link>https://ohmysummer.github.io/post/2019-03-25-i-like-rakudo-100x/</link>
      <pubDate>Mon, 25 Mar 2019 11:03:13 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-03-25-i-like-rakudo-100x/</guid>
      <description>我的一个脚本在没有经过我的手修改的情况下停止了工作，并出现了一个非常奇特的错误信息。</description>
    </item>
    
    <item>
      <title>Threading Nqp Through a Channel</title>
      <link>https://ohmysummer.github.io/post/2019-02-03-threading-nqp-through-a-channel/</link>
      <pubDate>Sun, 03 Feb 2019 11:07:23 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-02-03-threading-nqp-through-a-channel/</guid>
      <description>考虑到 nqp 比普通 Perl 6 和线程快，两者结合起来应该会给我们带来不错的速度。在上一篇文章中承诺的使用 Supply 并没有真正的帮助。emit 会阻塞，直到 Supply 的内部队列被清空。如果我们想递归处理文件，文件系统可能会在递归线程被解除阻塞后停滞。如果我们在消费者中对文件系统施加压力，我们最好使用一个能迅速填满文件路径的 Channel。</description>
    </item>
    
    <item>
      <title>nqp Is Faster Then Threads</title>
      <link>https://ohmysummer.github.io/post/2019-02-02-nqp-is-faster-then-threads/</link>
      <pubDate>Sat, 02 Feb 2019 11:10:45 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-02-02-nqp-is-faster-then-threads/</guid>
      <description>在使用了20年的老文件系统和unix命令无法处理奇数文件名之后，我决定用 Perl 6 脚本代替 find /somewhere -type f | xargs -P 10 -n 1 do-stuff。</description>
    </item>
    
    <item>
      <title>a Picky Caller</title>
      <link>https://ohmysummer.github.io/post/2019-01-23-a-picky-caller/</link>
      <pubDate>Wed, 23 Jan 2019 11:16:35 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-01-23-a-picky-caller/</guid>
      <description>我通过在我的 linux 盒子上设置一个 bcache，把一个快速的sd和一个可观的磁盘结合起来，给自己买了一个矛盾的硬盘。现在我得到了一个硬盘，它的速度非常快，但文件却很小。bcache 通过 sysfs 提供了一些统计数据。要看这些数据，需要读取一些文本文件。一个很适合 slurp 的任务。我最后得到了一堆尖号块，是这样的。</description>
    </item>
    
    <item>
      <title>Iterating Past the Finish</title>
      <link>https://ohmysummer.github.io/post/2019-01-11-iterating-past-the-finish/</link>
      <pubDate>Fri, 11 Jan 2019 11:21:31 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2019-01-11-iterating-past-the-finish/</guid>
      <description>前段时间有人提出如何增强(augment) Any 的问题。事实证明，增强部分是有效的，但新增加的方法并没有传播给内置类型的子类型。可以通过对所有类型对象调用 .</description>
    </item>
    
    <item>
      <title>Deconstructing Simple Grammars</title>
      <link>https://ohmysummer.github.io/post/2018-05-10-deconstructing-simple-grammars/</link>
      <pubDate>Thu, 10 May 2018 11:27:22 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2018-05-10-deconstructing-simple-grammars/</guid>
      <description>去年我写了一个鸡蛋定时器，它的解析命令行参数类似于 GNU sleep。我对这个解析器的严格形式很满意，如下。</description>
    </item>
    
    <item>
      <title>Expensive Egg Timers</title>
      <link>https://ohmysummer.github.io/post/2017-12-31-expensive-egg-timers/</link>
      <pubDate>Sun, 31 Dec 2017 11:32:50 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-12-31-expensive-egg-timers/</guid>
      <description>如果你使用 CLI，你可能已经做了一些类似的事情。</description>
    </item>
    
    <item>
      <title>Racing Rakudo</title>
      <link>https://ohmysummer.github.io/post/2017-11-05-racing-rakudo/</link>
      <pubDate>Sun, 05 Nov 2017 11:44:56 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-11-05-racing-rakudo/</guid>
      <description>在许多赛车运动中，遥测在提高速度方面起着重要作用。 感谢lizmat的大量提交，你现在也可以使用遥测了。</description>
    </item>
    
    <item>
      <title>There Is More Than One Way at the Same Time</title>
      <link>https://ohmysummer.github.io/post/2017-10-22-there-is-more-than-one-way-at-the-same-time/</link>
      <pubDate>Sun, 22 Oct 2017 12:26:51 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-10-22-there-is-more-than-one-way-at-the-same-time/</guid>
      <description>Perl 6 Rosattacode 中用于并行计算的部分已经非常过时，而且缺少了过去几周中添加或修复的所有好东西。通过这篇文章，我想为 Rosettacode 提出一个更新的版本。如果你认为我遗漏了什么，请在下面评论。请记住，Rosettacode 是用来炫耀的，而不是用来全面的。</description>
    </item>
    
    <item>
      <title>The Siege Can Continue</title>
      <link>https://ohmysummer.github.io/post/2017-09-16-the-siege-can-continue/</link>
      <pubDate>Sat, 16 Sep 2017 12:38:45 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-09-16-the-siege-can-continue/</guid>
      <description>一位睿智的网络飞船海盗曾写道：&amp;ldquo;抱怨能让你得到东西。这就是为什么人类处于食物链的顶端&amp;rdquo;。我的抱怨让我得到了一个修复，它结束了对 http 请求做出反应的长期运行脚本的 segfaults。</description>
    </item>
    
    <item>
      <title>Goto the Last Fifo</title>
      <link>https://ohmysummer.github.io/post/2017-09-13-goto-the-last-fifo/</link>
      <pubDate>Wed, 13 Sep 2017 12:41:45 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-09-13-goto-the-last-fifo/</guid>
      <description>我一直很欣赏 sysfs 的优雅。你把一个文本写到一个文件里，然后和运行在内核空间的函数对话。只要你知道如何处理文件，你就可以改变系统的行为和重用访问控制机制，而不需要任何特殊的工具。脚本和转储（部分）系统状态是非常容易的。</description>
    </item>
    
    <item>
      <title>Preparations for Your</title>
      <link>https://ohmysummer.github.io/post/2017-08-20-preparations-for-your/</link>
      <pubDate>Sun, 20 Aug 2017 12:45:36 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-08-20-preparations-for-your/</guid>
      <description>在他出色的演讲中，Damian Conway 展示了如何实现一个新的声明符，他把这个声明符称为 your，它会把任何值的变化输出到容器中进行调试。整件事让我担心 Perl 5 可能会超越 Perl 6，导致更多的命名混乱，因为我们已经得到了。所以我又开始让我们领先一点。</description>
    </item>
    
    <item>
      <title>on Good Terms With Constants</title>
      <link>https://ohmysummer.github.io/post/2017-08-13-on-good-terms-with-constants/</link>
      <pubDate>Sun, 13 Aug 2017 12:50:14 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-08-13-on-good-terms-with-constants/</guid>
      <description>在构建一个小助手模块来获取网络电台的时候，我发现自己想要提供一个常量的命名参数。不少 DateTime 的方法都有一个命名的参数，而 $*TZ 就不对了。事实证明，这在 Perl 6 中真的很简单。</description>
    </item>
    
    <item>
      <title>It&#39;s Classes All the Way Down</title>
      <link>https://ohmysummer.github.io/post/2017-08-08-it-s-classes-all-the-way-down/</link>
      <pubDate>Tue, 08 Aug 2017 12:32:26 +0800</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-08-08-it-s-classes-all-the-way-down/</guid>
      <description>当我在为一个网络 api 构建缓存时，我发现自己在同一个数据上走了两遍，以解决缺乏正确的输入法的问题。JSON 只知道字符串，尽管大部分字段都是整数和时间戳。我在用 JSON::Fast 解析JSON后，通过强制 .</description>
    </item>
    
  </channel>
</rss>