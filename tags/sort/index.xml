<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sort on Raku Programming</title>
    <link>https://ohmysummer.github.io/tags/sort/</link>
    <description>Recent content in sort on Raku Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 02 Jan 2017 22:56:16 +0000</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/sort/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2017 StackOverFlow-sort,deepmap,flat</title>
      <link>https://ohmysummer.github.io/post/2017-01-02-stackoverflow/</link>
      <pubDate>Mon, 02 Jan 2017 22:56:16 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2017-01-02-stackoverflow/</guid>
      <description>raku What is the best way to match any of a group of words?  我想匹配任意一组单词，但是失败了，请问怎样才能正确地匹配到？
my @a=&amp;lt;a b c d e f&amp;gt;; my $x=&amp;quot;a1234567&amp;quot;; say $x ~~ m/ @a.any /; Answer
my @a = &amp;lt;a b c d e f&amp;gt;; my $x = &amp;quot;a1234567&amp;quot;; say $x ~~ /@a/ /@a/ 和 /| @a/ 相同，它是最长的备选分支。对于备选分支，你可以使用 /|| @a/。
 How to build lazy lists with defined generators and is there a “takeWhile” alternative?</description>
    </item>
    
    <item>
      <title>Sneaking into a loop</title>
      <link>https://ohmysummer.github.io/post/2015-03-23-sneaking-into-a-loop/</link>
      <pubDate>Mon, 23 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-03-23-sneaking-into-a-loop/</guid>
      <description>Sneaking into a loop [Sneaking into a loop]https://gfldex.wordpress.com/2016/08/10/sneaking-into-a-loop/
Zoffix 回答了一个关于 Perl 5s &amp;lt;&amp;gt; 操作符的问题。
slurp.words.Bag.sort(-*.value).fmt(&amp;quot;%10s3d\n&amp;quot;).say;slurp 会从 STDIN 中读取整个 &amp;ldquo;file&amp;rdquo; 并返回一个 Str。方法 Str::words 会按照某种 Unicode 意义的单词把该字符串分割成一个列表。把列表强转为 Bag 则创建一个计数 Hash, 它是如下表述的快捷方式。
my %h;%h{$_}++ for &amp;lt;peter paul marry&amp;gt;;dd %h;# # OUTPUT«Hash %h = {:marry(1), :paul(1), :peter(1)}␤»在关联数组上调用 .sort(-*.value) 会按照值的降序排序并返回一个排序后的 Pairs 列表。List::fmt 会调用 Pair::fmt, 它调用 fmt 方法, .key 作为其第二个参数, .value 也作为参数。say 会会使用一个空格连接各个元素并输出到标准输出。最后一步有一点错误因为除了第一行之外的每一行前面都会有一个额外的空格。
slurp.words.Bag.sort(-*.value).fmt(&amp;quot;%10s =&amp;gt; %3d&amp;quot;).join(&amp;quot;\n&amp;quot;).say;手动连接字符串更好。这对于简短的单行程序来说有点多了。我们需要找到最长的单词并使用 .chars 来获取列宽。
slurp 会在 $*IN 身上调用 .</description>
    </item>
    
  </channel>
</rss>