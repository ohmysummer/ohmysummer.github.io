<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rotor on Rakudo Perl 6</title>
    <link>https://ohmysummer.github.io/tags/rotor/</link>
    <description>Recent content in Rotor on Rakudo Perl 6</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 14 Dec 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/rotor/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>给数字添加千分位分割符</title>
      <link>https://ohmysummer.github.io/post/2015-12-14-%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E5%88%86%E5%89%B2%E7%AC%A6/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-12-14-%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E5%88%86%E5%89%B2%E7%AC%A6/</guid>
      <description>使用链式函数调用 考虑最简单的一种情况, 不带小数点的数字:
&amp;quot;1234567890&amp;quot;.comb.reverse.rotor(3,:partial).map(*.join(&#39;&#39;)).join(&#39;,&#39;).comb.reverse.join(&#39;&#39;) # 1,234,567,890  使用 \\ 转义空白, 使代码对齐:
&amp;quot;1234567890&amp;quot;.comb\ .reverse\ .rotor(3,:partial)\ .map(*.join(‘’))\ .join(‘,’)\ .comb\ .reverse\ .join(‘’)\ .say;  使用正则表达式 comming soon!
使用 Grammar comming soon!</description>
    </item>
    
    <item>
      <title>rotor</title>
      <link>https://ohmysummer.github.io/post/2015-08-08-rotor/</link>
      <pubDate>Sat, 08 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-08-08-rotor/</guid>
      <description>method rotor(*@cycle, Bool() :$partial)  rotor 返回一个 list, 这个 list 的元素也是 list, 其中每个子列表由调用者中的元素组成. 在最简单的情况下, @cycle 只包含一个整数, 这时调用者列表被分割为多个子列表, 每个子列表中的元素尽可能多的为那个整数指定的个数. 如果 :$partial 为 True, 不够分的最后那部分也会被包括进去, 即使它不满足长度的要求:
say (&#39;a&#39;..&#39;h&#39;).rotor(3).join(&#39;|&#39;); # a b c|d e f say (&#39;a&#39;..&#39;h&#39;).rotor(3, :partial).join(&#39;|&#39;); # a b c|d e f|g h  如果 @cycle 的元素是一个 /type/Pair, 则 pair 的键指定了所返回子列表的长度(即每个子列表中含有的元素数), pair 的键值指定两个列表之间的间隙; 负的间隙会产生重叠:
say (&#39;a&#39;..&#39;h&#39;).rotor(2 =&amp;gt; 1).join(&#39;|&#39;); # a b|d e|g h say (&#39;a&#39;..&#39;h&#39;).rotor(3 =&amp;gt; -1).join(&#39;|&#39;); # a b c|c d e|e f g &amp;gt; my $pair = 2 =&amp;gt; 1;&amp;gt; my $key = $pair.</description>
    </item>
    
    <item>
      <title>Perl 6 rotor--列表操作之王</title>
      <link>https://ohmysummer.github.io/post/2015-07-14-perl-6-rotor-%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%8E%8B/</link>
      <pubDate>Tue, 14 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-14-perl-6-rotor-%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C%E4%B9%8B%E7%8E%8B/</guid>
      <description>Perl 6 .rotor - The King of List Manipulation
对于 Perl 6 程序员, .rotor是一个强大的列表操作工具。
分段 最简单的, .rotor接收一个整数$number并把列表分成多个子列表, 每个子列表含有 $number 个元素:
say &amp;lt;a b c d e f g h&amp;gt;.rotor: 3 # ((a b c) (d e f))  我们有一个含有 8 个元素的列表, 我们在该列表上调用接收参数 3 的 .rotor方法, 它返回 2 个列表, 每个列表中含有 3 个元素。不包括原列表中的最后 2 个元素, 因为它们没有组成一个完整的3个元素的列表。然而它们可以被包含进来, 使用 :partial具名参数设置为 True:
say &amp;lt;a b c d e f g h&amp;gt;.rotor: 3, :partial # ((a b c) (d e f) (g h)) say &amp;lt;a b c d e f g h&amp;gt;.</description>
    </item>
    
  </channel>
</rss>