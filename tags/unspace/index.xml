<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unspace on 焉知非鱼</title>
    <link>http://ohmysummer.github.io/tags/unspace/</link>
    <description>Recent content in Unspace on 焉知非鱼</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Aug 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://ohmysummer.github.io/tags/unspace/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>unspaces</title>
      <link>http://ohmysummer.github.io/post/2016-08-01-unspaces/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ohmysummer.github.io/post/2016-08-01-unspaces/</guid>
      <description>有些语言例如 C 允许你转义一个换行符使行联合起来. 其它语言(例如正则表达式)因为各种各样的原因, 允许你使用反斜线转义一个空白符. Perl 6 把这种记法推广到任何种类的空白上. 通过在空白处前置一个 \, 任何相邻的空白(包括注释)都会在解析器面前隐身. 这就是鼎鼎大名的空白隐身( “unspace”).
在 Perl 中, 一个 unspace 能够抑制任意的几种空白附属物. 例如, 因为 Perl 要求名词和后缀操作符之间不能出现空白, 所以使用 unspace 让你可以把后缀操作符贴线对齐:
%hash\ {$key} @array\ [$ix] $subref\($arg)  上面的最后一种形式作为一种退化了的 unspace, 即反斜线后面直接跟着后缀. 注意, 反斜线前面不允许有空白, 所以:
$subref \($arg)  是语法错误(two terms in a row). 而
foo \($arg)  会被解析为带有 Capture 参数的列表操作:
foo(\($arg))  然而, 其它形式的 unspace 可能被有效地放在空白之前.
其它后缀操作符也可能使用 unspace:
$number\ ++; $number\ --; 1+3\ i; $object\ .say(); $object\#`{ your ad here }.</description>
    </item>
    
    <item>
      <title>给数字添加千分位分割符</title>
      <link>http://ohmysummer.github.io/post/2015-12-14-%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E5%88%86%E5%89%B2%E7%AC%A6/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ohmysummer.github.io/post/2015-12-14-%E7%BB%99%E6%95%B0%E5%AD%97%E6%B7%BB%E5%8A%A0%E5%8D%83%E5%88%86%E4%BD%8D%E5%88%86%E5%89%B2%E7%AC%A6/</guid>
      <description>使用链式函数调用 考虑最简单的一种情况, 不带小数点的数字:
&amp;quot;1234567890&amp;quot;.comb.reverse.rotor(3,:partial).map(*.join(&#39;&#39;)).join(&#39;,&#39;).comb.reverse.join(&#39;&#39;) # 1,234,567,890  使用 \\ 转义空白, 使代码对齐:
&amp;quot;1234567890&amp;quot;.comb\ .reverse\ .rotor(3,:partial)\ .map(*.join(‘’))\ .join(‘,’)\ .comb\ .reverse\ .join(‘’)\ .say;  使用正则表达式 comming soon!
使用 Grammar comming soon!</description>
    </item>
    
    <item>
      <title>空白格</title>
      <link>http://ohmysummer.github.io/post/2015-09-18-%E7%A9%BA%E7%99%BD%E6%A0%BC/</link>
      <pubDate>Fri, 18 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ohmysummer.github.io/post/2015-09-18-%E7%A9%BA%E7%99%BD%E6%A0%BC/</guid>
      <description> 空格最少化 在数组或散列的开括号(即下标左边的那个括号)之前不允许有空格, 参数列表的圆开括号前面也是不能有空格的. 即:
@deadbeef[$x] # okay %monsters{&#39;cookie&#39;} # okay saymewant(&#39;cookie&#39;) # okay @a [$b] # WRONG %people {&#39;john&#39;} # WRONG mewant (&#39;cookie&#39;) # WRONG  这种限制的的几个副作用之一就是条件控制结构的周围不再需要圆括号了:
if $value eq $target { print &amp;quot;Bullseye!&amp;quot;; } while $i &amp;lt; 10 { $i++ }  然而, 显式的使用 unspace 语法仍然能够让你对齐下标和后缀操作符:
%squirrels{&#39;fluffy&#39;} = Squirrel.new; %monsters.{&#39;cookie&#39;} = Monster.new; %beatles\.{&#39;ringo&#39;} = Beatle.new; %people\ .{&#39;john&#39;} = Person.new;  </description>
    </item>
    
  </channel>
</rss>