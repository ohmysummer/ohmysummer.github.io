<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>冒号 on 焉知非鱼</title>
    <link>http://ohmysummer.github.io/tags/%E5%86%92%E5%8F%B7/</link>
    <description>Recent content in 冒号 on 焉知非鱼</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 11 Sep 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://ohmysummer.github.io/tags/%E5%86%92%E5%8F%B7/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Perl 6 Weekly(一)</title>
      <link>http://ohmysummer.github.io/post/2015-09-11-perl-6-weekly%E4%B8%80/</link>
      <pubDate>Fri, 11 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ohmysummer.github.io/post/2015-09-11-perl-6-weekly%E4%B8%80/</guid>
      <description>1、在 Perl 6 中怎样检查文件的时间戳属性？
在 Perl 6 中怎样检查文件的时间戳属性？ 在 Perl 5 中是使用文件测试操作符 file test operators , 在 Perl 6 中是使用来自于 IO::FileTestable role 的方法 (e.g. .modified, .accessed and .changed) 。
例如:
my $filename = &amp;quot;sample.txt&amp;quot;; my $seconds_since_epoch = $filename.IO.accessed; my $readable_timestamp = DateTime.new($filename.IO.accessed); say &amp;quot;File &#39;$filename&#39; was last accessed at &#39;$readable_timestamp&#39;, which is {$seconds_since_epoch.Num} seconds since the epoch&amp;quot;;  2、我正尝试生成包含 10 个随机随机序列的 FASTQ 文件， 序列由随机品质分数构成。我原来是使用下面的代码，它工作良好:
my @seq = (rand_fa_seq() for ^10); my @qual = (rand_qual() for ^10); @seq.</description>
    </item>
    
    <item>
      <title>MAIN 中的冒号</title>
      <link>http://ohmysummer.github.io/post/2015-07-05-main-%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</link>
      <pubDate>Sun, 05 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ohmysummer.github.io/post/2015-07-05-main-%E4%B8%AD%E7%9A%84%E5%86%92%E5%8F%B7/</guid>
      <description>假如我有多个文本文件, 我要写一段脚本来进行替换操作。在命令行中提供一些列选项供配置。文本格式如下:
Perl 6 很灵活 Perl 6 很强大 Perl 6 很复杂 I 123 Love Perl Six 尽管它456还很稚嫩789 对了, 它的 logo 是一个可爱的456花蝴蝶。  我想把每行中第一次出现的 3 位数字替换为 &amp;ldquo;在木星&amp;rdquo;。
@蘑菇 的脚本:
use v6; use MONKEY-SEE-NO-EVAL; sub MAIN(Str :$regex, Str :$substr, Str :$ext = &#39;.out&#39;, Int :$ignore-line = 0, *@files) { for @files -&amp;gt; $file { my $out = open $file ~ &amp;quot;.out&amp;quot;, :w; # 写入文件 for $file.IO.lines.kv -&amp;gt; $index, $line is copy { next if $index &amp;lt;= $ignore-line; # 忽略前 $ignore-line几行 $line ~~ EVAL &amp;quot;s/&amp;quot; ~ $regex ~ &amp;quot;/&amp;quot; ~ $substr ~ &amp;quot;/&amp;quot;; # 根据正则表达式进行替换 say $/; $out.</description>
    </item>
    
  </channel>
</rss>