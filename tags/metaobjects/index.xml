<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Metaobjects on Rakudo Perl 6</title>
    <link>https://ohmysummer.github.io/tags/metaobjects/</link>
    <description>Recent content in Metaobjects on Rakudo Perl 6</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 16 Jul 2015 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/metaobjects/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>元对象协议</title>
      <link>https://ohmysummer.github.io/post/2015-07-16-%E5%85%83%E5%AF%B9%E8%B1%A1%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Thu, 16 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2015-07-16-%E5%85%83%E5%AF%B9%E8%B1%A1%E5%8D%8F%E8%AE%AE/</guid>
      <description>自省和 Perl 6 的对象系统 Perl 6 是构建在元对象层上面的。那意味着有些对象(元对象)控制着各种面向对象结构(例如类、roles、方法、属性、枚举,…)怎样去表现。
要感受类的元对象, 这儿有一个同样的例子出现2次: 一次一种 Perl 6中的普通声明, 一次通过元模型来表达:
class A { method x() { say 42 } } A.x(); # 42  对应于:
constant A := Metamodel::ClassHOW.new_type( name =&amp;gt; &#39;A&#39; ); # class A { A.^add_method(&#39;x&#39;, my method x(A:) { say 42 }); # method x() .. . A.^compose; # } A.x(); # 42  (除了声明形式的运行在编译时, 后面这种形式不是)
对象后面的元对象能使用 $obj.HOW获取, 这儿的 HOW 代表着 Higher Order Workings(或者 HOW the *%@$ does this work?</description>
    </item>
    
  </channel>
</rss>