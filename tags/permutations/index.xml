<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>permutations on Raku Programming</title>
    <link>https://ohmysummer.github.io/tags/permutations/</link>
    <description>Recent content in permutations on Raku Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 30 Dec 2016 23:14:12 +0000</lastBuildDate>
    
	<atom:link href="https://ohmysummer.github.io/tags/permutations/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Raku Tips - 排列组合</title>
      <link>https://ohmysummer.github.io/post/2016-12-30-raku-tips-%E6%8E%A2%E7%B4%A2%E7%BB%84%E5%90%88/</link>
      <pubDate>Fri, 30 Dec 2016 23:14:12 +0000</pubDate>
      
      <guid>https://ohmysummer.github.io/post/2016-12-30-raku-tips-%E6%8E%A2%E7%B4%A2%E7%BB%84%E5%90%88/</guid>
      <description>Quick Tip #16: 探索组合
xx 是列表重复操作符, 用于将一个列表重复指定的次数。xx 不会展平列表中的元素。
$ raku &amp;gt; my @n = &amp;lt;1 2 3&amp;gt;; [1 2 3] &amp;gt; my $n = 4; 4 &amp;gt; my @c = @n xx $n 输出：
[[1 2 3] [1 2 3] [1 2 3] [1 2 3]] 现在我想要长度为 $n 的一堆列表的所有排列（combinations）:
&amp;gt; ( [X] ( @n xx $n ) ) ((1 1 1 1) (1 1 1 2) (1 1 1 3) (1 1 2 1) (1 1 2 2) (1 1 2 3) (1 1 3 1) (1 1 3 2) (1 1 3 3) (1 2 1 1) (1 2 1 2) (1 2 1 3) (1 2 2 1) (1 2 2 2) (1 2 2 3) (1 2 3 1) (1 2 3 2) (1 2 3 3) (1 3 1 1) (1 3 1 2) (1 3 1 3) (1 3 2 1) (1 3 2 2) (1 3 2 3) (1 3 3 1) (1 3 3 2) (1 3 3 3) (2 1 1 1) (2 1 1 2) (2 1 1 3) (2 1 2 1) (2 1 2 2) (2 1 2 3) (2 1 3 1) (2 1 3 2) (2 1 3 3) (2 2 1 1) (2 2 1 2) (2 2 1 3) (2 2 2 1) (2 2 2 2) (2 2 2 3) (2 2 3 1) (2 2 3 2) (2 2 3 3) (2 3 1 1) (2 3 1 2) (2 3 1 3) (2 3 2 1) (2 3 2 2) (2 3 2 3) (2 3 3 1) (2 3 3 2) (2 3 3 3) (3 1 1 1) (3 1 1 2) (3 1 1 3) (3 1 2 1) (3 1 2 2) (3 1 2 3) (3 1 3 1) (3 1 3 2) (3 1 3 3) (3 2 1 1) (3 2 1 2) (3 2 1 3) (3 2 2 1) (3 2 2 2) (3 2 2 3) (3 2 3 1) (3 2 3 2) (3 2 3 3) (3 3 1 1) (3 3 1 2) (3 3 1 3) (3 3 2 1) (3 3 2 2) (3 3 2 3) (3 3 3 1) (3 3 3 2) (3 3 3 3)) 注意，排列是不一样的，它更简单，因为有一个方法来生成排列：</description>
    </item>
    
  </channel>
</rss>