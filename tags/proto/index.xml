<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Proto on 焉知非鱼</title>
    <link>http://ohmysummer.github.io/tags/proto/</link>
    <description>Recent content in Proto on 焉知非鱼</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Feb 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://ohmysummer.github.io/tags/proto/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>适当的使用proto</title>
      <link>http://ohmysummer.github.io/post/2016-02-11-%E6%81%B0%E5%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8proto/</link>
      <pubDate>Thu, 11 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ohmysummer.github.io/post/2016-02-11-%E6%81%B0%E5%BD%93%E7%9A%84%E4%BD%BF%E7%94%A8proto/</guid>
      <description>原文在此Apropos proto: Perl6.c multi thoughts
Multi 程序相当整洁, 但对于我来说是不彻底的。一些背景 — 有人可能这样计算阶乘:
multi fac(0) { 1 } multi fac(Int $n where 1..Inf) { $n * fac( $n-1 ) } say fac(4); # 24  现在假设我们要把我们的递归 multi-sub 作为一个回调传递会怎样呢？
given &amp;amp;fac -&amp;gt; $some_fun { say &amp;quot;some_fun(4)=&amp;quot;, $some_fun(4) }  现在&amp;hellip; 定义一个匿名的 multi-sub 怎么样？
my $anon_fac = do { multi hidden_fac(0) { 1 } multi hidden_fac(Int $n where 1..Inf) { $n * fac( $n - 1 ) } &amp;amp;hidden_fac }; say $anon_fac(4); # 24  这也会有作用, 但是有点 hack 的味道, 并且我们的 multi-sub 并不是真正的匿名。它仅仅是被隐藏了。真正匿名的对象不会在任何作用域中安装, 而在这个例子中, &amp;ldquo;hidden_fac&amp;rdquo; 被安装在 &amp;ldquo;do&amp;rdquo; block 中的本地作用域中。</description>
    </item>
    
    <item>
      <title>Perl6 中的可变 Grammar</title>
      <link>http://ohmysummer.github.io/post/2015-11-16-perl6%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98grammar/</link>
      <pubDate>Mon, 16 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ohmysummer.github.io/post/2015-11-16-perl6%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98grammar/</guid>
      <description>## A Mutable Grammar For Perl 6 Rules Rules 就像 perl5的 regexes，并且更好。它们像子例程和方法那样申明，并且还能调用其它 rules
下面是一个解析 Perl 6 基本变量名的例子：
grammar Perl6 { # among other stuff: # token alpha 是一个预定义好的 rule token identifier { &amp;lt;alpha&amp;gt; \w+ } # 匹配一个全限定名标识符 # [ ... ] 是非捕获组 token name { &amp;lt;identifier&amp;gt; [ &#39;::&#39; &amp;lt;identifier&amp;gt; ] * } # .. | .. 是分支. 最长匹配胜出. token sigil { &#39;$&#39; | &#39;@&#39; | &#39;&amp;amp;&#39; | &#39;%&#39; | &#39;::&#39; } # &amp;lt;rule&amp;gt; 调用命名 rule, 隐式地锚定在当前位置 token variable { &amp;lt;sigil&amp;gt; &amp;lt;name&amp;gt; } }  Grammars Grammar 跟类很像，含有 rules 而不是 methods。 grammars 是 rules 的集合并支持继承。</description>
    </item>
    
    <item>
      <title>proto</title>
      <link>http://ohmysummer.github.io/post/2015-10-06-proto/</link>
      <pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://ohmysummer.github.io/post/2015-10-06-proto/</guid>
      <description>proto proto 意思为原型。proto 从形式上声明了 multi 候选者之间的共性。 proto 充当作能检查但不会修改参数的包裹。看看这个基本的例子:
proto congratulate(Str $reason, Str $name, |) {*} multi congratulate($reason, $name) { say &amp;quot;Hooray for your $reason, $name&amp;quot;; } multi congratulate($reason, $name, Int $rank) { say &amp;quot;Hooray for your $reason, $name -- you got rank $rank!&amp;quot;; } congratulate(&#39;being a cool number&#39;, &#39;Fred&#39;); # OK congratulate(&#39;being a cool number&#39;, &#39;Fred&#39;, 42); # OK congratulate(&#39;being a cool number&#39;, 42); # Proto match error  所有的 multi congratulate 会遵守基本的签名, 这个签名中有两个字符串参数, 后面跟着可选的更多的参数。 | 是一个未命名的 Capture 形参, 这允许 multi 接收额外的参数。第三个 congratulate 调用在编译时失败, 因为第一行的 proto 的签名变成了所有三个 multi congratulate 的共同签名, 而 42 不匹配 Str。</description>
    </item>
    
  </channel>
</rss>